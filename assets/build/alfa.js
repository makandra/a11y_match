(() => {
  var __defProp = Object.defineProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };

  // node_modules/@siteimprove/alfa-clone/dist/clone.js
  var Clone;
  (function(Clone2) {
    function clone(value) {
      return value.clone();
    }
    Clone2.clone = clone;
  })(Clone || (Clone = {}));

  // node_modules/@siteimprove/alfa-equatable/dist/equatable.js
  var Equatable;
  (function(Equatable2) {
    function isFunction7(value) {
      return typeof value === "function";
    }
    function isObject9(value) {
      return typeof value === "object" && value !== null;
    }
    function isEquatable(value) {
      return isObject9(value) && isFunction7(value.equals);
    }
    Equatable2.isEquatable = isEquatable;
    function equals34(a, b) {
      if (a === b || // `NaN` is the only value in JavaScript that is not equal to itself.
      a !== a && b !== b) {
        return true;
      }
      if (isEquatable(a)) {
        return a.equals(b);
      }
      if (isEquatable(b)) {
        return b.equals(a);
      }
      return false;
    }
    Equatable2.equals = equals34;
  })(Equatable || (Equatable = {}));

  // node_modules/@siteimprove/alfa-predicate/dist/predicate.js
  var Predicate;
  (function(Predicate2) {
    function test43(predicate, value, ...args) {
      return predicate(value, ...args);
    }
    Predicate2.test = test43;
    function fold2(predicate, ifTrue, ifFalse, value, ...args) {
      return predicate(value, ...args) ? ifTrue(value) : ifFalse(value);
    }
    Predicate2.fold = fold2;
    function not54(predicate) {
      return (value, ...args) => !predicate(value, ...args);
    }
    Predicate2.not = not54;
    function and107(...predicates) {
      return (value, ...args) => {
        for (let i = 0, n = predicates.length; i < n; i++) {
          if (!predicates[i](value, ...args)) {
            return false;
          }
        }
        return true;
      };
    }
    Predicate2.and = and107;
    function or40(...predicates) {
      return (value, ...args) => {
        for (let i = 0, n = predicates.length; i < n; i++) {
          if (predicates[i](value, ...args)) {
            return true;
          }
        }
        return false;
      };
    }
    Predicate2.or = or40;
    function xor2(...predicates) {
      return and107(or40(...predicates), not54(and107(...predicates)));
    }
    Predicate2.xor = xor2;
    function nor6(...predicates) {
      return not54(or40(...predicates));
    }
    Predicate2.nor = nor6;
    function nand(...predicates) {
      return not54(and107(...predicates));
    }
    Predicate2.nand = nand;
    function equals34(...values) {
      return (other) => values.some((value) => Equatable.equals(other, value));
    }
    Predicate2.equals = equals34;
    function property16(property17, predicate) {
      return (value, ...args) => predicate(value[property17], ...args);
    }
    Predicate2.property = property16;
    function tee5(predicate, callback) {
      return (value, ...args) => {
        const result = predicate(value, ...args);
        callback(value, result, ...args);
        return result;
      };
    }
    Predicate2.tee = tee5;
  })(Predicate || (Predicate = {}));

  // node_modules/@siteimprove/alfa-refinement/dist/refinement.js
  var Refinement;
  (function(Refinement2) {
    Refinement2.test = Predicate.test;
    Refinement2.fold = Predicate.fold;
    Refinement2.not = Predicate.not;
    Refinement2.and = Predicate.and;
    Refinement2.or = Predicate.or;
    Refinement2.xor = Predicate.xor;
    Refinement2.nor = Predicate.nor;
    Refinement2.nand = Predicate.nand;
    Refinement2.equals = Predicate.equals;
    Refinement2.tee = Predicate.tee;
    function isString3(value) {
      return typeof value === "string";
    }
    Refinement2.isString = isString3;
    function isNumber6(value) {
      return typeof value === "number";
    }
    Refinement2.isNumber = isNumber6;
    function isBigInt2(value) {
      return typeof value === "bigint";
    }
    Refinement2.isBigInt = isBigInt2;
    function isBoolean4(value) {
      return typeof value === "boolean";
    }
    Refinement2.isBoolean = isBoolean4;
    function isNull2(value) {
      return value === null;
    }
    Refinement2.isNull = isNull2;
    function isUndefined(value) {
      return value === void 0;
    }
    Refinement2.isUndefined = isUndefined;
    function isSymbol(value) {
      return typeof value === "symbol";
    }
    Refinement2.isSymbol = isSymbol;
    function isFunction7(value) {
      return typeof value === "function";
    }
    Refinement2.isFunction = isFunction7;
    function isObject9(value) {
      return typeof value === "object" && value !== null;
    }
    Refinement2.isObject = isObject9;
    Refinement2.isPrimitive = Refinement2.or(isString3, Refinement2.or(isNumber6, Refinement2.or(isBigInt2, Refinement2.or(isBoolean4, Refinement2.or(isNull2, Refinement2.or(isUndefined, isSymbol))))));
  })(Refinement || (Refinement = {}));

  // node_modules/@siteimprove/alfa-comparable/dist/comparison.js
  var Comparison;
  (function(Comparison3) {
    Comparison3[Comparison3["Less"] = -1] = "Less";
    Comparison3[Comparison3["Equal"] = 0] = "Equal";
    Comparison3[Comparison3["Greater"] = 1] = "Greater";
  })(Comparison || (Comparison = {}));

  // node_modules/@siteimprove/alfa-comparable/dist/comparable.js
  var { isString, isNumber, isBigInt, isBoolean, isFunction, isObject } = Refinement;
  var Comparable;
  (function(Comparable2) {
    function isComparable(value) {
      return isObject(value) && isFunction(value.compare);
    }
    Comparable2.isComparable = isComparable;
    function compare(a, b) {
      if (isString(a)) {
        return compareString(a, b);
      }
      if (isNumber(a)) {
        return compareNumber(a, b);
      }
      if (isBigInt(a)) {
        return compareBigInt(a, b);
      }
      if (isBoolean(a)) {
        return compareBoolean(a, b);
      }
      return compareComparable8(a, b);
    }
    Comparable2.compare = compare;
    function compareString(a, b) {
      return comparePrimitive(a, b);
    }
    Comparable2.compareString = compareString;
    function compareNumber(a, b) {
      return comparePrimitive(a, b);
    }
    Comparable2.compareNumber = compareNumber;
    function compareBigInt(a, b) {
      return comparePrimitive(a, b);
    }
    Comparable2.compareBigInt = compareBigInt;
    function compareBoolean(a, b) {
      return comparePrimitive(a, b);
    }
    Comparable2.compareBoolean = compareBoolean;
    function compareComparable8(a, b) {
      return a.compare(b);
    }
    Comparable2.compareComparable = compareComparable8;
    function comparePrimitive(a, b) {
      if (a < b) {
        return Comparison.Less;
      }
      if (a > b) {
        return Comparison.Greater;
      }
      return Comparison.Equal;
    }
    function compareLexicographically(a, b, comparer) {
      for (let i = 0; i < a.length; i++) {
        const comparison = comparer[i](a[i], b[i]);
        if (comparison === Comparison.Equal) {
          continue;
        }
        return comparison;
      }
      return Comparison.Equal;
    }
    Comparable2.compareLexicographically = compareLexicographically;
    function isLessThan(a, b) {
      return a.compare(b) < 0;
    }
    Comparable2.isLessThan = isLessThan;
    function isLessThanOrEqual(a, b) {
      return a.compare(b) <= 0;
    }
    Comparable2.isLessThanOrEqual = isLessThanOrEqual;
    function isEqual(a, b) {
      return a.compare(b) === 0;
    }
    Comparable2.isEqual = isEqual;
    function isGreaterThan(a, b) {
      return a.compare(b) > 0;
    }
    Comparable2.isGreaterThan = isGreaterThan;
    function isGreaterThanOrEqual(a, b) {
      return a.compare(b) >= 0;
    }
    Comparable2.isGreaterThanOrEqual = isGreaterThanOrEqual;
  })(Comparable || (Comparable = {}));

  // node_modules/@siteimprove/alfa-json/dist/builtin.js
  var Builtin = JSON;

  // node_modules/@siteimprove/alfa-json/dist/json.js
  var JSON2;
  (function(JSON3) {
    function parse57(value) {
      return Builtin.parse(value);
    }
    JSON3.parse = parse57;
    function stringify(value) {
      return Builtin.stringify(value);
    }
    JSON3.stringify = stringify;
  })(JSON2 || (JSON2 = {}));

  // node_modules/@siteimprove/alfa-json/dist/serializable.js
  var { keys } = Object;
  var { isArray } = Array;
  var { isFunction: isFunction2, isObject: isObject2, isString: isString2, isNumber: isNumber2, isBoolean: isBoolean2, isNull } = Refinement;
  var Serializable;
  (function(Serializable4) {
    function isSerializable(value) {
      return isObject2(value) && isFunction2(value.toJSON);
    }
    Serializable4.isSerializable = isSerializable;
    function toJSON(value, options) {
      if (isSerializable(value)) {
        return value.toJSON(options);
      }
      if (isString2(value) || isNumber2(value) || isBoolean2(value) || isNull(value)) {
        return value;
      }
      if (isArray(value)) {
        return value.map((item) => toJSON(item, options));
      }
      if (isObject2(value)) {
        const json = {};
        for (const key of keys(value)) {
          if (value[key] !== void 0) {
            json[key] = toJSON(value[key], options);
          }
        }
        return json;
      }
      return null;
    }
    Serializable4.toJSON = toJSON;
    let Verbosity;
    (function(Verbosity2) {
      Verbosity2[Verbosity2["Minimal"] = 0] = "Minimal";
      Verbosity2[Verbosity2["Low"] = 100] = "Low";
      Verbosity2[Verbosity2["Medium"] = 200] = "Medium";
      Verbosity2[Verbosity2["High"] = 300] = "High";
    })(Verbosity = Serializable4.Verbosity || (Serializable4.Verbosity = {}));
  })(Serializable || (Serializable = {}));

  // node_modules/@siteimprove/alfa-option/dist/none.js
  var { compareComparable } = Comparable;
  var None = new class None2 {
    isSome() {
      return false;
    }
    isNone() {
      return true;
    }
    map() {
      return this;
    }
    forEach() {
      return;
    }
    apply() {
      return this;
    }
    flatMap() {
      return this;
    }
    flatten() {
      return this;
    }
    reduce(reducer, accumulator) {
      return accumulator;
    }
    filter() {
      return this;
    }
    reject() {
      return this;
    }
    includes() {
      return false;
    }
    some() {
      return false;
    }
    none() {
      return true;
    }
    every() {
      return true;
    }
    and() {
      return this;
    }
    andThen() {
      return this;
    }
    or(option64) {
      return option64;
    }
    orElse(option64) {
      return option64();
    }
    /**
     * @internal
     */
    getUnsafe(message = "Attempted to .getUnsafe() from None") {
      throw new Error(message);
    }
    getOr(value) {
      return value;
    }
    getOrElse(value) {
      return value();
    }
    tee() {
      return this;
    }
    compare(option64) {
      return this.compareWith(option64, compareComparable);
    }
    compareWith(option64) {
      return option64.isNone() ? Comparison.Equal : Comparison.Less;
    }
    equals(value) {
      return value instanceof None2;
    }
    hash(hash2) {
      hash2.writeBoolean(false);
    }
    *[Symbol.iterator]() {
    }
    toArray() {
      return [];
    }
    toJSON() {
      return {
        type: "none"
      };
    }
    toString() {
      return "None";
    }
  }();

  // node_modules/@siteimprove/alfa-option/dist/some.js
  var { not, test } = Predicate;
  var { compareComparable: compareComparable2 } = Comparable;
  var Some = class _Some {
    static of(value) {
      return new _Some(value);
    }
    _value;
    constructor(value) {
      this._value = value;
    }
    isSome() {
      return true;
    }
    isNone() {
      return false;
    }
    map(mapper) {
      return new _Some(mapper(this._value));
    }
    forEach(mapper) {
      mapper(this._value);
    }
    apply(mapper) {
      return mapper.map((mapper2) => mapper2(this._value));
    }
    flatMap(mapper) {
      return mapper(this._value);
    }
    flatten() {
      return this._value;
    }
    reduce(reducer, accumulator) {
      return reducer(accumulator, this._value);
    }
    filter(predicate) {
      return test(predicate, this._value) ? this : None;
    }
    reject(predicate) {
      return this.filter(not(predicate));
    }
    includes(value) {
      return Equatable.equals(value, this._value);
    }
    some(predicate) {
      return test(predicate, this._value);
    }
    none(predicate) {
      return test(not(predicate), this._value);
    }
    every(predicate) {
      return test(predicate, this._value);
    }
    and(option64) {
      return option64;
    }
    andThen(option64) {
      return option64(this._value);
    }
    or() {
      return this;
    }
    orElse() {
      return this;
    }
    get() {
      return this._value;
    }
    /**
     * @internal
     */
    getUnsafe() {
      return this._value;
    }
    getOr() {
      return this._value;
    }
    getOrElse() {
      return this._value;
    }
    tee(callback) {
      callback(this._value);
      return this;
    }
    compare(option64) {
      return this.compareWith(option64, compareComparable2);
    }
    compareWith(option64, comparer) {
      return option64.isSome() ? comparer(this._value, option64._value) : Comparison.Greater;
    }
    equals(value) {
      return value instanceof _Some && Equatable.equals(value._value, this._value);
    }
    hash(hash2) {
      hash2.writeBoolean(true).writeUnknown(this._value);
    }
    *[Symbol.iterator]() {
      yield this._value;
    }
    toArray() {
      return [this._value];
    }
    toJSON(options) {
      return {
        type: "some",
        value: Serializable.toJSON(this._value, options)
      };
    }
    toString() {
      return `Some { ${this._value} }`;
    }
  };
  (function(Some2) {
    function isSome(value) {
      return value instanceof Some2;
    }
    Some2.isSome = isSome;
  })(Some || (Some = {}));

  // node_modules/@siteimprove/alfa-option/dist/option.js
  var Option;
  (function(Option2) {
    function isOption2(value) {
      return isSome(value) || isNone(value);
    }
    Option2.isOption = isOption2;
    function isSome(value) {
      return Some.isSome(value);
    }
    Option2.isSome = isSome;
    function isNone(value) {
      return value === None;
    }
    Option2.isNone = isNone;
    function of(value) {
      return Some.of(value);
    }
    Option2.of = of;
    function empty() {
      return None;
    }
    Option2.empty = empty;
    function from(value) {
      return value === null || value === void 0 ? None : Some.of(value);
    }
    Option2.from = from;
    function conditional(value, predicate) {
      return predicate(value) ? Some.of(value) : None;
    }
    Option2.conditional = conditional;
  })(Option || (Option = {}));

  // node_modules/@siteimprove/alfa-option/dist/maybe.js
  var Maybe;
  (function(Maybe2) {
    function toOption(maybe) {
      return Option.isOption(maybe) ? maybe : Option.of(maybe);
    }
    Maybe2.toOption = toOption;
  })(Maybe || (Maybe = {}));

  // node_modules/@siteimprove/alfa-iterable/dist/iterable.js
  var { not: not2 } = Predicate;
  var { isObject: isObject3 } = Refinement;
  var { compareComparable: compareComparable3 } = Comparable;
  var Iterable;
  (function(Iterable2) {
    function isIterable(value) {
      return isObject3(value) && Symbol.iterator in value;
    }
    Iterable2.isIterable = isIterable;
    function* empty() {
    }
    Iterable2.empty = empty;
    function* from(arrayLike) {
      for (let i = 0, n = arrayLike.length; i < n; i++) {
        yield arrayLike[i];
      }
    }
    Iterable2.from = from;
    function size(iterable) {
      return reduce2(iterable, (size2) => size2 + 1, 0);
    }
    Iterable2.size = size;
    function isEmpty10(iterable) {
      for (const _ of iterable) {
        return false;
      }
      return true;
    }
    Iterable2.isEmpty = isEmpty10;
    function forEach(iterable, callback) {
      let index = 0;
      for (const value of iterable) {
        callback(value, index++);
      }
    }
    Iterable2.forEach = forEach;
    function* map126(iterable, mapper) {
      let index = 0;
      for (const value of iterable) {
        yield mapper(value, index++);
      }
    }
    Iterable2.map = map126;
    function* flatMap5(iterable, mapper) {
      let index = 0;
      for (const value of iterable) {
        yield* mapper(value, index++);
      }
    }
    Iterable2.flatMap = flatMap5;
    function* flatten2(iterable) {
      for (const value of iterable) {
        yield* value;
      }
    }
    Iterable2.flatten = flatten2;
    function reduce2(iterable, reducer, accumulator) {
      let index = 0;
      for (const value of iterable) {
        accumulator = reducer(accumulator, value, index++);
      }
      return accumulator;
    }
    Iterable2.reduce = reduce2;
    function reduceWhile(iterable, predicate, reducer, accumulator) {
      let index = 0;
      for (const value of iterable) {
        if (predicate(value, index)) {
          accumulator = reducer(accumulator, value, index++);
        } else {
          break;
        }
      }
      return accumulator;
    }
    Iterable2.reduceWhile = reduceWhile;
    function reduceUntil(iterable, predicate, reducer, accumulator) {
      return reduceWhile(iterable, not2(predicate), reducer, accumulator);
    }
    Iterable2.reduceUntil = reduceUntil;
    function apply(iterable, mapper) {
      return flatMap5(mapper, (mapper2) => map126(iterable, mapper2));
    }
    Iterable2.apply = apply;
    function* filter13(iterable, predicate) {
      let index = 0;
      for (const value of iterable) {
        if (predicate(value, index++)) {
          yield value;
        }
      }
    }
    Iterable2.filter = filter13;
    function reject(iterable, predicate) {
      return filter13(iterable, not2(predicate));
    }
    Iterable2.reject = reject;
    function find(iterable, predicate) {
      let index = 0;
      for (const value of iterable) {
        if (predicate(value, index++)) {
          return Option.of(value);
        }
      }
      return None;
    }
    Iterable2.find = find;
    function findLast(iterable, predicate) {
      let index = 0;
      let result = None;
      for (const value of iterable) {
        if (predicate(value, index++)) {
          result = Option.of(value);
        }
      }
      return result;
    }
    Iterable2.findLast = findLast;
    function includes(iterable, value) {
      return some2(iterable, Predicate.equals(value));
    }
    Iterable2.includes = includes;
    function collect(iterable, mapper) {
      return flatMap5(iterable, mapper);
    }
    Iterable2.collect = collect;
    function collectFirst(iterable, mapper) {
      return first(collect(iterable, mapper));
    }
    Iterable2.collectFirst = collectFirst;
    function some2(iterable, predicate) {
      let index = 0;
      for (const value of iterable) {
        if (predicate(value, index++)) {
          return true;
        }
      }
      return false;
    }
    Iterable2.some = some2;
    function none2(iterable, predicate) {
      return every(iterable, not2(predicate));
    }
    Iterable2.none = none2;
    function every(iterable, predicate) {
      let index = 0;
      for (const value of iterable) {
        if (!predicate(value, index++)) {
          return false;
        }
      }
      return true;
    }
    Iterable2.every = every;
    function count(iterable, predicate) {
      return reduce2(iterable, (count2, value, index) => predicate(value, index) ? count2 + 1 : count2, 0);
    }
    Iterable2.count = count;
    function* distinct(iterable) {
      const seen = [];
      for (const value of iterable) {
        if (seen.some(Predicate.equals(value))) {
          continue;
        }
        seen.push(value);
        yield value;
      }
    }
    Iterable2.distinct = distinct;
    function get(iterable, index) {
      return index < 0 ? None : first(skip3(iterable, index));
    }
    Iterable2.get = get;
    function has(iterable, index) {
      return index < 0 ? false : !isEmpty10(skip3(iterable, index));
    }
    Iterable2.has = has;
    function* set2(iterable, index, value) {
      const it = iterator(iterable);
      while (index-- > 0) {
        const next2 = it.next();
        if (next2.done === true) {
          return;
        }
        yield next2.value;
      }
      const next = it.next();
      if (next.done === true) {
        return;
      }
      yield value;
      while (true) {
        const next2 = it.next();
        if (next2.done === true) {
          return;
        }
        yield next2.value;
      }
    }
    Iterable2.set = set2;
    function* insert2(iterable, index, value) {
      const it = iterator(iterable);
      while (index-- > 0) {
        const next = it.next();
        if (next.done === true) {
          return;
        }
        yield next.value;
      }
      yield value;
      while (true) {
        const next = it.next();
        if (next.done === true) {
          return;
        }
        yield next.value;
      }
    }
    Iterable2.insert = insert2;
    function* append(iterable, value) {
      yield* iterable;
      yield value;
    }
    Iterable2.append = append;
    function* prepend(iterable, value) {
      yield value;
      yield* iterable;
    }
    Iterable2.prepend = prepend;
    function* concat(iterable, ...iterables) {
      yield* iterable;
      for (const iterable2 of iterables) {
        yield* iterable2;
      }
    }
    Iterable2.concat = concat;
    function subtract(iterable, ...iterables) {
      return reject(iterable, (value) => includes(flatten2(iterables), value));
    }
    Iterable2.subtract = subtract;
    function intersect(iterable, ...iterables) {
      return filter13(iterable, (value) => includes(flatten2(iterables), value));
    }
    Iterable2.intersect = intersect;
    function* zip(a, b) {
      const itA = iterator(a);
      const itB = iterator(b);
      while (true) {
        const a2 = itA.next();
        const b2 = itB.next();
        if (a2.done === true || b2.done === true) {
          return;
        }
        yield [a2.value, b2.value];
      }
    }
    Iterable2.zip = zip;
    function first(iterable) {
      for (const value of iterable) {
        return Option.of(value);
      }
      return None;
    }
    Iterable2.first = first;
    function last(iterable) {
      let last2 = null;
      for (const value of iterable) {
        last2 = value;
      }
      return Option.from(last2);
    }
    Iterable2.last = last;
    function* take9(iterable, count2) {
      const it = iterator(iterable);
      while (count2-- > 0) {
        const next = it.next();
        if (next.done === true) {
          return;
        }
        yield next.value;
      }
    }
    Iterable2.take = take9;
    function* takeWhile2(iterable, predicate) {
      let index = 0;
      for (const value of iterable) {
        if (predicate(value, index++)) {
          yield value;
        } else {
          break;
        }
      }
    }
    Iterable2.takeWhile = takeWhile2;
    function takeUntil5(iterable, predicate) {
      return takeWhile2(iterable, not2(predicate));
    }
    Iterable2.takeUntil = takeUntil5;
    function* takeLast(iterable, count2 = 1) {
      if (count2 <= 0) {
        return;
      }
      const last2 = [];
      for (const value of iterable) {
        last2.push(value);
        if (last2.length > count2) {
          last2.shift();
        }
      }
      yield* last2;
    }
    Iterable2.takeLast = takeLast;
    function* takeLastWhile(iterable, predicate) {
      const values = [...iterable];
      let last2 = values.length - 1;
      while (last2 >= 0) {
        if (predicate(values[last2], last2)) {
          last2--;
        } else {
          break;
        }
      }
      for (let i = last2, n = values.length - 1; i < n; i++) {
        yield values[i];
      }
    }
    Iterable2.takeLastWhile = takeLastWhile;
    function takeLastUntil(iterable, predicate) {
      return takeLastWhile(iterable, not2(predicate));
    }
    Iterable2.takeLastUntil = takeLastUntil;
    function* skip3(iterable, count2) {
      const it = iterator(iterable);
      while (count2-- > 0) {
        const next = it.next();
        if (next.done === true) {
          return;
        }
      }
      while (true) {
        const next = it.next();
        if (next.done === true) {
          return;
        }
        yield next.value;
      }
    }
    Iterable2.skip = skip3;
    function* skipWhile(iterable, predicate) {
      let index = 0;
      let skipped = false;
      for (const value of iterable) {
        if (!skipped && predicate(value, index++)) {
          continue;
        } else {
          skipped = true;
          yield value;
        }
      }
    }
    Iterable2.skipWhile = skipWhile;
    function skipUntil(iterable, predicate) {
      return skipWhile(iterable, not2(predicate));
    }
    Iterable2.skipUntil = skipUntil;
    function* skipLast(iterable, count2 = 1) {
      const it = iterator(iterable);
      const first2 = [];
      while (count2-- > 0) {
        const next = it.next();
        if (next.done === true) {
          return;
        }
        first2.push(next.value);
      }
      while (true) {
        const next = it.next();
        if (next.done === true) {
          return;
        }
        first2.push(next.value);
        yield first2.shift();
      }
    }
    Iterable2.skipLast = skipLast;
    function* skipLastWhile(iterable, predicate) {
      const values = [...iterable];
      let last2 = values.length - 1;
      while (last2 >= 0) {
        if (predicate(values[last2], last2)) {
          last2--;
        } else {
          break;
        }
      }
      for (let i = 0, n = last2; i < n; i++) {
        yield values[i];
      }
    }
    Iterable2.skipLastWhile = skipLastWhile;
    function skipLastUntil(iterable, predicate) {
      return skipLastWhile(iterable, not2(predicate));
    }
    Iterable2.skipLastUntil = skipLastUntil;
    function trim2(iterable, predicate) {
      return trimTrailing(trimLeading(iterable, predicate), predicate);
    }
    Iterable2.trim = trim2;
    function trimLeading(iterable, predicate) {
      return skipWhile(iterable, predicate);
    }
    Iterable2.trimLeading = trimLeading;
    function trimTrailing(iterable, predicate) {
      return skipLastWhile(iterable, predicate);
    }
    Iterable2.trimTrailing = trimTrailing;
    function rest(iterable) {
      return skip3(iterable, 1);
    }
    Iterable2.rest = rest;
    function slice(iterable, start, end10) {
      iterable = skip3(iterable, start);
      if (end10 !== void 0) {
        iterable = take9(iterable, end10 - start);
      }
      return iterable;
    }
    Iterable2.slice = slice;
    function* reverse(iterable) {
      const array = Array.from(iterable);
      for (let i = array.length - 1; i >= 0; i--) {
        yield array[i];
      }
    }
    Iterable2.reverse = reverse;
    function join(iterable, separator) {
      const it = iterator(iterable);
      let next = it.next();
      if (next.done === true) {
        return "";
      }
      let result = `${next.value}`;
      next = it.next();
      while (next.done !== true) {
        result += `${separator}${next.value}`;
        next = it.next();
      }
      return result;
    }
    Iterable2.join = join;
    function sort(iterable) {
      return sortWith(iterable, compareComparable3);
    }
    Iterable2.sort = sort;
    function* sortWith(iterable, comparer) {
      yield* [...iterable].sort(comparer);
    }
    Iterable2.sortWith = sortWith;
    function compare(a, b) {
      return compareWith(a, b, compareComparable3);
    }
    Iterable2.compare = compare;
    function compareWith(a, b, comparer) {
      const itA = iterator(a);
      const itB = iterator(b);
      let index = 0;
      while (true) {
        const a2 = itA.next();
        const b2 = itB.next();
        if (a2.done === true) {
          return b2.done === true ? Comparison.Equal : Comparison.Less;
        }
        if (b2.done === true) {
          return Comparison.Greater;
        }
        const result = comparer(a2.value, b2.value, index++);
        if (result !== 0) {
          return result;
        }
      }
    }
    Iterable2.compareWith = compareWith;
    function equals34(a, b) {
      const itA = iterator(a);
      const itB = iterator(b);
      while (true) {
        const a2 = itA.next();
        const b2 = itB.next();
        if (a2.done === true) {
          return b2.done === true;
        }
        if (b2.done === true || !Equatable.equals(a2.value, b2.value)) {
          return false;
        }
      }
    }
    Iterable2.equals = equals34;
    function hash2(iterable, hash3) {
      let size2 = 0;
      for (const value of iterable) {
        hash3.writeUnknown(value);
        size2++;
      }
      hash3.writeUint32(size2);
    }
    Iterable2.hash = hash2;
    function iterator(iterable) {
      return iterable[Symbol.iterator]();
    }
    Iterable2.iterator = iterator;
    function groupBy(iterable, grouper) {
      const groups = [];
      let index = 0;
      for (const value of iterable) {
        const group = grouper(value, index++);
        const existing = groups.find(([existing2]) => Equatable.equals(group, existing2));
        if (existing === void 0) {
          groups.push([group, [value]]);
        } else {
          existing[1].push(value);
        }
      }
      return groups;
    }
    Iterable2.groupBy = groupBy;
    function toJSON(iterable, options) {
      return [...map126(iterable, (value) => Serializable.toJSON(value, options))];
    }
    Iterable2.toJSON = toJSON;
  })(Iterable || (Iterable = {}));

  // node_modules/@siteimprove/alfa-array/dist/builtin.js
  var Builtin2 = Array;

  // node_modules/@siteimprove/alfa-array/dist/array.js
  var { not: not3 } = Predicate;
  var { compareComparable: compareComparable4 } = Comparable;
  var Array2;
  (function(Array3) {
    function isArray2(value) {
      return Builtin2.isArray(value);
    }
    Array3.isArray = isArray2;
    function of(...values) {
      return values;
    }
    Array3.of = of;
    function empty() {
      return [];
    }
    Array3.empty = empty;
    function allocate(capacity) {
      return new Builtin2(capacity);
    }
    Array3.allocate = allocate;
    function from(iterable) {
      if (isArray2(iterable)) {
        return iterable;
      }
      return [...iterable];
    }
    Array3.from = from;
    function size(array) {
      return array.length;
    }
    Array3.size = size;
    function isEmpty10(array) {
      return array.length === 0;
    }
    Array3.isEmpty = isEmpty10;
    function copy(array) {
      return array.slice(0);
    }
    Array3.copy = copy;
    function clone(array) {
      return array.map(Clone.clone);
    }
    Array3.clone = clone;
    function forEach(array, callback) {
      for (let i = 0, n = array.length; i < n; i++) {
        callback(array[i], i);
      }
    }
    Array3.forEach = forEach;
    function map126(array, mapper) {
      const result = new Builtin2(array.length);
      for (let i = 0, n = array.length; i < n; i++) {
        result[i] = mapper(array[i], i);
      }
      return result;
    }
    Array3.map = map126;
    function flatMap5(array, mapper) {
      const result = empty();
      for (let i = 0, n = array.length; i < n; i++) {
        result.push(...mapper(array[i], i));
      }
      return result;
    }
    Array3.flatMap = flatMap5;
    function flatten2(array) {
      return flatMap5(array, (array2) => array2);
    }
    Array3.flatten = flatten2;
    function reduce2(array, reducer, accumulator) {
      for (let i = 0, n = array.length; i < n; i++) {
        accumulator = reducer(accumulator, array[i], i);
      }
      return accumulator;
    }
    Array3.reduce = reduce2;
    function reduceWhile(array, predicate, reducer, accumulator) {
      for (let i = 0, n = array.length; i < n; i++) {
        const value = array[i];
        if (predicate(value, i)) {
          accumulator = reducer(accumulator, value, i);
        } else {
          break;
        }
      }
      return accumulator;
    }
    Array3.reduceWhile = reduceWhile;
    function reduceUntil(array, predicate, reducer, accumulator) {
      return reduceWhile(array, not3(predicate), reducer, accumulator);
    }
    Array3.reduceUntil = reduceUntil;
    function apply(array, mapper) {
      return flatMap5(mapper, (mapper2) => map126(array, mapper2));
    }
    Array3.apply = apply;
    function filter13(array, predicate) {
      const result = empty();
      for (let i = 0, n = array.length; i < n; i++) {
        const value = array[i];
        if (predicate(value, i)) {
          result.push(value);
        }
      }
      return result;
    }
    Array3.filter = filter13;
    function reject(array, predicate) {
      return filter13(array, not3(predicate));
    }
    Array3.reject = reject;
    function find(array, predicate) {
      for (let i = 0, n = array.length; i < n; i++) {
        const value = array[i];
        if (predicate(value, i)) {
          return Option.of(value);
        }
      }
      return None;
    }
    Array3.find = find;
    function findLast(array, predicate) {
      for (let i = array.length - 1; i >= 0; i--) {
        const value = array[i];
        if (predicate(value, i)) {
          return Option.of(value);
        }
      }
      return None;
    }
    Array3.findLast = findLast;
    function includes(array, value) {
      return some2(array, Predicate.equals(value));
    }
    Array3.includes = includes;
    function collect(array, mapper) {
      const result = empty();
      for (let i = 0, n = array.length; i < n; i++) {
        for (const value of mapper(array[i], i)) {
          result.push(value);
        }
      }
      return result;
    }
    Array3.collect = collect;
    function collectFirst(array, mapper) {
      for (let i = 0, n = array.length; i < n; i++) {
        const value = mapper(array[i], i);
        if (value.isSome()) {
          return value;
        }
      }
      return None;
    }
    Array3.collectFirst = collectFirst;
    function some2(array, predicate) {
      for (let i = 0, n = array.length; i < n; i++) {
        if (predicate(array[i], i)) {
          return true;
        }
      }
      return false;
    }
    Array3.some = some2;
    function none2(array, predicate) {
      return every(array, not3(predicate));
    }
    Array3.none = none2;
    function every(array, predicate) {
      for (let i = 0, n = array.length; i < n; i++) {
        if (!predicate(array[i], i)) {
          return false;
        }
      }
      return true;
    }
    Array3.every = every;
    function count(array, predicate) {
      return reduce2(array, (count2, value, index) => predicate(value, index) ? count2 + 1 : count2, 0);
    }
    Array3.count = count;
    function distinct(array) {
      const result = empty();
      for (let i = 0, n = array.length; i < n; i++) {
        const value = array[i];
        if (result.some(Predicate.equals(value))) {
          continue;
        }
        result.push(value);
      }
      return result;
    }
    Array3.distinct = distinct;
    function get(array, index) {
      return index < array.length ? Option.of(array[index]) : None;
    }
    Array3.get = get;
    function has(array, index) {
      return index < array.length;
    }
    Array3.has = has;
    function set2(array, index, value) {
      if (index < array.length) {
        array[index] = value;
      }
      return array;
    }
    Array3.set = set2;
    function insert2(array, index, value) {
      if (index <= array.length) {
        array.splice(index, 0, value);
      }
      return array;
    }
    Array3.insert = insert2;
    function append(array, value) {
      array.push(value);
      return array;
    }
    Array3.append = append;
    function prepend(array, value) {
      array.unshift(value);
      return array;
    }
    Array3.prepend = prepend;
    function concat(array, ...iterables) {
      return [...Iterable.concat(array, ...iterables)];
    }
    Array3.concat = concat;
    function subtract(array, ...iterables) {
      return [...Iterable.subtract(array, ...iterables)];
    }
    Array3.subtract = subtract;
    function intersect(array, ...iterables) {
      return [...Iterable.intersect(array, ...iterables)];
    }
    Array3.intersect = intersect;
    function zip(array, iterable) {
      const result = empty();
      const it = Iterable.iterator(iterable);
      for (let i = 0, n = array.length; i < n; i++) {
        const next = it.next();
        if (next.done === true) {
          break;
        }
        result.push([array[i], next.value]);
      }
      return result;
    }
    Array3.zip = zip;
    function first(array) {
      return array.length > 0 ? Option.of(array[0]) : None;
    }
    Array3.first = first;
    function last(array) {
      return array.length > 0 ? Option.of(array[array.length - 1]) : None;
    }
    Array3.last = last;
    function sort(array) {
      return sortWith(array, compareComparable4);
    }
    Array3.sort = sort;
    function sortWith(array, comparer) {
      return array.sort(comparer);
    }
    Array3.sortWith = sortWith;
    function compare(a, b) {
      return compareWith(a, b, compareComparable4);
    }
    Array3.compare = compare;
    function compareWith(a, b, comparer) {
      return Iterable.compareWith(a, b, comparer);
    }
    Array3.compareWith = compareWith;
    function search(array, value, comparer) {
      let lower = 0;
      let upper = array.length - 1;
      while (lower <= upper) {
        const middle = lower + (upper - lower) / 2 >>> 0;
        switch (comparer(value, array[middle])) {
          case Comparison.Greater:
            lower = middle + 1;
            break;
          case Comparison.Less:
            upper = middle - 1;
            break;
          case Comparison.Equal:
            return middle;
        }
      }
      return lower;
    }
    Array3.search = search;
    function equals34(a, b) {
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0, n = a.length; i < n; i++) {
        if (!Equatable.equals(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    Array3.equals = equals34;
    function hash2(array, hash3) {
      for (let i = 0, n = array.length; i < n; i++) {
        hash3.writeUnknown(array[i]);
      }
      hash3.writeUint32(array.length);
    }
    Array3.hash = hash2;
    function iterator(array) {
      return array[Symbol.iterator]();
    }
    Array3.iterator = iterator;
    function toJSON(array, options) {
      return array.map((value) => Serializable.toJSON(value, options));
    }
    Array3.toJSON = toJSON;
  })(Array2 || (Array2 = {}));

  // node_modules/@siteimprove/alfa-future/dist/future.js
  var Future = class {
    then(callback) {
      let step = this;
      while (true) {
        const next = step.step();
        if (step !== next) {
          step = next;
        } else {
          return next.then(callback);
        }
      }
    }
    get() {
      let step = this;
      while (true) {
        const next = step.step();
        if (step !== next) {
          step = next;
        } else {
          return next.get();
        }
      }
    }
    map(mapper) {
      return this.flatMap((value) => Now.of(mapper(value)));
    }
    apply(mapper) {
      return mapper.flatMap((mapper2) => this.map(mapper2));
    }
    flatten() {
      return this.flatMap((future) => future);
    }
    tee(callback) {
      return this.map((value) => {
        callback(value);
        return value;
      });
    }
    async *asyncIterator() {
      yield this.toPromise();
    }
    [Symbol.asyncIterator]() {
      return this.asyncIterator();
    }
    toPromise() {
      return new Promise((resolve3) => this.then(resolve3));
    }
  };
  (function(Future2) {
    function isFuture(value) {
      return value instanceof Future2;
    }
    Future2.isFuture = isFuture;
    function empty() {
      return now(void 0);
    }
    Future2.empty = empty;
    function now(value) {
      return Now.of(value);
    }
    Future2.now = now;
    function defer2(continuation) {
      return Defer.of(continuation);
    }
    Future2.defer = defer2;
    function suspend(thunk) {
      return Suspend.of(thunk);
    }
    Future2.suspend = suspend;
    function delay(thunk) {
      return suspend(() => now(thunk()));
    }
    Future2.delay = delay;
    function from(promise) {
      return Future2.defer((callback) => (typeof promise === "function" ? promise() : promise).then(callback));
    }
    Future2.from = from;
    function traverse(values, mapper) {
      return Iterable.reduce(values, (values2, value, i) => values2.flatMap((values3) => mapper(value, i).map((value2) => Array2.append(values3, value2))), now(Array2.empty()));
    }
    Future2.traverse = traverse;
    function sequence(futures) {
      return traverse(futures, (value) => value);
    }
    Future2.sequence = sequence;
  })(Future || (Future = {}));
  var Now = class _Now extends Future {
    static of(value) {
      return new _Now(value);
    }
    _value;
    constructor(value) {
      super();
      this._value = value;
    }
    step() {
      return this;
    }
    then(callback) {
      callback(this._value);
    }
    get() {
      return this._value;
    }
    isNow() {
      return true;
    }
    isDeferred() {
      return false;
    }
    isSuspended() {
      return false;
    }
    map(mapper) {
      return new _Now(mapper(this._value));
    }
    flatMap(mapper) {
      return Suspend.of(() => mapper(this._value));
    }
  };
  var Defer = class _Defer extends Future {
    static of(continuation) {
      return new _Defer(continuation);
    }
    _continuation;
    constructor(continuation) {
      super();
      this._continuation = continuation;
    }
    step() {
      return this;
    }
    then(callback) {
      this._continuation((value) => defer(() => callback(value)));
    }
    get() {
      throw new Error("Attempted to .get() from deferred future");
    }
    isNow() {
      return false;
    }
    isDeferred() {
      return true;
    }
    isSuspended() {
      return false;
    }
    flatMap(mapper) {
      return _Defer.Bind.of(this._continuation, mapper);
    }
  };
  (function(Defer2) {
    class Bind2 extends Future {
      static of(continuation, mapper) {
        return new Bind2(continuation, mapper);
      }
      _continuation;
      _mapper;
      constructor(continuation, mapper) {
        super();
        this._continuation = continuation;
        this._mapper = mapper;
      }
      step() {
        return this;
      }
      then(callback) {
        this._continuation((value) => defer(() => this._mapper(value).then(callback)));
      }
      get() {
        throw new Error("Attempted to .get() from deferred future");
      }
      isNow() {
        return false;
      }
      isDeferred() {
        return true;
      }
      isSuspended() {
        return false;
      }
      flatMap(mapper) {
        return Suspend.of(() => Bind2.of(this._continuation, (value) => this._mapper(value).flatMap(mapper)));
      }
    }
    Defer2.Bind = Bind2;
  })(Defer || (Defer = {}));
  var Suspend = class _Suspend extends Future {
    static of(thunk) {
      return new _Suspend(thunk);
    }
    _thunk;
    constructor(thunk) {
      super();
      this._thunk = thunk;
    }
    step() {
      return this._thunk();
    }
    isNow() {
      return false;
    }
    isDeferred() {
      return false;
    }
    isSuspended() {
      return true;
    }
    flatMap(mapper) {
      return _Suspend.Bind.of(this._thunk, mapper);
    }
  };
  (function(Suspend3) {
    class Bind2 extends Future {
      static of(thunk, mapper) {
        return new Bind2(thunk, mapper);
      }
      _thunk;
      _mapper;
      constructor(thunk, mapper) {
        super();
        this._thunk = thunk;
        this._mapper = mapper;
      }
      step() {
        return this._thunk().flatMap(this._mapper);
      }
      isNow() {
        return false;
      }
      isDeferred() {
        return false;
      }
      isSuspended() {
        return true;
      }
      flatMap(mapper) {
        return Suspend3.of(() => Bind2.of(this._thunk, (value) => this._mapper(value).flatMap(mapper)));
      }
    }
    Suspend3.Bind = Bind2;
  })(Suspend || (Suspend = {}));
  async function defer(thunk) {
    return Promise.resolve().then(thunk);
  }

  // node_modules/@siteimprove/alfa-encoding/dist/decoder.js
  var Decoder;
  (function(Decoder2) {
    function decode(input) {
      let output = "";
      let i = 0;
      while (i < input.length) {
        let byte = input[i];
        let bytesNeeded = 0;
        let codePoint = 0;
        if (byte <= 127) {
          bytesNeeded = 0;
          codePoint = byte & 255;
        } else if (byte <= 223) {
          bytesNeeded = 1;
          codePoint = byte & 31;
        } else if (byte <= 239) {
          bytesNeeded = 2;
          codePoint = byte & 15;
        } else if (byte <= 244) {
          bytesNeeded = 3;
          codePoint = byte & 7;
        }
        if (input.length - i - bytesNeeded > 0) {
          let k = 0;
          while (k < bytesNeeded) {
            byte = input[i + k + 1];
            codePoint = codePoint << 6 | byte & 63;
            k += 1;
          }
        } else {
          codePoint = 65533;
          bytesNeeded = input.length - i;
        }
        output += String.fromCodePoint(codePoint);
        i += bytesNeeded + 1;
      }
      return output;
    }
    Decoder2.decode = decode;
  })(Decoder || (Decoder = {}));

  // node_modules/@siteimprove/alfa-encoding/dist/encoder.js
  var Encoder;
  (function(Encoder2) {
    function encode(input) {
      const output = [];
      const length = input.length;
      let i = 0;
      while (i < length) {
        const codePoint = input.codePointAt(i);
        let count = 0;
        let bits = 0;
        if (codePoint <= 127) {
          count = 0;
          bits = 0;
        } else if (codePoint <= 2047) {
          count = 6;
          bits = 192;
        } else if (codePoint <= 65535) {
          count = 12;
          bits = 224;
        } else if (codePoint <= 2097151) {
          count = 18;
          bits = 240;
        }
        output.push(bits | codePoint >> count);
        count -= 6;
        while (count >= 0) {
          output.push(128 | codePoint >> count & 63);
          count -= 6;
        }
        i += codePoint >= 65536 ? 2 : 1;
      }
      return new Uint8Array(output);
    }
    Encoder2.encode = encode;
  })(Encoder || (Encoder = {}));

  // node_modules/@siteimprove/alfa-hash/dist/hashable.js
  var { isFunction: isFunction3, isObject: isObject4 } = Refinement;
  var Hashable;
  (function(Hashable2) {
    function isHashable(value) {
      return isObject4(value) && isFunction3(value.hash);
    }
    Hashable2.isHashable = isHashable;
  })(Hashable || (Hashable = {}));

  // node_modules/@siteimprove/alfa-hash/dist/hash.js
  var { keys: keys2 } = Object;
  var builtinOffset = 2216757312;
  var Hash = class _Hash {
    /**
     * A map from objects to their hash values. Objects are weakly referenced as
     * to not prevent them from being garbage collected.
     */
    static _objectHashes = /* @__PURE__ */ new WeakMap();
    /**
     * A map from symbols to their hash values. As there's not currently a way to
     * weakly reference symbols, we have to instead use strong references.
     *
     * {@link https://github.com/tc39/proposal-symbols-as-weakmap-keys}
     */
    static _symbolHashes = /* @__PURE__ */ new Map();
    /**
     * The next available hash value. This is used for symbols and objects that
     * don't implement the {@link (Hashable:interface)} interface.
     */
    static _nextHash = 0;
    constructor() {
    }
    writeString(data) {
      return this.write(Encoder.encode(data));
    }
    /**
     * @remarks
     * As JavaScript represents numbers in double-precision floating-point format,
     * numbers in general will be written as such.
     *
     * {@link https://en.wikipedia.org/wiki/Double-precision_floating-point_format}
     */
    writeNumber(data) {
      return this.writeFloat64(data);
    }
    writeInt(data, size = 32, signed = true) {
      const buffer = new ArrayBuffer(size / 8);
      const view = new DataView(buffer);
      switch (size) {
        case 8:
          signed ? view.setInt8(0, data) : view.setUint8(0, data);
          break;
        case 16:
          signed ? view.setInt16(0, data) : view.setUint16(0, data);
          break;
        case 32:
          signed ? view.setInt32(0, data) : view.setUint32(0, data);
      }
      return this.write(new Uint8Array(buffer));
    }
    writeInt8(data) {
      return this.writeInt(data, 8, true);
    }
    writeUint8(data) {
      return this.writeInt(data, 8, false);
    }
    writeInt16(data) {
      return this.writeInt(data, 16, true);
    }
    writeUint16(data) {
      return this.writeInt(data, 16, false);
    }
    writeInt32(data) {
      return this.writeInt(data, 32, true);
    }
    writeUint32(data) {
      return this.writeInt(data, 32, false);
    }
    writeBigInt(data, size = 64, signed = true) {
      const buffer = new ArrayBuffer(size / 8);
      const view = new DataView(buffer);
      switch (size) {
        case 64:
          signed ? view.setBigInt64(0, data) : view.setBigUint64(0, data);
      }
      return this.write(new Uint8Array(buffer));
    }
    writeBigInt64(data) {
      return this.writeBigInt(data, 64, true);
    }
    writeBigUint64(data) {
      return this.writeBigInt(data, 64, false);
    }
    writeFloat(data, size = 32) {
      const buffer = new ArrayBuffer(size / 8);
      const view = new DataView(buffer);
      switch (size) {
        case 32:
          view.setFloat32(0, data);
          break;
        case 64:
          view.setFloat64(0, data);
      }
      return this.write(new Uint8Array(buffer));
    }
    writeFloat32(data) {
      return this.writeFloat(data, 32);
    }
    writeFloat64(data) {
      return this.writeFloat(data, 64);
    }
    writeBoolean(data) {
      return this.writeUint8(builtinOffset + (data ? 1 : 0));
    }
    writeUndefined() {
      return this.writeUint32(builtinOffset + 2);
    }
    writeNull() {
      return this.writeUint32(builtinOffset + 3);
    }
    writeObject(data) {
      let hash2 = _Hash._objectHashes.get(data);
      if (hash2 === void 0) {
        hash2 = _Hash._getNextHash();
        _Hash._objectHashes.set(data, hash2);
      }
      return this.writeUint32(hash2);
    }
    writeSymbol(data) {
      let hash2 = _Hash._symbolHashes.get(data);
      if (hash2 === void 0) {
        hash2 = _Hash._getNextHash();
        _Hash._symbolHashes.set(data, hash2);
      }
      return this.writeUint32(hash2);
    }
    writeHashable(data) {
      data.hash(this);
      return this;
    }
    writeUnknown(data) {
      switch (typeof data) {
        case "string":
          return this.writeString(data);
        case "number":
          return this.writeNumber(data);
        case "bigint":
          return this.writeBigInt(data);
        case "boolean":
          return this.writeBoolean(data);
        case "symbol":
          return this.writeSymbol(data);
        case "undefined":
          return this.writeUndefined();
        case "object":
          if (data === null) {
            return this.writeNull();
          }
          if (Hashable.isHashable(data)) {
            return this.writeHashable(data);
          }
          return this.writeObject(data);
        case "function":
          return this.writeObject(data);
      }
    }
    writeJSON(data) {
      switch (typeof data) {
        case "string":
          return this.writeString(data);
        case "number":
          return this.writeNumber(data);
        case "boolean":
          return this.writeBoolean(data);
        case "object":
          if (Array.isArray(data)) {
            for (let i = 0, n = data.length; i < n; i++) {
              this.writeJSON(data[i]);
            }
            this.writeUint32(data.length);
          } else if (data !== null) {
            for (const key of keys2(data).sort()) {
              const value = data[key];
              this.writeString(key);
              if (value !== void 0) {
                this.writeJSON(value);
              }
              this.writeUint8(0);
            }
          }
          return this;
      }
    }
    equals(value) {
      return value instanceof _Hash && value.finish() === this.finish();
    }
    hash(hash2) {
      hash2.writeUint32(this.finish());
    }
    static _getNextHash() {
      const nextHash = _Hash._nextHash;
      _Hash._nextHash = _Hash._nextHash + 1 >>> 0;
      return nextHash;
    }
  };

  // node_modules/@siteimprove/alfa-fnv/dist/fnv.js
  var FNV = class _FNV extends Hash {
    static empty() {
      return new _FNV();
    }
    _hash = 2166136261;
    constructor() {
      super();
    }
    finish() {
      return this._hash >>> 0;
    }
    write(data) {
      let hash2 = this._hash;
      for (const octet of data) {
        hash2 ^= octet;
        hash2 += (hash2 << 1) + (hash2 << 4) + (hash2 << 7) + (hash2 << 8) + (hash2 << 24);
      }
      this._hash = hash2;
      return this;
    }
    equals(value) {
      return value instanceof _FNV && value._hash === this._hash;
    }
  };

  // node_modules/@siteimprove/alfa-bits/dist/bits.js
  var Bits;
  (function(Bits2) {
    function bit3(i) {
      return 1 << i;
    }
    Bits2.bit = bit3;
    function set2(bits, i) {
      return bits | bit3(i);
    }
    Bits2.set = set2;
    function clear2(bits, i) {
      return bits & ~bit3(i);
    }
    Bits2.clear = clear2;
    function test43(bits, i) {
      return (bits & bit3(i)) !== 0;
    }
    Bits2.test = test43;
    function take9(bits, n) {
      return bits & (1 << n) - 1;
    }
    Bits2.take = take9;
    function skip3(bits, n) {
      return bits >>> n;
    }
    Bits2.skip = skip3;
    function popCount2(bits) {
      bits -= bits >> 1 & 1431655765;
      bits = (bits & 858993459) + (bits >> 2 & 858993459);
      bits = bits + (bits >> 4) & 252645135;
      bits += bits >> 8;
      bits += bits >> 16;
      return bits & 127;
    }
    Bits2.popCount = popCount2;
  })(Bits || (Bits = {}));

  // node_modules/@siteimprove/alfa-map/dist/status.js
  var Status;
  (function(Status_1) {
    class Status2 {
      _result;
      constructor(result) {
        this._result = result;
      }
      get result() {
        return this._result;
      }
    }
    class Created extends Status2 {
      static of(result) {
        return new Created(result);
      }
      constructor(result) {
        super(result);
      }
      get status() {
        return "created";
      }
    }
    Status_1.Created = Created;
    Status_1.created = Created.of;
    class Updated extends Status2 {
      static of(result) {
        return new Updated(result);
      }
      constructor(result) {
        super(result);
      }
      get status() {
        return "updated";
      }
    }
    Status_1.Updated = Updated;
    Status_1.updated = Updated.of;
    class Deleted extends Status2 {
      static of(result) {
        return new Deleted(result);
      }
      constructor(result) {
        super(result);
      }
      get status() {
        return "deleted";
      }
    }
    Status_1.Deleted = Deleted;
    Status_1.deleted = Deleted.of;
    class Unchanged extends Status2 {
      static of(result) {
        return new Unchanged(result);
      }
      constructor(result) {
        super(result);
      }
      get status() {
        return "unchanged";
      }
    }
    Status_1.Unchanged = Unchanged;
    Status_1.unchanged = Unchanged.of;
  })(Status || (Status = {}));

  // node_modules/@siteimprove/alfa-map/dist/node.js
  var { bit, take, skip, test: test2, set, clear, popCount } = Bits;
  var Node;
  (function(Node6) {
    Node6.Bits = 5;
    function fragment(hash2, shift) {
      return take(skip(hash2, shift), Node6.Bits);
    }
    Node6.fragment = fragment;
    function index(fragment2, mask) {
      return popCount(take(mask, fragment2));
    }
    Node6.index = index;
  })(Node || (Node = {}));
  var Empty = new class Empty2 {
    isEmpty() {
      return true;
    }
    isLeaf() {
      return false;
    }
    get() {
      return None;
    }
    set(key, value, hash2) {
      return Status.created(Leaf.of(hash2, key, value));
    }
    delete() {
      return Status.unchanged(this);
    }
    map() {
      return this;
    }
    equals(value) {
      return value instanceof Empty2;
    }
    *[Symbol.iterator]() {
    }
  }();
  var Leaf = class _Leaf {
    static of(hash2, key, value) {
      return new _Leaf(hash2, key, value);
    }
    _hash;
    _key;
    _value;
    constructor(hash2, key, value) {
      this._hash = hash2;
      this._key = key;
      this._value = value;
    }
    get key() {
      return this._key;
    }
    get value() {
      return this._value;
    }
    isEmpty() {
      return false;
    }
    isLeaf() {
      return true;
    }
    get(key, hash2, shift) {
      return hash2 === this._hash && Equatable.equals(key, this._key) ? Option.of(this._value) : None;
    }
    set(key, value, hash2, shift) {
      if (hash2 === this._hash) {
        if (Equatable.equals(key, this._key)) {
          if (Equatable.equals(value, this._value)) {
            return Status.unchanged(this);
          }
          return Status.updated(_Leaf.of(hash2, key, value));
        }
        return Status.created(Collision.of(hash2, [this, _Leaf.of(hash2, key, value)]));
      }
      const fragment = Node.fragment(this._hash, shift);
      return Sparse.of(bit(fragment), [this]).set(key, value, hash2, shift);
    }
    delete(key, hash2) {
      return hash2 === this._hash && Equatable.equals(key, this._key) ? Status.deleted(Empty) : Status.unchanged(this);
    }
    map(mapper) {
      return _Leaf.of(this._hash, this._key, mapper(this._value, this._key));
    }
    equals(value) {
      return value instanceof _Leaf && value._hash === this._hash && Equatable.equals(value._key, this._key) && Equatable.equals(value._value, this._value);
    }
    *[Symbol.iterator]() {
      yield [this._key, this._value];
    }
  };
  var Collision = class _Collision {
    static of(hash2, nodes) {
      return new _Collision(hash2, nodes);
    }
    _hash;
    _nodes;
    constructor(hash2, nodes) {
      this._hash = hash2;
      this._nodes = nodes;
    }
    isEmpty() {
      return false;
    }
    isLeaf() {
      return false;
    }
    get(key, hash2, shift) {
      if (hash2 === this._hash) {
        for (const node of this._nodes) {
          const value = node.get(key, hash2, shift);
          if (value.isSome()) {
            return value;
          }
        }
      }
      return None;
    }
    set(key, value, hash2, shift) {
      if (hash2 === this._hash) {
        for (let i = 0, n = this._nodes.length; i < n; i++) {
          const node = this._nodes[i];
          if (Equatable.equals(key, node.key)) {
            if (Equatable.equals(value, node.value)) {
              return Status.unchanged(this);
            }
            return Status.updated(_Collision.of(this._hash, replace(this._nodes, i, Leaf.of(hash2, key, value))));
          }
        }
        return Status.created(_Collision.of(this._hash, this._nodes.concat(Leaf.of(hash2, key, value))));
      }
      const fragment = Node.fragment(this._hash, shift);
      return Sparse.of(bit(fragment), [this]).set(key, value, hash2, shift);
    }
    delete(key, hash2) {
      if (hash2 === this._hash) {
        for (let i = 0, n = this._nodes.length; i < n; i++) {
          const node = this._nodes[i];
          if (Equatable.equals(key, node.key)) {
            const nodes = remove(this._nodes, i);
            if (nodes.length === 1) {
              return Status.deleted(nodes[0]);
            }
            return Status.deleted(_Collision.of(this._hash, nodes));
          }
        }
      }
      return Status.unchanged(this);
    }
    map(mapper) {
      return _Collision.of(this._hash, this._nodes.map((node) => node.map(mapper)));
    }
    equals(value) {
      return value instanceof _Collision && value._hash === this._hash && value._nodes.length === this._nodes.length && value._nodes.every((node, i) => node.equals(this._nodes[i]));
    }
    *[Symbol.iterator]() {
      for (const node of this._nodes) {
        yield* node;
      }
    }
  };
  var Sparse = class _Sparse {
    static of(mask, nodes) {
      return new _Sparse(mask, nodes);
    }
    _mask;
    _nodes;
    constructor(mask, nodes) {
      this._mask = mask;
      this._nodes = nodes;
    }
    isEmpty() {
      return false;
    }
    isLeaf() {
      return false;
    }
    get(key, hash2, shift) {
      const fragment = Node.fragment(hash2, shift);
      if (test2(this._mask, fragment)) {
        const index = Node.index(fragment, this._mask);
        return this._nodes[index].get(key, hash2, shift + Node.Bits);
      }
      return None;
    }
    set(key, value, hash2, shift) {
      const fragment = Node.fragment(hash2, shift);
      const index = Node.index(fragment, this._mask);
      if (test2(this._mask, fragment)) {
        const { result: node, status } = this._nodes[index].set(key, value, hash2, shift + Node.Bits);
        if (status === "unchanged") {
          return Status.unchanged(this);
        }
        const sparse = _Sparse.of(this._mask, replace(this._nodes, index, node));
        switch (status) {
          case "created":
            return Status.created(sparse);
          case "updated":
          default:
            return Status.updated(sparse);
        }
      }
      return Status.created(_Sparse.of(set(this._mask, fragment), insert(this._nodes, index, Leaf.of(hash2, key, value))));
    }
    delete(key, hash2, shift) {
      const fragment = Node.fragment(hash2, shift);
      if (test2(this._mask, fragment)) {
        const index = Node.index(fragment, this._mask);
        const { result: node, status } = this._nodes[index].delete(key, hash2, shift + Node.Bits);
        if (status === "unchanged") {
          return Status.unchanged(this);
        }
        if (node.isEmpty()) {
          const nodes = remove(this._nodes, index);
          if (nodes.length === 1) {
            if (nodes[0].isLeaf() || nodes[0] instanceof Collision) {
              return Status.deleted(nodes[0]);
            }
          }
          return Status.deleted(_Sparse.of(clear(this._mask, fragment), nodes));
        }
        return Status.deleted(_Sparse.of(this._mask, replace(this._nodes, index, node)));
      }
      return Status.unchanged(this);
    }
    map(mapper) {
      return _Sparse.of(this._mask, this._nodes.map((node) => node.map(mapper)));
    }
    equals(value) {
      return value instanceof _Sparse && value._mask === this._mask && value._nodes.length === this._nodes.length && value._nodes.every((node, i) => node.equals(this._nodes[i]));
    }
    *[Symbol.iterator]() {
      for (const node of this._nodes) {
        yield* node;
      }
    }
  };
  function insert(array, index, value) {
    const result = new Array(array.length + 1);
    result[index] = value;
    for (let i = 0, n = index; i < n; i++) {
      result[i] = array[i];
    }
    for (let i = index, n = array.length; i < n; i++) {
      result[i + 1] = array[i];
    }
    return result;
  }
  function remove(array, index) {
    const result = new Array(array.length - 1);
    for (let i = 0, n = index; i < n; i++) {
      result[i] = array[i];
    }
    for (let i = index, n = result.length; i < n; i++) {
      result[i] = array[i + 1];
    }
    return result;
  }
  function replace(array, index, value) {
    const result = array.slice(0);
    result[index] = value;
    return result;
  }

  // node_modules/@siteimprove/alfa-map/dist/map.js
  var { not: not4 } = Predicate;
  var Map2 = class _Map {
    static of(...entries3) {
      return entries3.reduce((map126, [key, value]) => map126.set(key, value), _Map.empty());
    }
    static _empty = new _Map(Empty, 0);
    static empty() {
      return this._empty;
    }
    _root;
    _size;
    constructor(root, size) {
      this._root = root;
      this._size = size;
    }
    get size() {
      return this._size;
    }
    isEmpty() {
      return this._size === 0;
    }
    forEach(callback) {
      Iterable.forEach(this, ([key, value]) => callback(value, key));
    }
    map(mapper) {
      return new _Map(this._root.map(mapper), this._size);
    }
    /**
     * Apply a map of functions to each corresponding value of this map.
     *
     * @remarks
     * Keys without a corresponding function or value are dropped from the
     * resulting map.
     *
     * @example
     * ```ts
     * Map.of(["a", 1], ["b", 2])
     *   .apply(Map.of(["a", (x) => x + 1], ["b", (x) => x * 2]))
     *   .toArray();
     * // => [["a", 2], ["b", 4]]
     * ```
     */
    apply(mapper) {
      return this.collect((value, key) => mapper.get(key).map((mapper2) => mapper2(value)));
    }
    /**
     * @remarks
     * As the order of maps is undefined, it is also undefined which keys are
     * kept when duplicate keys are encountered.
     */
    flatMap(mapper) {
      return this.reduce((map126, value, key) => map126.concat(mapper(value, key)), _Map.empty());
    }
    /**
     * @remarks
     * As the order of maps is undefined, it is also undefined which keys are
     * kept when duplicate keys are encountered.
     */
    flatten() {
      return this.flatMap((map126) => map126);
    }
    reduce(reducer, accumulator) {
      return Iterable.reduce(this, (accumulator2, [key, value]) => reducer(accumulator2, value, key), accumulator);
    }
    filter(predicate) {
      return this.reduce((map126, value, key) => predicate(value, key) ? map126.set(key, value) : map126, _Map.empty());
    }
    reject(predicate) {
      return this.filter(not4(predicate));
    }
    find(predicate) {
      return Iterable.find(this, ([key, value]) => predicate(value, key)).map(([, value]) => value);
    }
    includes(value) {
      return Iterable.includes(this.values(), value);
    }
    collect(mapper) {
      return _Map.from(Iterable.collect(this, ([key, value]) => mapper(value, key).map((value2) => [key, value2])));
    }
    collectFirst(mapper) {
      return Iterable.collectFirst(this, ([key, value]) => mapper(value, key));
    }
    some(predicate) {
      return Iterable.some(this, ([key, value]) => predicate(value, key));
    }
    none(predicate) {
      return Iterable.none(this, ([key, value]) => predicate(value, key));
    }
    every(predicate) {
      return Iterable.every(this, ([key, value]) => predicate(value, key));
    }
    count(predicate) {
      return Iterable.count(this, ([key, value]) => predicate(value, key));
    }
    /**
     * @remarks
     * As the order of maps is undefined, it is also undefined which keys are
     * kept when duplicate values are encountered.
     */
    distinct() {
      let seen = _Map.empty();
      let map126 = this;
      for (const [key, value] of map126) {
        if (seen.has(value)) {
          map126 = map126.delete(key);
        } else {
          seen = seen.set(value, value);
        }
      }
      return map126;
    }
    get(key) {
      return this._root.get(key, hash(key), 0);
    }
    has(key) {
      return this.get(key).isSome();
    }
    set(key, value) {
      const { result: root, status } = this._root.set(key, value, hash(key), 0);
      if (status === "unchanged") {
        return this;
      }
      return new _Map(root, this._size + (status === "updated" ? 0 : 1));
    }
    delete(key) {
      const { result: root, status } = this._root.delete(key, hash(key), 0);
      if (status === "unchanged") {
        return this;
      }
      return new _Map(root, this._size - 1);
    }
    concat(iterable) {
      return Iterable.reduce(iterable, (map126, [key, value]) => map126.set(key, value), this);
    }
    subtract(iterable) {
      return Iterable.reduce(iterable, (map126, [key]) => map126.delete(key), this);
    }
    intersect(iterable) {
      return _Map.fromIterable(Iterable.filter(iterable, ([key]) => this.has(key)));
    }
    tee(callback, ...args) {
      callback(this, ...args);
      return this;
    }
    equals(value) {
      return value instanceof _Map && value._size === this._size && value._root.equals(this._root);
    }
    hash(hash2) {
      for (const [key, value] of this) {
        hash2.writeUnknown(key).writeUnknown(value);
      }
      hash2.writeUint32(this._size);
    }
    keys() {
      return Iterable.map(this._root, (entry) => entry[0]);
    }
    values() {
      return Iterable.map(this._root, (entry) => entry[1]);
    }
    *iterator() {
      yield* this._root;
    }
    [Symbol.iterator]() {
      return this.iterator();
    }
    toArray() {
      return [...this];
    }
    toJSON(options) {
      return this.toArray().map(([key, value]) => [
        Serializable.toJSON(key, options),
        Serializable.toJSON(value, options)
      ]);
    }
    toString() {
      const entries3 = this.toArray().map(([key, value]) => `${key} => ${value}`).join(", ");
      return `Map {${entries3 === "" ? "" : ` ${entries3} `}}`;
    }
  };
  (function(Map3) {
    function isMap(value) {
      return value instanceof Map3;
    }
    Map3.isMap = isMap;
    function from(iterable) {
      if (isMap(iterable)) {
        return iterable;
      }
      if (Array2.isArray(iterable)) {
        return fromArray(iterable);
      }
      return fromIterable(iterable);
    }
    Map3.from = from;
    function fromArray(array) {
      return Array2.reduce(array, (map126, [key, value]) => map126.set(key, value), Map3.empty());
    }
    Map3.fromArray = fromArray;
    function fromIterable(iterable) {
      return Iterable.reduce(iterable, (map126, [key, value]) => map126.set(key, value), Map3.empty());
    }
    Map3.fromIterable = fromIterable;
  })(Map2 || (Map2 = {}));
  function hash(key) {
    return FNV.empty().writeUnknown(key).finish();
  }

  // node_modules/@siteimprove/alfa-set/dist/set.js
  var { not: not5 } = Predicate;
  var Set2 = class _Set {
    static of(...values) {
      return values.reduce((set2, value) => set2.add(value), _Set.empty());
    }
    static _empty = new _Set(Map2.empty());
    static empty() {
      return this._empty;
    }
    _values;
    constructor(values) {
      this._values = values;
    }
    get size() {
      return this._values.size;
    }
    isEmpty() {
      return this._values.isEmpty();
    }
    forEach(callback) {
      Iterable.forEach(this, callback);
    }
    map(mapper) {
      return this._values.reduce((set2, _, value) => set2.add(mapper(value)), _Set.empty());
    }
    apply(mapper) {
      return mapper.flatMap((mapper2) => this.map(mapper2));
    }
    flatMap(mapper) {
      return this.reduce((set2, value) => set2.concat(mapper(value)), _Set.empty());
    }
    flatten() {
      return this.flatMap((set2) => set2);
    }
    reduce(reducer, accumulator) {
      return Iterable.reduce(this, reducer, accumulator);
    }
    filter(predicate) {
      return this.reduce((set2, value) => predicate(value) ? set2.add(value) : set2, _Set.empty());
    }
    reject(predicate) {
      return this.filter(not5(predicate));
    }
    find(predicate) {
      return Iterable.find(this, predicate);
    }
    includes(value) {
      return Iterable.includes(this, value);
    }
    collect(mapper) {
      return _Set.from(Iterable.collect(this, mapper));
    }
    collectFirst(mapper) {
      return Iterable.collectFirst(this, mapper);
    }
    some(predicate) {
      return Iterable.some(this, predicate);
    }
    none(predicate) {
      return Iterable.none(this, predicate);
    }
    every(predicate) {
      return Iterable.every(this, predicate);
    }
    count(predicate) {
      return Iterable.count(this, predicate);
    }
    /**
     * @remarks
     * As sets don't contain duplicate values, they will only ever contain
     * distinct values.
     */
    distinct() {
      return this;
    }
    get(value) {
      return this._values.get(value);
    }
    has(value) {
      return this._values.has(value);
    }
    add(value) {
      const values = this._values.set(value, value);
      if (values === this._values) {
        return this;
      }
      return new _Set(values);
    }
    delete(value) {
      const values = this._values.delete(value);
      if (values === this._values) {
        return this;
      }
      return new _Set(values);
    }
    concat(iterable) {
      return Iterable.reduce(iterable, (set2, value) => set2.add(value), this);
    }
    subtract(iterable) {
      return Iterable.reduce(iterable, (set2, value) => set2.delete(value), this);
    }
    intersect(iterable) {
      return _Set.fromIterable(Iterable.filter(iterable, (value) => this.has(value)));
    }
    tee(callback, ...args) {
      callback(this, ...args);
      return this;
    }
    equals(value) {
      return value instanceof _Set && value._values.equals(this._values);
    }
    hash(hash2) {
      for (const value of this) {
        hash2.writeUnknown(value);
      }
      hash2.writeUint32(this._values.size);
    }
    *iterator() {
      for (const [value] of this._values) {
        yield value;
      }
    }
    [Symbol.iterator]() {
      return this.iterator();
    }
    toArray() {
      return [...this];
    }
    toJSON(options) {
      return this.toArray().map((value) => Serializable.toJSON(value, options));
    }
    toString() {
      const entries3 = this.toArray().join(", ");
      return `Set {${entries3 === "" ? "" : ` ${entries3} `}}`;
    }
  };
  (function(Set3) {
    function isSet(value) {
      return value instanceof Set3;
    }
    Set3.isSet = isSet;
    function from(iterable) {
      if (isSet(iterable)) {
        return iterable;
      }
      if (Array2.isArray(iterable)) {
        return fromArray(iterable);
      }
      return fromIterable(iterable);
    }
    Set3.from = from;
    function fromArray(array) {
      return Array2.reduce(array, (set2, value) => set2.add(value), Set3.empty());
    }
    Set3.fromArray = fromArray;
    function fromIterable(iterable) {
      return Iterable.reduce(iterable, (set2, value) => set2.add(value), Set3.empty());
    }
    Set3.fromIterable = fromIterable;
  })(Set2 || (Set2 = {}));

  // node_modules/@siteimprove/alfa-list/dist/node.js
  var { bit: bit2, take: take2, skip: skip2 } = Bits;
  var Node2;
  (function(Node6) {
    Node6.Bits = 5;
    Node6.Capacity = bit2(Node6.Bits);
    function fragment(index, shift) {
      return take2(skip2(index, shift), Node6.Bits);
    }
    Node6.fragment = fragment;
    function overflow2(shift) {
      return Node6.Capacity << shift - Node6.Bits;
    }
    Node6.overflow = overflow2;
    function underflow(shift) {
      return Node6.Capacity << shift - Node6.Bits * 2;
    }
    Node6.underflow = underflow;
  })(Node2 || (Node2 = {}));
  var Empty3 = new class Empty4 {
    isEmpty() {
      return true;
    }
    isLeaf() {
      return false;
    }
    get() {
      return None;
    }
    set() {
      return this;
    }
    map() {
      return this;
    }
    equals(value) {
      return value instanceof Empty4;
    }
    *[Symbol.iterator]() {
    }
  }();
  var Leaf2 = class _Leaf {
    static of(values) {
      return new _Leaf(values);
    }
    _values;
    constructor(values) {
      this._values = values;
    }
    get values() {
      return this._values;
    }
    isEmpty() {
      return false;
    }
    isLeaf() {
      return true;
    }
    hasCapacity() {
      return this._values.length < Node2.Capacity;
    }
    get(index) {
      const fragment = take2(index, Node2.Bits);
      return Option.of(this._values[fragment]);
    }
    set(index, value) {
      const fragment = take2(index, Node2.Bits);
      if (Equatable.equals(value, this._values[fragment])) {
        return this;
      }
      const values = this._values.slice(0);
      values[fragment] = value;
      return _Leaf.of(values);
    }
    map(mapper) {
      return _Leaf.of(this._values.map(mapper));
    }
    equals(value) {
      return value instanceof _Leaf && value._values.length === this._values.length && value._values.every((value2, i) => Equatable.equals(value2, this._values[i]));
    }
    *[Symbol.iterator]() {
      yield* this._values;
    }
  };
  var Branch = class _Branch {
    static of(nodes) {
      return new _Branch(nodes);
    }
    static empty() {
      return new _Branch([]);
    }
    _nodes;
    constructor(nodes) {
      this._nodes = nodes;
    }
    get nodes() {
      return this._nodes;
    }
    isEmpty() {
      return false;
    }
    isLeaf() {
      return false;
    }
    clone() {
      return _Branch.of(this._nodes.slice(0));
    }
    get(index, shift) {
      const fragment = Node2.fragment(index, shift);
      return this._nodes[fragment].get(index, shift - Node2.Bits);
    }
    set(index, value, shift) {
      const fragment = Node2.fragment(index, shift);
      const node = this._nodes[fragment].set(index, value, shift - Node2.Bits);
      if (node === this._nodes[fragment]) {
        return this;
      }
      const nodes = this._nodes.slice(0);
      nodes[fragment] = node;
      return _Branch.of(nodes);
    }
    map(mapper) {
      return _Branch.of(this._nodes.map((node) => node.map(mapper)));
    }
    equals(value) {
      return value instanceof _Branch && value._nodes.length === this._nodes.length && value._nodes.every((node, i) => node.equals(this._nodes[i]));
    }
    *[Symbol.iterator]() {
      for (const node of this._nodes) {
        yield* node;
      }
    }
  };

  // node_modules/@siteimprove/alfa-list/dist/list.js
  var { not: not6 } = Predicate;
  var { compareComparable: compareComparable5 } = Comparable;
  var List = class _List {
    static of(...values) {
      const size = values.length;
      if (size <= Node2.Capacity) {
        return new _List(Empty3, Leaf2.of(values), 0, size);
      }
      return values.reduce((list, value) => list._push(value), _List.empty());
    }
    static _empty = new _List(Empty3, Empty3, 0, 0);
    static empty() {
      return this._empty;
    }
    _head;
    _tail;
    _shift;
    _size;
    constructor(head, tail, shift, size) {
      this._head = head;
      this._tail = tail;
      this._shift = shift;
      this._size = size;
    }
    get size() {
      return this._size;
    }
    isEmpty() {
      return this._tail.isEmpty();
    }
    forEach(callback) {
      Iterable.forEach(this, callback);
    }
    map(mapper) {
      let index = 0;
      const tail = this._tail.map((value) => mapper(value, index++));
      const head = this._head.map((value) => mapper(value, index++));
      return new _List(head, tail, this._shift, this._size);
    }
    apply(mapper) {
      return mapper.flatMap((mapper2) => this.map(mapper2));
    }
    flatMap(mapper) {
      return this.reduce((list, value, index) => list.concat(mapper(value, index)), _List.empty());
    }
    flatten() {
      return this.flatMap((list) => list);
    }
    reduce(reducer, accumulator) {
      return Iterable.reduce(this, reducer, accumulator);
    }
    reduceWhile(predicate, reducer, accumulator) {
      return Iterable.reduceWhile(this, predicate, reducer, accumulator);
    }
    reduceUntil(predicate, reducer, accumulator) {
      return Iterable.reduceUntil(this, predicate, reducer, accumulator);
    }
    filter(predicate) {
      return _List.from(Iterable.filter(this, predicate));
    }
    reject(predicate) {
      return this.filter(not6(predicate));
    }
    find(predicate) {
      return Iterable.find(this, predicate);
    }
    includes(value) {
      return Iterable.includes(this, value);
    }
    collect(mapper) {
      return _List.from(Iterable.collect(this, mapper));
    }
    collectFirst(mapper) {
      return Iterable.collectFirst(this, mapper);
    }
    some(predicate) {
      return Iterable.some(this, predicate);
    }
    none(predicate) {
      return Iterable.none(this, predicate);
    }
    every(predicate) {
      return Iterable.every(this, predicate);
    }
    count(predicate) {
      return Iterable.count(this, predicate);
    }
    distinct() {
      let seen = Set2.empty();
      let list = _List.empty();
      for (const value of this) {
        if (seen.has(value)) {
          continue;
        }
        seen = seen.add(value);
        list = list.append(value);
      }
      return list;
    }
    get(index) {
      if (index < 0 || index >= this._size || this._tail.isEmpty()) {
        return None;
      }
      const offset = this._size - this._tail.values.length;
      let value;
      if (index < offset) {
        value = this._head.get(index, this._shift - Node2.Bits);
      } else {
        value = this._tail.get(index - offset);
      }
      return value;
    }
    has(index) {
      return index >= 0 && index < this._size;
    }
    set(index, value) {
      if (index < 0 || index >= this._size || this._tail.isEmpty()) {
        return this;
      }
      const offset = this._size - this._tail.values.length;
      let head = this._head;
      let tail = this._tail;
      if (index < offset) {
        if (head.isEmpty()) {
          return this;
        }
        head = head.set(index, value, this._shift);
        if (head === this._head) {
          return this;
        }
      } else {
        tail = tail.set(index - offset, value);
        if (tail === this._tail) {
          return this;
        }
      }
      return new _List(head, tail, this._shift, this._size);
    }
    insert(index, value) {
      if (index < 0 || index > this.size) {
        return this;
      }
      if (index === 0) {
        return this.prepend(value);
      }
      if (index === this.size) {
        return this.append(value);
      }
      return _List.from(Iterable.concat(Iterable.take(this, index), Iterable.from([value]), Iterable.skip(this, index)));
    }
    append(value) {
      return this._push(value);
    }
    prepend(value) {
      return _List.of(value).concat(this);
    }
    concat(iterable) {
      return Iterable.reduce(iterable, (list, value) => list._push(value), this);
    }
    subtract(iterable) {
      return _List.from(Iterable.subtract(this, iterable));
    }
    intersect(iterable) {
      return _List.from(Iterable.intersect(this, iterable));
    }
    tee(callback, ...args) {
      callback(this, ...args);
      return this;
    }
    zip(iterable) {
      return _List.from(Iterable.zip(this, iterable));
    }
    first() {
      return this._tail.isEmpty() ? None : Option.of(this._tail.values[0]);
    }
    last() {
      return Iterable.last(this);
    }
    take(count) {
      return _List.from(Iterable.take(this, count));
    }
    takeWhile(predicate) {
      return _List.from(Iterable.takeWhile(this, predicate));
    }
    takeUntil(predicate) {
      return this.takeWhile(not6(predicate));
    }
    takeLast(count = 1) {
      return _List.from(Iterable.takeLast(this, count));
    }
    takeLastWhile(predicate) {
      return _List.from(Iterable.takeLastWhile(this, predicate));
    }
    takeLastUntil(predicate) {
      return this.takeLastWhile(not6(predicate));
    }
    skip(count) {
      return _List.from(Iterable.skip(this, count));
    }
    skipWhile(predicate) {
      return _List.from(Iterable.skipWhile(this, predicate));
    }
    skipUntil(predicate) {
      return this.skipWhile(not6(predicate));
    }
    skipLast(count = 1) {
      let list = this;
      while (count-- > 0) {
        list = list._pop();
      }
      return list;
    }
    skipLastWhile(predicate) {
      return _List.from(Iterable.skipLastWhile(this, predicate));
    }
    skipLastUntil(predicate) {
      return this.skipLastWhile(not6(predicate));
    }
    trim(predicate) {
      return this.trimLeading(predicate).trimTrailing(predicate);
    }
    trimLeading(predicate) {
      return this.skipWhile(predicate);
    }
    trimTrailing(predicate) {
      return this.skipLastWhile(predicate);
    }
    rest() {
      return this.skip(1);
    }
    slice(start, end10) {
      return _List.from(Iterable.slice(this, start, end10));
    }
    reverse() {
      return _List.from(Iterable.reverse(this));
    }
    join(separator) {
      return Iterable.join(this, separator);
    }
    sort() {
      return this.sortWith(compareComparable5);
    }
    sortWith(comparer) {
      return _List.from(Iterable.sortWith(this, comparer));
    }
    compare(iterable) {
      return this.compareWith(iterable, compareComparable5);
    }
    compareWith(iterable, comparer) {
      return Iterable.compareWith(this, iterable, comparer);
    }
    groupBy(grouper) {
      return this.reduce((groups, value) => {
        const group = grouper(value);
        return groups.set(group, groups.get(group).getOrElse(() => _List.empty())._push(value));
      }, Map2.empty());
    }
    equals(value) {
      return value instanceof _List && value._size === this._size && value._head.equals(this._head) && value._tail.equals(this._tail);
    }
    hash(hash2) {
      for (const value of this) {
        hash2.writeUnknown(value);
      }
      hash2.writeUint32(this._size);
    }
    *[Symbol.iterator]() {
      yield* this._head;
      yield* this._tail;
    }
    toArray() {
      return [...this];
    }
    toJSON(options) {
      return this.toArray().map((value) => Serializable.toJSON(value, options));
    }
    toString() {
      const values = this.join(", ");
      return `List [${values === "" ? "" : ` ${values} `}]`;
    }
    _push(value) {
      if (this._tail.isEmpty()) {
        return new _List(Empty3, Leaf2.of([value]), 0, 1);
      }
      if (this._tail.hasCapacity()) {
        return new _List(this._head, Leaf2.of([...this._tail.values, value]), this._shift, this._size + 1);
      }
      if (this._head.isEmpty()) {
        return new _List(this._tail, Leaf2.of([value]), this._shift + Node2.Bits, this._size + 1);
      }
      const index = this._size - Node2.Capacity;
      let head = this._head;
      let shift = this._shift;
      if (head.isLeaf() || index === Node2.overflow(shift)) {
        head = Branch.of([head]);
        shift += Node2.Bits;
      } else {
        head = head.clone();
      }
      let prev = head;
      let level = shift - Node2.Bits;
      while (level > 0) {
        const i = Node2.fragment(index, level);
        level -= Node2.Bits;
        const next = prev.nodes[i];
        if (next === void 0) {
          if (level === 0) {
            prev.nodes[i] = this._tail;
          } else {
            prev.nodes[i] = prev = Branch.empty();
          }
        } else {
          prev.nodes[i] = prev = next.clone();
        }
      }
      return new _List(head, Leaf2.of([value]), shift, this._size + 1);
    }
    _pop() {
      if (this._tail.isEmpty()) {
        return this;
      }
      if (this._size === 1) {
        return _List.empty();
      }
      if (this._tail.values.length > 1) {
        return new _List(this._head, Leaf2.of(this._tail.values.slice(0, this._tail.values.length - 1)), this._shift, this._size - 1);
      }
      if (this._head.isLeaf() || this._head.isEmpty()) {
        return new _List(Empty3, this._head, this._shift - Node2.Bits, this._size - 1);
      }
      let head = this._head.clone();
      let tail = this._tail;
      let shift = this._shift;
      const index = this._size - Node2.Capacity - 1;
      let prev = head;
      let level = shift - Node2.Bits;
      while (level > 0) {
        const fragment = Node2.fragment(index, level);
        level -= Node2.Bits;
        const next = prev.nodes[fragment];
        if (next.isLeaf()) {
          prev.nodes.pop();
          tail = next;
        } else {
          prev = prev.nodes[fragment] = next.clone();
        }
      }
      if (index === Node2.underflow(shift)) {
        head = head.nodes[0];
        shift -= Node2.Bits;
      }
      return new _List(head, tail, shift, this._size - 1);
    }
  };
  (function(List5) {
    function isList(value) {
      return value instanceof List5;
    }
    List5.isList = isList;
    function from(iterable) {
      if (isList(iterable)) {
        return iterable;
      }
      if (Array2.isArray(iterable)) {
        return fromArray(iterable);
      }
      return fromIterable(iterable);
    }
    List5.from = from;
    function fromArray(array) {
      const size = array.length;
      if (size <= Node2.Capacity) {
        return List5.of(...array);
      }
      return Array2.reduce(array, (list, value) => list.append(value), List5.empty());
    }
    List5.fromArray = fromArray;
    function fromIterable(iterable) {
      return Iterable.reduce(iterable, (list, value) => list.append(value), List5.empty());
    }
    List5.fromIterable = fromIterable;
  })(List || (List = {}));

  // node_modules/@siteimprove/alfa-act/dist/cache.js
  var Cache = class _Cache {
    static empty() {
      return new _Cache();
    }
    _storage = /* @__PURE__ */ new WeakMap();
    constructor() {
    }
    get(rule, ifMissing) {
      let outcomes = this._storage.get(rule);
      if (outcomes === void 0) {
        outcomes = ifMissing();
        this._storage.set(rule, outcomes);
      }
      return outcomes;
    }
  };

  // node_modules/@siteimprove/alfa-act/dist/audit.js
  var Audit = class _Audit {
    static of(input, rules, oracle = () => Future.now(None)) {
      return new _Audit(input, List.from(rules), oracle);
    }
    _input;
    _rules;
    _oracle;
    constructor(input, rules, oracle) {
      this._input = input;
      this._rules = rules;
      this._oracle = oracle;
    }
    evaluate(performance) {
      const outcomes = Cache.empty();
      return Future.traverse(this._rules, (rule) => rule.evaluate(this._input, this._oracle, outcomes, performance)).map(Iterable.flatten);
    }
  };

  // node_modules/@siteimprove/alfa-string/dist/string.js
  var String2;
  (function(String4) {
    function and107(...transformers) {
      return (input) => transformers.reduce((input2, transformer) => transformer(input2), input);
    }
    String4.and = and107;
    function indent(input) {
      return input.replace(/^/gm, "  ");
    }
    String4.indent = indent;
    function flatten2(input) {
      return input.replace(/\s+/g, " ");
    }
    String4.flatten = flatten2;
    function normalize2(input, toLowerCase2 = true) {
      return flatten2(toLowerCase2 ? input.toLowerCase() : input).trim();
    }
    String4.normalize = normalize2;
    function removePunctuation(input) {
      return input.replace(/\p{P}|\p{S}|\p{Cf}/gu, "");
    }
    String4.removePunctuation = removePunctuation;
    function toLowerCase(input) {
      return input.toLowerCase();
    }
    String4.toLowerCase = toLowerCase;
    function isWhitespace3(input, allowEmpty = true) {
      return (allowEmpty || input.length > 0) && input.trim() === "";
    }
    String4.isWhitespace = isWhitespace3;
    function hasWhitespace(input) {
      return /\s/.test(input);
    }
    String4.hasWhitespace = hasWhitespace;
    function hasSoftWrapOpportunity(input) {
      return /\s|\p{P}/u.test(input);
    }
    String4.hasSoftWrapOpportunity = hasSoftWrapOpportunity;
  })(String2 || (String2 = {}));

  // node_modules/@siteimprove/alfa-act/dist/diagnostic.js
  var Diagnostic = class _Diagnostic {
    static of(message) {
      return new _Diagnostic(String2.normalize(message, false));
    }
    _message;
    constructor(message) {
      this._message = message;
    }
    get message() {
      return this._message;
    }
    equals(value) {
      return value instanceof _Diagnostic && value._message === this._message;
    }
    hash(hash2) {
      hash2.writeString(this._message);
    }
    toJSON(options) {
      return {
        message: this._message
      };
    }
  };
  (function(Diagnostic3) {
    function isDiagnostic(value) {
      return value instanceof Diagnostic3;
    }
    Diagnostic3.isDiagnostic = isDiagnostic;
    Diagnostic3.empty = Diagnostic3.of("No extra information");
  })(Diagnostic || (Diagnostic = {}));

  // node_modules/@siteimprove/alfa-either/dist/left.js
  var Left = class _Left {
    static of(value) {
      return new _Left(value);
    }
    _value;
    constructor(value) {
      this._value = value;
    }
    isLeft() {
      return true;
    }
    isRight() {
      return false;
    }
    map() {
      return this;
    }
    apply() {
      return this;
    }
    flatMap() {
      return this;
    }
    flatten() {
      return this;
    }
    reduce(reducer, accumulator) {
      return accumulator;
    }
    either(left22) {
      return left22(this._value);
    }
    get() {
      return this._value;
    }
    left() {
      return Option.of(this._value);
    }
    right() {
      return None;
    }
    teeLeft(callback) {
      callback(this._value);
      return this;
    }
    teeRight() {
      return this;
    }
    equals(value) {
      return value instanceof _Left && Equatable.equals(value._value, this._value);
    }
    hash(hash2) {
      hash2.writeBoolean(false).writeUnknown(this._value);
    }
    *[Symbol.iterator]() {
      yield this._value;
    }
    toJSON() {
      return {
        type: "left",
        value: Serializable.toJSON(this._value)
      };
    }
    toString() {
      return `Left { ${this._value} }`;
    }
  };
  (function(Left2) {
    function isLeft(value) {
      return value instanceof Left2;
    }
    Left2.isLeft = isLeft;
  })(Left || (Left = {}));

  // node_modules/@siteimprove/alfa-either/dist/right.js
  var Right = class _Right {
    static of(value) {
      return new _Right(value);
    }
    _value;
    constructor(value) {
      this._value = value;
    }
    isLeft() {
      return false;
    }
    isRight() {
      return true;
    }
    map(mapper) {
      return new _Right(mapper(this._value));
    }
    apply(mapper) {
      return mapper.map((mapper2) => mapper2(this._value));
    }
    flatMap(mapper) {
      return mapper(this._value);
    }
    flatten() {
      return this._value;
    }
    reduce(reducer, accumulator) {
      return reducer(accumulator, this._value);
    }
    either(left22, right38) {
      return right38(this._value);
    }
    get() {
      return this._value;
    }
    left() {
      return None;
    }
    right() {
      return Option.of(this._value);
    }
    teeLeft() {
      return this;
    }
    teeRight(callback) {
      callback(this._value);
      return this;
    }
    equals(value) {
      return value instanceof _Right && Equatable.equals(value._value, this._value);
    }
    hash(hash2) {
      hash2.writeBoolean(true).writeUnknown(this._value);
    }
    *[Symbol.iterator]() {
      yield this._value;
    }
    toJSON() {
      return {
        type: "right",
        value: Serializable.toJSON(this._value)
      };
    }
    toString() {
      return `Right { ${this._value} }`;
    }
  };
  (function(Right2) {
    function isRight(value) {
      return value instanceof Right2;
    }
    Right2.isRight = isRight;
  })(Right || (Right = {}));

  // node_modules/@siteimprove/alfa-either/dist/either.js
  var Either;
  (function(Either2) {
    function isEither(value) {
      return isLeft(value) || isRight(value);
    }
    Either2.isEither = isEither;
    function isLeft(value) {
      return Left.isLeft(value);
    }
    Either2.isLeft = isLeft;
    function isRight(value) {
      return Right.isRight(value);
    }
    Either2.isRight = isRight;
    function left22(value) {
      return Left.of(value);
    }
    Either2.left = left22;
    function right38(value) {
      return Right.of(value);
    }
    Either2.right = right38;
  })(Either || (Either = {}));

  // node_modules/@siteimprove/alfa-tuple/dist/tuple.js
  var Tuple;
  (function(Tuple3) {
    function of(...values) {
      return values;
    }
    Tuple3.of = of;
    function empty() {
      return [];
    }
    Tuple3.empty = empty;
    function size(tuple) {
      return Array2.size(tuple);
    }
    Tuple3.size = size;
    function copy(tuple) {
      return Array2.copy(tuple);
    }
    Tuple3.copy = copy;
    function forEach(tuple, callback) {
      Array2.forEach(tuple, callback);
    }
    Tuple3.forEach = forEach;
    function map126(tuple, mapper) {
      return Array2.map(tuple, mapper);
    }
    Tuple3.map = map126;
    function reduce2(tuple, reducer, accumulator) {
      return Array2.reduce(tuple, reducer, accumulator);
    }
    Tuple3.reduce = reduce2;
    function reduceWhile(tuple, predicate, reducer, accumulator) {
      return Array2.reduceWhile(tuple, predicate, reducer, accumulator);
    }
    Tuple3.reduceWhile = reduceWhile;
    function reduceUntil(tuple, predicate, reducer, accumulator) {
      return Array2.reduceUntil(tuple, predicate, reducer, accumulator);
    }
    Tuple3.reduceUntil = reduceUntil;
    function filter13(tuple, predicate) {
      return Array2.filter(tuple, predicate);
    }
    Tuple3.filter = filter13;
    function reject(tuple, predicate) {
      return Array2.filter(tuple, predicate);
    }
    Tuple3.reject = reject;
    function find(tuple, predicate) {
      return Array2.find(tuple, predicate);
    }
    Tuple3.find = find;
    function findLast(tuple, predicate) {
      return Array2.findLast(tuple, predicate);
    }
    Tuple3.findLast = findLast;
    function includes(tuple, value) {
      return Array2.includes(tuple, value);
    }
    Tuple3.includes = includes;
    function collect(tuple, mapper) {
      return Array2.collect(tuple, mapper);
    }
    Tuple3.collect = collect;
    function collectFirst(tuple, mapper) {
      return Array2.collectFirst(tuple, mapper);
    }
    Tuple3.collectFirst = collectFirst;
    function some2(tuple, predicate) {
      return Array2.some(tuple, predicate);
    }
    Tuple3.some = some2;
    function none2(tuple, predicate) {
      return Array2.none(tuple, predicate);
    }
    Tuple3.none = none2;
    function every(tuple, predicate) {
      return Array2.every(tuple, predicate);
    }
    Tuple3.every = every;
    function count(tuple, predicate) {
      return Array2.count(tuple, predicate);
    }
    Tuple3.count = count;
    function get(tuple, index) {
      return Array2.get(tuple, index);
    }
    Tuple3.get = get;
    function has(tuple, index) {
      return Array2.has(tuple, index);
    }
    Tuple3.has = has;
    function set2(tuple, index, value) {
      return Array2.set(copy(tuple), index, value);
    }
    Tuple3.set = set2;
    function insert2(tuple, index, value) {
      return Array2.insert(copy(tuple), index, value);
    }
    Tuple3.insert = insert2;
    function append(tuple, value) {
      return Array2.append(copy(tuple), value);
    }
    Tuple3.append = append;
    function prepend(tuple, value) {
      return Array2.prepend(copy(tuple), value);
    }
    Tuple3.prepend = prepend;
    function first(tuple) {
      return Array2.first(tuple);
    }
    Tuple3.first = first;
    function last(tuple) {
      return Array2.last(tuple);
    }
    Tuple3.last = last;
    function search(tuple, value, comparer) {
      return Array2.search(tuple, value, comparer);
    }
    Tuple3.search = search;
    function equals34(a, b) {
      return Array2.equals(a, b);
    }
    Tuple3.equals = equals34;
    function hash2(tuple, hash3) {
      Array2.hash(tuple, hash3);
    }
    Tuple3.hash = hash2;
    function iterator(tuple) {
      return Array2.iterator(tuple);
    }
    Tuple3.iterator = iterator;
  })(Tuple || (Tuple = {}));

  // node_modules/@siteimprove/alfa-act/dist/question.js
  var { isOption } = Option;
  var { isBoolean: isBoolean3, isFunction: isFunction4 } = Refinement;
  var Question = class _Question {
    static of(type, uri, message, subject, context, options = {}) {
      const { fallback = None, diagnostic = Diagnostic.empty } = options;
      return new _Question(type, uri, message, diagnostic, fallback, subject, context, (answer) => answer);
    }
    _type;
    _uri;
    _message;
    _diagnostic;
    _fallback;
    _subject;
    _context;
    _quester;
    constructor(type, uri, message, diagnostic, fallback, subject, context, quester) {
      this._type = type;
      this._uri = uri;
      this._message = message;
      this._diagnostic = diagnostic;
      this._fallback = fallback;
      this._subject = subject;
      this._context = context;
      this._quester = quester;
    }
    get type() {
      return this._type;
    }
    get uri() {
      return this._uri;
    }
    get message() {
      return this._message;
    }
    get diagnostic() {
      return this._diagnostic;
    }
    get fallback() {
      return this._fallback;
    }
    get subject() {
      return this._subject;
    }
    get context() {
      return this._context;
    }
    isRhetorical() {
      return this instanceof _Question.Rhetorical;
    }
    answer(answer) {
      return this._quester(answer);
    }
    answerIf(conditionOrPredicateOrAnswer, answerOrMerger) {
      let condition = false;
      let answer;
      let diagnostic = this._diagnostic;
      if (isBoolean3(conditionOrPredicateOrAnswer)) {
        condition = conditionOrPredicateOrAnswer;
        answer = answerOrMerger;
      } else if (isFunction4(conditionOrPredicateOrAnswer)) {
        condition = conditionOrPredicateOrAnswer(this._subject, this._context);
        answer = answerOrMerger;
      } else if (isOption(conditionOrPredicateOrAnswer)) {
        if (conditionOrPredicateOrAnswer.isSome()) {
          condition = true;
          answer = conditionOrPredicateOrAnswer.get();
        }
      } else {
        condition = conditionOrPredicateOrAnswer.isOk();
        if (condition) {
          answer = conditionOrPredicateOrAnswer.getUnsafe();
        } else {
          const error = conditionOrPredicateOrAnswer.getErrUnsafe();
          if (Diagnostic.isDiagnostic(error)) {
            const merger = answerOrMerger ?? // Default is to overwrite the old diagnostic
            ((old, cur) => cur);
            diagnostic = merger(diagnostic, error);
          }
        }
      }
      return condition ? new _Question.Rhetorical(this._type, this._uri, this._message, this._diagnostic, this._subject, this._context, this.answer(answer)) : new _Question(this._type, this._uri, this._message, diagnostic, this._fallback, this._subject, this._context, this._quester);
    }
    map(mapper) {
      return new _Question(this._type, this._uri, this._message, this._diagnostic, this._fallback, this._subject, this._context, (answer) => mapper(this._quester(answer)));
    }
    apply(mapper) {
      return mapper.flatMap((mapper2) => this.map(mapper2));
    }
    flatMap(mapper) {
      return new _Question(this._type, this._uri, this._message, this._diagnostic, this._fallback, this._subject, this._context, (answer) => mapper(this._quester(answer))._quester(answer));
    }
    flatten() {
      return new _Question(this._type, this._uri, this._message, this._diagnostic, this._fallback, this._subject, this._context, (answer) => this._quester(answer)._quester(answer));
    }
    toJSON() {
      return {
        type: Serializable.toJSON(this._type),
        uri: this._uri,
        message: this._message,
        diagnostic: this._diagnostic.toJSON(),
        fallback: this._fallback.toJSON(),
        subject: Serializable.toJSON(this._subject),
        context: Serializable.toJSON(this._context)
      };
    }
  };
  (function(Question3) {
    function isQuestion(value) {
      return value instanceof Question3;
    }
    Question3.isQuestion = isQuestion;
    class Rhetorical extends Question3 {
      _answer;
      constructor(type, uri, message, diagnostic, subject, context, answer) {
        super(type, uri, message, diagnostic, None, subject, context, () => answer);
        this._answer = answer;
      }
      answer() {
        return this._answer;
      }
      /**
       * @remarks
       * Overriding {@link (Question:class).map} ensures that the answer to a
       * rhetorical question is not lost as the question is transformed.
       */
      map(mapper) {
        return new Rhetorical(this._type, this._uri, this._message, this._diagnostic, this._subject, this._context, mapper(this._answer));
      }
    }
    Question3.Rhetorical = Rhetorical;
  })(Question || (Question = {}));

  // node_modules/@siteimprove/alfa-act/dist/interview.js
  var Interview;
  (function(Interview2) {
    function conduct(interview, rule, oracle, oracleUsed = false) {
      if (interview instanceof Question) {
        let answer;
        if (interview.isRhetorical()) {
          answer = Future.now(Option.of(interview.answer()));
        } else {
          answer = oracle(rule, interview).map((option64) => option64.tee((_) => oracleUsed = true).or(interview.fallback).map(interview.answer.bind(interview)));
        }
        return answer.flatMap((answer2) => answer2.map((answer3) => conduct(answer3, rule, oracle, oracleUsed)).getOrElse(() => Future.now(Either.right(Tuple.of(interview.diagnostic, oracleUsed)))));
      }
      return Future.now(Either.left(Tuple.of(interview, oracleUsed)));
    }
    Interview2.conduct = conduct;
  })(Interview || (Interview = {}));

  // node_modules/@siteimprove/alfa-record/dist/record.js
  var Record = class _Record {
    static of(properties) {
      const keys3 = Object.keys(properties ?? {}).sort();
      return new _Record(new Map(Iterable.map(keys3, (key, i) => [key, i])), keys3, List.from(keys3.map((key) => properties[key])));
    }
    _indices;
    _keys;
    _values;
    constructor(indices, keys3, values) {
      this._indices = indices;
      this._keys = keys3;
      this._values = values;
    }
    has(key) {
      return this._indices.has(key);
    }
    get(key) {
      const i = this._indices.get(key);
      if (i === void 0) {
        return None;
      }
      return this._values.get(i);
    }
    set(key, value) {
      const i = this._indices.get(key);
      if (i === void 0) {
        return this;
      }
      return new _Record(this._indices, this._keys, this._values.set(i, value));
    }
    reduce(reducer, accumulator) {
      return Iterable.reduce(this, (accumulator2, [key, value]) => reducer(accumulator2, value, key), accumulator);
    }
    some(predicate) {
      return Iterable.some(this, ([key, value]) => predicate(value, key));
    }
    every(predicate) {
      return Iterable.every(this, ([key, value]) => predicate(value, key));
    }
    equals(value) {
      return value instanceof _Record && value._keys.length === this._keys.length && value._keys.every((key, i) => key === this._keys[i]) && value._values.equals(this._values);
    }
    *keys() {
      yield* this._keys;
    }
    *values() {
      yield* this._values;
    }
    *entries() {
      yield* this;
    }
    *[Symbol.iterator]() {
      let i = 0;
      for (const value of this._values) {
        yield [this._keys[i++], value];
      }
    }
    toArray() {
      return [...this];
    }
    toJSON(options) {
      const json = {};
      for (const [key, value] of this) {
        json[key] = Serializable.toJSON(value, options);
      }
      return json;
    }
    toString() {
      const entries3 = this.toArray().map(([key, value]) => `${key}: ${value}`).join(", ");
      return `Record {${entries3 === "" ? "" : ` ${entries3} `}}`;
    }
  };
  (function(Record2) {
    function isRecord(value) {
      return value instanceof Record2;
    }
    Record2.isRecord = isRecord;
    function from(entries3) {
      const record = {};
      for (const [key, value] of entries3) {
        record[key] = value;
      }
      return Record2.of(record);
    }
    Record2.from = from;
  })(Record || (Record = {}));

  // node_modules/@siteimprove/alfa-result/dist/err.js
  var { not: not7, test: test3 } = Predicate;
  var Err = class _Err {
    static of(error) {
      return new _Err(error);
    }
    _error;
    constructor(error) {
      this._error = error;
    }
    isOk() {
      return false;
    }
    isErr() {
      return true;
    }
    map() {
      return this;
    }
    mapErr(mapper) {
      return new _Err(mapper(this._error));
    }
    mapOrElse(ok, err) {
      return err(this._error);
    }
    apply() {
      return this;
    }
    flatMap() {
      return this;
    }
    flatten() {
      return this;
    }
    reduce(reducer, accumulator) {
      return accumulator;
    }
    includes() {
      return false;
    }
    includesErr(error) {
      return Equatable.equals(this._error, error);
    }
    some() {
      return false;
    }
    someErr(predicate) {
      return test3(predicate, this._error);
    }
    none() {
      return true;
    }
    noneErr(predicate) {
      return test3(not7(predicate), this._error);
    }
    every() {
      return true;
    }
    everyErr(predicate) {
      return test3(predicate, this._error);
    }
    and() {
      return this;
    }
    andThen() {
      return this;
    }
    or(result) {
      return result;
    }
    orElse(result) {
      return result();
    }
    /**
     * @internal
     */
    getUnsafe(message = "Attempted to .getUnsafe() from Err") {
      throw new Error(message);
    }
    /**
     * @internal
     */
    getErrUnsafe() {
      return this._error;
    }
    getErr() {
      return this._error;
    }
    getOr(value) {
      return value;
    }
    getOrElse(value) {
      return value();
    }
    getErrOr() {
      return this._error;
    }
    getErrOrElse() {
      return this._error;
    }
    ok() {
      return None;
    }
    err() {
      return Option.of(this._error);
    }
    tee() {
      return this;
    }
    teeErr(callback) {
      callback(this._error);
      return this;
    }
    equals(value) {
      return value instanceof _Err && Equatable.equals(value._error, this._error);
    }
    hash(hash2) {
      hash2.writeBoolean(false).writeUnknown(this._error);
    }
    *[Symbol.iterator]() {
    }
    toJSON(options) {
      return {
        type: "err",
        error: Serializable.toJSON(this._error, options)
      };
    }
    toString() {
      return `Err { ${this._error} }`;
    }
  };
  (function(Err2) {
    function isErr(value) {
      return value instanceof Err2;
    }
    Err2.isErr = isErr;
  })(Err || (Err = {}));

  // node_modules/@siteimprove/alfa-result/dist/ok.js
  var { not: not8, test: test4 } = Predicate;
  var Ok = class _Ok {
    static of(value) {
      return new _Ok(value);
    }
    _value;
    constructor(value) {
      this._value = value;
    }
    isOk() {
      return true;
    }
    isErr() {
      return false;
    }
    map(mapper) {
      return new _Ok(mapper(this._value));
    }
    mapErr() {
      return this;
    }
    mapOrElse(ok) {
      return ok(this._value);
    }
    apply(mapper) {
      return mapper.map((mapper2) => mapper2(this._value));
    }
    flatMap(mapper) {
      return mapper(this._value);
    }
    flatten() {
      return this._value;
    }
    reduce(reducer, accumulator) {
      return reducer(accumulator, this._value);
    }
    includes(value) {
      return Equatable.equals(this._value, value);
    }
    includesErr() {
      return false;
    }
    some(predicate) {
      return test4(predicate, this._value);
    }
    someErr() {
      return false;
    }
    none(predicate) {
      return test4(not8(predicate), this._value);
    }
    noneErr() {
      return true;
    }
    every(predicate) {
      return test4(predicate, this._value);
    }
    everyErr() {
      return true;
    }
    and(result) {
      return result;
    }
    andThen(result) {
      return result(this._value);
    }
    or() {
      return this;
    }
    orElse() {
      return this;
    }
    get() {
      return this._value;
    }
    /**
     * @internal
     */
    getUnsafe() {
      return this._value;
    }
    /**
     * @internal
     */
    getErrUnsafe(message = "Attempted to .getErrUnsafe() from Ok") {
      throw new Error(message);
    }
    getOr() {
      return this._value;
    }
    getOrElse() {
      return this._value;
    }
    getErrOr(error) {
      return error;
    }
    getErrOrElse(error) {
      return error();
    }
    ok() {
      return Option.of(this._value);
    }
    err() {
      return None;
    }
    tee(callback) {
      callback(this._value);
      return this;
    }
    teeErr() {
      return this;
    }
    equals(value) {
      return value instanceof _Ok && Equatable.equals(value._value, this._value);
    }
    hash(hash2) {
      hash2.writeBoolean(true).writeUnknown(this._value);
    }
    *[Symbol.iterator]() {
      yield this._value;
    }
    toJSON(options) {
      return {
        type: "ok",
        value: Serializable.toJSON(this._value, options)
      };
    }
    toString() {
      return `Ok { ${this._value} }`;
    }
  };
  (function(Ok2) {
    function isOk(value) {
      return value instanceof Ok2;
    }
    Ok2.isOk = isOk;
  })(Ok || (Ok = {}));

  // node_modules/@siteimprove/alfa-result/dist/result.js
  var Result;
  (function(Result2) {
    function isResult(value) {
      return isOk(value) || isErr(value);
    }
    Result2.isResult = isResult;
    function isOk(value) {
      return Ok.isOk(value);
    }
    Result2.isOk = isOk;
    function isErr(value) {
      return Err.isErr(value);
    }
    Result2.isErr = isErr;
    function of(value) {
      return Ok.of(value);
    }
    Result2.of = of;
    function from(thunk) {
      let value;
      try {
        value = thunk();
      } catch (error) {
        return Err.of(error);
      }
      if (value instanceof Promise) {
        return value.then((value2) => Ok.of(value2)).catch((error) => Err.of(error));
      }
      return Ok.of(value);
    }
    Result2.from = from;
  })(Result || (Result = {}));

  // node_modules/@siteimprove/alfa-trilean/dist/trilean.js
  var Trilean;
  (function(Trilean2) {
    function test43(predicate, value, ...args) {
      return predicate(value, ...args);
    }
    Trilean2.test = test43;
    function fold2(predicate, ifTrue, ifFalse, ifUndefined, value, ...args) {
      switch (predicate(value, ...args)) {
        case true:
          return ifTrue(value);
        case false:
          return ifFalse(value);
        case void 0:
          return ifUndefined(value);
      }
    }
    Trilean2.fold = fold2;
    function not54(predicate) {
      return (value, ...args) => {
        switch (predicate(value, ...args)) {
          case true:
            return false;
          case false:
            return true;
          case void 0:
            return void 0;
        }
      };
    }
    Trilean2.not = not54;
    function and107(...predicates) {
      return (value, ...args) => predicates.reduce((holds, predicate) => {
        if (holds === false) {
          return false;
        }
        if (holds === true) {
          return predicate(value, ...args);
        }
        if (predicate(value, ...args) === false) {
          return false;
        } else {
          return void 0;
        }
      }, true);
    }
    Trilean2.and = and107;
    function or40(...predicates) {
      return (value, ...args) => predicates.reduce((holds, predicate) => {
        if (holds === true) {
          return true;
        }
        if (holds === false) {
          return predicate(value, ...args);
        }
        if (predicate(value, ...args) === true) {
          return true;
        } else {
          return void 0;
        }
      }, false);
    }
    Trilean2.or = or40;
    function xor2(left22, right38) {
      return and107(or40(left22, right38), not54(and107(left22, right38)));
    }
    Trilean2.xor = xor2;
    function nor6(left22, right38) {
      return not54(or40(left22, right38));
    }
    Trilean2.nor = nor6;
    function nand(left22, right38) {
      return not54(and107(left22, right38));
    }
    Trilean2.nand = nand;
    function some2(iterable, predicate) {
      return Iterable.reduce(iterable, (result, value, i) => test43(or40(() => result, predicate), value, i), false);
    }
    Trilean2.some = some2;
    function none2(iterable, predicate) {
      return every(iterable, not54(predicate));
    }
    Trilean2.none = none2;
    function every(iterable, predicate) {
      return Iterable.reduce(iterable, (result, value, i) => test43(and107(() => result, predicate), value, i), true);
    }
    Trilean2.every = every;
  })(Trilean || (Trilean = {}));

  // node_modules/@siteimprove/alfa-earl/dist/serializable.js
  var { isFunction: isFunction5, isObject: isObject5 } = Refinement;
  var Serializable2;
  (function(Serializable4) {
    function isSerializable(value) {
      return isObject5(value) && isFunction5(value.toEARL);
    }
    Serializable4.isSerializable = isSerializable;
    function toEARL(value) {
      if (isSerializable(value)) {
        return Some.of(value.toEARL());
      }
      return None;
    }
    Serializable4.toEARL = toEARL;
  })(Serializable2 || (Serializable2 = {}));

  // node_modules/@siteimprove/alfa-sarif/dist/serializable.js
  var { isFunction: isFunction6, isObject: isObject6 } = Refinement;
  var Serializable3;
  (function(Serializable4) {
    function isSerializable(value) {
      return isObject6(value) && isFunction6(value.toSARIF);
    }
    Serializable4.isSerializable = isSerializable;
    function toSARIF(value) {
      if (isSerializable(value)) {
        return Some.of(value.toSARIF());
      }
      return None;
    }
    Serializable4.toSARIF = toSARIF;
  })(Serializable3 || (Serializable3 = {}));

  // node_modules/@siteimprove/alfa-act/dist/outcome.js
  var Outcome = class _Outcome {
    /**
     * {@link https://www.w3.org/TR/EARL10-Schema/#outcome}
     */
    _outcome;
    /**
     * {@link https://www.w3.org/TR/EARL10-Schema/#test}
     * While this is called a "test" in EARL, in Alfa this is always a "rule".
     */
    _rule;
    /**
     * {@link https://www.w3.org/TR/EARL10-Schema/#mode}
     */
    _mode;
    constructor(outcome, rule, mode) {
      this._outcome = outcome;
      this._rule = rule;
      this._mode = mode;
    }
    /**
     * {@link https://www.w3.org/TR/EARL10-Schema/#outcome}
     */
    get outcome() {
      return this._outcome;
    }
    /**
     * {@link https://www.w3.org/TR/EARL10-Schema/#test}
     * While this is called a "test" in EARL, in Alfa this is always a "rule".
     */
    get rule() {
      return this._rule;
    }
    /**
     * {@link https://www.w3.org/TR/EARL10-Schema/#mode}
     */
    get mode() {
      return this._mode;
    }
    get isSemiAuto() {
      return this._mode === _Outcome.Mode.SemiAuto;
    }
    get target() {
      return void 0;
    }
    equals(value) {
      return value instanceof _Outcome && value._rule.equals(this._rule) && value._outcome === this._outcome && value._mode === this._mode;
    }
    hash(hash2) {
      this._rule.hash(hash2);
      hash2.writeString(this._outcome);
      hash2.writeString(this._mode);
    }
    toJSON(options) {
      return {
        outcome: this._outcome,
        rule: this._rule.toJSON(),
        mode: this._mode
      };
    }
    toEARL() {
      return {
        "@context": {
          earl: "http://www.w3.org/ns/earl#"
        },
        "@type": "earl:Assertion",
        "earl:mode": `earl:${this._mode}`,
        "earl:test": {
          "@id": this._rule.uri
        }
      };
    }
  };
  (function(Outcome2) {
    let Value6;
    (function(Value7) {
      Value7["Inapplicable"] = "inapplicable";
      Value7["Passed"] = "passed";
      Value7["Failed"] = "failed";
      Value7["CantTell"] = "cantTell";
    })(Value6 = Outcome2.Value || (Outcome2.Value = {}));
    let Mode;
    (function(Mode2) {
      Mode2["Automatic"] = "automatic";
      Mode2["SemiAuto"] = "semiAuto";
      Mode2["Manual"] = "manual";
    })(Mode = Outcome2.Mode || (Outcome2.Mode = {}));
    class Passed extends Outcome2 {
      static of(rule, target, expectations, mode) {
        return new Passed(rule, target, expectations, mode);
      }
      _target;
      _expectations;
      constructor(rule, target, expectations, mode) {
        super(Value6.Passed, rule, mode);
        this._target = target;
        this._expectations = Record.from(expectations.toArray());
      }
      get target() {
        return this._target;
      }
      get expectations() {
        return this._expectations;
      }
      equals(value) {
        return super.equals(value) && value instanceof Passed && Equatable.equals(value._target, this._target) && value._expectations.equals(this._expectations);
      }
      hash(hash2) {
        super.hash(hash2);
        this._target.hash(hash2);
        for (const [id, result] of this._expectations) {
          hash2.writeString(id);
          result.hash(hash2);
        }
      }
      toJSON(options) {
        return {
          ...super.toJSON(options),
          target: Serializable.toJSON(this._target, options),
          expectations: this._expectations.toArray().map(([id, expectation2]) => [id, expectation2.toJSON(options)])
        };
      }
      toEARL() {
        const outcome = {
          ...super.toEARL(),
          "earl:result": {
            "@type": "earl:TestResult",
            "earl:outcome": {
              "@id": "earl:passed"
            },
            "earl:info": this._expectations.toArray().reduce((message, [, expectation2]) => (
              // the outcome is passed, so all expectations should be Ok
              message + "\n" + expectation2.getUnsafe().message
            ), "").trim()
          }
        };
        for (const pointer of Serializable2.toEARL(this._target)) {
          outcome["earl:result"]["earl:pointer"] = pointer;
        }
        return outcome;
      }
      toSARIF() {
        const message = "The test target passes all requirements:\n\n" + this._expectations.toArray().map(([, expectation2]) => `- ${expectation2.getUnsafe().message}`).join("\n");
        const locations = [];
        for (const location of Serializable3.toSARIF(this._target)) {
          locations.push(location);
        }
        return {
          ruleId: this._rule.uri,
          kind: "pass",
          level: "none",
          message: {
            text: message,
            markdown: message
          },
          locations
        };
      }
    }
    Outcome2.Passed = Passed;
    (function(Passed2) {
      function isPassed2(value) {
        return value instanceof Passed2;
      }
      Passed2.isPassed = isPassed2;
    })(Passed = Outcome2.Passed || (Outcome2.Passed = {}));
    Outcome2.passed = Passed.of, Outcome2.isPassed = Passed.isPassed;
    class Failed extends Outcome2 {
      static of(rule, target, expectations, mode) {
        return new Failed(rule, target, expectations, mode);
      }
      _target;
      _expectations;
      constructor(rule, target, expectations, mode) {
        super(Value6.Failed, rule, mode);
        this._target = target;
        this._expectations = Record.from(expectations.toArray());
      }
      get target() {
        return this._target;
      }
      get expectations() {
        return this._expectations;
      }
      equals(value) {
        return super.equals(value) && value instanceof Failed && Equatable.equals(value._target, this._target) && value._expectations.equals(this._expectations);
      }
      hash(hash2) {
        super.hash(hash2);
        this._target.hash(hash2);
        for (const [id, result] of this._expectations) {
          hash2.writeString(id);
          result.hash(hash2);
        }
      }
      toJSON(options) {
        return {
          ...super.toJSON(options),
          target: Serializable.toJSON(this._target, options),
          expectations: this._expectations.toArray().map(([id, expectation2]) => [id, expectation2.toJSON(options)])
        };
      }
      toEARL() {
        const outcome = {
          ...super.toEARL(),
          "earl:result": {
            "@type": "earl:TestResult",
            "earl:outcome": {
              "@id": "earl:failed"
            },
            "earl:info": this._expectations.toArray().reduce((message, [, expectation2]) => {
              if (expectation2.isErr()) {
                message += "\n" + expectation2.getErr().message;
              }
              return message;
            }, "").trim()
          }
        };
        for (const pointer of Serializable2.toEARL(this._target)) {
          outcome["earl:result"]["earl:pointer"] = pointer;
        }
        return outcome;
      }
      toSARIF() {
        const message = "The test target fails the following requirements:\n\n" + Iterable.join(Iterable.map(Iterable.filter(Iterable.map(this._expectations.entries(), ([, expectation2]) => expectation2), Err.isErr), (expectation2) => `- ${expectation2.getErr().message}`), "\n");
        const locations = [];
        for (const location of Serializable3.toSARIF(this._target)) {
          locations.push(location);
        }
        return {
          ruleId: this._rule.uri,
          kind: "fail",
          level: "error",
          message: {
            text: message,
            markdown: message
          },
          locations
        };
      }
    }
    Outcome2.Failed = Failed;
    (function(Failed2) {
      function isFailed(value) {
        return value instanceof Failed2;
      }
      Failed2.isFailed = isFailed;
    })(Failed = Outcome2.Failed || (Outcome2.Failed = {}));
    Outcome2.failed = Failed.of, Outcome2.isFailed = Failed.isFailed;
    class CantTell extends Outcome2 {
      static of(rule, target, diagnostic, mode) {
        return new CantTell(rule, target, diagnostic, mode);
      }
      _target;
      _diagnostic;
      constructor(rule, target, diagnostic, mode) {
        super(Value6.CantTell, rule, mode);
        this._target = target;
        this._diagnostic = diagnostic;
      }
      get target() {
        return this._target;
      }
      get diagnostic() {
        return this._diagnostic;
      }
      equals(value) {
        return super.equals(value) && value instanceof CantTell && Equatable.equals(value._target, this._target) && value._diagnostic.equals(this._diagnostic);
      }
      hash(hash2) {
        super.hash(hash2);
        this._target.hash(hash2);
        this._diagnostic.hash(hash2);
      }
      toJSON(options) {
        return {
          ...super.toJSON(options),
          target: Serializable.toJSON(this._target, options),
          diagnostic: this._diagnostic.toJSON(options)
        };
      }
      toEARL() {
        const outcome = {
          ...super.toEARL(),
          "earl:result": {
            "@type": "earl:TestResult",
            "earl:outcome": {
              "@id": "earl:cantTell"
            }
          }
        };
        for (const pointer of Serializable2.toEARL(this._target)) {
          outcome["earl:result"]["earl:pointer"] = pointer;
        }
        return outcome;
      }
      toSARIF() {
        const message = "The rule has outstanding questions that must be answered for the test target";
        const locations = [];
        for (const location of Serializable3.toSARIF(this._target)) {
          locations.push(location);
        }
        return {
          ruleId: this._rule.uri,
          kind: "review",
          level: "warning",
          message: {
            text: message,
            markdown: message
          },
          locations
        };
      }
    }
    Outcome2.CantTell = CantTell;
    (function(CantTell2) {
      function isCantTell(value) {
        return value instanceof CantTell2;
      }
      CantTell2.isCantTell = isCantTell;
    })(CantTell = Outcome2.CantTell || (Outcome2.CantTell = {}));
    Outcome2.cantTell = CantTell.of, Outcome2.isCantTell = CantTell.isCantTell;
    let Applicable;
    (function(Applicable2) {
      function isApplicable(value) {
        return Outcome2.isPassed(value) || Outcome2.isFailed(value) || Outcome2.isCantTell(value);
      }
      Applicable2.isApplicable = isApplicable;
    })(Applicable = Outcome2.Applicable || (Outcome2.Applicable = {}));
    Outcome2.isApplicable = Applicable.isApplicable;
    class Inapplicable extends Outcome2 {
      static of(rule, mode) {
        return new Inapplicable(rule, mode);
      }
      constructor(rule, mode) {
        super(Value6.Inapplicable, rule, mode);
      }
      equals(value) {
        return super.equals(value) && value instanceof Inapplicable;
      }
      toJSON(options) {
        return super.toJSON(options);
      }
      toEARL() {
        return {
          ...super.toEARL(),
          "earl:result": {
            "@type": "earl:TestResult",
            "earl:outcome": {
              "@id": "earl:inapplicable"
            }
          }
        };
      }
      toSARIF() {
        const message = "The rule did not apply to the test subject";
        return {
          ruleId: this._rule.uri,
          kind: "notApplicable",
          level: "none",
          message: {
            text: message,
            markdown: message
          }
        };
      }
    }
    Outcome2.Inapplicable = Inapplicable;
    (function(Inapplicable2) {
      function isInapplicable(value) {
        return value instanceof Inapplicable2;
      }
      Inapplicable2.isInapplicable = isInapplicable;
    })(Inapplicable = Outcome2.Inapplicable || (Outcome2.Inapplicable = {}));
    Outcome2.inapplicable = Inapplicable.of, Outcome2.isInapplicable = Inapplicable.isInapplicable;
    function from(rule, target, expectations, mode) {
      return Trilean.fold((expectations2) => Trilean.every(expectations2, (expectation2) => expectation2.map((expectation3) => expectation3.isOk()).getOr(void 0)), () => Passed.of(rule, target, Record.from(Iterable.map(expectations.entries(), ([id, expectation2]) => [
        id,
        // Due to the predicate in every, this branch is only taken if every
        // expectation is a Some<Ok<T>>.
        expectation2.getUnsafe()
      ])), mode), () => Failed.of(rule, target, Record.from(Iterable.map(expectations.entries(), ([id, expectation2]) => [
        id,
        // One expectation being a Some<Err<T>> is enough to take that branch,
        // even if others are None.
        expectation2.getOr(Err.of(Diagnostic.empty))
      ])), mode), () => CantTell.of(rule, target, Diagnostic.empty, mode), expectations.values());
    }
    Outcome2.from = from;
  })(Outcome || (Outcome = {}));

  // node_modules/@siteimprove/alfa-act/dist/requirement.js
  var Requirement = class _Requirement {
    _type;
    _uri;
    constructor(type, uri) {
      this._type = type;
      this._uri = uri;
    }
    get type() {
      return this._type;
    }
    get uri() {
      return this._uri;
    }
    equals(value) {
      return value instanceof _Requirement && value.uri === this.uri;
    }
    toJSON() {
      return {
        type: this._type,
        uri: this._uri
      };
    }
    toEARL() {
      return {
        "@context": {
          earl: "http://www.w3.org/ns/earl#"
        },
        "@type": ["earl:TestCriterion", "earl:TestRequirement"],
        "@id": this.uri
      };
    }
  };
  (function(Requirement2) {
    function isRequirement(value) {
      return value instanceof Requirement2;
    }
    Requirement2.isRequirement = isRequirement;
  })(Requirement || (Requirement = {}));

  // node_modules/@siteimprove/alfa-trampoline/dist/trampoline.js
  var Trampoline = class {
    run() {
      let step = this;
      while (true) {
        const next = step.step();
        if (step !== next) {
          step = next;
        } else {
          return next.run();
        }
      }
    }
    map(mapper) {
      return this.flatMap((value) => Done.of(mapper(value)));
    }
    apply(mapper) {
      return mapper.flatMap((mapper2) => this.map(mapper2));
    }
    flatten() {
      return this.flatMap((trampoline) => trampoline);
    }
    reduce(reducer, accumulator) {
      return reducer(accumulator, this.run());
    }
    tee(callback) {
      return this.map((value) => {
        callback(value);
        return value;
      });
    }
    *iterator() {
      yield this.run();
    }
    [Symbol.iterator]() {
      return this.iterator();
    }
  };
  (function(Trampoline2) {
    function isTrampoline(value) {
      return value instanceof Trampoline2;
    }
    Trampoline2.isTrampoline = isTrampoline;
    function empty() {
      return done(void 0);
    }
    Trampoline2.empty = empty;
    function done(value) {
      return Done.of(value);
    }
    Trampoline2.done = done;
    function suspend(thunk) {
      return Suspend2.of(thunk);
    }
    Trampoline2.suspend = suspend;
    function delay(thunk) {
      return suspend(() => done(thunk()));
    }
    Trampoline2.delay = delay;
    function traverse(values, mapper) {
      return Iterable.reduce(values, (values2, value, i) => values2.flatMap((values3) => mapper(value, i).map((value2) => Array2.append(values3, value2))), done(Array2.empty()));
    }
    Trampoline2.traverse = traverse;
    function sequence(futures) {
      return traverse(futures, (value) => value);
    }
    Trampoline2.sequence = sequence;
  })(Trampoline || (Trampoline = {}));
  var Done = class _Done extends Trampoline {
    static of(value) {
      return new _Done(value);
    }
    _value;
    constructor(value) {
      super();
      this._value = value;
    }
    step() {
      return this;
    }
    run() {
      return this._value;
    }
    isDone() {
      return true;
    }
    isSuspended() {
      return false;
    }
    map(mapper) {
      return new _Done(mapper(this._value));
    }
    flatMap(mapper) {
      return Suspend2.of(() => mapper(this._value));
    }
  };
  var Suspend2 = class _Suspend extends Trampoline {
    static of(thunk) {
      return new _Suspend(thunk);
    }
    _thunk;
    constructor(thunk) {
      super();
      this._thunk = thunk;
    }
    step() {
      return this._thunk();
    }
    isDone() {
      return false;
    }
    isSuspended() {
      return true;
    }
    flatMap(mapper) {
      return Bind.of(this._thunk, mapper);
    }
  };
  var Bind = class _Bind extends Trampoline {
    static of(thunk, mapper) {
      return new _Bind(thunk, mapper);
    }
    _thunk;
    _mapper;
    constructor(thunk, mapper) {
      super();
      this._thunk = thunk;
      this._mapper = mapper;
    }
    step() {
      return this._thunk().flatMap(this._mapper);
    }
    isDone() {
      return false;
    }
    isSuspended() {
      return true;
    }
    flatMap(mapper) {
      return Suspend2.of(() => _Bind.of(this._thunk, (value) => this._mapper(value).flatMap(mapper)));
    }
  };

  // node_modules/@siteimprove/alfa-lazy/dist/lazy.js
  var Lazy = class _Lazy {
    static of(thunk) {
      return new _Lazy(Trampoline.delay(thunk));
    }
    static force(value) {
      return new _Lazy(Trampoline.done(value));
    }
    _value;
    constructor(value) {
      this._value = value;
    }
    force() {
      if (this._value.isSuspended()) {
        this._value = Trampoline.done(this._value.run());
      }
      return this._value.run();
    }
    map(mapper) {
      return new _Lazy(this._value.flatMap((value) => {
        if (this._value.isSuspended()) {
          this._value = Trampoline.done(value);
        }
        return Trampoline.done(mapper(value));
      }));
    }
    apply(mapper) {
      return mapper.map((mapper2) => mapper2(this.force()));
    }
    flatMap(mapper) {
      return new _Lazy(this._value.flatMap((value) => {
        if (this._value.isSuspended()) {
          this._value = Trampoline.done(value);
        }
        return mapper(value)._value;
      }));
    }
    flatten() {
      return this.flatMap((lazy) => lazy);
    }
    equals(value) {
      return value instanceof _Lazy && Equatable.equals(value.force(), this.force());
    }
    *iterator() {
      yield this.force();
    }
    [Symbol.iterator]() {
      return this.iterator();
    }
    toThunk() {
      return () => this.force();
    }
    toJSON(options) {
      return Serializable.toJSON(this.force(), options);
    }
    toString() {
      return `Lazy { ${this.force()} }`;
    }
  };

  // node_modules/@siteimprove/alfa-sequence/dist/nil.js
  var Nil = new class Nil2 {
    get size() {
      return 0;
    }
    isEmpty() {
      return true;
    }
    forEach() {
    }
    map() {
      return this;
    }
    apply() {
      return this;
    }
    flatMap() {
      return this;
    }
    flatten() {
      return this;
    }
    reduce(reducer, accumulator) {
      return accumulator;
    }
    reduceWhile(predicate, reducer, accumulator) {
      return accumulator;
    }
    reduceUntil(predicate, reducer, accumulator) {
      return accumulator;
    }
    filter() {
      return this;
    }
    reject() {
      return this;
    }
    find() {
      return None;
    }
    includes() {
      return false;
    }
    collect() {
      return this;
    }
    collectFirst() {
      return None;
    }
    some() {
      return false;
    }
    none() {
      return true;
    }
    every() {
      return true;
    }
    count() {
      return 0;
    }
    distinct() {
      return this;
    }
    get() {
      return None;
    }
    has() {
      return false;
    }
    set() {
      return this;
    }
    insert(index, value) {
      return index === 0 ? Cons.of(value) : this;
    }
    append(value) {
      return Cons.of(value);
    }
    prepend(value) {
      return Cons.of(value);
    }
    concat(iterable) {
      if (iterable === this) {
        return this;
      }
      return Sequence.from(iterable);
    }
    subtract() {
      return this;
    }
    intersect() {
      return this;
    }
    tee(callback, ...args) {
      callback(this, ...args);
      return this;
    }
    zip() {
      return this;
    }
    first() {
      return None;
    }
    last() {
      return None;
    }
    take() {
      return this;
    }
    takeWhile() {
      return this;
    }
    takeUntil() {
      return this;
    }
    takeLast() {
      return this;
    }
    takeLastWhile() {
      return this;
    }
    takeLastUntil() {
      return this;
    }
    skip() {
      return this;
    }
    skipWhile() {
      return this;
    }
    skipUntil() {
      return this;
    }
    skipLast() {
      return this;
    }
    skipLastWhile() {
      return this;
    }
    skipLastUntil() {
      return this;
    }
    trim() {
      return this;
    }
    trimLeading() {
      return this;
    }
    trimTrailing() {
      return this;
    }
    rest() {
      return this;
    }
    slice() {
      return this;
    }
    reverse() {
      return this;
    }
    join() {
      return "";
    }
    sort() {
      return this;
    }
    sortWith() {
      return this;
    }
    compare(iterable) {
      return this.compareWith(iterable, Comparable.compare);
    }
    compareWith(iterable, comparer) {
      return Iterable.compareWith(this, iterable, comparer);
    }
    groupBy() {
      return Map2.empty();
    }
    equals(value) {
      return value instanceof Nil2;
    }
    hash(hash2) {
      hash2.writeUint32(0);
    }
    *iterator() {
    }
    [Symbol.iterator]() {
      return this.iterator();
    }
    toArray() {
      return [];
    }
    toJSON() {
      return [];
    }
    toString() {
      return "Sequence []";
    }
  }();

  // node_modules/@siteimprove/alfa-sequence/dist/sequence.js
  var Sequence;
  (function(Sequence2) {
    function isSequence(value) {
      return isCons(value) || isNil(value);
    }
    Sequence2.isSequence = isSequence;
    function isCons(value) {
      return Cons.isCons(value);
    }
    Sequence2.isCons = isCons;
    function isNil(value) {
      return value === Nil;
    }
    Sequence2.isNil = isNil;
    function of(head, tail) {
      return Cons.of(head, tail);
    }
    Sequence2.of = of;
    function empty() {
      return Nil;
    }
    Sequence2.empty = empty;
    function from(iterable) {
      if (isSequence(iterable)) {
        return iterable;
      }
      if (Array2.isArray(iterable)) {
        return fromArray(iterable);
      }
      return fromIterable(iterable);
    }
    Sequence2.from = from;
    function fromArray(array) {
      let i = 0;
      const tail = () => {
        if (i >= array.length) {
          return empty();
        }
        return of(array[i++], Lazy.of(tail));
      };
      return tail();
    }
    Sequence2.fromArray = fromArray;
    function fromIterable(iterable) {
      return fromIterator(iterable[Symbol.iterator]());
    }
    Sequence2.fromIterable = fromIterable;
    function fromIterator(iterator) {
      const tail = () => {
        const head = iterator.next();
        if (head.done === true) {
          return empty();
        }
        return of(head.value, Lazy.of(tail));
      };
      return tail();
    }
    Sequence2.fromIterator = fromIterator;
  })(Sequence || (Sequence = {}));

  // node_modules/@siteimprove/alfa-sequence/dist/cons.js
  var { not: not9, equals } = Predicate;
  var { compareComparable: compareComparable6 } = Comparable;
  var Cons = class _Cons {
    static of(head, tail = Lazy.force(Nil)) {
      return new _Cons(head, tail);
    }
    _head;
    _tail;
    constructor(head, tail) {
      this._head = head;
      this._tail = tail;
    }
    get size() {
      return Iterable.size(this);
    }
    isEmpty() {
      return false;
    }
    forEach(callback) {
      Iterable.forEach(this, callback);
    }
    map(mapper, index = 0) {
      return new _Cons(mapper(this._head, index), this._tail.map((tail) => _Cons.isCons(tail) ? tail.map(mapper, index + 1) : Nil));
    }
    apply(mapper) {
      return mapper.flatMap((mapper2) => this.map(mapper2));
    }
    flatMap(mapper, index = 0) {
      let next = this;
      while (true) {
        const head = mapper(next._head, index++);
        if (_Cons.isCons(head)) {
          return new _Cons(head._head, head._tail.map((left22) => {
            const right38 = next._tail.force();
            return _Cons.isCons(right38) ? left22.concat(right38.flatMap(mapper, index)) : left22;
          }));
        }
        const tail = next._tail.force();
        if (_Cons.isCons(tail)) {
          next = tail;
        } else {
          return Nil;
        }
      }
    }
    flatten() {
      return this.flatMap((sequence) => sequence);
    }
    reduce(reducer, accumulator) {
      let next = this;
      let index = 0;
      while (true) {
        accumulator = reducer(accumulator, next._head, index++);
        const tail = next._tail.force();
        if (_Cons.isCons(tail)) {
          next = tail;
        } else {
          break;
        }
      }
      return accumulator;
    }
    reduceWhile(predicate, reducer, accumulator) {
      let next = this;
      let index = 0;
      while (predicate(next._head, index)) {
        accumulator = reducer(accumulator, next._head, index++);
        const tail = next._tail.force();
        if (_Cons.isCons(tail)) {
          next = tail;
        } else {
          break;
        }
      }
      return accumulator;
    }
    reduceUntil(predicate, reducer, accumulator) {
      return this.reduceWhile(not9(predicate), reducer, accumulator);
    }
    filter(predicate, index = 0) {
      let next = this;
      while (true) {
        if (predicate(next._head, index++)) {
          return new _Cons(next._head, next._tail.map((tail2) => _Cons.isCons(tail2) ? tail2.filter(predicate, index) : Nil));
        }
        const tail = next._tail.force();
        if (_Cons.isCons(tail)) {
          next = tail;
        } else {
          return Nil;
        }
      }
    }
    reject(predicate) {
      return this.filter(not9(predicate));
    }
    find(predicate) {
      let next = this;
      let index = 0;
      while (true) {
        const head = next._head;
        if (predicate(head, index++)) {
          return Option.of(head);
        }
        const tail = next._tail.force();
        if (_Cons.isCons(tail)) {
          next = tail;
        } else {
          return None;
        }
      }
    }
    includes(value) {
      return this.some(equals(value));
    }
    collect(mapper, index = 0) {
      let next = this;
      while (true) {
        const value = mapper(next._head, index++);
        if (value.isSome()) {
          return new _Cons(value.get(), next._tail.map((tail2) => _Cons.isCons(tail2) ? tail2.collect(mapper, index) : Nil));
        }
        const tail = next._tail.force();
        if (_Cons.isCons(tail)) {
          next = tail;
        } else {
          return Nil;
        }
      }
    }
    collectFirst(mapper) {
      let next = this;
      let index = 0;
      while (true) {
        const value = mapper(next._head, index++);
        if (value.isSome()) {
          return value;
        }
        const tail = next._tail.force();
        if (_Cons.isCons(tail)) {
          next = tail;
        } else {
          return None;
        }
      }
    }
    some(predicate) {
      let next = this;
      let index = 0;
      while (true) {
        if (predicate(next._head, index++)) {
          return true;
        }
        const tail = next._tail.force();
        if (_Cons.isCons(tail)) {
          next = tail;
        } else {
          return false;
        }
      }
    }
    none(predicate) {
      return this.every(not9(predicate));
    }
    every(predicate) {
      let next = this;
      let index = 0;
      while (true) {
        if (!predicate(next._head, index++)) {
          return false;
        }
        const tail = next._tail.force();
        if (_Cons.isCons(tail)) {
          next = tail;
        } else {
          return true;
        }
      }
    }
    count(predicate) {
      return this.reduce((count, value, index) => predicate(value, index) ? count + 1 : count, 0);
    }
    distinct(seen = Set2.empty()) {
      let next = this;
      while (true) {
        if (seen.has(next._head)) {
          const tail = next._tail.force();
          if (_Cons.isCons(tail)) {
            next = tail;
          } else {
            return Nil;
          }
        } else {
          return _Cons.of(next._head, next._tail.map((tail) => _Cons.isCons(tail) ? tail.distinct(seen.add(next._head)) : Nil));
        }
      }
    }
    get(index) {
      return index < 0 ? None : this.skip(index).first();
    }
    has(index) {
      return this.get(index).isSome();
    }
    set(index, value) {
      if (index < 0) {
        return this;
      }
      if (index === 0) {
        if (Equatable.equals(value, this._head)) {
          return this;
        }
        return new _Cons(value, this._tail);
      }
      return new _Cons(this._head, this._tail.map((tail) => tail.set(index - 1, value)));
    }
    insert(index, value) {
      if (index < 0) {
        return this;
      }
      if (index === 0) {
        return new _Cons(value, Lazy.force(this));
      }
      return new _Cons(this._head, this._tail.map((tail) => tail.set(index - 1, value)));
    }
    append(value) {
      return new _Cons(this._head, this._tail.map((tail) => tail.append(value)));
    }
    prepend(value) {
      return new _Cons(value, Lazy.force(this));
    }
    concat(iterable) {
      const sequence = Sequence.from(iterable);
      if (_Cons.isCons(sequence)) {
        return new _Cons(this._head, this._tail.map((tail) => tail.concat(sequence)));
      }
      return this;
    }
    subtract(iterable) {
      return this.filter((value) => !Iterable.includes(iterable, value));
    }
    intersect(iterable) {
      return this.filter((value) => Iterable.includes(iterable, value));
    }
    tee(callback, ...args) {
      callback(this, ...args);
      return this;
    }
    zip(iterable) {
      const sequence = Sequence.from(iterable);
      if (_Cons.isCons(sequence)) {
        return new _Cons([this._head, sequence._head], this._tail.map((tail) => tail.zip(sequence.rest())));
      }
      return Nil;
    }
    first() {
      return Option.of(this._head);
    }
    last() {
      let next = this;
      while (true) {
        const tail = next._tail.force();
        if (_Cons.isCons(tail)) {
          next = tail;
        } else {
          return Option.of(next._head);
        }
      }
    }
    take(count) {
      if (count <= 0) {
        return Nil;
      }
      return new _Cons(this._head, count === 1 ? Lazy.force(Nil) : this._tail.map((tail) => _Cons.isCons(tail) ? tail.take(count - 1) : Nil));
    }
    takeWhile(predicate) {
      return this.takeUntil(not9(predicate));
    }
    takeUntil(predicate, index = 0) {
      if (predicate(this._head, index)) {
        return Nil;
      }
      return new _Cons(this._head, this._tail.map((tail) => _Cons.isCons(tail) ? tail.takeUntil(predicate, index + 1) : tail.takeUntil(predicate)));
    }
    takeLast(count) {
      return this.skip(this.size - count);
    }
    takeLastWhile(predicate) {
      return this.reverse().takeWhile(predicate).reverse();
    }
    takeLastUntil(predicate) {
      return this.takeLastWhile(not9(predicate));
    }
    skip(count) {
      let next = this;
      while (count-- > 0) {
        const tail = next._tail.force();
        if (_Cons.isCons(tail)) {
          next = tail;
        } else {
          return Nil;
        }
      }
      return next;
    }
    skipWhile(predicate) {
      let next = this;
      let index = 0;
      while (predicate(next._head, index++)) {
        const tail = next._tail.force();
        if (_Cons.isCons(tail)) {
          next = tail;
        } else {
          return Nil;
        }
      }
      return next;
    }
    skipUntil(predicate) {
      return this.skipWhile(not9(predicate));
    }
    skipLast(count) {
      return this.take(this.size - count);
    }
    skipLastWhile(predicate) {
      return this.reverse().skipWhile(predicate).reverse();
    }
    skipLastUntil(predicate) {
      return this.skipLastWhile(not9(predicate));
    }
    trim(predicate) {
      return this.trimLeading(predicate).trimTrailing(predicate);
    }
    trimLeading(predicate) {
      return this.skipWhile(predicate);
    }
    trimTrailing(predicate) {
      return this.skipLastWhile(predicate);
    }
    rest() {
      return this._tail.force();
    }
    slice(start, end10) {
      let slice = this.skip(start);
      if (end10 !== void 0) {
        slice = slice.take(end10 - start);
      }
      return slice;
    }
    reverse() {
      return this.reduce((reversed, value) => new _Cons(value, Lazy.force(reversed)), Nil);
    }
    join(separator) {
      let result = `${this._head}`;
      let next = this;
      while (true) {
        const tail = next._tail.force();
        if (_Cons.isCons(tail)) {
          result += `${separator}${tail._head}`;
          next = tail;
        } else {
          return result;
        }
      }
    }
    sort() {
      return this.sortWith(compareComparable6);
    }
    sortWith(comparer) {
      return Sequence.fromArray(Array2.sortWith(this.toArray(), comparer));
    }
    compare(iterable) {
      return this.compareWith(iterable, Comparable.compare);
    }
    compareWith(iterable, comparer) {
      return Iterable.compareWith(this, iterable, comparer);
    }
    groupBy(grouper) {
      return this.reduce((groups, value, index) => {
        const group = grouper(value, index);
        return groups.set(group, new _Cons(value, Lazy.force(groups.get(group).getOrElse(() => Nil))));
      }, Map2.empty()).map((group) => group.reverse());
    }
    equals(value) {
      if (!_Cons.isCons(value)) {
        return false;
      }
      let a = this;
      let b = value;
      while (true) {
        if (!Equatable.equals(a._head, b._head)) {
          return false;
        }
        const ta = a._tail.force();
        const tb = b._tail.force();
        if (_Cons.isCons(ta) && _Cons.isCons(tb)) {
          a = ta;
          b = tb;
        } else {
          return ta === Nil && tb === Nil;
        }
      }
    }
    hash(hash2) {
      let size = 0;
      for (const value of this) {
        hash2.writeUnknown(value);
        size++;
      }
      hash2.writeUint32(size);
    }
    *iterator() {
      let next = this;
      while (true) {
        yield next._head;
        const tail = next._tail.force();
        if (_Cons.isCons(tail)) {
          next = tail;
        } else {
          break;
        }
      }
    }
    [Symbol.iterator]() {
      return this.iterator();
    }
    toArray() {
      const array = [];
      let next = this;
      while (true) {
        array.push(next._head);
        const tail = next._tail.force();
        if (_Cons.isCons(tail)) {
          next = tail;
        } else {
          return array;
        }
      }
    }
    toJSON(options) {
      const json = [];
      let next = this;
      while (true) {
        json.push(Serializable.toJSON(next._head, options));
        const tail = next._tail.force();
        if (_Cons.isCons(tail)) {
          next = tail;
        } else {
          return json;
        }
      }
    }
    toString() {
      return `Sequence [ ${this.join(", ")} ]`;
    }
  };
  (function(Cons2) {
    function isCons(value) {
      return value instanceof Cons2;
    }
    Cons2.isCons = isCons;
  })(Cons || (Cons = {}));

  // node_modules/@siteimprove/alfa-act/dist/tag.js
  var Tag = class _Tag {
    constructor() {
    }
    equals(value) {
      return value instanceof _Tag && value.type === this.type;
    }
    toJSON() {
      return {
        type: this.type
      };
    }
  };
  (function(Tag2) {
    function isTag(value, type) {
      return value instanceof Tag2 && (type === void 0 || value.type === type);
    }
    Tag2.isTag = isTag;
  })(Tag || (Tag = {}));

  // node_modules/@siteimprove/alfa-act/dist/rule.js
  var { flatten, reduce } = Iterable;
  var Rule = class _Rule {
    _uri;
    _requirements;
    _tags;
    _evaluate;
    constructor(uri, requirements, tags, evaluator) {
      this._uri = uri;
      this._requirements = requirements;
      this._tags = tags;
      this._evaluate = evaluator;
    }
    get uri() {
      return this._uri;
    }
    get requirements() {
      return this._requirements;
    }
    get tags() {
      return this._tags;
    }
    hasRequirement(requirementOrPredicate) {
      const predicate = Requirement.isRequirement(requirementOrPredicate) ? (requirement) => requirementOrPredicate.equals(requirement) : requirementOrPredicate;
      return Array2.some(this._requirements, predicate);
    }
    hasTag(tagOrPredicate) {
      const predicate = Tag.isTag(tagOrPredicate) ? (tag) => tagOrPredicate.equals(tag) : tagOrPredicate;
      return Array2.some(this._tags, predicate);
    }
    evaluate(input, oracle = () => Future.now(None), outcomes = Cache.empty(), performance) {
      return this._evaluate(input, oracle, outcomes, performance);
    }
    equals(value) {
      return value instanceof _Rule && value._uri === this._uri;
    }
    hash(hash2) {
      hash2.writeString(this._uri);
    }
    toEARL() {
      return {
        "@context": {
          earl: "http://www.w3.org/ns/earl#",
          dct: "http://purl.org/dc/terms/"
        },
        "@type": ["earl:TestCriterion", "earl:TestCase"],
        "@id": this._uri,
        "dct:isPartOf": {
          "@set": this._requirements.map((requirement) => requirement.toEARL())
        }
      };
    }
    toSARIF() {
      return {
        id: this._uri,
        helpUri: this._uri
      };
    }
  };
  (function(Rule3) {
    const { Applicable } = Outcome;
    function isRule(value) {
      return value instanceof Rule3;
    }
    Rule3.isRule = isRule;
    class Atomic extends Rule3 {
      static of(properties) {
        return new Atomic(properties.uri, Array2.from(properties.requirements ?? []), Array2.from(properties.tags ?? []), properties.evaluate);
      }
      constructor(uri, requirements, tags, evaluate) {
        super(uri, requirements, tags, (input, oracle, outcomes, performance) => outcomes.get(this, () => {
          const startRule = performance?.mark(Event.start(this)).start;
          const rulePerformance = performance !== void 0 ? {
            mark: (name) => performance?.mark(Event.start(this, name)),
            measure: (name, start) => performance?.measure(Event.end(this, name), start)
          } : void 0;
          const { applicability, expectations } = evaluate(input, rulePerformance);
          const startApplicability = performance?.mark(Event.startApplicability(this)).start;
          let startExpectation;
          return Future.traverse(applicability(), (interview) => Interview.conduct(interview, this, oracle).map((target) => target.either(
            // We have a target, wrap it properly and return it.
            ([target2, oracleUsed]) => Tuple.of(Maybe.toOption(target2), oracleUsed),
            // We have an unanswered question and return None
            ([_, oracleUsed]) => Tuple.of(None, oracleUsed)
          ))).map((targets) => (
            // We both need to keep with each target whether the oracle was used,
            // and with the global sequence whether it was used at all.
            // The second case is needed to decide whether the oracle was used
            // when producing an Inapplicable result (empty sequence).
            // None are cleared from the sequence, and Some are opened to only
            // keep the targets.
            //
            // For efficiency, we prepend the targets and reverse the full
            // sequence later to conserve the order.
            // This result in a O(n) rather than O(n²) process.
            Sequence.from(targets).reduce(([acc, wasUsed], [cur, isUsed]) => Tuple.of(cur.isSome() ? acc.prepend(Tuple.of(cur.get(), isUsed)) : acc, wasUsed || isUsed), Tuple.of(Sequence.empty(), false))
          )).tee(() => {
            performance?.measure(Event.endApplicability(this), startApplicability);
            startExpectation = performance?.mark(Event.startExpectation(this)).start;
          }).flatMap(([targets, oracleUsed]) => {
            if (targets.isEmpty()) {
              return Future.now([
                Outcome.Inapplicable.of(this, getMode(oracleUsed))
              ]);
            }
            return Future.traverse(
              // Since targets were prepended when Applicability was processed,
              // we now need to reverse the sequence to restore initial order.
              targets.reverse(),
              ([target, oracleUsedInApplicability]) => resolve(target, Record.of(expectations(target)), this, oracle, oracleUsedInApplicability)
            ).tee(() => {
              performance?.measure(Event.endExpectation(this), startExpectation);
            });
          }).tee(() => {
            performance?.measure(Event.end(this), startRule);
          });
        }));
      }
      toJSON() {
        return {
          type: "atomic",
          uri: this._uri,
          requirements: this._requirements.map((requirement) => requirement.toJSON()),
          tags: this._tags.map((tag) => tag.toJSON())
        };
      }
    }
    Rule3.Atomic = Atomic;
    (function(Atomic2) {
      function isAtomic(value) {
        return value instanceof Atomic2;
      }
      Atomic2.isAtomic = isAtomic;
    })(Atomic = Rule3.Atomic || (Rule3.Atomic = {}));
    Rule3.isAtomic = Atomic.isAtomic;
    class Composite extends Rule3 {
      static of(properties) {
        return new Composite(properties.uri, Array2.from(properties.requirements ?? []), Array2.from(properties.tags ?? []), Array2.from(properties.composes), properties.evaluate);
      }
      _composes;
      constructor(uri, requirements, tags, composes, evaluate) {
        super(uri, requirements, tags, (input, oracle, outcomes, performance) => outcomes.get(this, () => {
          const startRule = performance?.mark(Event.start(this)).start;
          const rulePerformance = performance !== void 0 ? {
            mark: (name) => performance?.mark(Event.start(this, name)),
            measure: (name, start) => performance?.measure(Event.end(this, name), start)
          } : void 0;
          return Future.traverse(this._composes, (rule) => rule.evaluate(input, oracle, outcomes, performance)).map((outcomes2) => (
            // We both need to keep with each outcome whether the oracle was used,
            // and with the global sequence whether it was used at all.
            // The second case is needed to decide whether the oracle was used
            // when producing an Inapplicable result (empty sequence).
            // Inapplicable outcomes one are cleared from the sequence.
            //
            // For efficiency, we prepend the targets and reverse the full
            // sequence later to conserve the order.
            // This result in a O(n) rather than O(n²) process.
            Sequence.from(flatten(outcomes2)).reduce(([acc, wasUsed], outcome) => Tuple.of(Applicable.isApplicable(outcome) ? acc.prepend(outcome) : acc, wasUsed || outcome.isSemiAuto), Tuple.of(Sequence.empty(), false))
          )).flatMap(([targets, oracleUsed]) => {
            if (targets.isEmpty()) {
              return Future.now([
                Outcome.Inapplicable.of(this, getMode(oracleUsed))
              ]);
            }
            const { expectations } = evaluate(input, rulePerformance);
            return Future.traverse(
              // Since targets were prepended when Applicability was processed,
              // we now need to reverse the sequence to restore initial order.
              targets.reverse().groupBy((outcome) => outcome.target),
              ([target, outcomes2]) => resolve(target, Record.of(expectations(outcomes2)), this, oracle, oracleUsed)
            );
          }).tee(() => {
            performance?.measure(Event.end(this), startRule);
          });
        }));
        this._composes = composes;
      }
      get composes() {
        return this._composes;
      }
      toJSON() {
        return {
          type: "composite",
          uri: this._uri,
          requirements: this._requirements.map((requirement) => requirement.toJSON()),
          tags: this._tags.map((tag) => tag.toJSON()),
          composes: this._composes.map((rule) => rule.toJSON())
        };
      }
    }
    Rule3.Composite = Composite;
    (function(Composite2) {
      function isComposite(value) {
        return value instanceof Composite2;
      }
      Composite2.isComposite = isComposite;
    })(Composite = Rule3.Composite || (Rule3.Composite = {}));
    Rule3.isComposite = Composite.isComposite;
    class Event {
      static of(type, rule, name) {
        return new Event(type, rule, name);
      }
      _type;
      _rule;
      _name;
      constructor(type, rule, name) {
        this._type = type;
        this._rule = rule;
        this._name = name;
      }
      get type() {
        return this._type;
      }
      get rule() {
        return this._rule;
      }
      get name() {
        return this._name;
      }
      toJSON() {
        return {
          type: this._type,
          rule: this._rule.toJSON(),
          name: this._name
        };
      }
    }
    Rule3.Event = Event;
    (function(Event2) {
      function isEvent(value) {
        return value instanceof Event2;
      }
      Event2.isEvent = isEvent;
      function start(rule, name = "total") {
        return Event2.of("start", rule, name);
      }
      Event2.start = start;
      function end10(rule, name = "total") {
        return Event2.of("end", rule, name);
      }
      Event2.end = end10;
      function startApplicability(rule) {
        return Event2.of("start", rule, "applicability");
      }
      Event2.startApplicability = startApplicability;
      function endApplicability(rule) {
        return Event2.of("end", rule, "applicability");
      }
      Event2.endApplicability = endApplicability;
      function startExpectation(rule) {
        return Event2.of("start", rule, "expectation");
      }
      Event2.startExpectation = startExpectation;
      function endExpectation(rule) {
        return Event2.of("end", rule, "expectation");
      }
      Event2.endExpectation = endExpectation;
    })(Event = Rule3.Event || (Rule3.Event = {}));
  })(Rule || (Rule = {}));
  function processExpectation(acc, [id, expectation2]) {
    return acc.either(
      // The accumulator only contains true result, keep going.
      ([accumulator, oracleUsedAccumulator]) => expectation2.either(
        // The current result is defined, accumulate.
        ([result, oracleUsed]) => Left.of(Tuple.of(accumulator.append([id, Maybe.toOption(result)]), oracleUsedAccumulator || oracleUsed)),
        // The current result is cantTell, abort.
        ([diagnostic, oracleUsed]) => Right.of(Tuple.of(diagnostic, oracleUsedAccumulator || oracleUsed))
      ),
      // The accumulator already contains cantTell, skip.
      // Note that we only keep the mode of the first Expectation that cannot tell,
      // which is likely OK.
      () => acc
    );
  }
  function resolve(target, expectations, rule, oracle, oracleUsedInApplicability) {
    return Future.traverse(expectations, ([id, interview]) => Interview.conduct(interview, rule, oracle).map((expectation2) => [id, expectation2])).map((expectations2) => reduce(expectations2, processExpectation, Left.of(Tuple.of(List.empty(), oracleUsedInApplicability)))).map((expectation2) => expectation2.either(([expectations2, oracleUsed]) => Outcome.from(rule, target, Record.from(expectations2), getMode(oracleUsed)), ([diagnostic, oracleUsed]) => Outcome.CantTell.of(rule, target, diagnostic, getMode(oracleUsed))));
  }
  function getMode(oracleUsed) {
    return oracleUsed ? Outcome.Mode.SemiAuto : Outcome.Mode.Automatic;
  }

  // node_modules/@siteimprove/alfa-dom/dist/namespace.js
  var Namespace;
  (function(Namespace2) {
    Namespace2["HTML"] = "http://www.w3.org/1999/xhtml";
    Namespace2["MathML"] = "http://www.w3.org/1998/Math/MathML";
    Namespace2["SVG"] = "http://www.w3.org/2000/svg";
    Namespace2["XLink"] = "http://www.w3.org/1999/xlink";
    Namespace2["XML"] = "http://www.w3.org/XML/1998/namespace";
    Namespace2["XMLNS"] = "http://www.w3.org/2000/xmlns/";
  })(Namespace || (Namespace = {}));
  (function(Namespace2) {
    function isNamespace(value) {
      switch (value) {
        case Namespace2.HTML:
        case Namespace2.MathML:
        case Namespace2.SVG:
        case Namespace2.XLink:
        case Namespace2.XML:
        case Namespace2.XMLNS:
          return true;
        default:
          return false;
      }
    }
    Namespace2.isNamespace = isNamespace;
  })(Namespace || (Namespace = {}));

  // node_modules/@siteimprove/alfa-parser/dist/parser.js
  var { not: not10 } = Predicate;
  var Parser;
  (function(Parser2) {
    function toParser(infallible) {
      return (input, ...args) => Result.of(infallible(input, ...args));
    }
    Parser2.toParser = toParser;
    function map126(parser, mapper) {
      return (input, ...args) => parser(input, ...args).map(([remainder, value]) => [
        remainder,
        mapper(value)
      ]);
    }
    Parser2.map = map126;
    function mapResult3(parser, mapper) {
      return (input, ...args) => parser(input, ...args).flatMap(([remainder, value]) => mapper(value).map((result) => [remainder, result]));
    }
    Parser2.mapResult = mapResult3;
    function flatMap5(parser, mapper) {
      return (input, ...args) => parser(input, ...args).flatMap(([remainder, value]) => mapper(value)(remainder, ...args));
    }
    Parser2.flatMap = flatMap5;
    function filter13(parser, predicate, ifError) {
      return mapResult3(parser, (value) => predicate(value) ? Result.of(value) : Err.of(ifError(value)));
    }
    Parser2.filter = filter13;
    function reject(parser, predicate, ifError) {
      return filter13(parser, not10(predicate), ifError);
    }
    Parser2.reject = reject;
    function zeroOrMore7(parser) {
      return takeAtLeast(parser, 0);
    }
    Parser2.zeroOrMore = zeroOrMore7;
    function oneOrMore4(parser) {
      return takeAtLeast(parser, 1);
    }
    Parser2.oneOrMore = oneOrMore4;
    function take9(parser, count) {
      return takeBetween20(parser, count, count);
    }
    Parser2.take = take9;
    function takeBetween20(parser, lower, upper) {
      return (input, ...args) => {
        const values = [];
        let value;
        for (let i = 0; i < upper; i++) {
          const result = parser(input, ...args);
          if (result.isOk()) {
            [input, value] = result.get();
            values.push(value);
          } else if (result.isErr()) {
            if (values.length < lower) {
              return result;
            } else {
              break;
            }
          }
        }
        return Result.of([input, values]);
      };
    }
    Parser2.takeBetween = takeBetween20;
    function takeAtLeast(parser, lower) {
      return takeBetween20(parser, lower, Infinity);
    }
    Parser2.takeAtLeast = takeAtLeast;
    function takeAtMost(parser, upper) {
      return takeBetween20(parser, 0, upper);
    }
    Parser2.takeAtMost = takeAtMost;
    function takeUntil5(parser, condition) {
      return (input, ...args) => {
        const values = [];
        let value;
        while (true) {
          if (condition(input, ...args).isOk()) {
            return Result.of([input, values]);
          }
          const result = parser(input, ...args);
          if (result.isOk()) {
            [input, value] = result.get();
            values.push(value);
          } else if (result.isErr()) {
            return result;
          }
        }
      };
    }
    Parser2.takeUntil = takeUntil5;
    function peek2(parser) {
      return (input, ...args) => parser(input, ...args).map(([, value]) => [input, value]);
    }
    Parser2.peek = peek2;
    function tee5(parser, callback) {
      return (input, ...args) => parser(input, ...args).tee(([remainder, result]) => {
        callback(result, remainder, ...args);
      });
    }
    Parser2.tee = tee5;
    function teeErr(parser, callback) {
      return (input, ...args) => parser(input, ...args).teeErr((err) => {
        callback(err, ...args);
      });
    }
    Parser2.teeErr = teeErr;
    function option64(parser) {
      return (input, ...args) => {
        const result = parser(input, ...args);
        if (result.isOk()) {
          const [input2, value] = result.get();
          return Result.of([input2, Option.of(value)]);
        }
        return Result.of([input, None]);
      };
    }
    Parser2.option = option64;
    function either100(...parsers) {
      return (input, ...args) => {
        let error;
        for (const parser of parsers) {
          const result = parser(input, ...args);
          if (result.isErr()) {
            error = result;
          } else {
            return result;
          }
        }
        return error;
      };
    }
    Parser2.either = either100;
    function pair36(left23, right39) {
      return flatMap5(left23, (left24) => map126(right39, (right40) => [left24, right40]));
    }
    Parser2.pair = pair36;
    function left22(left23, right39) {
      return flatMap5(left23, (left24) => map126(right39, () => left24));
    }
    Parser2.left = left22;
    function right38(left23, right39) {
      return flatMap5(left23, () => map126(right39, (right40) => right40));
    }
    Parser2.right = right38;
    function delimited49(left23, parser, right39 = left23) {
      return flatMap5(left23, () => flatMap5(parser, (parser2) => map126(right39, () => parser2)));
    }
    Parser2.delimited = delimited49;
    function separated5(left23, separator, right39 = left23) {
      return flatMap5(left23, (left24) => flatMap5(separator, () => map126(right39, (right40) => [left24, right40])));
    }
    Parser2.separated = separated5;
    function separatedList15(parser, separator, lower = 1, upper = Infinity) {
      return map126(pair36(parser, takeBetween20(right38(separator, parser), Math.max(0, lower - 1), Math.min(Infinity, upper - 1))), ([first, rest]) => Array2.prepend(rest, first));
    }
    Parser2.separatedList = separatedList15;
    function parseIf5(refinement, parser, ifError) {
      return (input, ...args) => parser(input, ...args).flatMap(([rest, result]) => refinement(result) ? Ok.of([rest, result]) : Err.of(ifError(result)));
    }
    Parser2.parseIf = parseIf5;
    function doubleBar2(separator, ...parsers) {
      const size = parsers.length;
      return (input, ...args) => {
        const result = globalThis.Array(size).map(() => void 0);
        mainLoop: while (true) {
          for (const [remainder] of separator(input, ...args)) {
            input = remainder;
          }
          for (let i = 0; i < size; i++) {
            if (result[i] !== void 0) {
              continue;
            }
            const parsed = parsers[i](input, ...args);
            if (parsed.isOk()) {
              [input, result[i]] = parsed.get();
              continue mainLoop;
            }
          }
          break;
        }
        return Result.of([input, result]);
      };
    }
    Parser2.doubleBar = doubleBar2;
    function end10(ifError) {
      return (input) => {
        for (const value of input) {
          return Err.of(ifError(value));
        }
        return Result.of([input, void 0]);
      };
    }
    Parser2.end = end10;
    Parser2.eof = end10;
  })(Parser || (Parser = {}));

  // node_modules/@siteimprove/alfa-slice/dist/slice.js
  var { not: not11 } = Predicate;
  var { compareComparable: compareComparable7 } = Comparable;
  var Slice = class _Slice {
    static of(array, start = 0, end10 = array.length) {
      start = clamp(start, array.length);
      return new _Slice(array, start, clamp(end10, array.length) - start);
    }
    static _empty = new _Slice([], 0, 0);
    static empty() {
      return this._empty;
    }
    _array;
    _offset;
    _length;
    constructor(array, offset, length) {
      this._array = array;
      this._offset = offset;
      this._length = length;
    }
    get length() {
      return this._length;
    }
    get size() {
      return this._length;
    }
    isEmpty() {
      return this._length === 0;
    }
    forEach(callback) {
      Iterable.forEach(this, callback);
    }
    map(mapper) {
      const result = Array2.allocate(this._length);
      for (let i = 0, n = this._length; i < n; i++) {
        result[i] = mapper(this._array[this._offset + i], i);
      }
      return new _Slice(result, 0, result.length);
    }
    apply(mapper) {
      const array = [...Iterable.apply(this, mapper)];
      return new _Slice(array, 0, array.length);
    }
    flatMap(mapper) {
      const array = [...Iterable.flatMap(this, mapper)];
      return new _Slice(array, 0, array.length);
    }
    flatten() {
      return this.flatMap((slice) => slice);
    }
    reduce(reducer, accumulator) {
      return Iterable.reduce(this, reducer, accumulator);
    }
    reduceWhile(predicate, reducer, accumulator) {
      return Iterable.reduceWhile(this, predicate, reducer, accumulator);
    }
    reduceUntil(predicate, reducer, accumulator) {
      return Iterable.reduceUntil(this, predicate, reducer, accumulator);
    }
    filter(predicate) {
      const array = [...Iterable.filter(this, predicate)];
      return new _Slice(array, 0, array.length);
    }
    reject(predicate) {
      const array = [...Iterable.reject(this, predicate)];
      return new _Slice(array, 0, array.length);
    }
    find(predicate) {
      return Iterable.find(this, predicate);
    }
    includes(value) {
      return Iterable.includes(this, value);
    }
    collect(mapper) {
      const array = [...Iterable.collect(this, mapper)];
      return new _Slice(array, 0, array.length);
    }
    collectFirst(mapper) {
      return Iterable.collectFirst(this, mapper);
    }
    some(predicate) {
      return Iterable.some(this, predicate);
    }
    none(predicate) {
      return Iterable.none(this, predicate);
    }
    every(predicate) {
      return Iterable.every(this, predicate);
    }
    count(predicate) {
      return Iterable.count(this, predicate);
    }
    distinct() {
      const array = [...Iterable.distinct(this)];
      return new _Slice(array, 0, array.length);
    }
    get(index) {
      if (index < 0 || index >= this._length) {
        return None;
      }
      return Option.of(this._array[this._offset + index]);
    }
    has(index) {
      return index < 0 || index >= this._length;
    }
    set(index, value) {
      if (index < 0 || index >= this._length) {
        return this;
      }
      const array = this.toArray();
      array[index] = value;
      return new _Slice(array, 0, array.length);
    }
    insert(index, value) {
      const array = Array2.insert(this.toArray(), index, value);
      return new _Slice(array, 0, array.length);
    }
    append(value) {
      const array = Array2.append(this.toArray(), value);
      return new _Slice(array, 0, array.length);
    }
    prepend(value) {
      const array = Array2.prepend(this.toArray(), value);
      return new _Slice(array, 0, array.length);
    }
    concat(iterable) {
      const array = this.toArray();
      for (const value of iterable) {
        array.push(value);
      }
      return new _Slice(array, 0, array.length);
    }
    subtract(iterable) {
      const array = [...Iterable.subtract(this, iterable)];
      return new _Slice(array, 0, array.length);
    }
    intersect(iterable) {
      const array = [...Iterable.intersect(this, iterable)];
      return new _Slice(array, 0, array.length);
    }
    tee(callback, ...args) {
      callback(this, ...args);
      return this;
    }
    zip(iterable) {
      const array = [...Iterable.zip(this, iterable)];
      return new _Slice(array, 0, array.length);
    }
    first() {
      return this.get(0);
    }
    last() {
      return this.get(this._length - 1);
    }
    take(count) {
      return this.slice(0, count);
    }
    takeWhile(predicate) {
      let count = 0;
      for (let i = 0, n = this._length; i < n; i++) {
        if (predicate(this._array[this._offset + i], i)) {
          count++;
        } else {
          break;
        }
      }
      return this.take(count);
    }
    takeUntil(predicate) {
      return this.takeWhile(not11(predicate));
    }
    takeLast(count) {
      return this.slice(this._length - count);
    }
    takeLastWhile(predicate) {
      let count = 0;
      for (let i = this._length - 1; i >= 0; i--) {
        if (predicate(this._array[this._offset + i], i)) {
          count++;
        } else {
          break;
        }
      }
      return this.takeLast(count);
    }
    takeLastUntil(predicate) {
      return this.takeLastWhile(not11(predicate));
    }
    skip(count) {
      return this.slice(count);
    }
    skipWhile(predicate) {
      let count = 0;
      for (let i = 0, n = this._length; i < n; i++) {
        if (predicate(this._array[this._offset + i], i)) {
          count++;
        } else {
          break;
        }
      }
      return this.skip(count);
    }
    skipUntil(predicate) {
      return this.skipWhile(not11(predicate));
    }
    skipLast(count) {
      return this.slice(0, this._length - count);
    }
    skipLastWhile(predicate) {
      let count = 0;
      for (let i = this._length - 1; i >= 0; i--) {
        if (predicate(this._array[this._offset + i], i)) {
          count++;
        } else {
          break;
        }
      }
      return this.skipLast(count);
    }
    skipLastUntil(predicate) {
      return this.skipLastWhile(not11(predicate));
    }
    trim(predicate) {
      return this.trimLeading(predicate).trimTrailing(predicate);
    }
    trimLeading(predicate) {
      return this.skipWhile(predicate);
    }
    trimTrailing(predicate) {
      return this.skipLastWhile(predicate);
    }
    rest() {
      return this.slice(1);
    }
    slice(start, end10 = this._length) {
      start = clamp(start, this._length);
      return new _Slice(this._array, this._offset + start, clamp(end10, this._length) - start);
    }
    reverse() {
      const array = this.toArray().reverse();
      return new _Slice(array, 0, array.length);
    }
    join(separator) {
      return Iterable.join(this, separator);
    }
    sort() {
      return this.sortWith(compareComparable7);
    }
    sortWith(comparer) {
      const array = Array2.sortWith(this.toArray(), comparer);
      return new _Slice(array, 0, array.length);
    }
    compare(iterable) {
      return this.compareWith(iterable, compareComparable7);
    }
    compareWith(iterable, comparer) {
      return Iterable.compareWith(this, iterable, comparer);
    }
    *iterator() {
      for (let i = this._offset, n = i + this._length; i < n; i++) {
        yield this._array[i];
      }
    }
    [Symbol.iterator]() {
      return this.iterator();
    }
    equals(value) {
      if (value instanceof _Slice && value._length === this._length) {
        for (let i = 0, n = value._length; i < n; i++) {
          if (!Equatable.equals(value._array[value._offset + i], this._array[this._offset + i])) {
            return false;
          }
        }
        return true;
      }
      return false;
    }
    hash(hash2) {
      Iterable.hash(this, hash2);
    }
    toArray() {
      return this._array.slice(this._offset, this._offset + this._length);
    }
    toJSON(options) {
      return this.toArray().map((value) => Serializable.toJSON(value, options));
    }
    toString() {
      const values = this.toArray().join(", ");
      return `Slice [${values === "" ? "" : ` ${values} `}]`;
    }
  };
  (function(Slice2) {
    function from(iterable) {
      if (isSlice(iterable)) {
        return iterable;
      }
      return Slice2.of([...iterable]);
    }
    Slice2.from = from;
    function isSlice(value) {
      return value instanceof Slice2;
    }
    Slice2.isSlice = isSlice;
  })(Slice || (Slice = {}));
  function clamp(value, length) {
    return value < 0 ? 0 : value > length ? length : value;
  }

  // node_modules/@siteimprove/alfa-css/dist/syntax/token.js
  var { map, oneOrMore, parseIf } = Parser;
  var { fromCharCode } = String;
  var { and } = Refinement;
  var Token;
  (function(Token2) {
    const parseFirst2 = (input) => input.first().map((token) => Ok.of([input.rest(), token])).getOr(Err.of("No token left"));
    function parseToken(refinement) {
      return parseIf(refinement, parseFirst2, () => "Mismatching token");
    }
    class Ident2 {
      static of(value) {
        return new Ident2(value);
      }
      _value;
      constructor(value) {
        this._value = value;
      }
      get type() {
        return "ident";
      }
      get value() {
        return this._value;
      }
      equals(value) {
        return value instanceof Ident2 && value._value === this._value;
      }
      toJSON() {
        return {
          type: "ident",
          value: this._value
        };
      }
      toString() {
        return this._value;
      }
    }
    Token2.Ident = Ident2;
    (function(Ident3) {
      function isIdent(value) {
        return value instanceof Ident3;
      }
      Ident3.isIdent = isIdent;
    })(Ident2 = Token2.Ident || (Token2.Ident = {}));
    Token2.ident = Ident2.of, Token2.isIdent = Ident2.isIdent;
    function parseIdent3(query = () => true) {
      let predicate;
      if (typeof query === "function") {
        predicate = query;
      } else {
        const value = query;
        predicate = (ident) => ident.value === value;
      }
      return parseToken(and(Token2.isIdent, predicate));
    }
    Token2.parseIdent = parseIdent3;
    class Function4 {
      static of(value) {
        return new Function4(value);
      }
      _value;
      constructor(value) {
        this._value = value;
      }
      get type() {
        return "function";
      }
      get value() {
        return this._value;
      }
      get mirror() {
        return CloseParenthesis.of();
      }
      equals(value) {
        return value instanceof Function4 && value._value === this._value;
      }
      toJSON() {
        return {
          type: "function",
          value: this._value
        };
      }
      toString() {
        return `${this._value}(`;
      }
    }
    Token2.Function = Function4;
    (function(Function5) {
      function isFunction7(value) {
        return value instanceof Function5;
      }
      Function5.isFunction = isFunction7;
    })(Function4 = Token2.Function || (Token2.Function = {}));
    Token2.func = Function4.of, Token2.isFunction = Function4.isFunction;
    function parseFunction(query = () => true) {
      const predicate = typeof query === "function" ? query : (ident) => ident.value === query;
      return parseToken(and(Token2.isFunction, predicate));
    }
    Token2.parseFunction = parseFunction;
    class AtKeyword {
      static of(value) {
        return new AtKeyword(value);
      }
      _value;
      constructor(value) {
        this._value = value;
      }
      get type() {
        return "at-keyword";
      }
      get value() {
        return this._value;
      }
      equals(value) {
        return value instanceof AtKeyword && value._value === this._value;
      }
      toJSON() {
        return {
          type: "at-keyword",
          value: this._value
        };
      }
      toString() {
        return `@${this._value}`;
      }
    }
    Token2.AtKeyword = AtKeyword;
    Token2.atKeyword = AtKeyword.of;
    class Hash2 {
      static of(value, isIdentifier) {
        return new Hash2(value, isIdentifier);
      }
      _value;
      _isIdentifier;
      constructor(value, isIdentifier) {
        this._value = value;
        this._isIdentifier = isIdentifier;
      }
      get type() {
        return "hash";
      }
      get value() {
        return this._value;
      }
      get isIdentifier() {
        return this._isIdentifier;
      }
      equals(value) {
        return value instanceof Hash2 && value._value === this._value && value._isIdentifier === this._isIdentifier;
      }
      toJSON() {
        return {
          type: "hash",
          value: this._value,
          isIdentifier: this._isIdentifier
        };
      }
      toString() {
        return `#${this._value}`;
      }
    }
    Token2.Hash = Hash2;
    (function(Hash3) {
      function isHash(value) {
        return value instanceof Hash3;
      }
      Hash3.isHash = isHash;
    })(Hash2 = Token2.Hash || (Token2.Hash = {}));
    Token2.hash = Hash2.of, Token2.isHash = Hash2.isHash;
    function parseHash(predicate = () => true) {
      return parseToken(and(Token2.isHash, predicate));
    }
    Token2.parseHash = parseHash;
    class String4 {
      static of(value) {
        return new String4(value);
      }
      _value;
      constructor(value) {
        this._value = value;
      }
      get type() {
        return "string";
      }
      get value() {
        return this._value;
      }
      equals(value) {
        return value instanceof String4 && value._value === this._value;
      }
      toJSON() {
        return {
          type: "string",
          value: this._value
        };
      }
      toString() {
        return `"${this._value.replace(/"/g, `\\"`)}"`;
      }
    }
    Token2.String = String4;
    (function(String5) {
      function isString3(value) {
        return value instanceof String5;
      }
      String5.isString = isString3;
    })(String4 = Token2.String || (Token2.String = {}));
    Token2.string = String4.of, Token2.isString = String4.isString;
    function parseString(predicate = () => true) {
      return parseToken(and(Token2.isString, predicate));
    }
    Token2.parseString = parseString;
    class URL4 {
      static of(value) {
        return new URL4(value);
      }
      _value;
      constructor(value) {
        this._value = value;
      }
      get type() {
        return "url";
      }
      get value() {
        return this._value;
      }
      equals(value) {
        return value instanceof URL4 && value._value === this._value;
      }
      toJSON() {
        return {
          type: "url",
          value: this._value
        };
      }
      toString() {
        return `url(${this._value})`;
      }
    }
    Token2.URL = URL4;
    (function(URL5) {
      function isURL(value) {
        return value instanceof URL5;
      }
      URL5.isURL = isURL;
    })(URL4 = Token2.URL || (Token2.URL = {}));
    Token2.url = URL4.of, Token2.isURL = URL4.isURL;
    function parseURL(predicate = () => true) {
      return parseToken(and(Token2.isURL, predicate));
    }
    Token2.parseURL = parseURL;
    class BadURL {
      static of() {
        return new BadURL();
      }
      constructor() {
      }
      get type() {
        return "bad-url";
      }
      equals(value) {
        return value instanceof BadURL;
      }
      toJSON() {
        return {
          type: "bad-url"
        };
      }
      toString() {
        return "";
      }
    }
    Token2.BadURL = BadURL;
    Token2.badURL = BadURL.of;
    class Delim {
      static _delims = /* @__PURE__ */ new Map();
      static of(value) {
        let delim = Delim._delims.get(value);
        if (delim === void 0) {
          delim = new Delim(value);
          Delim._delims.set(value, delim);
        }
        return delim;
      }
      _value;
      constructor(value) {
        this._value = value;
      }
      get type() {
        return "delim";
      }
      get value() {
        return this._value;
      }
      equals(value) {
        return value instanceof Delim && value._value === this._value;
      }
      toJSON() {
        return {
          type: "delim",
          value: this._value
        };
      }
      toString() {
        return fromCharCode(this._value);
      }
    }
    Token2.Delim = Delim;
    (function(Delim2) {
      function isDelim(value) {
        return value instanceof Delim2;
      }
      Delim2.isDelim = isDelim;
    })(Delim = Token2.Delim || (Token2.Delim = {}));
    Token2.delim = Delim.of, Token2.isDelim = Delim.isDelim;
    function parseDelim2(query = () => true) {
      let predicate;
      if (typeof query === "function") {
        predicate = query;
      } else {
        const value = typeof query === "number" ? query : query.charCodeAt(0);
        predicate = (delim) => delim.value === value;
      }
      return parseToken(and(Token2.isDelim, predicate));
    }
    Token2.parseDelim = parseDelim2;
    class Number4 {
      static of(value, isInteger, isSigned) {
        return new Number4(value, isInteger, isSigned);
      }
      _value;
      _isInteger;
      _isSigned;
      constructor(value, isInteger, isSigned) {
        this._value = value;
        this._isInteger = isInteger;
        this._isSigned = isSigned;
      }
      get type() {
        return "number";
      }
      get value() {
        return this._value;
      }
      get isInteger() {
        return this._isInteger;
      }
      get isSigned() {
        return this._isSigned;
      }
      equals(value) {
        return value instanceof Number4 && value._value === this._value && value._isInteger === this._isInteger && value._isSigned === this._isSigned;
      }
      toJSON() {
        return {
          type: "number",
          value: this._value,
          isInteger: this._isInteger,
          isSigned: this._isSigned
        };
      }
      toString() {
        const sign = this._isSigned && this._value >= 0 ? "+" : "";
        return `${sign}${this._value}`;
      }
    }
    Token2.Number = Number4;
    (function(Number5) {
      function isNumber6(value) {
        return value instanceof Number5;
      }
      Number5.isNumber = isNumber6;
    })(Number4 = Token2.Number || (Token2.Number = {}));
    Token2.number = Number4.of, Token2.isNumber = Number4.isNumber;
    function parseNumber(predicate = () => true) {
      return parseToken(and(Token2.isNumber, predicate));
    }
    Token2.parseNumber = parseNumber;
    class Percentage3 {
      static of(value, isInteger) {
        return new Percentage3(value, isInteger);
      }
      _value;
      _isInteger;
      constructor(value, isInteger) {
        this._value = value;
        this._isInteger = isInteger;
      }
      get type() {
        return "percentage";
      }
      get value() {
        return this._value;
      }
      get isInteger() {
        return this._isInteger;
      }
      equals(value) {
        return value instanceof Percentage3 && value._value === this._value && value._isInteger === this._isInteger;
      }
      toJSON() {
        return {
          type: "percentage",
          value: this._value,
          isInteger: this._isInteger
        };
      }
      toString() {
        return `${this._value * 100}%`;
      }
    }
    Token2.Percentage = Percentage3;
    (function(Percentage4) {
      function isPercentage3(value) {
        return value instanceof Percentage4;
      }
      Percentage4.isPercentage = isPercentage3;
    })(Percentage3 = Token2.Percentage || (Token2.Percentage = {}));
    Token2.percentage = Percentage3.of, Token2.isPercentage = Percentage3.isPercentage;
    function parsePercentage(predicate = () => true) {
      return parseToken(and(Token2.isPercentage, predicate));
    }
    Token2.parsePercentage = parsePercentage;
    class Dimension3 {
      static of(value, unit, isInteger, isSigned) {
        return new Dimension3(value, unit, isInteger, isSigned);
      }
      _value;
      _unit;
      _isInteger;
      _isSigned;
      constructor(value, unit, isInteger, isSigned) {
        this._value = value;
        this._unit = unit;
        this._isInteger = isInteger;
        this._isSigned = isSigned;
      }
      get type() {
        return "dimension";
      }
      get value() {
        return this._value;
      }
      get unit() {
        return this._unit;
      }
      get isInteger() {
        return this._isInteger;
      }
      get isSigned() {
        return this._isSigned;
      }
      equals(value) {
        return value instanceof Dimension3 && value._value === this._value && value._unit === this._unit && value._isInteger === this._isInteger && value._isSigned === this._isSigned;
      }
      toJSON() {
        return {
          type: "dimension",
          value: this._value,
          unit: this._unit,
          isInteger: this._isInteger,
          isSigned: this._isSigned
        };
      }
      toString() {
        const sign = this._isSigned && this._value >= 0 ? "+" : "";
        return `${sign}${this._value}${this._unit}`;
      }
    }
    Token2.Dimension = Dimension3;
    (function(Dimension4) {
      function isDimension2(value) {
        return value instanceof Dimension4;
      }
      Dimension4.isDimension = isDimension2;
    })(Dimension3 = Token2.Dimension || (Token2.Dimension = {}));
    Token2.dimension = Dimension3.of, Token2.isDimension = Dimension3.isDimension;
    function parseDimension2(predicate = () => true) {
      return parseToken(and(Token2.isDimension, predicate));
    }
    Token2.parseDimension = parseDimension2;
    class Whitespace {
      static _instance = new Whitespace();
      static of() {
        return Whitespace._instance;
      }
      constructor() {
      }
      get type() {
        return "whitespace";
      }
      equals(value) {
        return value instanceof Whitespace;
      }
      toJSON() {
        return {
          type: "whitespace"
        };
      }
      toString() {
        return " ";
      }
    }
    Token2.Whitespace = Whitespace;
    (function(Whitespace2) {
      function isWhitespace3(value) {
        return value instanceof Whitespace2;
      }
      Whitespace2.isWhitespace = isWhitespace3;
    })(Whitespace = Token2.Whitespace || (Token2.Whitespace = {}));
    Token2.whitespace = Whitespace.of, Token2.isWhitespace = Whitespace.isWhitespace;
    Token2.parseWhitespace = map(oneOrMore(parseToken(Token2.isWhitespace)), ([first]) => first);
    class Colon {
      static _instance = new Colon();
      static of() {
        return Colon._instance;
      }
      constructor() {
      }
      get type() {
        return "colon";
      }
      equals(value) {
        return value instanceof Colon;
      }
      toJSON() {
        return {
          type: "colon"
        };
      }
      toString() {
        return ":";
      }
    }
    Token2.Colon = Colon;
    (function(Colon2) {
      function isColon(value) {
        return value instanceof Colon2;
      }
      Colon2.isColon = isColon;
    })(Colon = Token2.Colon || (Token2.Colon = {}));
    Token2.colon = Colon.of, Token2.isColon = Colon.isColon;
    Token2.parseColon = parseToken(Token2.isColon);
    class Semicolon {
      static _instance = new Semicolon();
      static of() {
        return Semicolon._instance;
      }
      constructor() {
      }
      get type() {
        return "semicolon";
      }
      equals(value) {
        return value instanceof Semicolon;
      }
      toJSON() {
        return {
          type: "semicolon"
        };
      }
      toString() {
        return ";";
      }
    }
    Token2.Semicolon = Semicolon;
    (function(Semicolon2) {
      function isSemicolon(value) {
        return value instanceof Semicolon2;
      }
      Semicolon2.isSemicolon = isSemicolon;
    })(Semicolon = Token2.Semicolon || (Token2.Semicolon = {}));
    Token2.semicolon = Semicolon.of, Token2.isSemicolon = Semicolon.isSemicolon;
    Token2.parseSemicolon = parseToken(Token2.isSemicolon);
    class Comma2 {
      static _instance = new Comma2();
      static of() {
        return Comma2._instance;
      }
      constructor() {
      }
      get type() {
        return "comma";
      }
      equals(value) {
        return value instanceof Comma2;
      }
      toJSON() {
        return {
          type: "comma"
        };
      }
      toString() {
        return ",";
      }
    }
    Token2.Comma = Comma2;
    (function(Comma3) {
      function isComma(value) {
        return value instanceof Comma3;
      }
      Comma3.isComma = isComma;
    })(Comma2 = Token2.Comma || (Token2.Comma = {}));
    Token2.comma = Comma2.of, Token2.isComma = Comma2.isComma;
    Token2.parseComma = parseToken(Token2.isComma);
    class OpenParenthesis {
      static _instance = new OpenParenthesis();
      static of() {
        return OpenParenthesis._instance;
      }
      constructor() {
      }
      get type() {
        return "open-parenthesis";
      }
      get mirror() {
        return CloseParenthesis.of();
      }
      equals(value) {
        return value instanceof OpenParenthesis;
      }
      toJSON() {
        return {
          type: "open-parenthesis"
        };
      }
      toString() {
        return "(";
      }
    }
    Token2.OpenParenthesis = OpenParenthesis;
    (function(OpenParenthesis2) {
      function isOpenParenthesis(value) {
        return value instanceof OpenParenthesis2;
      }
      OpenParenthesis2.isOpenParenthesis = isOpenParenthesis;
    })(OpenParenthesis = Token2.OpenParenthesis || (Token2.OpenParenthesis = {}));
    Token2.openParenthesis = OpenParenthesis.of, Token2.isOpenParenthesis = OpenParenthesis.isOpenParenthesis;
    Token2.parseOpenParenthesis = parseToken(Token2.isOpenParenthesis);
    class CloseParenthesis {
      static _instance = new CloseParenthesis();
      static of() {
        return CloseParenthesis._instance;
      }
      constructor() {
      }
      get type() {
        return "close-parenthesis";
      }
      get mirror() {
        return OpenParenthesis.of();
      }
      equals(value) {
        return value instanceof CloseParenthesis;
      }
      toJSON() {
        return {
          type: "close-parenthesis"
        };
      }
      toString() {
        return ")";
      }
    }
    Token2.CloseParenthesis = CloseParenthesis;
    (function(CloseParenthesis2) {
      function isCloseParenthesis(value) {
        return value instanceof CloseParenthesis2;
      }
      CloseParenthesis2.isCloseParenthesis = isCloseParenthesis;
    })(CloseParenthesis = Token2.CloseParenthesis || (Token2.CloseParenthesis = {}));
    Token2.closeParenthesis = CloseParenthesis.of, Token2.isCloseParenthesis = CloseParenthesis.isCloseParenthesis;
    Token2.parseCloseParenthesis = parseToken(Token2.isCloseParenthesis);
    class OpenSquareBracket {
      static _instance = new OpenSquareBracket();
      static of() {
        return OpenSquareBracket._instance;
      }
      constructor() {
      }
      get type() {
        return "open-square-bracket";
      }
      get mirror() {
        return CloseSquareBracket.of();
      }
      equals(value) {
        return value instanceof OpenSquareBracket;
      }
      toJSON() {
        return {
          type: "open-square-bracket"
        };
      }
      toString() {
        return "[";
      }
    }
    Token2.OpenSquareBracket = OpenSquareBracket;
    (function(OpenSquareBracket2) {
      function isOpenSquareBracket(value) {
        return value instanceof OpenSquareBracket2;
      }
      OpenSquareBracket2.isOpenSquareBracket = isOpenSquareBracket;
    })(OpenSquareBracket = Token2.OpenSquareBracket || (Token2.OpenSquareBracket = {}));
    Token2.openSquareBracket = OpenSquareBracket.of, Token2.isOpenSquareBracket = OpenSquareBracket.isOpenSquareBracket;
    Token2.parseOpenSquareBracket = parseToken(Token2.isOpenSquareBracket);
    class CloseSquareBracket {
      static _instance = new CloseSquareBracket();
      static of() {
        return CloseSquareBracket._instance;
      }
      constructor() {
      }
      get type() {
        return "close-square-bracket";
      }
      get mirror() {
        return OpenSquareBracket.of();
      }
      equals(value) {
        return value instanceof CloseSquareBracket;
      }
      toJSON() {
        return {
          type: "close-square-bracket"
        };
      }
      toString() {
        return "]";
      }
    }
    Token2.CloseSquareBracket = CloseSquareBracket;
    (function(CloseSquareBracket2) {
      function isCloseSquareBracket(value) {
        return value instanceof CloseSquareBracket2;
      }
      CloseSquareBracket2.isCloseSquareBracket = isCloseSquareBracket;
    })(CloseSquareBracket = Token2.CloseSquareBracket || (Token2.CloseSquareBracket = {}));
    Token2.closeSquareBracket = CloseSquareBracket.of, Token2.isCloseSquareBracket = CloseSquareBracket.isCloseSquareBracket;
    Token2.parseCloseSquareBracket = parseToken(Token2.isCloseSquareBracket);
    class OpenCurlyBracket {
      static _instance = new OpenCurlyBracket();
      static of() {
        return OpenCurlyBracket._instance;
      }
      constructor() {
      }
      get type() {
        return "open-curly-bracket";
      }
      get mirror() {
        return CloseCurlyBracket.of();
      }
      equals(value) {
        return value instanceof OpenCurlyBracket;
      }
      toJSON() {
        return {
          type: "open-curly-bracket"
        };
      }
      toString() {
        return "{";
      }
    }
    Token2.OpenCurlyBracket = OpenCurlyBracket;
    (function(OpenCurlyBracket2) {
      function isOpenCurlyBracket(value) {
        return value instanceof OpenCurlyBracket2;
      }
      OpenCurlyBracket2.isOpenCurlyBracket = isOpenCurlyBracket;
    })(OpenCurlyBracket = Token2.OpenCurlyBracket || (Token2.OpenCurlyBracket = {}));
    Token2.openCurlyBracket = OpenCurlyBracket.of, Token2.isOpenCurlyBracket = OpenCurlyBracket.isOpenCurlyBracket;
    Token2.parseOpenCurlyBracket = parseToken(Token2.isOpenCurlyBracket);
    class CloseCurlyBracket {
      static _instance = new CloseCurlyBracket();
      static of() {
        return CloseCurlyBracket._instance;
      }
      constructor() {
      }
      get type() {
        return "close-curly-bracket";
      }
      get mirror() {
        return OpenCurlyBracket.of();
      }
      equals(value) {
        return value instanceof CloseCurlyBracket;
      }
      toJSON() {
        return {
          type: "close-curly-bracket"
        };
      }
      toString() {
        return "}";
      }
    }
    Token2.CloseCurlyBracket = CloseCurlyBracket;
    (function(CloseCurlyBracket2) {
      function isCloseCurlyBracket(value) {
        return value instanceof CloseCurlyBracket2;
      }
      CloseCurlyBracket2.isCloseCurlyBracket = isCloseCurlyBracket;
    })(CloseCurlyBracket = Token2.CloseCurlyBracket || (Token2.CloseCurlyBracket = {}));
    Token2.closeCurlyBracket = CloseCurlyBracket.of, Token2.isCloseCurlyBracket = CloseCurlyBracket.isCloseCurlyBracket;
    Token2.parseCloseCurlyBracket = parseToken(Token2.isCloseCurlyBracket);
    class OpenComment {
      static _instance = new OpenComment();
      static of() {
        return OpenComment._instance;
      }
      constructor() {
      }
      get type() {
        return "open-comment";
      }
      equals(value) {
        return value instanceof OpenComment;
      }
      toJSON() {
        return {
          type: "open-comment"
        };
      }
      toString() {
        return "<!--";
      }
    }
    Token2.OpenComment = OpenComment;
    (function(OpenComment2) {
      function isOpenComment(value) {
        return value instanceof OpenComment2;
      }
      OpenComment2.isOpenComment = isOpenComment;
    })(OpenComment = Token2.OpenComment || (Token2.OpenComment = {}));
    Token2.openComment = OpenComment.of, Token2.isOpenComment = OpenComment.isOpenComment;
    Token2.parseOpenComment = parseToken(Token2.isOpenComment);
    class CloseComment {
      static _instance = new CloseComment();
      static of() {
        return CloseComment._instance;
      }
      constructor() {
      }
      get type() {
        return "close-comment";
      }
      equals(value) {
        return value instanceof CloseComment;
      }
      toJSON() {
        return {
          type: "close-comment"
        };
      }
      toString() {
        return "-->";
      }
    }
    Token2.CloseComment = CloseComment;
    (function(CloseComment2) {
      function isCloseComment(value) {
        return value instanceof CloseComment2;
      }
      CloseComment2.isCloseComment = isCloseComment;
    })(CloseComment = Token2.CloseComment || (Token2.CloseComment = {}));
    Token2.closeComment = CloseComment.of, Token2.isCloseComment = CloseComment.isCloseComment;
    Token2.parseCloseComment = parseToken(Token2.isCloseComment);
  })(Token || (Token = {}));

  // node_modules/@siteimprove/alfa-css/dist/syntax/function.js
  var { delimited, flatMap, option, peek, right, left, pair, map: map2, takeUntil, either, end } = Parser;
  var Function = class _Function {
    static of(name, value) {
      return new _Function(name, Array.from(value));
    }
    _name;
    _value;
    constructor(name, value) {
      this._name = name;
      this._value = value;
    }
    get name() {
      return this._name;
    }
    get value() {
      return this._value;
    }
    *[Symbol.iterator]() {
      yield Token.Function.of(this._name);
      yield* this._value;
      yield Token.CloseParenthesis.of();
    }
    equals(value) {
      return value instanceof _Function && value._name === this._name && value._value.length === this._value.length && value._value.every((token, i) => token.equals(this._value[i]));
    }
    toJSON() {
      return {
        name: this._name,
        value: this._value.map((token) => token.toJSON())
      };
    }
    toString() {
      return `${this._name}(${this._value.join("")})`;
    }
  };
  (function(Function4) {
    Function4.consume = (input) => (
      // eta expansion is necessary for `this` binding to resolve correctly
      map2(pair(Token.parseFunction(), map2(left(takeUntil(Component.consume, either(Token.parseCloseParenthesis, end(() => "Dummy error message since this should never fail"))), option(Token.parseCloseParenthesis)), (components) => components.flatMap((component) => [...component]))), ([{ value: name }, value]) => Function4.of(name, value))(input)
    );
    Function4.parse = (query, body) => flatMap(right(peek(Token.parseFunction(query)), Function4.consume), (fn) => (input) => {
      if (body === void 0) {
        return Result.of([input, [fn, void 0]]);
      }
      let parse57;
      try {
        parse57 = body();
        if (Result.isResult(parse57)) {
          throw new Error("It was a parser after all");
        }
      } catch (err) {
        parse57 = body;
      }
      const result = delimited(
        // whitespace just inside the parentheses are OK.
        option(Token.parseWhitespace),
        parse57
      )(Slice.of(fn.value));
      if (result.isErr()) {
        return result;
      }
      const [remainder, value] = result.getUnsafe();
      if (remainder.length > 0) {
        return Err.of(`Unexpected token ${remainder.get(0).getUnsafe()}`);
      }
      return Result.of([input, [fn, value]]);
    });
  })(Function || (Function = {}));

  // node_modules/@siteimprove/alfa-css/dist/syntax/component.js
  var { delimited: delimited2, option: option2, either: either2, map: map3 } = Parser;
  var Component = class _Component {
    static of(value) {
      return new _Component(Array.from(value));
    }
    _value;
    constructor(value) {
      this._value = value;
    }
    get value() {
      return this._value;
    }
    *[Symbol.iterator]() {
      yield* this._value;
    }
    equals(value) {
      return value instanceof _Component && value._value.length === this._value.length && value._value.every((token, i) => token.equals(this._value[i]));
    }
    toJSON() {
      return this._value.map((token) => token.toJSON());
    }
    toString() {
      return this._value.join("");
    }
  };
  (function(Component3) {
    Component3.consume = (input) => (
      // eta expansion is necessary for `this` binding to resolve correctly
      either2(map3(Block.consume, (value) => Component3.of(value)), map3(Function.consume, (value) => Component3.of(value)), (input2) => input2.first().map((token) => Result.of([
        input2.rest(),
        Component3.of([token])
      ])).getOr(Err.of("Unexpected end of file")))(input)
    );
    Component3.parse = delimited2(option2(Token.parseWhitespace), Component3.consume);
  })(Component || (Component = {}));

  // node_modules/@siteimprove/alfa-css/dist/syntax/block.js
  var { either: either3, pair: pair2, left: left2, map: map4, takeUntil: takeUntil2 } = Parser;
  var Block = class _Block {
    static of(token, value) {
      return new _Block(token, Array.from(value));
    }
    _token;
    _value;
    constructor(token, value) {
      this._token = token;
      this._value = value;
    }
    get token() {
      return this._token;
    }
    get value() {
      return this._value;
    }
    *[Symbol.iterator]() {
      yield this._token;
      yield* this._value;
      yield this._token.mirror;
    }
    equals(value) {
      return value instanceof _Block && value._token.equals(this._token) && value._value.length === this._value.length && value._value.every((token, i) => token.equals(this._value[i]));
    }
    toJSON() {
      return {
        token: this._token.toJSON(),
        value: this._value.map((token) => token.toJSON())
      };
    }
    toString() {
      return this._token.toString() + this._value.join("") + this._token.mirror.toString();
    }
  };
  (function(Block4) {
    function consumeDelimited(open, closed) {
      return map4(left2(pair2(
        open,
        // eta expansion is necessary for `this` binding to resolve correctly
        takeUntil2((input) => Component.consume(input), closed)
      ), closed), ([open2, components]) => Block4.of(open2, components.flatMap((component) => [...component])));
    }
    const consumeParentheses = consumeDelimited(Token.parseOpenParenthesis, Token.parseCloseParenthesis);
    const consumeSquareBrackets = consumeDelimited(Token.parseOpenSquareBracket, Token.parseCloseSquareBracket);
    const consumeCurlyBracket = consumeDelimited(Token.parseOpenCurlyBracket, Token.parseCloseCurlyBracket);
    Block4.consume = either3(consumeParentheses, consumeSquareBrackets, consumeCurlyBracket);
  })(Block || (Block = {}));

  // node_modules/@siteimprove/alfa-css/dist/syntax/comma.js
  var { option: option3, delimited: delimited3 } = Parser;
  var Comma;
  (function(Comma2) {
    Comma2.parse = delimited3(option3(Token.parseWhitespace), Token.parseComma);
  })(Comma || (Comma = {}));

  // node_modules/@siteimprove/alfa-css/dist/syntax/declaration.js
  var { not: not12 } = Predicate;
  var { option: option4, delimited: delimited4, left: left3, zeroOrMore, map: map5, pair: pair3, flatMap: flatMap2 } = Parser;
  var Declaration = class _Declaration {
    static of(name, value, important = false) {
      return new _Declaration(name, Array.from(value), important);
    }
    _name;
    _value;
    _important;
    constructor(name, value, important) {
      this._name = name;
      this._value = value;
      this._important = important;
    }
    get name() {
      return this._name;
    }
    get value() {
      return this._value;
    }
    get important() {
      return this._important;
    }
    *[Symbol.iterator]() {
      yield Token.Ident.of(this._name);
      yield Token.Colon.of();
      yield* this._value;
      if (this._important) {
        yield Token.Delim.of(33);
        yield Token.Ident.of("important");
      }
    }
    equals(value) {
      return value instanceof _Declaration && value._name === this._name && value._important === this._important && value._value.length === this._value.length && value._value.every((token, i) => token.equals(this._value[i]));
    }
    toJSON() {
      return {
        name: this._name,
        value: this._value.map((token) => token.toJSON()),
        important: this._important
      };
    }
    toString() {
      return `${this._name}: ${this._value}${this._important ? " !important" : ""}`;
    }
  };
  (function(Declaration3) {
    Declaration3.consume = flatMap2(pair3(left3(Token.parseIdent(), delimited4(option4(Token.parseWhitespace), Token.parseColon)), map5(zeroOrMore(Component.consume), (components) => components.flatMap((component) => [...component]))), ([{ value: name }, value]) => (input) => {
      let important = false;
      if (value.length >= 2) {
        const fst = value[value.length - 2];
        const snd = value[value.length - 1];
        if (fst.type === "delim" && fst.value === 33 && snd.type === "ident" && snd.value.toLowerCase() === "important") {
          value.splice(value.length - 2, 2);
          important = true;
        }
      }
      if (value.length >= 1) {
        const lst = value[value.length - 1];
        if (lst.type === "whitespace") {
          value.pop();
        }
      }
      return Result.of([
        input,
        Declaration3.of(name, value, important)
      ]);
    });
    Declaration3.parse = (input) => {
      while (input.get(0).some(Token.isWhitespace)) {
        input = input.slice(1);
      }
      const next = input.get(0);
      if (next.none(Token.isIdent)) {
        return Err.of("Expected an ident");
      }
      return Declaration3.consume(input);
    };
    Declaration3.consumeList = (input) => {
      const declarations = [];
      while (input.length > 0) {
        for (const next of input.get(0)) {
          input = input.slice(1);
          if (Token.isWhitespace(next) || Token.isSemicolon(next)) {
            continue;
          }
          if (Token.isIdent(next)) {
            const value = [next];
            while (input.get(0).some(not12(Token.isSemicolon))) {
              const [remainder, component] = Component.consume(input).getUnsafe();
              input = remainder;
              value.push(...component);
            }
            const result = Declaration3.consume(Slice.of(value));
            if (result.isOk()) {
              declarations.push(result.get()[1]);
            }
          } else {
            while (input.get(0).some(not12(Token.isSemicolon))) {
              const [remainder] = Component.consume(input).getUnsafe();
              input = remainder;
            }
          }
        }
      }
      return Result.of([input, declarations]);
    };
    Declaration3.parseList = Declaration3.consumeList;
  })(Declaration || (Declaration = {}));

  // node_modules/@siteimprove/alfa-css/dist/syntax/lexer.js
  var { fromCharCode: fromCharCode2 } = String;
  var { zeroOrMore: zeroOrMore2 } = Parser;
  var Lexer;
  (function(Lexer2) {
    function lex(input) {
      const points = new Array(input.length);
      for (let i = 0, n = input.length; i < n; i++) {
        points[i] = input.charCodeAt(i);
      }
      const tokens = [];
      for (let i = 0, n = points.length; i < n; ) {
        let token;
        [[, i], token] = consumeToken([points, i]);
        if (token === null) {
          break;
        }
        tokens.push(token);
      }
      return Slice.of(tokens);
    }
    Lexer2.lex = lex;
  })(Lexer || (Lexer = {}));
  var isDigit = (code) => code >= 48 && code <= 57;
  var digit = ([input, i]) => {
    const code = input[i];
    return isDigit(code) ? Result.of([[input, i + 1], code]) : Err.of("Expected a digit");
  };
  var isHexDigit = (code) => isDigit(code) || code >= 65 && code <= 70 || code >= 97 && code <= 102;
  var hexDigit = ([input, i]) => {
    const code = input[i];
    return isHexDigit(code) ? Result.of([[input, i + 1], code]) : Err.of("Expected a hex digit");
  };
  var isUppercaseLetter = (code) => code >= 65 && code <= 90;
  var isLowercaseLetter = (code) => code >= 97 && code <= 122;
  var isLetter = (code) => isUppercaseLetter(code) || isLowercaseLetter(code);
  var isNonAscii = (code) => code >= 128;
  var isNewline = (code) => code === 10;
  var isWhitespace = (code) => isNewline(code) || code === 9 || code === 32;
  var isNonPrintable = (code) => code >= 0 && code <= 8 || code === 11 || code >= 14 && code <= 31 || code === 127;
  var isNameStart = (code) => isLetter(code) || isNonAscii(code) || code === 95;
  var isName = (code) => isNameStart(code) || isDigit(code) || code === 45;
  var isSurrogate = (code) => code >= 55296 && code <= 57343;
  var startsValidEscape = ([input, i]) => input[i] === 92 && !isNewline(input[i + 1]);
  var startsNumber = ([input, i]) => {
    switch (input[i]) {
      case 43:
      case 45:
        if (input[i + 1] === 46) {
          return isDigit(input[i + 3]);
        } else {
          return isDigit(input[i + 1]);
        }
      case 46:
        return isDigit(input[i + 1]);
      default:
        return isDigit(input[i]);
    }
  };
  var startsIdentifier = ([input, i]) => {
    switch (input[i]) {
      case 45:
        return isNameStart(input[i + 1]) || input[i + 1] === 45 || startsValidEscape([input, i + 1]);
      case 92:
        return startsValidEscape([input, i]);
      default:
        return isNameStart(input[i]);
    }
  };
  var consumeName = ([input, i]) => {
    let name = "";
    let code;
    for (const n = input.length; i < n; ) {
      code = input[i];
      if (isName(code)) {
        i++;
        name += fromCharCode2(code);
      } else if (startsValidEscape([input, i])) {
        [[input, i], code] = consumeEscapedCodePoint([input, i + 1]);
        name += fromCharCode2(code);
      } else {
        break;
      }
    }
    return [[input, i], name];
  };
  var consumeEscapedCodePoint = ([input, i]) => {
    const byte = input[i];
    if (isNaN(byte)) {
      return [[input, i], 65533];
    }
    i++;
    if (isHexDigit(byte)) {
      const bytes = [byte];
      for (const n = i + 5; i < n; i++) {
        const result = hexDigit([input, i]);
        if (!result.isOk()) {
          break;
        }
        const [, byte2] = result.get();
        bytes.push(byte2);
      }
      let code = 0;
      for (let i2 = 0, n = bytes.length; i2 < n; i2++) {
        let byte2 = bytes[i2];
        if (isDigit(byte2)) {
          byte2 = byte2 - 48;
        } else if (isLowercaseLetter(byte2)) {
          byte2 = byte2 - 97 + 10;
        } else if (isUppercaseLetter(byte2)) {
          byte2 = byte2 - 65 + 10;
        }
        code = 16 * code + byte2;
      }
      if (isWhitespace(input[i])) {
        i++;
      }
      if (code === 0 || isSurrogate(code) || code > 1114111) {
        return [[input, i], 65533];
      }
      return [[input, i], code];
    }
    return [[input, i], byte];
  };
  var consumeNumber = ([input, i]) => {
    const number = [];
    let code = input[i];
    let isSigned = false;
    let isInteger = true;
    if (code === 43 || code === 45) {
      number.push(code);
      code = input[++i];
      isSigned = true;
    }
    while (isDigit(code)) {
      number.push(code);
      code = input[++i];
    }
    if (code === 46 && isDigit(input[i + 1])) {
      number.push(46, input[i + 1]);
      code = input[i += 2];
      isInteger = false;
      while (isDigit(code)) {
        number.push(code);
        code = input[++i];
      }
    }
    if (code === 69 || code === 101) {
      let offset = 1;
      if (input[i + 1] === 43 || input[i + 1] === 45) {
        offset = 2;
      }
      if (isDigit(input[i + offset])) {
        number.push(...input.slice(i, i + offset + 1));
        code = input[i += offset + 1];
        isInteger = false;
        while (isDigit(code)) {
          number.push(code);
          code = input[++i];
        }
      }
    }
    return [[input, i], Token.number(convert(number), isInteger, isSigned)];
  };
  var consumeNumeric = ([input, i]) => {
    let number;
    [[input, i], number] = consumeNumber([input, i]);
    if (startsIdentifier([input, i])) {
      let name;
      [[input, i], name] = consumeName([input, i]);
      return [
        [input, i],
        Token.dimension(number.value, name, number.isInteger, number.isSigned)
      ];
    }
    if (input[i] === 37) {
      return [
        [input, i + 1],
        Token.percentage(number.value / 100, number.isInteger)
      ];
    }
    return [[input, i], number];
  };
  var consumeIdentifierLike = ([input, i]) => {
    let string;
    [[input, i], string] = consumeName([input, i]);
    const code = input[i];
    if (string.toLowerCase() === "url" && code === 40) {
      i++;
      while (isWhitespace(input[i]) && isWhitespace(input[i + 1])) {
        i++;
      }
      if (input[i] === 34 || input[i] === 39 || isWhitespace(input[i]) && (input[i + 1] === 34 || input[i + 1] === 39)) {
        return [[input, i], Token.func(string)];
      }
      return consumeURL([input, i]);
    }
    if (code === 40) {
      return [[input, i + 1], Token.func(string)];
    }
    return [[input, i], Token.ident(string)];
  };
  var consumeString = ([input, i]) => {
    const end10 = input[i++];
    let string = "";
    let code;
    while (i < input.length) {
      code = input[i++];
      if (isNewline(code) || code === end10) {
        break;
      }
      string += fromCharCode2(code);
    }
    return [[input, i], Token.string(string)];
  };
  var consumeURL = ([input, i]) => {
    while (isWhitespace(input[i])) {
      i++;
    }
    let value = "";
    let code;
    while (i < input.length) {
      code = input[i];
      if (code === 41) {
        i++;
        break;
      }
      if (isWhitespace(code)) {
        while (isWhitespace(input[i])) {
          i++;
        }
        if (input[i] === 41) {
          i++;
          break;
        } else {
          return consumeBadURL([input, i]);
        }
      }
      if (code === 34 || code === 39 || code === 40 || isNonPrintable(code)) {
        return consumeBadURL([input, i + 1]);
      }
      if (code === 92) {
        if (startsValidEscape([input, i])) {
          [[input, i], code] = consumeEscapedCodePoint([input, i]);
          value += fromCharCode2(code);
          continue;
        } else {
          return consumeBadURL([input, i]);
        }
      }
      i++;
      value += fromCharCode2(code);
    }
    return [[input, i], Token.url(value)];
  };
  var consumeBadURL = ([input, i]) => {
    let code;
    while (i < input.length) {
      if (startsValidEscape([input, i])) {
        [[input, i]] = consumeEscapedCodePoint([input, i]);
      } else {
        code = input[i++];
        if (code === 41) {
          break;
        }
      }
    }
    return [[input, i], Token.badURL()];
  };
  var consumeToken = ([input, i]) => {
    while (i < input.length) {
      if (input[i] === 47 && input[i + 1] === 42) {
        i += 2;
        while (i < input.length) {
          if (input[i] === 42 && input[i + 1] === 47) {
            i += 2;
            break;
          }
          i++;
        }
      } else {
        break;
      }
    }
    if (i >= input.length) {
      return [[input, i], null];
    }
    const code = input[i];
    if (isWhitespace(code)) {
      i++;
      while (isWhitespace(input[i])) {
        i++;
      }
      return [[input, i], Token.whitespace()];
    }
    if (isNameStart(code)) {
      return consumeIdentifierLike([input, i]);
    }
    if (isDigit(code)) {
      return consumeNumeric([input, i]);
    }
    switch (code) {
      case 34:
        return consumeString([input, i]);
      case 35:
        i++;
        if (isName(input[i]) || startsValidEscape([input, i])) {
          const isIdentifier = startsIdentifier([input, i]);
          let name;
          [[input, i], name] = consumeName([input, i]);
          return [[input, i], Token.hash(name, isIdentifier)];
        }
        return [[input, i], Token.delim(code)];
      case 39:
        return consumeString([input, i]);
      case 40:
        return [[input, i + 1], Token.openParenthesis()];
      case 41:
        return [[input, i + 1], Token.closeParenthesis()];
      case 43:
        if (startsNumber([input, i])) {
          return consumeNumeric([input, i]);
        }
        return [[input, i + 1], Token.delim(code)];
      case 44:
        return [[input, i + 1], Token.comma()];
      case 45:
        if (startsNumber([input, i])) {
          return consumeNumeric([input, i]);
        }
        if (input[i + 1] === 45 && input[i + 2] === 62) {
          return [[input, i + 3], Token.closeComment()];
        }
        if (startsIdentifier([input, i])) {
          return consumeIdentifierLike([input, i]);
        }
        return [[input, i + 1], Token.delim(code)];
      case 46:
        if (startsNumber([input, i])) {
          return consumeNumeric([input, i]);
        }
        return [[input, i + 1], Token.delim(code)];
      case 58:
        return [[input, i + 1], Token.colon()];
      case 59:
        return [[input, i + 1], Token.semicolon()];
      case 60:
        if (input[i + 1] === 33 && input[i + 2] === 45 && input[i + 3] === 45) {
          return [[input, i + 4], Token.openComment()];
        }
        return [[input, i + 1], Token.delim(code)];
      case 64:
        i++;
        if (startsIdentifier([input, i])) {
          let name;
          [[input, i], name] = consumeName([input, i]);
          return [[input, i], Token.atKeyword(name)];
        }
        return [[input, i], Token.delim(code)];
      case 91:
        return [[input, i + 1], Token.openSquareBracket()];
      case 92:
        if (startsValidEscape([input, i])) {
          return consumeIdentifierLike([input, i]);
        }
        return [[input, i + 1], Token.delim(code)];
      case 93:
        return [[input, i + 1], Token.closeSquareBracket()];
      case 123:
        return [[input, i + 1], Token.openCurlyBracket()];
      case 125:
        return [[input, i + 1], Token.closeCurlyBracket()];
    }
    return [[input, i + 1], Token.delim(code)];
  };
  function convert(input) {
    let i = 0;
    let s = input[i] === 45 ? -1 : input[i] === 43 ? 1 : null;
    if (s !== null) {
      i++;
    } else {
      s = 1;
    }
    let n;
    let v = 0;
    for ([[input, i], n] of zeroOrMore2(digit)([input, i])) {
      v = n.reduce((v2, c) => 10 * v2 + (c - 48), v);
    }
    if (input[i] === 46) {
      i++;
    }
    let f = 0;
    let d = 0;
    for ([[input, i], n] of zeroOrMore2(digit)([input, i])) {
      [f, d] = n.reduce(([f2, d2], c) => [10 * f2 + (c - 48), d2 + 1], [f, d]);
    }
    if (input[i] === 69 || input[i] === 101) {
      i++;
    }
    let t = input[i] === 45 ? -1 : input[i] === 43 ? 1 : null;
    if (t !== null) {
      i++;
    } else {
      t = 1;
    }
    let e = 0;
    for ([[input, i], n] of zeroOrMore2(digit)([input, i])) {
      e = n.reduce((e2, c) => 10 * e2 + (c - 48), e);
    }
    return s * (v + f / 10 ** d) / 10 ** (-t * e);
  }

  // node_modules/@siteimprove/alfa-css/dist/syntax/nth.js
  var { map: map6, right: right2, pair: pair4, delimited: delimited5, option: option5, either: either4 } = Parser;
  var Nth = class _Nth {
    static of(step, offset = 0) {
      return new _Nth(step | 0, offset | 0);
    }
    _step;
    _offset;
    constructor(step, offset) {
      this._step = step;
      this._offset = offset;
    }
    get step() {
      return this._step;
    }
    get offset() {
      return this._offset;
    }
    /**
     * Check if the given index matches the indices produced by this nth.
     *
     * @remarks
     * This is checked by solving the equation `an + b = i` for `n`, giving us
     * `n = (i - b) / a`. The index `i` is matched by this nth if the resulting
     * `n` is a non-negative integer.
     */
    matches(index) {
      if (this._step === 0) {
        return this._offset === (index | 0);
      }
      const n = ((index | 0) - this._offset) / this._step;
      return n >= 0 && n === (n | 0);
    }
    for(n) {
      return this._step * (n | 0) + this._offset;
    }
    *indices() {
      for (let n = 0; ; n++) {
        yield this.for(n);
      }
    }
    *[Symbol.iterator]() {
      if (this._step !== 0) {
        yield Token.Dimension.of(this._step, "n", true, this._step < 0);
      }
      if (this._offset !== 0) {
        yield Token.Number.of(this._offset, true, this._offset < 0 || this._step !== 0);
      }
    }
    equals(value) {
      return value instanceof _Nth && value._step === this._step && value._offset === this._offset;
    }
    toJSON() {
      return {
        step: this._step,
        offset: this._offset
      };
    }
    toString() {
      return this._step === 0 ? `${this._offset}` : `${this._step}n+${this._offset};`;
    }
  };
  (function(Nth2) {
    Nth2.parse = either4(
      // odd | even
      map6(Token.parseIdent((ident) => ident.value === "odd" || ident.value === "even"), (ident) => Nth2.of(2, ident.value === "even" ? 0 : 1)),
      // <integer>
      map6(Token.parseNumber((number) => number.isInteger), (number) => Nth2.of(0, number.value)),
      // <ndashdigit-dimension>
      map6(Token.parseDimension((dimension) => dimension.isInteger && /^n-\d+$/.test(dimension.unit)), (dimension) => Nth2.of(dimension.value, +dimension.unit.slice(1))),
      // "+"? <ndashdigit-ident>
      right2(option5(Token.parseDelim("+")), map6(Token.parseIdent((ident) => /^n-\d+$/.test(ident.value)), (ident) => Nth2.of(1, +ident.value.slice(1)))),
      // <dashndashdigit-ident>
      map6(Token.parseIdent((ident) => /^-n-\d+$/.test(ident.value)), (ident) => Nth2.of(-1, +ident.value.slice(2))),
      // [<n-dimension> | "+"? n | -n] [["+" | "-"]? <signless-integer> | <signed-integer>]?
      map6(pair4(
        // <n-dimension> | "+"? n | -n
        either4(
          // <n-dimension>
          map6(Token.parseDimension((dimension) => dimension.isInteger && dimension.unit === "n"), (dimension) => dimension.value),
          // "+"? n
          map6(right2(option5(Token.parseDelim("+")), Token.parseIdent("n")), () => 1),
          // -n
          map6(Token.parseIdent("-n"), () => -1)
        ),
        // [["+" | "-"]? <signless-integer> | <signed-integer>]?
        option5(either4(map6(pair4(
          // ["+" | "-"]?
          delimited5(option5(Token.parseWhitespace), option5(either4(map6(Token.parseDelim("+"), () => 1), map6(Token.parseDelim("-"), () => -1)))),
          // <signless-integer>
          Token.parseNumber((number) => number.isInteger && !number.isSigned)
        ), ([sign, number]) => sign.getOr(1) * number.value), delimited5(option5(Token.parseWhitespace), map6(Token.parseNumber((number) => number.isInteger), (number) => number.value))))
      ), ([step, offset]) => Nth2.of(step, offset.getOr(0))),
      // [<ndash-dimension> | "+"? n- | -n-] <signless-integer>
      map6(pair4(
        // <ndash-dimension> | "+"? n- | -n-
        either4(
          // <ndash-dimension>
          map6(Token.parseDimension((dimension) => dimension.isInteger && dimension.unit === "n-"), (dimension) => dimension.value),
          // "+"? n-
          map6(right2(option5(Token.parseDelim("+")), Token.parseIdent("n-")), () => 1),
          // -n-
          map6(Token.parseIdent("-n-"), () => -1)
        ),
        // <signless-integer>
        delimited5(option5(Token.parseWhitespace), map6(Token.parseNumber((number) => number.isInteger && !number.isSigned), (number) => number.value))
      ), ([step, offset]) => Nth2.of(step, -1 * offset))
    );
  })(Nth || (Nth = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/value.js
  var Value = class {
    _type;
    _hasCalculation;
    constructor(type, hasCalculation) {
      this._type = type;
      this._hasCalculation = hasCalculation;
    }
    get type() {
      return this._type;
    }
    hasCalculation() {
      return this._hasCalculation;
    }
    partiallyResolve(resolver) {
      return this.resolve(resolver);
    }
    toJSON() {
      return { type: this._type };
    }
  };
  (function(Value6) {
    function isValue(value, type) {
      return value instanceof Value6 && (type === void 0 || value.type === type);
    }
    Value6.isValue = isValue;
    function hasCalculation(...values) {
      return values.some((value) => value.hasCalculation());
    }
    Value6.hasCalculation = hasCalculation;
  })(Value || (Value = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/textual/ident.js
  var Ident = class _Ident extends Value {
    _value;
    constructor(type, value) {
      super(type, false);
      this._value = value;
    }
    get value() {
      return this._value;
    }
    is(...values) {
      return values.includes(this._value);
    }
    resolve() {
      return this;
    }
    equals(value) {
      return value instanceof _Ident && value._value === this._value;
    }
    hash(hash2) {
      hash2.writeString(this._value);
    }
    toJSON() {
      return {
        ...super.toJSON(),
        value: this._value
      };
    }
    toString() {
      return this._value;
    }
  };
  (function(Ident2) {
    function isIdent(value) {
      return value instanceof Ident2;
    }
    Ident2.isIdent = isIdent;
  })(Ident || (Ident = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/textual/keyword.js
  var { map: map7 } = Parser;
  var { equals: equals2 } = Predicate;
  var Keyword = class _Keyword extends Ident {
    static of(value) {
      return new _Keyword(value);
    }
    constructor(value) {
      super("keyword", value);
    }
    equals(value) {
      return value instanceof _Keyword && super.equals(value);
    }
  };
  (function(Keyword2) {
    function isKeyword2(value) {
      return value instanceof Keyword2;
    }
    Keyword2.isKeyword = isKeyword2;
    function parse57(...keywords) {
      return map7(Token.parseIdent((ident) => keywords.some(equals2(String2.toLowerCase(ident.value)))), (ident) => (
        // Make sure each possible keyword is separated into its own type. For
        // example, we want `parse("foo", "bar")` to result in the type
        // `Keyword<"foo"> | Keyword<"bar">`, not `Keyword<"foo" | "bar">`. Why?
        // Because the former is assignable to the latter, but the latter isn't
        // assignable to the former.
        Keyword2.of(String2.toLowerCase(ident.value))
      ));
    }
    Keyword2.parse = parse57;
  })(Keyword || (Keyword = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/box.js
  var { either: either5 } = Parser;
  var Box;
  (function(Box2) {
    Box2.parse = Keyword.parse("border-box", "padding-box", "content-box");
    Box2.parseShape = either5(Box2.parse, Keyword.parse("margin-box"));
    Box2.parseGeometry = either5(Box2.parseShape, Keyword.parse("fill-box", "stroke-box", "view-box"));
  })(Box || (Box = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/contain.js
  var { either: either6 } = Parser;
  var ContainFlags = class _ContainFlags extends Value {
    static of(size, inlineSize, layout, style, paint) {
      return new _ContainFlags(size, inlineSize, layout, style, paint);
    }
    _size;
    _inlineSize;
    _layout;
    _style;
    _paint;
    constructor(size, inlineSize, layout, style, paint) {
      super("contain-flags", false);
      this._size = size;
      this._inlineSize = inlineSize;
      this._layout = layout;
      this._style = style;
      this._paint = paint;
    }
    get size() {
      return this._size;
    }
    get inlineSize() {
      return this._inlineSize;
    }
    get layout() {
      return this._layout;
    }
    get style() {
      return this._style;
    }
    get paint() {
      return this._paint;
    }
    resolve() {
      return this;
    }
    equals(value) {
      return value instanceof _ContainFlags && value._size === this._size && value._inlineSize === this._inlineSize && value._layout === this._layout && value._style === this._style && value._paint === this._paint;
    }
    hash(hash2) {
      hash2.writeBoolean(this._size).writeBoolean(this._inlineSize).writeBoolean(this._layout).writeBoolean(this._style).writeBoolean(this._paint);
    }
    toJSON() {
      return {
        ...super.toJSON(),
        size: this._size,
        inlineSize: this._inlineSize,
        layout: this._layout,
        style: this._style,
        paint: this._paint
      };
    }
    toString() {
      let keywords = [];
      if (this._size) {
        keywords.push("size");
      }
      if (this._inlineSize) {
        keywords.push("inline-size");
      }
      if (this._layout) {
        keywords.push("layout");
      }
      if (this._style) {
        keywords.push("style");
      }
      if (this._paint) {
        keywords.push("paint");
      }
      return keywords.join(" ");
    }
  };
  (function(ContainFlags2) {
    function isContainFlags(value) {
      return value instanceof ContainFlags2;
    }
    ContainFlags2.isContainFlags = isContainFlags;
    ContainFlags2.parse = (input) => {
      let size;
      let layout;
      let style;
      let paint;
      while (true) {
        for (const [remainder] of Token.parseWhitespace(input)) {
          input = remainder;
        }
        if (size === void 0) {
          const result = Keyword.parse("size", "inline-size")(input);
          if (result.isOk()) {
            [input, size] = result.get();
            continue;
          }
        }
        if (layout === void 0) {
          const result = Keyword.parse("layout")(input);
          if (result.isOk()) {
            [input, layout] = result.get();
            continue;
          }
        }
        if (style === void 0) {
          const result = Keyword.parse("style")(input);
          if (result.isOk()) {
            [input, style] = result.get();
            continue;
          }
        }
        if (paint === void 0) {
          const result = Keyword.parse("paint")(input);
          if (result.isOk()) {
            [input, paint] = result.get();
            continue;
          }
        }
        break;
      }
      if (size === void 0 && layout === void 0 && style === void 0 && paint === void 0) {
        return Err.of("Expected at least one keyword");
      }
      return Result.of([
        input,
        ContainFlags2.of(size?.value === "size", size?.value === "inline-size", layout !== void 0, style !== void 0, paint !== void 0)
      ]);
    };
  })(ContainFlags || (ContainFlags = {}));
  var Contain;
  (function(Contain2) {
    Contain2.parse = either6(Keyword.parse("none", "strict", "content"), ContainFlags.parse);
  })(Contain || (Contain = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/collection/list.js
  var { delimited: delimited6, option: option6, map: map8, separatedList } = Parser;
  var List2 = class _List extends Value {
    static of(values, separator = " ") {
      return new _List(Array.from(values), separator);
    }
    _values;
    _separator;
    constructor(values, separator) {
      super("list", Value.hasCalculation(...values));
      this._values = values;
      this._separator = separator;
    }
    get values() {
      return this._values;
    }
    resolve(resolver) {
      return this.map((value) => value.resolve(resolver));
    }
    partiallyResolve(resolver) {
      return this.map((value) => value.partiallyResolve(resolver));
    }
    map(mapper) {
      return new _List(this._values.map(mapper), this._separator);
    }
    equals(value) {
      return value instanceof _List && value._values.length === this._values.length && value._values.every((value2, i) => value2.equals(this._values[i]));
    }
    hash(hash2) {
      for (const value of this._values) {
        value.hash(hash2);
      }
      hash2.writeUint32(this._values.length).writeString(this._separator);
    }
    *[Symbol.iterator]() {
      yield* this._values;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        values: this._values.map((value) => value.toJSON()),
        separator: this._separator
      };
    }
    toString() {
      return this._values.join(this._separator);
    }
  };
  (function(List5) {
    function isList(value) {
      return value instanceof List5;
    }
    List5.isList = isList;
    function parse57(parseValue, separator, parseSeparator, lower, upper) {
      return map8(separatedList(parseValue, parseSeparator, lower, upper), (values) => List5.of(values, separator));
    }
    const parseComma3 = delimited6(option6(Token.parseWhitespace), Token.parseComma);
    const parseSpace = option6(Token.parseWhitespace);
    List5.parseCommaSeparated = (parseValue, lower = 1, upper = Infinity) => parse57(parseValue, ", ", parseComma3, lower, upper);
    List5.parseSpaceSeparated = (parseValue, lower = 1, upper = Infinity) => parse57(parseValue, " ", parseSpace, lower, upper);
  })(List2 || (List2 = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/collection/tuple.js
  var Tuple2 = class _Tuple extends Value {
    static of(...values) {
      return new _Tuple(values);
    }
    _values;
    constructor(values) {
      super("tuple", Value.hasCalculation(...values));
      this._values = values;
    }
    get values() {
      return this._values;
    }
    resolve(resolver) {
      return new _Tuple(this._values.map((value) => value.resolve(resolver)));
    }
    partiallyResolve(resolver) {
      return new _Tuple(this._values.map((value) => value.resolve(resolver)));
    }
    equals(value) {
      return _Tuple.isTuple(value) && value._values.length === this._values.length && value._values.every((value2, i) => value2.equals(this._values[i]));
    }
    hash(hash2) {
      for (const value of this._values) {
        value.hash(hash2);
      }
      hash2.writeUint32(this._values.length);
    }
    toJSON() {
      return {
        ...super.toJSON(),
        values: this._values.map((value) => value.toJSON())
      };
    }
    toString() {
      return `${this._values.join(" ")}`.trim();
    }
  };
  (function(Tuple3) {
    function isTuple(value) {
      return value instanceof Tuple3;
    }
    Tuple3.isTuple = isTuple;
  })(Tuple2 || (Tuple2 = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/color/current.js
  var Current;
  (function(Current2) {
    Current2.parse = Keyword.parse("currentcolor");
  })(Current || (Current = {}));

  // node_modules/@siteimprove/alfa-css/dist/calculation/math-expression/expression.js
  var Expression = class {
    _type;
    _kind;
    constructor(type, kind) {
      this._type = type;
      this._kind = kind;
    }
    get type() {
      return this._type;
    }
    get kind() {
      return this._kind;
    }
    toAngle() {
      return Err.of(`${this} is not a reduced angle`);
    }
    toLength() {
      return Err.of(`${this} is not a reduced length`);
    }
    toNumber() {
      return Err.of(`${this} is not a reduced number`);
    }
    toPercentage() {
      return Err.of(`${this} is not a reduced percentage`);
    }
    toJSON() {
      return {
        type: this.type
      };
    }
  };

  // node_modules/@siteimprove/alfa-css/dist/unit/converter.js
  var { PI } = Math;
  function rates(fn) {
    return fn();
  }
  function converter(rates2) {
    return (value, from, to) => value * (rates2[from] / rates2[to]);
  }
  var Converter;
  (function(Converter2) {
    Converter2.length = converter(rates(() => {
      const px = 1;
      const inch = 96;
      const cm = inch / 2.54;
      const mm = cm / 10;
      const Q = cm / 40;
      const pc = inch / 6;
      const pt = inch / 72;
      return {
        cm,
        mm,
        Q,
        in: inch,
        pc,
        pt,
        px
      };
    }));
    Converter2.angle = converter({
      deg: 1,
      grad: 360 / 400,
      rad: 360 / (2 * PI),
      turn: 360
    });
    Converter2.time = converter({
      s: 1,
      ms: 1e-3
    });
    Converter2.frequency = converter({
      hz: 1,
      kHz: 1e3
    });
  })(Converter || (Converter = {}));

  // node_modules/@siteimprove/alfa-css/dist/unit/unit.js
  var Unit;
  (function(Unit2) {
    let Length3;
    (function(Length4) {
      function isRelative(unit) {
        return isFontRelative(unit) || isViewportRelative(unit);
      }
      Length4.isRelative = isRelative;
      function isFontRelative(unit) {
        switch (unit) {
          case "em":
          case "ex":
          case "ch":
          case "rem":
            return true;
        }
        return false;
      }
      Length4.isFontRelative = isFontRelative;
      function isViewportRelative(unit) {
        switch (unit) {
          case "vw":
          case "vh":
          case "vmin":
          case "vmax":
            return true;
        }
        return false;
      }
      Length4.isViewportRelative = isViewportRelative;
      Length4.Canonical = "px";
      function isCanonical(unit) {
        return unit === Length4.Canonical;
      }
      Length4.isCanonical = isCanonical;
      function isAbsolute(unit) {
        switch (unit) {
          case "cm":
          case "mm":
          case "Q":
          case "in":
          case "pc":
          case "pt":
          case "px":
            return true;
        }
        return false;
      }
      Length4.isAbsolute = isAbsolute;
    })(Length3 = Unit2.Length || (Unit2.Length = {}));
    Unit2.isRelativeLength = Length3.isRelative, Unit2.isFontRelativeLength = Length3.isFontRelative, Unit2.isViewportRelativeLength = Length3.isViewportRelative, Unit2.isAbsoluteLength = Length3.isAbsolute;
    function isLength4(unit) {
      return Unit2.isRelativeLength(unit) || Unit2.isAbsoluteLength(unit);
    }
    Unit2.isLength = isLength4;
    let Angle3;
    (function(Angle4) {
      Angle4.Canonical = "deg";
      function isCanonical(unit) {
        return unit === Angle4.Canonical;
      }
      Angle4.isCanonical = isCanonical;
    })(Angle3 = Unit2.Angle || (Unit2.Angle = {}));
    function isAngle4(unit) {
      switch (unit) {
        case "deg":
        case "grad":
        case "rad":
        case "turn":
          return true;
      }
      return false;
    }
    Unit2.isAngle = isAngle4;
    let Time;
    (function(Time2) {
      Time2.Canonical = "s";
      function isCanonical(unit) {
        return unit === Time2.Canonical;
      }
      Time2.isCanonical = isCanonical;
    })(Time = Unit2.Time || (Unit2.Time = {}));
    function isTime(unit) {
      switch (unit) {
        case "s":
        case "ms":
          return true;
      }
      return false;
    }
    Unit2.isTime = isTime;
    let Frequency;
    (function(Frequency2) {
      Frequency2.Canonical = "hz";
      function isCanonical(unit) {
        return unit === Frequency2.Canonical;
      }
      Frequency2.isCanonical = isCanonical;
    })(Frequency = Unit2.Frequency || (Unit2.Frequency = {}));
    function isFrequency(unit) {
      switch (unit) {
        case "hz":
        case "kHz":
          return true;
      }
      return false;
    }
    Unit2.isFrequency = isFrequency;
    let Resolution;
    (function(Resolution2) {
      Resolution2.Canonical = "dppx";
      function isCanonical(unit) {
        return unit === Resolution2.Canonical;
      }
      Resolution2.isCanonical = isCanonical;
    })(Resolution = Unit2.Resolution || (Unit2.Resolution = {}));
    function isResolution(unit) {
      switch (unit) {
        case "dpi":
        case "dpcm":
        case "dppx":
          return true;
      }
      return false;
    }
    Unit2.isResolution = isResolution;
  })(Unit || (Unit = {}));

  // node_modules/@siteimprove/alfa-math/dist/real.js
  var { abs, min, max } = Math;
  var Real;
  (function(Real2) {
    function isReal(value) {
      return typeof value === "number" && Number.isFinite(value);
    }
    Real2.isReal = isReal;
    function add(p, q) {
      return p + q;
    }
    Real2.add = add;
    function subtract(p, q) {
      return p - q;
    }
    Real2.subtract = subtract;
    function multiply2(p, q) {
      return p * q;
    }
    Real2.multiply = multiply2;
    function divide(p, d) {
      return p / d;
    }
    Real2.divide = divide;
    function modulo(p, d) {
      return (p % d + d) % d;
    }
    Real2.modulo = modulo;
    function clamp3(p, l, u) {
      return max(l, min(p, u));
    }
    Real2.clamp = clamp3;
    function round2(p, n = 0) {
      return n === 0 ? Math.round(p) : Math.round(p * 10 ** n) / 10 ** n;
    }
    Real2.round = round2;
    function equals34(a, b, e = Number.EPSILON) {
      if (a === b) {
        return true;
      }
      const diff = abs(a - b);
      if (a === 0 || b === 0) {
        return diff < e;
      }
      return diff / min(abs(b) + abs(a), Number.MAX_VALUE) < e;
    }
    Real2.equals = equals34;
  })(Real || (Real = {}));

  // node_modules/@siteimprove/alfa-math/dist/matrix.js
  var Matrix;
  (function(Matrix3) {
    function isMatrix(value) {
      return Array.isArray(value) && value.every((r) => Array.isArray(r) && r.every((v) => typeof v === "number"));
    }
    Matrix3.isMatrix = isMatrix;
    function isSquare(m) {
      return rows(m) === columns(m);
    }
    Matrix3.isSquare = isSquare;
    function clone(m) {
      return m.map((r) => r.slice(0));
    }
    Matrix3.clone = clone;
    function equals34(m, n, e) {
      return m.length === n.length && m.every((r, i) => r.length === n[i].length && r.every((v, j) => Real.equals(v, n[i][j], e)));
    }
    Matrix3.equals = equals34;
    function identity(n) {
      return new Array(n).fill([]).map((_, i) => {
        const r = new Array(n).fill(0);
        r[i] = 1;
        return r;
      });
    }
    Matrix3.identity = identity;
    function size(m) {
      return [rows(m), columns(m)];
    }
    Matrix3.size = size;
    function rows(m) {
      return m.length;
    }
    Matrix3.rows = rows;
    function columns(m) {
      return m.length === 0 ? 0 : m[0].length;
    }
    Matrix3.columns = columns;
    function row(m, i) {
      return m[i];
    }
    Matrix3.row = row;
    function column(m, i) {
      return m.map((r) => r[i]);
    }
    Matrix3.column = column;
    function add(m, n) {
      return m.map((r, i) => r.map((v, j) => v + n?.[i]?.[j]));
    }
    Matrix3.add = add;
    function subtract(m, n) {
      return m.map((r, i) => r.map((v, j) => v - n?.[i]?.[j]));
    }
    Matrix3.subtract = subtract;
    function multiply2(m, n) {
      return typeof n === "number" ? m.map((r) => r.map((v) => v * n)) : m.map((r, i) => n[0].map((_, j) => r.reduce((s, _2, k) => s + m[i][k] * n?.[k]?.[j], 0)));
    }
    Matrix3.multiply = multiply2;
    function transpose2(m) {
      return m.length === 0 ? m : m[0].map((_, i) => m.map((row2) => row2[i]));
    }
    Matrix3.transpose = transpose2;
    function determinant2(m) {
      switch (m.length) {
        // The determinant of a 1x1 matrix is the single value of the matrix.
        case 1:
          return m[0][0];
        // The determinant of a 2x2 matrix is fairly short to write out and so
        // this is done as an optimization.
        case 2:
          return m[0]?.[0] * m[1]?.[1] - m[0]?.[1] * m[1]?.[0];
        default:
          return m.reduce((d, _, i) => d + m[0]?.[i] * cofactor(m, 0, i), 0);
      }
    }
    Matrix3.determinant = determinant2;
    function inverse2(m) {
      return multiply2(adjugate(m), 1 / determinant2(m));
    }
    Matrix3.inverse = inverse2;
    function cofactor(m, i, j) {
      return (-1) ** (i + j) * minor(m, i, j);
    }
    function minor(m, i, j) {
      return determinant2(m.filter((_, k) => k !== i).map((r) => r.filter((_, l) => l !== j)));
    }
    function adjugate(m) {
      return transpose2(m.map((r, i) => r.map((_, j) => cofactor(m, i, j))));
    }
  })(Matrix || (Matrix = {}));

  // node_modules/@siteimprove/alfa-math/dist/vector.js
  var { sqrt } = Math;
  var Vector;
  (function(Vector2) {
    function isVector(value) {
      return Array.isArray(value) && value.every((n) => typeof n === "number");
    }
    Vector2.isVector = isVector;
    function clone(v) {
      return v.slice(0);
    }
    Vector2.clone = clone;
    function equals34(v, u, e) {
      return v.length === u.length && v.every((n, i) => Real.equals(n, u[i], e));
    }
    Vector2.equals = equals34;
    function size(v) {
      return v.length;
    }
    Vector2.size = size;
    function add(v, u) {
      return v.map((n, i) => n + u?.[i]);
    }
    Vector2.add = add;
    function subtract(v, u) {
      return v.map((n, i) => n - u?.[i]);
    }
    Vector2.subtract = subtract;
    function multiply2(v, s) {
      return v.map((n) => n * s);
    }
    Vector2.multiply = multiply2;
    function divide(v, d) {
      return v.map((n) => n / d);
    }
    Vector2.divide = divide;
    function dot2(v, u) {
      return v.reduce((s, n, i) => s + n * u?.[i], 0);
    }
    Vector2.dot = dot2;
    function cross2(v, u) {
      const [vx, vy, vz] = v;
      const [ux, uy, uz] = u;
      return [vy * uz - vz * uy, vz * ux - vx * uz, vx * uy - vy * ux];
    }
    Vector2.cross = cross2;
    function norm2(v) {
      return sqrt(v.reduce((s, n) => s + n ** 2, 0));
    }
    Vector2.norm = norm2;
    function normalize2(v) {
      return divide(v, norm2(v));
    }
    Vector2.normalize = normalize2;
  })(Vector || (Vector = {}));

  // node_modules/@siteimprove/alfa-css/dist/calculation/numeric/numeric.js
  var Numeric = class _Numeric {
    /**
     * The number of decimals stored for every numeric value.
     */
    static Decimals = 7;
    _value;
    _type;
    constructor(value, type) {
      this._type = type;
      this._value = Real.round(value, _Numeric.Decimals);
    }
    get type() {
      return this._type;
    }
    get value() {
      return this._value;
    }
    equals(value) {
      return value instanceof _Numeric && value._value === this._value;
    }
    hash(hash2) {
      hash2.writeFloat64(this._value);
    }
    toJSON() {
      return {
        type: this._type,
        value: this._value
      };
    }
    toString() {
      return `${this._value}`;
    }
  };
  (function(Numeric3) {
    function isNumeric(value) {
      return value instanceof Numeric3;
    }
    Numeric3.isNumeric = isNumeric;
  })(Numeric || (Numeric = {}));

  // node_modules/@siteimprove/alfa-css/dist/calculation/numeric/dimension.js
  var Dimension = class _Dimension extends Numeric {
    _unit;
    constructor(value, unit, type) {
      super(value, type);
      this._unit = unit;
    }
    get unit() {
      return this._unit;
    }
    hasUnit(unit) {
      return this._unit === unit;
    }
    equals(value) {
      return value instanceof _Dimension && super.equals(value) && value._unit === this._unit;
    }
    toJSON() {
      return { ...super.toJSON(), unit: this._unit };
    }
  };
  (function(Dimension3) {
    function isDimension2(value) {
      return value instanceof Dimension3;
    }
    Dimension3.isDimension = isDimension2;
  })(Dimension || (Dimension = {}));

  // node_modules/@siteimprove/alfa-css/dist/calculation/numeric/angle.js
  var { map: map9 } = Parser;
  var Angle = class _Angle extends Dimension {
    static of(value, unit) {
      return new _Angle(value, unit);
    }
    constructor(value, unit) {
      super(value, unit, "angle");
    }
    hasUnit(unit) {
      return this._unit === unit;
    }
    withUnit(unit) {
      if (this.hasUnit(unit)) {
        return this;
      }
      return new _Angle(Converter.angle(this._value, this._unit, unit), unit);
    }
    scale(factor) {
      return new _Angle(this._value * factor, this._unit);
    }
    equals(value) {
      return value instanceof _Angle && super.equals(value) && value._unit === this._unit;
    }
    hash(hash2) {
      super.hash(hash2);
      hash2.writeString(this._unit);
    }
    toJSON() {
      return super.toJSON();
    }
    toString() {
      return `${this._value}${this._unit}`;
    }
  };
  (function(Angle3) {
    function isAngle4(value) {
      return value instanceof Angle3;
    }
    Angle3.isAngle = isAngle4;
    Angle3.parse = map9(Token.parseDimension((dimension) => Unit.isAngle(dimension.unit)), (dimension) => Angle3.of(dimension.value, dimension.unit));
  })(Angle || (Angle = {}));

  // node_modules/@siteimprove/alfa-css/dist/calculation/numeric/integer.js
  var { map: map10 } = Parser;
  var Integer = class _Integer extends Numeric {
    /**
     * {@link https://drafts.csswg.org/css-values/#css-round-to-the-nearest-integer}
     */
    static of(value) {
      return new _Integer(Math.round(value) | 0);
    }
    constructor(value) {
      super(value, "integer");
    }
    scale(factor) {
      return new _Integer(this._value * factor);
    }
    equals(value) {
      return value instanceof _Integer && super.equals(value);
    }
    hash(hash2) {
      hash2.writeInt32(this._value);
    }
    toJSON() {
      return super.toJSON();
    }
  };
  (function(Integer3) {
    function isInteger(value) {
      return value instanceof Integer3;
    }
    Integer3.isInteger = isInteger;
    Integer3.parse = map10(Token.parseNumber((number) => number.isInteger), (integer) => Integer3.of(integer.value));
  })(Integer || (Integer = {}));

  // node_modules/@siteimprove/alfa-css/dist/calculation/numeric/length.js
  var { map: map11, either: either7 } = Parser;
  var Length = class _Length extends Dimension {
    static of(value, unit) {
      return new _Length(value, unit);
    }
    constructor(value, unit) {
      super(value, unit, "length");
    }
    hasUnit(unit) {
      return this._unit === unit;
    }
    withUnit(unit) {
      if (this.hasUnit(unit)) {
        return this;
      }
      if (Unit.isAbsoluteLength(unit) && Unit.isAbsoluteLength(this._unit)) {
        return _Length.of(Converter.length(this._value, this._unit, unit), unit);
      }
      throw new Error(`Cannot convert ${this._unit} to ${unit}`);
    }
    isRelative() {
      return Unit.isRelativeLength(this._unit);
    }
    scale(factor) {
      return new _Length(this._value * factor, this._unit);
    }
    equals(value) {
      return value instanceof _Length && super.equals(value) && value._unit === this._unit;
    }
    hash(hash2) {
      super.hash(hash2);
      hash2.writeString(this._unit);
    }
    toJSON() {
      return super.toJSON();
    }
    toString() {
      return `${this._value}${this._unit}`;
    }
  };
  (function(Length3) {
    function isLength4(value) {
      return value instanceof Length3;
    }
    Length3.isLength = isLength4;
    Length3.parse = either7(map11(Token.parseDimension((dimension) => Unit.isLength(dimension.unit)), (dimension) => Length3.of(dimension.value, dimension.unit)), map11(Token.parseNumber((number) => number.isInteger && number.value === 0), () => Length3.of(0, Unit.Length.Canonical)));
  })(Length || (Length = {}));

  // node_modules/@siteimprove/alfa-css/dist/calculation/numeric/number.js
  var { map: map12 } = Parser;
  var Number2 = class _Number extends Numeric {
    static of(value) {
      return new _Number(value);
    }
    constructor(value) {
      super(value, "number");
    }
    scale(factor) {
      return new _Number(this._value * factor);
    }
    equals(value) {
      return value instanceof _Number && super.equals(value);
    }
    toJSON() {
      return super.toJSON();
    }
  };
  (function(Number4) {
    function isNumber6(value) {
      return value instanceof Number4;
    }
    Number4.isNumber = isNumber6;
    Number4.parseZero = map12(Token.parseNumber((number) => number.value === 0), (number) => Number4.of(number.value));
    Number4.parse = map12(Token.parseNumber(), (number) => Number4.of(number.value));
  })(Number2 || (Number2 = {}));

  // node_modules/@siteimprove/alfa-css/dist/calculation/numeric/percentage.js
  var { map: map13 } = Parser;
  var Percentage = class _Percentage extends Numeric {
    static of(value) {
      return new _Percentage(value);
    }
    constructor(value) {
      super(value, "percentage");
    }
    scale(factor) {
      return new _Percentage(this._value * factor);
    }
    equals(value) {
      return value instanceof _Percentage && super.equals(value);
    }
    toJSON() {
      return super.toJSON();
    }
    toString() {
      return `${this._value * 100}%`;
    }
  };
  (function(Percentage3) {
    function isPercentage3(value) {
      return value instanceof Percentage3;
    }
    Percentage3.isPercentage = isPercentage3;
    Percentage3.parse = map13(Token.parsePercentage(), (percentage) => Percentage3.of(percentage.value));
  })(Percentage || (Percentage = {}));

  // node_modules/@siteimprove/alfa-selective/dist/selective.js
  var Selective = class _Selective {
    static of(value) {
      return new _Selective(Left.of(value));
    }
    _value;
    constructor(value) {
      this._value = value;
    }
    map(mapper) {
      return new _Selective(this._value.map(mapper));
    }
    apply(mapper) {
      return mapper.flatMap((mapper2) => this.map(mapper2));
    }
    flatMap(mapper) {
      return new _Selective(this._value.flatMap((value) => mapper(value)._value));
    }
    flatten() {
      return this.flatMap((selective) => selective);
    }
    if(predicate, mapper) {
      return this._value.either((value) => predicate(value) ? new _Selective(Right.of(mapper(value))) : this, () => this);
    }
    ifGuarded(predicate, guard, ifTrue, ifFalse) {
      return this._value.either((value) => predicate(value) ? guard(value) ? new _Selective(Right.of(ifTrue(value))) : new _Selective(Right.of(ifFalse(value))) : this, () => this);
    }
    else(mapper) {
      return new _Selective(Right.of(this._value.either((value) => mapper(value), (value) => value)));
    }
    get() {
      return this._value.get();
    }
    /**
     * Ensure that this {@link (Selective:class)} is exhaustively matched,
     * returning its resulting value.
     *
     * @remarks
     * This method should only be used for cases where
     * {@link (Selective:class).get} is insufficient. If in doubt, assume that
     * it isn't.
     */
    exhaust() {
      return this.get();
    }
    tee(left22, right38, ...args) {
      this._value.either((value) => left22(value, ...args), (value) => right38(value, ...args));
      return this;
    }
    equals(value) {
      return value instanceof _Selective && value._value.equals(this._value);
    }
    hash(hash2) {
      hash2.writeHashable(this._value);
    }
    *iterator() {
      yield this._value.get();
    }
    [Symbol.iterator]() {
      return this.iterator();
    }
    toJSON() {
      return this._value.toJSON();
    }
    toString() {
      return `Selective { ${this._value} }`;
    }
  };

  // node_modules/@siteimprove/alfa-css/dist/calculation/math-expression/kind.js
  var Kind = class _Kind {
    static of(kind) {
      const kinds = this._empty._kinds;
      return new _Kind(kind === void 0 ? kinds : kinds.set(kind, 1), None);
    }
    static _empty = new _Kind(Record.of({
      length: 0,
      angle: 0,
      percentage: 0
    }), None);
    _kinds;
    _hint;
    constructor(kinds, hint) {
      this._kinds = kinds;
      this._hint = hint;
    }
    get kinds() {
      return this._kinds;
    }
    get hint() {
      return this._hint;
    }
    /**
     * {@link https://drafts.css-houdini.org/css-typed-om/#cssnumericvalue-match}
     */
    is(kind, value = 1, hinted = kind === "percentage") {
      for (const entry of this._kinds) {
        if (entry[0] !== kind && entry[1] === 0) {
          continue;
        }
        if (entry[0] === kind && entry[1] === value) {
          continue;
        }
        return false;
      }
      return this._hint.isNone() || hinted;
    }
    /**
     * {@link https://drafts.css-houdini.org/css-typed-om/#cssnumericvalue-add-two-types}
     */
    add(kind) {
      let a = this;
      let b = kind;
      if (a._hint.some((a2) => b._hint.some((b2) => a2 !== b2))) {
        return Err.of(`Cannot add types ${a} and ${b}`);
      }
      if (a._hint.isNone()) {
        for (const hint of b._hint) {
          a = a.apply(hint);
        }
      }
      if (b._hint.isNone()) {
        for (const hint of a._hint) {
          b = b.apply(hint);
        }
      }
      if (a._kinds.equals(b._kinds)) {
        return Result.of(a);
      }
      if ([a._kinds, b._kinds].some((kinds) => kinds.get("percentage").getOr(0) !== 0) && [a._kinds, b._kinds].some((kinds) => kinds.some((value, kind2) => kind2 !== "percentage" && value !== 0))) {
        for (const hint of ["length", "angle"]) {
          const kind2 = a.apply(hint);
          if (kind2._kinds.equals(b.apply(hint)._kinds)) {
            return Result.of(kind2);
          }
        }
      }
      return Err.of(`Cannot add types ${a} and ${b}`);
    }
    /**
     * {@link https://drafts.css-houdini.org/css-typed-om/#cssnumericvalue-multiply-two-types}
     */
    multiply(kind) {
      let a = this;
      let b = kind;
      if (a._hint.some((a2) => b._hint.some((b2) => a2 !== b2))) {
        return Err.of(`Cannot multiply types ${a} and ${b}`);
      }
      if (a._hint.isNone()) {
        for (const hint of b._hint) {
          a = a.apply(hint);
        }
      }
      if (b._hint.isNone()) {
        for (const hint of a._hint) {
          b = b.apply(hint);
        }
      }
      return Result.of(new _Kind(b._kinds.reduce((kinds, value, kind2) => kinds.set(kind2, kinds.get(kind2).getOr(0) + value), a._kinds), a._hint));
    }
    /**
     * {@link https://drafts.css-houdini.org/css-typed-om/#cssnumericvalue-invert-a-type}
     */
    invert() {
      return new _Kind(this._kinds.reduce((kinds, value, kind) => kinds.set(kind, -1 * value), this._kinds), None);
    }
    /**
     * {@link https://drafts.css-houdini.org/css-typed-om/#apply-the-percent-hint}
     */
    apply(hint) {
      return new _Kind(this._kinds.set(hint, this._kinds.get(hint).getOr(0) + this._kinds.get("percentage").getOr(0)).set("percentage", 0), Option.of(hint));
    }
    equals(value) {
      return value instanceof _Kind && value._kinds.equals(this._kinds) && value._hint.equals(this._hint);
    }
    toJSON() {
      return {
        kinds: this._kinds.toArray(),
        hint: this._hint.getOr(null)
      };
    }
  };

  // node_modules/@siteimprove/alfa-css/dist/calculation/math-expression/value.js
  var { isAngle } = Angle;
  var { isLength } = Length;
  var { isNumber: isNumber3 } = Number2;
  var { isPercentage } = Percentage;
  var Value2 = class _Value extends Expression {
    static of(value, kindHint) {
      const kind = Selective.of(value).if(isPercentage, () => Kind.of("percentage")).if(isLength, () => Kind.of("length")).if(isAngle, () => Kind.of("angle")).else(() => kindHint ?? Kind.of()).get();
      return new _Value(value, kind);
    }
    _value;
    constructor(value, kind) {
      super("value", kind);
      this._value = value;
    }
    get value() {
      return this._value;
    }
    reduce(resolver) {
      if (isPercentage(this._value)) {
        return _Value.of(resolver.percentage(this._value));
      }
      return _Value.of(Selective.of(this._value).if(isLength, _Value.lengthResolver(resolver.length)).if(isAngle, _Value.angleResolver).get(), this._kind).simplify();
    }
    toAngle() {
      if (isAngle(this._value)) {
        return Ok.of(this._value);
      }
      if (this._kind.is("angle")) {
        return Ok.of(Angle.of(this._value.value, Unit.Angle.Canonical));
      }
      return Err.of(`${this} is not an angle`);
    }
    toLength() {
      if (isLength(this.value)) {
        return Ok.of(this.value);
      }
      if (this._kind.is("length")) {
        return Ok.of(Length.of(this._value.value, Unit.Length.Canonical));
      }
      return Err.of(`${this} is not a length`);
    }
    toNumber() {
      if (isNumber3(this.value)) {
        return Ok.of(this.value);
      }
      return Err.of(`${this} is not a number`);
    }
    toPercentage() {
      if (isPercentage(this.value)) {
        return Ok.of(this.value);
      }
      if (this._kind.is("percentage")) {
        return Ok.of(Percentage.of(this._value.value));
      }
      return Err.of(`${this} is not a percentage`);
    }
    simplify() {
      return this.toAngle().orElse(this.toLength.bind(this)).orElse(this.toPercentage.bind(this)).orElse(this.toNumber.bind(this)).map((value) => _Value.of(value, this._kind)).getOr(this);
    }
    isCanonical() {
      return Selective.of(this._value).if(isAngle, (angle) => Unit.Angle.isCanonical(angle.unit)).if(isLength, (length) => Unit.Length.isCanonical(length.unit)).if(isNumber3, () => true).if(isPercentage, () => true).else(() => false).get();
    }
    equals(value) {
      return value instanceof _Value && value._value.equals(this._value);
    }
    toJSON() {
      return {
        type: "value",
        value: this._value.toJSON()
      };
    }
    toString() {
      return `${this._value}`;
    }
  };
  (function(Value6) {
    function isValueExpression2(value) {
      return value instanceof Value6;
    }
    Value6.isValueExpression = isValueExpression2;
    function angleResolver(angle) {
      return angle.withUnit(Unit.Angle.Canonical);
    }
    Value6.angleResolver = angleResolver;
    function lengthResolver(resolver) {
      return (length) => length.isRelative() ? resolver(length) : length.withUnit(Unit.Length.Canonical);
    }
    Value6.lengthResolver = lengthResolver;
  })(Value2 || (Value2 = {}));

  // node_modules/@siteimprove/alfa-css/dist/calculation/math-expression/function.js
  var { isAngle: isAngle2 } = Angle;
  var { isLength: isLength2 } = Length;
  var { isNumber: isNumber4 } = Number2;
  var { isValueExpression } = Value2;
  var Function2 = class _Function extends Expression {
    _args;
    _kind;
    constructor(type, args, kind) {
      super(type, kind);
      this._args = args;
      this._kind = kind;
    }
    get args() {
      return this._args;
    }
    equals(value) {
      return value instanceof _Function && value.type === this.type && value._args.length === this._args.length && value._args.every((arg, i) => arg.equals(this._args[i]));
    }
    toJSON() {
      return { ...super.toJSON(), arguments: Array2.toJSON(this._args) };
    }
  };
  (function(Function4) {
    class Calculation extends Function4 {
      static of(expression) {
        return new Calculation([expression], expression.kind);
      }
      constructor(args, kind) {
        super("calculation", args, kind);
      }
      reduce(resolver) {
        const reduced = this._args[0].reduce(resolver);
        return isValueExpression(reduced) ? reduced : Calculation.of(reduced);
      }
      toString() {
        return `calc(${this._args[0]})`;
      }
    }
    Function4.Calculation = Calculation;
    function isCalculation(value) {
      return value instanceof Calculation;
    }
    Function4.isCalculation = isCalculation;
    class Max extends Function4 {
      static of(first, ...expressions) {
        const kind = expressions.reduce((old, cur) => old.flatMap((kind2) => kind2.add(cur.kind)), Result.of(first.kind));
        return kind.map((kind2) => new Max([first, ...expressions], kind2));
      }
      constructor(args, kind) {
        super("max", args, kind);
      }
      reduce(resolver) {
        const reduced = this._args.map((expr) => expr.reduce(resolver));
        if (Array2.every(reduced, isValueExpression)) {
          const values = reduced.map((expr) => expr.value);
          if (values.every(isNumber4)) {
            return Value2.of(Number2.of(Math.max(...values.map((value) => value.value))));
          }
          if (values.every(
            // The unit test is theoretically not needed since reduced angle values
            // should always be in the canonical unit (no relative angles)
            (value) => isAngle2(value) && value.hasUnit(Unit.Angle.Canonical)
          )) {
            return Value2.of(Angle.of(Math.max(...values.map((value) => value.value)), Unit.Angle.Canonical));
          }
          if (values.every((value) => isLength2(value) && value.hasUnit(Unit.Length.Canonical))) {
            return Value2.of(Length.of(Math.max(...values.map((value) => value.value)), Unit.Length.Canonical));
          }
        }
        return new Max(reduced, this._kind);
      }
      toString() {
        return `max(${this._args.map((expr) => expr.toString()).join(", ")})`;
      }
    }
    Function4.Max = Max;
  })(Function2 || (Function2 = {}));

  // node_modules/@siteimprove/alfa-css/dist/calculation/math-expression/operation.js
  var { isAngle: isAngle3 } = Angle;
  var { isDimension } = Dimension;
  var { isLength: isLength3 } = Length;
  var { isNumber: isNumber5 } = Number2;
  var { isPercentage: isPercentage2 } = Percentage;
  var Operation = class _Operation extends Expression {
    _operands;
    constructor(type, operands, kind) {
      super(type, kind);
      this._operands = operands;
    }
    get operands() {
      return this._operands;
    }
    equals(value) {
      return value instanceof _Operation && value._type === this._type && value._operands.length === this._operands.length && value._operands.every((operand, i) => operand.equals(this._operands[i]));
    }
    toJSON() {
      return { ...super.toJSON(), operands: Array2.toJSON(this._operands) };
    }
  };
  (function(Operation2) {
    class Unary extends Operation2 {
      constructor(type, operands, kind) {
        super(type, operands, kind);
      }
    }
    Operation2.Unary = Unary;
    class Binary extends Operation2 {
      constructor(type, operands, kind) {
        super(type, operands, kind);
      }
    }
    Operation2.Binary = Binary;
    class Sum extends Binary {
      static of(...operands) {
        const [fst, snd] = operands;
        const kind = fst.kind.add(snd.kind);
        return kind.map((kind2) => new Sum(operands, kind2));
      }
      constructor(operands, kind) {
        super("sum", operands, kind);
      }
      reduce(resolver) {
        const [fst, snd] = this._operands.map((operand) => operand.reduce(resolver));
        if (Value2.isValueExpression(fst) && Value2.isValueExpression(snd)) {
          if (isNumber5(fst.value) && isNumber5(snd.value)) {
            return Value2.of(Number2.of(fst.value.value + snd.value.value));
          }
          if (isPercentage2(fst.value) && isPercentage2(snd.value)) {
            return Value2.of(Percentage.of(fst.value.value + snd.value.value));
          }
          if (isDimension(fst.value) && isDimension(snd.value) && fst.value.unit === snd.value.unit) {
            const { unit } = fst.value;
            if (Unit.isLength(unit)) {
              return Value2.of(Length.of(fst.value.value + snd.value.value, unit));
            }
            if (Unit.isAngle(unit)) {
              return Value2.of(Angle.of(fst.value.value + snd.value.value, unit));
            }
          }
        }
        return new Sum([fst, snd], this._kind);
      }
      toString() {
        const [fst, snd] = this._operands;
        if (isNegateExpression(snd)) {
          return `(${fst} - ${snd.operands[0]})`;
        }
        return `(${fst} + ${snd})`;
      }
    }
    Operation2.Sum = Sum;
    function isSumExpression(value) {
      return value instanceof Sum;
    }
    Operation2.isSumExpression = isSumExpression;
    class Negate extends Unary {
      static of(operand) {
        return new Negate([operand], operand.kind);
      }
      constructor(operand, kind) {
        super("negate", operand, kind);
      }
      reduce(resolver) {
        const [operand] = this._operands.map((operand2) => operand2.reduce(resolver));
        if (Value2.isValueExpression(operand)) {
          const { value } = operand;
          if (isNumber5(value)) {
            return Value2.of(Number2.of(0 - value.value));
          }
          if (isPercentage2(value)) {
            return Value2.of(Percentage.of(0 - value.value));
          }
          if (isLength3(value)) {
            return Value2.of(Length.of(0 - value.value, value.unit));
          }
          if (isAngle3(value)) {
            return Value2.of(Angle.of(0 - value.value, value.unit));
          }
        }
        if (isNegateExpression(operand)) {
          return operand._operands[0];
        }
        return Negate.of(operand);
      }
      toString() {
        const [operand] = this._operands;
        return `(-1 * ${operand})`;
      }
    }
    Operation2.Negate = Negate;
    function isNegateExpression(value) {
      return value instanceof Negate;
    }
    Operation2.isNegateExpression = isNegateExpression;
    class Product extends Binary {
      static of(...operands) {
        const [fst, snd] = operands;
        const kind = fst.kind.multiply(snd.kind);
        return kind.map((kind2) => new Product(operands, kind2));
      }
      constructor(operands, kind) {
        super("product", operands, kind);
      }
      reduce(resolver) {
        const [fst, snd] = this._operands.map((operand) => operand.reduce(resolver));
        if (Value2.isValueExpression(fst) && Value2.isValueExpression(snd)) {
          if (fst.isCanonical() && snd.isCanonical()) {
            return Value2.of(Number2.of(fst.value.value * snd.value.value), fst.kind.multiply(snd.kind).getUnsafe()).simplify();
          }
          let multiplier;
          let value;
          if (isNumber5(fst.value) && fst.kind.is()) {
            multiplier = fst.value.value;
            value = snd.value;
          } else if (isNumber5(snd.value) && snd.kind.is()) {
            multiplier = snd.value.value;
            value = fst.value;
          }
          if (multiplier !== void 0) {
            return Value2.of(value.scale(multiplier));
          }
        }
        return new Product([fst, snd], this._kind);
      }
      toString() {
        const [fst, snd] = this._operands;
        return `${fst} * ${snd}`;
      }
    }
    Operation2.Product = Product;
    function isProductExpression(value) {
      return value instanceof Product;
    }
    Operation2.isProductExpression = isProductExpression;
    class Invert extends Unary {
      static of(operand) {
        return new Invert([operand], operand.kind.invert());
      }
      constructor(operand, kind) {
        super("invert", operand, kind);
      }
      reduce(resolver) {
        const [operand] = this._operands.map((operand2) => operand2.reduce(resolver));
        if (Value2.isValueExpression(operand) && operand.isCanonical()) {
          const { value } = operand;
          return Value2.of(Number2.of(1 / value.value), operand.kind.invert());
        }
        if (isInvertExpression(operand)) {
          return operand._operands[0];
        }
        return Invert.of(operand);
      }
      toString() {
        const [operand] = this._operands;
        return `(1 / ${operand})`;
      }
    }
    Operation2.Invert = Invert;
    function isInvertExpression(value) {
      return value instanceof Invert;
    }
    Operation2.isInvertExpression = isInvertExpression;
  })(Operation || (Operation = {}));

  // node_modules/@siteimprove/alfa-css/dist/calculation/math-expression/math.js
  var { delimited: delimited7, either: either8, filter, map: map14, mapResult, option: option7, pair: pair5, separatedList: separatedList2, zeroOrMore: zeroOrMore3 } = Parser;
  var Math2 = class _Math {
    static of(expression) {
      return new _Math(expression.reduce({
        length: (value) => value,
        percentage: (value) => value
      }));
    }
    _expression;
    _type = "math expression";
    constructor(expression) {
      this._expression = expression;
    }
    get expression() {
      return this._expression;
    }
    get type() {
      return this._type;
    }
    reduce(resolver) {
      return new _Math(this._expression.reduce(resolver));
    }
    /**
     * {@link https://drafts.css-houdini.org/css-typed-om/#cssnumericvalue-match}
     */
    isDimension(dimension) {
      return this._expression.kind.is(dimension);
    }
    /**
     * {@link https://drafts.css-houdini.org/css-typed-om/#cssnumericvalue-match}
     */
    isDimensionPercentage(dimension) {
      return (
        // dimension-percentage are not just (dimension | percentage) because the
        // dimension does accept a percent hint in this case; while pure
        // dimensions may not be hinted.
        this._expression.kind.is(dimension, 1, true) || this._expression.kind.is("percentage")
      );
    }
    /**
     * {@link https://drafts.css-houdini.org/css-typed-om/#cssnumericvalue-match}
     */
    isNumber() {
      return this._expression.kind.is();
    }
    /**
     * {@link https://drafts.css-houdini.org/css-typed-om/#cssnumericvalue-match}
     */
    isPercentage() {
      return this._expression.kind.is("percentage");
    }
    resolve(resolver) {
      try {
        const expression = this._expression.reduce({
          // If the expression is a length, and we can't resolve relative lengths,
          // abort.
          length: () => {
            throw new Error(`Missing length resolver for ${this}`);
          },
          // If the expression is a percentage, and we can't resolve percentages,
          // we keep them as percentages.
          percentage: (p) => p,
          // override default values
          ...resolver
        });
        return expression.toAngle().orElse(expression.toLength.bind(expression)).orElse(expression.toPercentage.bind(expression)).orElse(expression.toNumber.bind(expression)).or(Err.of(`${this} does not resolve to a valid expression`));
      } catch (e) {
        if (e instanceof Error) {
          return Err.of(e.message);
        } else {
          return Err.of(`Unexpected error while resolving math expression ${this}`);
        }
      }
    }
    hash(hash2) {
    }
    equals(value) {
      return value instanceof _Math && value._expression.equals(this._expression);
    }
    toJSON() {
      return {
        type: "math expression",
        expression: this._expression.toJSON()
      };
    }
    toString() {
      return this._expression.toString();
    }
  };
  (function(Math3) {
    function isCalculation(value) {
      return value instanceof Math3;
    }
    Math3.isCalculation = isCalculation;
    function isNumber6(value) {
      return isCalculation(value) && value.isNumber();
    }
    Math3.isNumber = isNumber6;
    function isPercentage3(value) {
      return isCalculation(value) && value.isPercentage();
    }
    Math3.isPercentage = isPercentage3;
    let parseSum;
    const parseCalc = map14(Function.parse("calc", (input) => parseSum(input)), ([, expression]) => Function2.Calculation.of(expression));
    const parseMax = mapResult(Function.parse("max", (input) => separatedList2(parseSum, delimited7(option7(Token.parseWhitespace), Token.parseComma))(input)), ([, args]) => Function2.Max.of(...args));
    const parseFunction = either8(parseCalc, parseMax);
    const parseValue = either8(map14(either8(Number2.parse, Percentage.parse, Length.parse, Angle.parse), Value2.of), parseFunction, delimited7(Token.parseOpenParenthesis, (input) => parseSum(input), Token.parseCloseParenthesis));
    const parseProduct = mapResult(pair5(parseValue, zeroOrMore3(pair5(delimited7(option7(Token.parseWhitespace), either8(map14(Token.parseDelim("*"), () => false), map14(Token.parseDelim("/"), () => true))), parseValue))), ([left22, result]) => result.map(([invert, right38]) => invert ? Operation.Invert.of(right38) : right38).reduce((left23, right38) => left23.flatMap((left24) => Operation.Product.of(left24, right38)), Result.of(left22)));
    parseSum = mapResult(pair5(parseProduct, zeroOrMore3(pair5(delimited7(Token.parseWhitespace, either8(map14(Token.parseDelim("+"), () => false), map14(Token.parseDelim("-"), () => true))), parseProduct))), ([left22, result]) => result.map(([invert, right38]) => invert ? Operation.Negate.of(right38) : right38).reduce((left23, right38) => left23.flatMap((left24) => Operation.Sum.of(left24, right38)), Result.of(left22)));
    Math3.parse = map14(parseFunction, Math3.of);
    Math3.parseAngle = filter(Math3.parse, (calculation) => calculation.isDimension("angle"), () => `calc() expression must be of type "angle"`);
    Math3.parseAnglePercentage = filter(Math3.parse, (calculation) => calculation.isDimensionPercentage("angle"), () => `calc() expression must be of type "angle" or "percentage"`);
    Math3.parseLength = filter(Math3.parse, (calculation) => calculation.isDimension("length"), () => `calc() expression must be of type "length"`);
    Math3.parseLengthPercentage = filter(Math3.parse, (calculation) => calculation.isDimensionPercentage("length"), () => `calc() expression must be of type "length" or "percentage"`);
    Math3.parseNumber = filter(Math3.parse, (calculation) => calculation.isNumber(), () => `calc() expression must be of type "number"`);
    Math3.parsePercentage = filter(Math3.parse, (calculation) => calculation.isPercentage(), () => `calc() expression must be of type "percentage"`);
  })(Math2 || (Math2 = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/numeric/numeric.js
  var Numeric2;
  (function(Numeric3) {
    class Calculated extends Value {
      _math;
      constructor(math, type) {
        super(type, true);
        this._math = math;
      }
      get math() {
        return this._math;
      }
      hasCalculation() {
        return true;
      }
      equals(value) {
        return value instanceof Calculated && value._math.equals(this._math);
      }
      hash(hash2) {
        this._math.hash(hash2);
      }
      toJSON() {
        return { ...super.toJSON(), math: this._math.toJSON() };
      }
      toString() {
        return this._math.toString();
      }
    }
    Numeric3.Calculated = Calculated;
    class Fixed extends Value {
      _value;
      constructor(value, type) {
        super(type, false);
        this._value = Real.round(value, Numeric.Decimals);
      }
      get value() {
        return this._value;
      }
      hasCalculation() {
        return false;
      }
      isZero() {
        return this._value === 0;
      }
      equals(value) {
        return value instanceof Fixed && value._value === this._value;
      }
      compare(value) {
        return Comparable.compareNumber(this._value, value._value);
      }
      hash(hash2) {
        hash2.writeFloat64(this._value);
      }
      toJSON() {
        return {
          ...super.toJSON(),
          value: this._value
        };
      }
      toString() {
        return `${this._value}`;
      }
    }
    Numeric3.Fixed = Fixed;
    function isCalculated(value) {
      return value instanceof Calculated;
    }
    Numeric3.isCalculated = isCalculated;
    function isFixed(value) {
      return value instanceof Fixed;
    }
    Numeric3.isFixed = isFixed;
    function isNumeric(value) {
      return value instanceof Calculated || value instanceof Fixed;
    }
    Numeric3.isNumeric = isNumeric;
    function isZero(value) {
      return value.isZero();
    }
    Numeric3.isZero = isZero;
  })(Numeric2 || (Numeric2 = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/numeric/dimension.js
  var Dimension2;
  (function(Dimension3) {
    class Calculated extends Numeric2.Calculated {
      constructor(math, type) {
        super(math, type);
      }
      hasCalculation() {
        return true;
      }
      equals(value) {
        return value instanceof Calculated && super.equals(value);
      }
    }
    Dimension3.Calculated = Calculated;
    class Fixed extends Numeric2.Fixed {
      _unit;
      constructor(value, unit, type) {
        super(value, type);
        this._unit = unit;
      }
      get unit() {
        return this._unit;
      }
      hasCalculation() {
        return false;
      }
      /**
       * {@link https://drafts.csswg.org/css-values/#canonical-unit}
       */
      get canonicalUnit() {
        return this.type === "angle" ? Unit.Angle.Canonical : Unit.Length.Canonical;
      }
      equals(value) {
        return value instanceof Fixed && super.equals(value) && value._unit === this._unit;
      }
      compare(value) {
        const a = this.withUnit(this.canonicalUnit);
        const b = value.withUnit(value.canonicalUnit);
        return Comparable.compareNumber(a.value, b.value);
      }
      hash(hash2) {
        super.hash(hash2);
        hash2.writeString(this._unit);
      }
      toJSON() {
        return { ...super.toJSON(), unit: this._unit };
      }
      toString() {
        return `${this._value}${this._unit}`;
      }
    }
    Dimension3.Fixed = Fixed;
    function isCalculated(value) {
      return value instanceof Calculated;
    }
    Dimension3.isCalculated = isCalculated;
    function isFixed(value) {
      return value instanceof Fixed;
    }
    Dimension3.isFixed = isFixed;
    function isDimension2(value) {
      return value instanceof Calculated || value instanceof Fixed;
    }
    Dimension3.isDimension = isDimension2;
  })(Dimension2 || (Dimension2 = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/numeric/length.js
  var { either: either9, map: map15 } = Parser;
  var Length2;
  (function(Length3) {
    class Calculated extends Dimension2.Calculated {
      static of(value) {
        return new Calculated(value);
      }
      constructor(math) {
        super(math, "length");
      }
      hasCalculation() {
        return true;
      }
      resolve(resolver2) {
        return Fixed.of(this._math.resolve(toExpressionResolver(resolver2)).getUnsafe(`Could not resolve ${this._math} as a length`));
      }
      equals(value) {
        return value instanceof Calculated && super.equals(value);
      }
    }
    Length3.Calculated = Calculated;
    class Fixed extends Dimension2.Fixed {
      static of(value, unit) {
        if (typeof value === "number") {
          return new Fixed(value, unit);
        }
        return new Fixed(value.value, value.unit);
      }
      constructor(value, unit) {
        super(value, unit, "length");
      }
      hasCalculation() {
        return false;
      }
      hasUnit(unit) {
        return this._unit === unit;
      }
      withUnit(unit) {
        if (this.hasUnit(unit)) {
          return this;
        }
        if (Unit.isAbsoluteLength(unit) && Unit.isAbsoluteLength(this._unit)) {
          return Fixed.of(Converter.length(this._value, this._unit, unit), unit);
        }
        throw new Error(`Cannot convert ${this._unit} to ${unit}`);
      }
      isRelative() {
        return Unit.isRelativeLength(this._unit);
      }
      isFontRelative() {
        return Unit.isFontRelativeLength(this._unit);
      }
      isViewportRelative() {
        return Unit.isViewportRelativeLength(this._unit);
      }
      isAbsolute() {
        return Unit.isAbsoluteLength(this._unit);
      }
      scale(factor) {
        return new Fixed(this._value * factor, this._unit);
      }
      /**
       * Resolve a Length into an absolute Length in pixels.
       */
      resolve(resolver2) {
        return this.isRelative() ? resolver2.length(this) : this.withUnit(Unit.Length.Canonical);
      }
      /**
       * @internal
       */
      toBase() {
        return Length.of(this._value, this._unit);
      }
      equals(value) {
        return value instanceof Fixed && super.equals(value);
      }
    }
    Length3.Fixed = Fixed;
    function toExpressionResolver(resolver2) {
      return resolver2?.length === void 0 ? {} : { length: (length) => resolver2.length(Fixed.of(length)).toBase() };
    }
    Length3.toExpressionResolver = toExpressionResolver;
    function resolver(emBase, remBase, vwBase, vhBase) {
      return (length) => {
        const { unit, value } = length;
        const [min4, max5] = vhBase.value < vwBase.value ? [vhBase, vwBase] : [vwBase, vhBase];
        switch (unit) {
          // https://www.w3.org/TR/css-values/#em
          case "em":
            return emBase.scale(value);
          // https://www.w3.org/TR/css-values/#rem
          case "rem": {
            return remBase.scale(value);
          }
          // https://www.w3.org/TR/css-values/#ex
          case "ex":
          // https://www.w3.org/TR/css-values/#ch
          case "ch":
            return emBase.scale(value * 0.5);
          // https://www.w3.org/TR/css-values/#vh
          case "vh":
            return vhBase.scale(value / 100);
          // https://www.w3.org/TR/css-values/#vw
          case "vw":
            return vwBase.scale(value / 100);
          // https://www.w3.org/TR/css-values/#vmin
          case "vmin":
            return min4.scale(value / 100);
          // https://www.w3.org/TR/css-values/#vmax
          case "vmax":
            return max5.scale(value / 100);
        }
      };
    }
    Length3.resolver = resolver;
    function isLength4(value) {
      return value instanceof Calculated || value instanceof Fixed;
    }
    Length3.isLength = isLength4;
    function isCalculated(value) {
      return value instanceof Calculated;
    }
    Length3.isCalculated = isCalculated;
    function isFixed(value) {
      return value instanceof Fixed;
    }
    Length3.isFixed = isFixed;
    function of(value, unit) {
      if (typeof value === "number") {
        return Fixed.of(value, unit);
      }
      if (Length.isLength(value)) {
        return Fixed.of(value.value, value.unit);
      }
      return Calculated.of(value);
    }
    Length3.of = of;
    Length3.parse = either9(map15(Length.parse, of), map15(Math2.parseLength, of));
  })(Length2 || (Length2 = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/numeric/angle.js
  var { either: either10, map: map16 } = Parser;
  var Angle2;
  (function(Angle3) {
    class Calculated extends Dimension2.Calculated {
      static of(value) {
        return new Calculated(value);
      }
      constructor(value) {
        super(value, "angle");
      }
      hasCalculation() {
        return true;
      }
      resolve(resolver) {
        return Fixed.of(this._math.resolve(Length2.toExpressionResolver(resolver)).getUnsafe(`Could not resolve ${this._math} as an angle`));
      }
      equals(value) {
        return value instanceof Calculated && super.equals(value);
      }
    }
    Angle3.Calculated = Calculated;
    class Fixed extends Dimension2.Fixed {
      static of(value, unit) {
        if (typeof value === "number") {
          return new Fixed(value, unit);
        }
        return new Fixed(value.value, value.unit);
      }
      constructor(value, unit) {
        super(value, unit, "angle");
      }
      hasCalculation() {
        return false;
      }
      hasUnit(unit) {
        return this._unit === unit;
      }
      withUnit(unit) {
        if (this.hasUnit(unit)) {
          return this;
        }
        return Fixed.of(Converter.angle(this._value, this._unit, unit), unit);
      }
      scale(factor) {
        return new Fixed(this._value * factor, this._unit);
      }
      resolve() {
        return this.withUnit("deg");
      }
      /**
       * @internal
       */
      toBase() {
        return Angle.of(this._value, this._unit);
      }
      equals(value) {
        return value instanceof Fixed && super.equals(value);
      }
    }
    Angle3.Fixed = Fixed;
    function isCalculated(value) {
      return value instanceof Calculated;
    }
    Angle3.isCalculated = isCalculated;
    function isFixed(value) {
      return value instanceof Fixed;
    }
    Angle3.isFixed = isFixed;
    function isAngle4(value) {
      return value instanceof Calculated || value instanceof Fixed;
    }
    Angle3.isAngle = isAngle4;
    function of(value, unit) {
      if (typeof value === "number") {
        return Fixed.of(value, unit);
      }
      if (Angle.isAngle(value)) {
        return Fixed.of(value.value, value.unit);
      }
      return Calculated.of(value);
    }
    Angle3.of = of;
    Angle3.parse = either10(map16(Angle.parse, of), map16(Math2.parseAngle, of));
  })(Angle2 || (Angle2 = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/numeric/integer.js
  var { either: either11, map: map17 } = Parser;
  var Integer2;
  (function(Integer3) {
    class Calculated extends Numeric2.Calculated {
      static of(value) {
        return new Calculated(value);
      }
      constructor(value) {
        super(value, "integer");
      }
      /**
       * @remarks
       * Numbers are rounded to the nearest integer upon resolving calculation
       *
       * {@link https://drafts.csswg.org/css-values/#calc-type-checking}
       */
      resolve(resolver) {
        return Fixed.of(this._math.resolve(Length2.toExpressionResolver(resolver)).getUnsafe(`Could not fully resolve ${this} as a number`).value);
      }
      partiallyResolve(resolver) {
        return this.resolve(resolver);
      }
      equals(value) {
        return value instanceof Calculated && super.equals(value);
      }
      toJSON() {
        return super.toJSON();
      }
    }
    Integer3.Calculated = Calculated;
    class Fixed extends Numeric2.Fixed {
      /**
       * {@link https://drafts.csswg.org/css-values/#css-round-to-the-nearest-integer}
       */
      static of(value) {
        return new Fixed(Integer.isInteger(value) ? value.value : (
          // Math.round ensure the correct rounding.
          // The bitwise or ensure coercion to 32 bits integer
          Math.round(value) | 0
        ));
      }
      constructor(value) {
        super(value, "integer");
      }
      resolve() {
        return this;
      }
      partiallyResolve() {
        return this;
      }
      scale(factor) {
        return new Fixed(this._value * factor);
      }
      /**
       * @internal
       */
      toBase() {
        return Integer.of(this._value);
      }
      equals(value) {
        return value instanceof Fixed && super.equals(value);
      }
      hash(hash2) {
        hash2.writeInt32(this._value);
      }
      toJSON() {
        return super.toJSON();
      }
    }
    Integer3.Fixed = Fixed;
    function isCalculated(value) {
      return value instanceof Calculated;
    }
    Integer3.isCalculated = isCalculated;
    function isFixed(value) {
      return value instanceof Fixed;
    }
    Integer3.isFixed = isFixed;
    function isInteger(value) {
      return value instanceof Calculated || value instanceof Fixed;
    }
    Integer3.isInteger = isInteger;
    function of(value) {
      return Selective.of(value).if(Math2.isNumber, Calculated.of).else(Fixed.of).get();
    }
    Integer3.of = of;
    Integer3.parse = either11(map17(Integer.parse, of), map17(Math2.parseNumber, of));
  })(Integer2 || (Integer2 = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/numeric/number.js
  var { either: either12, map: map18 } = Parser;
  var Number3;
  (function(Number4) {
    class Calculated extends Numeric2.Calculated {
      static of(value) {
        return new Calculated(value);
      }
      constructor(value) {
        super(value, "number");
      }
      resolve(resolver) {
        return Fixed.of(this._math.resolve(Length2.toExpressionResolver(resolver)).getUnsafe(`Could not fully resolve ${this} as a number`));
      }
      partiallyResolve(resolver) {
        return this.resolve(resolver);
      }
      equals(value) {
        return value instanceof Calculated && super.equals(value);
      }
      toJSON() {
        return super.toJSON();
      }
    }
    Number4.Calculated = Calculated;
    class Fixed extends Numeric2.Fixed {
      static of(value) {
        return new Fixed(Number2.isNumber(value) ? value.value : value);
      }
      constructor(value) {
        super(value, "number");
      }
      resolve() {
        return this;
      }
      partiallyResolve() {
        return this;
      }
      scale(factor) {
        return new Fixed(this._value * factor);
      }
      /**
       * @internal
       */
      toBase() {
        return Number2.of(this._value);
      }
      equals(value) {
        return value instanceof Fixed && super.equals(value);
      }
      toJSON() {
        return super.toJSON();
      }
    }
    Number4.Fixed = Fixed;
    function isCalculated(value) {
      return value instanceof Calculated;
    }
    Number4.isCalculated = isCalculated;
    function isFixed(value) {
      return value instanceof Fixed;
    }
    Number4.isFixed = isFixed;
    function isNumber6(value) {
      return value instanceof Calculated || value instanceof Fixed;
    }
    Number4.isNumber = isNumber6;
    function of(value) {
      return Selective.of(value).if(Math2.isNumber, Calculated.of).else(Fixed.of).get();
    }
    Number4.of = of;
    Number4.parse = either12(map18(Number2.parse, of), map18(Math2.parseNumber, of));
    Number4.parseZero = map18(Number2.parseZero, of);
  })(Number3 || (Number3 = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/numeric/percentage.js
  var { either: either13, map: map19 } = Parser;
  var Percentage2;
  (function(Percentage3) {
    class Calculated extends Numeric2.Calculated {
      static of(value) {
        return new Calculated(value);
      }
      constructor(math) {
        super(math, "percentage");
      }
      hasCalculation() {
        return true;
      }
      resolve(resolver) {
        if (resolver === void 0) {
          return Fixed.of(this._math.resolve().getUnsafe(`Could not fully resolve ${this} as a percentage`));
        }
        return Selective.of(this._math.resolve({
          percentage: (value) => value,
          ...toExpressionResolver(resolver),
          ...Length2.toExpressionResolver(resolver)
        }).getUnsafe(`Could not fully resolve ${this} as a percentage`)).if(Angle.isAngle, Angle2.Fixed.of).if(Integer.isInteger, Integer2.Fixed.of).if(Length.isLength, Length2.Fixed.of).if(Number2.isNumber, Number3.Fixed.of).else((value) => Fixed.of(value)).get();
      }
      partiallyResolve(resolver) {
        return Fixed.of(this._math.resolve({
          percentage: (value) => value,
          ...Length2.toExpressionResolver(resolver)
        }).getUnsafe(`Could not resolve ${this} as a percentage`));
      }
      equals(value) {
        return value instanceof Calculated && super.equals(value);
      }
      toJSON() {
        return super.toJSON();
      }
    }
    Percentage3.Calculated = Calculated;
    class Fixed extends Numeric2.Fixed {
      static of(value) {
        return new Fixed(Percentage.isPercentage(value) ? value.value : value);
      }
      constructor(value) {
        super(value, "percentage");
      }
      resolve(resolver) {
        return resolver?.percentageBase === void 0 ? this : (
          // since we don't know much about percentageBase, scale defaults to
          // the abstract one on Numeric and loses its actual type which needs
          // to be asserted again.
          resolver.percentageBase.scale(this._value)
        );
      }
      partiallyResolve() {
        return this;
      }
      scale(factor) {
        return new Fixed(this._value * factor);
      }
      /**
       * @internal
       */
      toBase() {
        return Percentage.of(this._value);
      }
      equals(value) {
        return value instanceof Fixed && super.equals(value);
      }
      toJSON() {
        return super.toJSON();
      }
      toString() {
        return `${this._value * 100}%`;
      }
    }
    Percentage3.Fixed = Fixed;
    function toExpressionResolver(resolver) {
      return resolver?.percentageBase === void 0 ? {} : {
        percentage: (value) => resolver.percentageBase.toBase().scale(value.value)
      };
    }
    Percentage3.toExpressionResolver = toExpressionResolver;
    function isCalculated(value) {
      return value instanceof Calculated;
    }
    Percentage3.isCalculated = isCalculated;
    function isFixed(value) {
      return value instanceof Fixed;
    }
    Percentage3.isFixed = isFixed;
    function isPercentage3(value) {
      return value instanceof Calculated || value instanceof Fixed;
    }
    Percentage3.isPercentage = isPercentage3;
    function of(value) {
      return Selective.of(value).if(Math2.isPercentage, Calculated.of).else(Fixed.of).get();
    }
    Percentage3.of = of;
    function parse57(input) {
      return either13(map19(Percentage.parse, of), map19(Math2.parsePercentage, of))(input);
    }
    Percentage3.parse = parse57;
  })(Percentage2 || (Percentage2 = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/numeric/angle-percentage.js
  var { either: either14, map: map20 } = Parser;
  var AnglePercentage;
  (function(AnglePercentage2) {
    class Calculated extends Dimension2.Calculated {
      static of(value) {
        return new Calculated(value);
      }
      constructor(math) {
        super(math, "angle-percentage");
      }
      hasCalculation() {
        return true;
      }
      resolve(resolver) {
        return Angle2.Fixed.of(this._math.resolve({
          // 100% is always 1 full turn!
          percentage: (value) => Angle.of(360, "deg").scale(value.value)
        }).getUnsafe(`Could not resolve ${this._math} as an angle`));
      }
      equals(value) {
        return value instanceof Calculated && super.equals(value);
      }
    }
    AnglePercentage2.Calculated = Calculated;
    function resolve3(value, resolver) {
      return Percentage2.isPercentage(value) ? value.resolve({
        percentageBase: Angle2.of(360, "deg"),
        ...Length2.toExpressionResolver(resolver)
      }) : value.resolve();
    }
    AnglePercentage2.resolve = resolve3;
    function isAnglePercentage(value) {
      return value instanceof Calculated || Angle2.isAngle(value) || Percentage2.isPercentage(value);
    }
    AnglePercentage2.isAnglePercentage = isAnglePercentage;
    function isCalculated(value) {
      return value instanceof Calculated || Angle2.isCalculated(value) || Percentage2.isCalculated(value);
    }
    AnglePercentage2.isCalculated = isCalculated;
    function isFixed(value) {
      return value instanceof Angle2.Fixed;
    }
    AnglePercentage2.isFixed = isFixed;
    function isPercentage3(value) {
      return value instanceof Percentage2.Fixed;
    }
    AnglePercentage2.isPercentage = isPercentage3;
    function of(value, unit) {
      if (typeof value === "number") {
        if (unit === void 0) {
          return Percentage2.of(value);
        } else {
          return Angle2.of(value, unit);
        }
      }
      if (Angle.isAngle(value)) {
        return Angle2.of(value.value, value.unit);
      }
      if (Percentage.isPercentage(value)) {
        return Percentage2.of(value.value);
      }
      if (value.isPercentage()) {
        return Percentage2.of(value);
      }
      if (value.isDimension("angle")) {
        return Angle2.of(value);
      }
      return Calculated.of(value);
    }
    AnglePercentage2.of = of;
    AnglePercentage2.parse = either14(Angle2.parse, Percentage2.parse, map20(Math2.parseAnglePercentage, of));
  })(AnglePercentage || (AnglePercentage = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/numeric/length-percentage.js
  var { either: either15, map: map21 } = Parser;
  var LengthPercentage;
  (function(LengthPercentage2) {
    class Calculated extends Dimension2.Calculated {
      static of(value) {
        return new Calculated(value);
      }
      constructor(math) {
        super(math, "length-percentage");
      }
      hasCalculation() {
        return true;
      }
      resolve(resolver) {
        const resolve4 = this._math.resolve({
          ...Length2.toExpressionResolver(resolver),
          ...Percentage2.toExpressionResolver(resolver)
        });
        return Length2.Fixed.of(resolve4.getUnsafe(`Could not resolve ${this._math} as a length`));
      }
      partiallyResolve(resolver) {
        return this;
      }
      equals(value) {
        return value instanceof Calculated && super.equals(value);
      }
    }
    LengthPercentage2.Calculated = Calculated;
    function resolve3(resolver) {
      return (value) => {
        return Percentage2.isPercentage(value) ? value.resolve(resolver) : value.resolve(resolver);
      };
    }
    LengthPercentage2.resolve = resolve3;
    function partiallyResolve(resolver) {
      return (value) => Selective.of(value).if(Length2.isLength, (value2) => value2.resolve(resolver)).if(Percentage2.isPercentage, (value2) => value2.partiallyResolve()).get();
    }
    LengthPercentage2.partiallyResolve = partiallyResolve;
    function isLengthPercentage(value) {
      return value instanceof Calculated || Length2.isLength(value) || Percentage2.isPercentage(value);
    }
    LengthPercentage2.isLengthPercentage = isLengthPercentage;
    function isCalculated(value) {
      return value instanceof Calculated || Length2.isCalculated(value) || Percentage2.isCalculated(value);
    }
    LengthPercentage2.isCalculated = isCalculated;
    function isFixed(value) {
      return value instanceof Length2.Fixed;
    }
    LengthPercentage2.isFixed = isFixed;
    function isPercentage3(value) {
      return value instanceof Percentage2.Fixed;
    }
    LengthPercentage2.isPercentage = isPercentage3;
    function of(value, unit) {
      if (typeof value === "number") {
        if (unit === void 0) {
          return Percentage2.of(value);
        } else {
          return Length2.of(value, unit);
        }
      }
      if (Length.isLength(value)) {
        return Length2.of(value.value, value.unit);
      }
      if (Percentage.isPercentage(value)) {
        return Percentage2.of(value.value);
      }
      if (value.isPercentage()) {
        return Percentage2.of(value);
      }
      if (value.isDimension("length")) {
        return Length2.of(value);
      }
      return Calculated.of(value);
    }
    LengthPercentage2.of = of;
    LengthPercentage2.parse = either15(Length2.parse, Percentage2.parse, map21(Math2.parseLengthPercentage, of));
  })(LengthPercentage || (LengthPercentage = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/color/format.js
  var Format = class extends Value {
    _format;
    constructor(format) {
      super("color", false);
      this._format = format;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        format: this._format
      };
    }
  };
  (function(Format2) {
    function toPercentage(channel, max5) {
      return Percentage2.of(Real.clamp(channel.value / (Number3.isNumber(channel) ? max5 : 1), 0, 1));
    }
    function resolve3(red, green, blue, alpha) {
      return [
        toPercentage(red, 255),
        toPercentage(green, 255),
        toPercentage(blue, 255),
        toPercentage(alpha, 1)
      ];
    }
    Format2.resolve = resolve3;
  })(Format || (Format = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/color/rgb.js
  var { pair: pair6, map: map22, either: either16, option: option8, right: right3, take: take3, delimited: delimited8 } = Parser;
  var RGB = class _RGB extends Format {
    static of(red, green, blue, alpha) {
      return new _RGB(red.resolve(), green.resolve(), blue.resolve(), alpha.resolve());
    }
    _red;
    _green;
    _blue;
    _alpha;
    constructor(red, green, blue, alpha) {
      super("rgb");
      this._red = red;
      this._green = green;
      this._blue = blue;
      this._alpha = alpha;
    }
    get red() {
      return this._red;
    }
    get green() {
      return this._green;
    }
    get blue() {
      return this._blue;
    }
    get alpha() {
      return this._alpha;
    }
    resolve() {
      return new _RGB(...Format.resolve(this._red, this._green, this._blue, this._alpha));
    }
    equals(value) {
      return value instanceof _RGB && value._red.equals(this._red) && value._green.equals(this._green) && value._blue.equals(this._blue) && value._alpha.equals(this._alpha);
    }
    hash(hash2) {
      hash2.writeHashable(this._red).writeHashable(this._green).writeHashable(this._blue).writeHashable(this._alpha);
    }
    toJSON() {
      return {
        ...super.toJSON(),
        red: this._red.toJSON(),
        green: this._green.toJSON(),
        blue: this._blue.toJSON(),
        alpha: this._alpha.toJSON()
      };
    }
    toString() {
      return `rgb(${this._red} ${this._green} ${this._blue}${this._alpha.value === 1 ? "" : ` / ${this._alpha}`})`;
    }
  };
  (function(RGB2) {
    function isRGB(value) {
      return value instanceof RGB2;
    }
    RGB2.isRGB = isRGB;
    const parseAlphaLegacy = either16(Number3.parse, Percentage2.parse);
    const parseAlphaModern = either16(Number3.parse, Percentage2.parse, map22(Keyword.parse("none"), () => Percentage2.of(0)));
    const parseItem2 = (parser, ifNone) => either16(parser, ifNone !== void 0 ? map22(Keyword.parse("none"), () => ifNone) : () => Err.of("none is not accepted in legacy rbg syntax"));
    const parseTriplet = (parser, separator, ifNone) => map22(pair6(parseItem2(parser, ifNone), take3(right3(separator, parseItem2(parser, ifNone)), 2)), ([r, [g, b]]) => [r, g, b]);
    const parseLegacyTriplet = (parser) => parseTriplet(parser, delimited8(option8(Token.parseWhitespace), Token.parseComma));
    const parseLegacy2 = pair6(either16(parseLegacyTriplet(Percentage2.parse), parseLegacyTriplet(Number3.parse)), option8(right3(delimited8(option8(Token.parseWhitespace), Token.parseComma), parseAlphaLegacy)));
    const parseModernTriplet = (parser, ifNone) => parseTriplet(parser, option8(Token.parseWhitespace), ifNone);
    const parseModern = pair6(either16(parseModernTriplet(Percentage2.parse, Percentage2.of(0)), parseModernTriplet(Number3.parse, Number3.of(0))), option8(right3(delimited8(option8(Token.parseWhitespace), Token.parseDelim("/")), parseAlphaModern)));
    RGB2.parse = map22(Function.parse((fn) => fn.value === "rgb" || fn.value === "rgba", either16(parseLegacy2, parseModern)), (result) => {
      const [, [[red, green, blue], alpha]] = result;
      return RGB2.of(red, green, blue, alpha.getOrElse(() => Number3.of(1)));
    });
  })(RGB || (RGB = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/color/hex.js
  var { map: map23 } = Parser;
  var Hex = class _Hex extends Format {
    static of(value) {
      return new _Hex(value);
    }
    _value;
    constructor(value) {
      super("hex");
      this._value = value & 4294967295;
    }
    get value() {
      return this._value;
    }
    get red() {
      return Number3.of(this._value >>> 24);
    }
    get green() {
      return Number3.of(this._value >>> 16 & 255);
    }
    get blue() {
      return Number3.of(this._value >>> 8 & 255);
    }
    get alpha() {
      return Number3.of(this._value & 255);
    }
    resolve() {
      return RGB.of(...Format.resolve(this.red, this.green, this.blue, this.alpha));
    }
    equals(value) {
      return value instanceof _Hex && value._value === this._value;
    }
    hash(hash2) {
      hash2.writeUint32(this._value);
    }
    toJSON() {
      return {
        ...super.toJSON(),
        value: this._value
      };
    }
    toString() {
      return `#${this._value.toString(16).padStart(8, "0")}`;
    }
  };
  (function(Hex2) {
    function isHex(value) {
      return value instanceof Hex2;
    }
    Hex2.isHex = isHex;
    Hex2.parse = map23(map23(Token.parseHash((hash2) => {
      switch (hash2.value.length) {
        case 3:
        case 4:
        case 6:
        case 8: {
          return /^[\da-f]*$/i.test(hash2.value);
        }
        default:
          return false;
      }
    }), (hash2) => {
      switch (hash2.value.length) {
        case 3: {
          const [r, g, b] = hash2.value;
          return r + r + g + g + b + b + "ff";
        }
        case 4: {
          const [r, g, b, a] = hash2.value;
          return r + r + g + g + b + b + a + a;
        }
        case 6:
          return hash2.value + "ff";
        default:
          return hash2.value;
      }
    }), (hash2) => Hex2.of(parseInt(hash2, 16)));
  })(Hex || (Hex = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/color/hsl.js
  var { pair: pair7, map: map24, either: either17, option: option9, right: right4, take: take4, delimited: delimited9 } = Parser;
  var HSL = class _HSL extends Format {
    static of(hue, saturation, lightness, alpha) {
      return new _HSL(hue.resolve(), saturation.resolve(), lightness.resolve(), alpha.resolve());
    }
    _hue;
    _saturation;
    _lightness;
    _red;
    _green;
    _blue;
    _alpha;
    constructor(hue, saturation, lightness, alpha) {
      super("hsl");
      this._hue = hue;
      this._saturation = saturation;
      this._lightness = lightness;
      this._alpha = alpha;
      const degrees = Angle2.isAngle(hue) ? hue.withUnit("deg").value : hue.value;
      const [red, green, blue] = hslToRgb(Real.modulo(degrees, 360) / 60, Real.clamp(saturation.value, 0, 1), Real.clamp(lightness.value, 0, 1));
      this._red = Percentage2.of(red);
      this._green = Percentage2.of(green);
      this._blue = Percentage2.of(blue);
    }
    get hue() {
      return this._hue;
    }
    get saturation() {
      return this._saturation;
    }
    get lightness() {
      return this._lightness;
    }
    get red() {
      return this._red;
    }
    get green() {
      return this._green;
    }
    get blue() {
      return this._blue;
    }
    get alpha() {
      return this._alpha;
    }
    resolve() {
      return RGB.of(...Format.resolve(this.red, this.green, this.blue, this.alpha));
    }
    equals(value) {
      return value instanceof _HSL && value._hue.equals(this._hue) && value._saturation.equals(this._saturation) && value._lightness.equals(this._lightness) && value._alpha.equals(this._alpha);
    }
    hash(hash2) {
      hash2.writeHashable(this._hue).writeHashable(this._saturation).writeHashable(this._lightness).writeHashable(this._alpha);
    }
    toJSON() {
      return {
        ...super.toJSON(),
        hue: this._hue.toJSON(),
        saturation: this._saturation.toJSON(),
        lightness: this._lightness.toJSON(),
        alpha: this._alpha.toJSON()
      };
    }
    toString() {
      return `hsl(${this._hue} ${this._saturation} ${this._lightness}${this._alpha.value === 1 ? "" : ` / ${this._alpha}`})`;
    }
  };
  (function(HSL2) {
    function isHSL(value) {
      return value instanceof HSL2;
    }
    HSL2.isHSL = isHSL;
    const parseAlpha = either17(Number3.parse, Percentage2.parse);
    const parseHue = either17(Number3.parse, Angle2.parse);
    const orNone = (parser) => either17(parser, map24(Keyword.parse("none"), () => Percentage2.of(0)));
    const parseTriplet = (separator, acceptNone = false) => map24(pair7(acceptNone ? either17(parseHue, map24(Keyword.parse("none"), () => Number3.of(0))) : parseHue, take4(right4(separator, acceptNone ? orNone(Percentage2.parse) : Percentage2.parse), 2)), ([h2, [s, l]]) => [h2, s, l]);
    const parseModern = pair7(parseTriplet(option9(Token.parseWhitespace), true), option9(right4(delimited9(option9(Token.parseWhitespace), Token.parseDelim("/")), orNone(parseAlpha))));
    const parseLegacy2 = pair7(parseTriplet(delimited9(option9(Token.parseWhitespace), Token.parseComma)), option9(right4(delimited9(option9(Token.parseWhitespace), Token.parseComma), parseAlpha)));
    HSL2.parse = map24(Function.parse((fn) => fn.value === "hsl" || fn.value === "hsla", either17(parseLegacy2, parseModern)), (result) => {
      const [, [[hue, saturation, lightness], alpha]] = result;
      return HSL2.of(hue, saturation, lightness, alpha.getOrElse(() => Number3.of(1)));
    });
  })(HSL || (HSL = {}));
  function hslToRgb(hue, saturation, lightness) {
    const t2 = lightness <= 0.5 ? lightness * (saturation + 1) : lightness + saturation - lightness * saturation;
    const t1 = lightness * 2 - t2;
    return [
      hueToRgb(t1, t2, Real.modulo(hue + 2, 6)),
      hueToRgb(t1, t2, hue),
      hueToRgb(t1, t2, Real.modulo(hue - 2, 6))
    ];
  }
  function hueToRgb(t1, t2, hue) {
    if (hue < 1) {
      return t1 + (t2 - t1) * hue;
    }
    if (hue < 3) {
      return t2;
    }
    if (hue < 4) {
      return t1 + (t2 - t1) * (4 - hue);
    }
    return t1;
  }

  // node_modules/@siteimprove/alfa-css/dist/value/color/named.js
  var { map: map25 } = Parser;
  var Named = class _Named extends Format {
    static of(color) {
      return new _Named(color);
    }
    _color;
    constructor(color) {
      super("named");
      this._color = color;
    }
    get color() {
      return this._color;
    }
    get value() {
      return Colors[this._color];
    }
    get red() {
      return Number3.of(this.value >>> 16);
    }
    get green() {
      return Number3.of(this.value >>> 8 & 255);
    }
    get blue() {
      return Number3.of(this.value & 255);
    }
    get alpha() {
      return Number3.of(this._color === "transparent" ? 0 : 1);
    }
    resolve() {
      return RGB.of(...Format.resolve(this.red, this.green, this.blue, this.alpha));
    }
    equals(value) {
      return value instanceof _Named && value._color === this._color;
    }
    hash(hash2) {
      hash2.writeString(this._color);
    }
    toJSON() {
      return {
        ...super.toJSON(),
        color: this._color
      };
    }
    toString() {
      return this._color;
    }
  };
  (function(Named2) {
    Named2.parse = map25(Token.parseIdent((ident) => ident.value.toLowerCase() in Colors), (ident) => Named2.of(ident.value.toLowerCase()));
  })(Named || (Named = {}));
  var Colors = {
    // The "transparent" color is a little special in that while it is defined
    // in its own section, it's still considered a named color.
    transparent: 0,
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  };

  // node_modules/@siteimprove/alfa-css/dist/value/color/system.js
  var System;
  (function(System2) {
    System2.parse = Keyword.parse("canvas", "canvastext", "linktext", "visitedtext", "activetext", "buttonface", "buttontext", "field", "fieldtext", "highlight", "highlighttext", "graytext");
  })(System || (System = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/color/color.js
  var { either: either18 } = Parser;
  var Color;
  (function(Color3) {
    Color3.current = Keyword.of("currentcolor");
    function hex(value) {
      return Hex.of(value);
    }
    Color3.hex = hex;
    function hsl(hue, saturation, lightness, alpha) {
      return HSL.of(hue, saturation, lightness, alpha);
    }
    Color3.hsl = hsl;
    function named(color) {
      return Named.of(color);
    }
    Color3.named = named;
    function rgb(red, green, blue, alpha) {
      return RGB.of(red, green, blue, alpha);
    }
    Color3.rgb = rgb;
    function system(keyword) {
      return Keyword.of(keyword);
    }
    Color3.system = system;
    Color3.parse = either18(Hex.parse, Named.parse, RGB.parse, HSL.parse, Current.parse, System.parse);
    function isTransparent2(color) {
      switch (color.type) {
        case "keyword":
          return false;
        case "color":
          return color.alpha.value === 0;
      }
    }
    Color3.isTransparent = isTransparent2;
  })(Color || (Color = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/image/gradient/item/hint.js
  var { map: map26 } = Parser;
  var Hint = class _Hint extends Value {
    static of(position) {
      return new _Hint(position);
    }
    _position;
    constructor(position) {
      super("hint", Value.hasCalculation(position));
      this._position = position;
    }
    get position() {
      return this._position;
    }
    resolve(resolver) {
      return new _Hint(LengthPercentage.resolve(resolver)(this._position));
    }
    partiallyResolve(resolver) {
      return new _Hint(LengthPercentage.partiallyResolve(resolver)(this._position));
    }
    equals(value) {
      return value instanceof _Hint && value._position.equals(this._position);
    }
    hash(hash2) {
      hash2.writeHashable(this._position);
    }
    toJSON() {
      return {
        type: "hint",
        position: this._position.toJSON()
      };
    }
    toString() {
      return `${this._position}`;
    }
  };
  (function(Hint2) {
    Hint2.parse = map26(LengthPercentage.parse, Hint2.of);
  })(Hint || (Hint = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/image/gradient/item/stop.js
  var { either: either19, pair: pair8, map: map27, left: left4, right: right5 } = Parser;
  var Stop = class _Stop extends Value {
    static of(color, position = None) {
      return new _Stop(color, position);
    }
    _color;
    _position;
    constructor(color, position) {
      super("stop", Value.hasCalculation(color) || position.map(Value.hasCalculation).getOr(false));
      this._color = color;
      this._position = position;
    }
    get color() {
      return this._color;
    }
    get position() {
      return this._position;
    }
    resolve(resolver) {
      return new _Stop(this._color.resolve(), this._position.map(LengthPercentage.resolve(resolver)));
    }
    partiallyResolve(resolver) {
      return new _Stop(this._color.resolve(), this._position.map(LengthPercentage.partiallyResolve(resolver)));
    }
    equals(value) {
      return value instanceof _Stop && value._color.equals(this._color) && value._position.equals(this._position);
    }
    hash(hash2) {
      hash2.writeHashable(this._color).writeHashable(this._position);
    }
    toJSON() {
      return {
        ...super.toJSON(),
        color: this._color.toJSON(),
        position: this._position.map((position) => position.toJSON()).getOr(null)
      };
    }
    toString() {
      return `${this._color}${this._position.map((position) => ` ${position}`).getOr("")}`;
    }
  };
  (function(Stop2) {
    function isStop(value) {
      return value instanceof Stop2;
    }
    Stop2.isStop = isStop;
    Stop2.parse = either19(map27(pair8(left4(Color.parse, Token.parseWhitespace), LengthPercentage.parse), (result) => {
      const [color, position] = result;
      return Stop2.of(color, Option.of(position));
    }), map27(pair8(LengthPercentage.parse, right5(Token.parseWhitespace, Color.parse)), (result) => {
      const [position, color] = result;
      return Stop2.of(color, Option.of(position));
    }), map27(Color.parse, (color) => Stop2.of(color)));
  })(Stop || (Stop = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/image/gradient/item/item.js
  var { pair: pair9, map: map28, option: option10, left: left5, right: right6, separatedList: separatedList3 } = Parser;
  var Item;
  (function(Item2) {
    function resolve3(resolver) {
      return (value) => value.resolve(resolver);
    }
    Item2.resolve = resolve3;
    const parse57 = pair9(option10(left5(Hint.parse, Comma.parse)), Stop.parse);
    Item2.parseList = map28(pair9(Stop.parse, right6(Comma.parse, separatedList3(parse57, Comma.parse))), ([first, rest]) => {
      const items = [first];
      for (const [hint, stop] of rest) {
        items.push(...hint, stop);
      }
      return items;
    });
  })(Item || (Item = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/image/gradient/linear/position.js
  var { map: map29, either: either20 } = Parser;
  var Position;
  (function(Position3) {
    Position3.parseVertical = map29(Token.parseIdent((ident) => ident.value === "top" || ident.value === "bottom"), (ident) => ident.value);
    Position3.parseHorizontal = map29(Token.parseIdent((ident) => ident.value === "left" || ident.value === "right"), (ident) => ident.value);
    Position3.parse = either20(Position3.parseVertical, Position3.parseHorizontal);
  })(Position || (Position = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/image/gradient/linear/corner.js
  var { map: map30, either: either21, pair: pair10, option: option11, right: right7 } = Parser;
  var Corner = class _Corner extends Value {
    static of(vertical, horizontal) {
      return new _Corner(vertical, horizontal);
    }
    _vertical;
    _horizontal;
    constructor(vertical, horizontal) {
      super("corner", false);
      this._vertical = vertical;
      this._horizontal = horizontal;
    }
    get vertical() {
      return this._vertical;
    }
    get horizontal() {
      return this._horizontal;
    }
    resolve() {
      return this;
    }
    equals(value) {
      return value instanceof _Corner && value._vertical === this._vertical && value._horizontal === this._horizontal;
    }
    hash(hash2) {
      hash2.writeString(this._vertical).writeString(this._horizontal);
    }
    toJSON() {
      return {
        ...super.toJSON(),
        vertical: this._vertical,
        horizontal: this._horizontal
      };
    }
    toString() {
      return `to ${this._vertical} ${this._horizontal}`;
    }
  };
  (function(Corner3) {
    const parseCorner = (side1, side2) => pair10(side1, right7(option11(Token.parseWhitespace), side2));
    Corner3.parse = right7(Token.parseIdent("to"), right7(Token.parseWhitespace, either21(map30(parseCorner(Position.parseVertical, Position.parseHorizontal), ([vertical, horizontal]) => Corner3.of(vertical, horizontal)), map30(parseCorner(Position.parseHorizontal, Position.parseVertical), ([horizontal, vertical]) => Corner3.of(vertical, horizontal)))));
  })(Corner || (Corner = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/image/gradient/linear/side.js
  var { map: map31, option: option12, right: right8 } = Parser;
  var Side = class _Side extends Value {
    static of(side) {
      return new _Side(side);
    }
    _side;
    constructor(side) {
      super("side", false);
      this._side = side;
    }
    get side() {
      return this._side;
    }
    resolve() {
      return this;
    }
    equals(value) {
      return value instanceof _Side && value._side === this._side;
    }
    hash(hash2) {
      hash2.writeString(this._side);
    }
    toJSON() {
      return { ...super.toJSON(), side: this._side };
    }
    toString() {
      return `to ${this._side}`;
    }
  };
  (function(Side3) {
    Side3.parse = map31(right8(Token.parseIdent("to"), right8(option12(Token.parseWhitespace), Position.parse)), (side) => Side3.of(side));
  })(Side || (Side = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/image/gradient/linear/direction.js
  var { either: either22 } = Parser;
  var Direction;
  (function(Direction2) {
    Direction2.parse = either22(
      Angle2.parse,
      // Corners must be parsed before sides as sides are also valid prefixes of
      // corners.
      Corner.parse,
      Side.parse
    );
  })(Direction || (Direction = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/image/gradient/linear/linear.js
  var { map: map32, pair: pair11, option: option13, left: left6 } = Parser;
  var Linear = class _Linear extends Value {
    static of(direction, items, repeats) {
      return new _Linear(direction, Array.from(items), repeats);
    }
    _direction;
    _items;
    _repeats;
    constructor(direction, items, repeats) {
      super("gradient", Value.hasCalculation(direction, ...items));
      this._direction = direction;
      this._items = items;
      this._repeats = repeats;
    }
    get kind() {
      return "linear";
    }
    get direction() {
      return this._direction;
    }
    get items() {
      return this._items;
    }
    get repeats() {
      return this._repeats;
    }
    resolve(resolver) {
      return new _Linear(this._direction.resolve(), this._items.map(Item.resolve(resolver)), this._repeats);
    }
    partiallyResolve(resolver) {
      return new _Linear(this._direction.resolve(), Array.from(Iterable.map(this._items, (item) => item.partiallyResolve(resolver))), this._repeats);
    }
    equals(value) {
      return value instanceof _Linear && value._direction.equals(this._direction) && value._items.length === this._items.length && value._items.every((item, i) => item.equals(this._items[i])) && value._repeats === this._repeats;
    }
    hash(hash2) {
      hash2.writeHashable(this._direction);
      for (const item of this._items) {
        hash2.writeHashable(item);
      }
      hash2.writeUint32(this._items.length).writeBoolean(this._repeats);
    }
    toJSON() {
      return {
        ...super.toJSON(),
        kind: "linear",
        direction: this._direction.toJSON(),
        items: this._items.map((item) => item.toJSON()),
        repeats: this._repeats
      };
    }
    toString() {
      const args = [this._direction, ...this._items].join(", ");
      return `${this._repeats ? "repeating-" : ""}linear-gradient(${args})`;
    }
  };
  (function(Linear2) {
    function isLinear(value) {
      return value instanceof Linear2;
    }
    Linear2.isLinear = isLinear;
    Linear2.parse = map32(Function.parse((fn) => fn.value === "linear-gradient" || fn.value === "repeating-linear-gradient", pair11(option13(left6(Direction.parse, Comma.parse)), Item.parseList)), ([fn, [direction, items]]) => {
      return Linear2.of(direction.getOrElse(() => Side.of("bottom")), items, fn.name.startsWith("repeating"));
    });
  })(Linear || (Linear = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/position/keywords.js
  var Keywords;
  (function(Keywords2) {
    Keywords2.parseCenter = Keyword.parse("center");
    Keywords2.parseVertical = Keyword.parse("top", "bottom");
    Keywords2.parseHorizontal = Keyword.parse("left", "right");
  })(Keywords || (Keywords = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/position/side.js
  var { either: either23, map: map33, pair: pair12, right: right9 } = Parser;
  var Side2 = class _Side extends Value {
    static of(side, offset) {
      return new _Side(side, Option.isOption(offset) ? offset : Option.from(offset));
    }
    _side;
    _offset;
    constructor(side, offset) {
      super("side", offset.some(Value.hasCalculation));
      this._side = side;
      this._offset = offset;
    }
    get side() {
      return this._side;
    }
    get offset() {
      return this._offset;
    }
    resolve(resolver) {
      return new _Side(this._side, this._offset.map(LengthPercentage.resolve(resolver)));
    }
    partiallyResolve(resolver) {
      return new _Side(this._side, this._offset.map(LengthPercentage.partiallyResolve(resolver)));
    }
    equals(value) {
      return value instanceof _Side && value._side.equals(this._side) && value._offset.equals(this._offset);
    }
    hash(hash2) {
      hash2.writeHashable(this._side).writeHashable(this._offset);
    }
    toJSON() {
      return {
        ...super.toJSON(),
        side: this._side.toJSON(),
        offset: this._offset.map((offset) => offset.toJSON()).getOr(null)
      };
    }
    toString() {
      return `${this._side}${this._offset.map((offset) => ` ${offset}`).getOr("")}`;
    }
  };
  (function(Side3) {
    function isSide(value) {
      return value instanceof Side3;
    }
    Side3.isSide = isSide;
    function parseKeyword(parser) {
      return either23(Keywords.parseCenter, map33(parser, (side) => Side3.of(side)));
    }
    function parseKeywordValue(parser) {
      return map33(pair12(parser, right9(Token.parseWhitespace, LengthPercentage.parse)), ([keyword, value]) => Side3.of(keyword, value));
    }
    Side3.parseHorizontalKeywordValue = parseKeywordValue(Keywords.parseHorizontal);
    Side3.parseHorizontalKeyword = parseKeyword(Keywords.parseHorizontal);
    Side3.parseHorizontal = either23(Side3.parseHorizontalKeyword, Side3.parseHorizontalKeywordValue);
    Side3.parseVerticalKeywordValue = parseKeywordValue(Keywords.parseVertical);
    Side3.parseVerticalKeyword = parseKeyword(Keywords.parseVertical);
    Side3.parseVertical = either23(Side3.parseVerticalKeyword, Side3.parseVerticalKeywordValue);
  })(Side2 || (Side2 = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/position/component.js
  var { either: either24, map: map34 } = Parser;
  var Component2;
  (function(Component3) {
    function resolve3(resolver) {
      return (value) => Side2.isSide(value) ? value.resolve(resolver) : value;
    }
    Component3.resolve = resolve3;
    function partiallyResolve(resolver) {
      return (value) => Side2.isSide(value) ? value.partiallyResolve(resolver) : value;
    }
    Component3.partiallyResolve = partiallyResolve;
    function parseOffset(side) {
      return map34(LengthPercentage.parse, (value) => Side2.of(side, value));
    }
    Component3.parseOffset = parseOffset;
    Component3.parseHorizontal = either24(parseOffset(Keyword.of("left")), Side2.parseHorizontal);
    Component3.parseVertical = either24(parseOffset(Keyword.of("top")), Side2.parseVertical);
  })(Component2 || (Component2 = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/position/position.js
  var { map: map35, either: either25, pair: pair13, right: right10 } = Parser;
  var Position2 = class _Position extends Value {
    static of(horizontal, vertical) {
      return new _Position(horizontal, vertical);
    }
    _horizontal;
    _vertical;
    constructor(horizontal, vertical) {
      super("position", Value.hasCalculation(horizontal, vertical));
      this._horizontal = horizontal;
      this._vertical = vertical;
    }
    get horizontal() {
      return this._horizontal;
    }
    get vertical() {
      return this._vertical;
    }
    resolve(resolver) {
      return new _Position(_Position.Component.resolve({
        length: resolver.length,
        percentageBase: resolver.percentageHBase
      })(this._horizontal), _Position.Component.resolve({
        length: resolver.length,
        percentageBase: resolver.percentageVBase
      })(this._vertical));
    }
    partiallyResolve(resolver) {
      return new _Position(_Position.Component.partiallyResolve(resolver)(this._horizontal), _Position.Component.partiallyResolve(resolver)(this._vertical));
    }
    equals(value) {
      return value instanceof _Position && value._horizontal.equals(this._horizontal) && value._vertical.equals(this._vertical);
    }
    hash(hash2) {
      hash2.writeHashable(this._horizontal).writeHashable(this._vertical);
    }
    toJSON() {
      return {
        ...super.toJSON(),
        horizontal: this._horizontal.toJSON(),
        vertical: this._vertical.toJSON()
      };
    }
    toString() {
      return `${this._horizontal} ${this._vertical}`;
    }
  };
  (function(Position3) {
    Position3.Keywords = Keywords;
    Position3.Side = Side2;
    Position3.Component = Component2;
    const mapHV = ([horizontal, vertical]) => Position3.of(horizontal, vertical);
    const mapVH = ([vertical, horizontal]) => Position3.of(horizontal, vertical);
    const { parseHorizontalKeywordValue, parseHorizontalKeyword, parseVerticalKeywordValue, parseVerticalKeyword } = Position3.Side;
    const parse410 = either25(map35(pair13(parseHorizontalKeywordValue, right10(Token.parseWhitespace, parseVerticalKeywordValue)), mapHV), map35(pair13(parseVerticalKeywordValue, right10(Token.parseWhitespace, parseHorizontalKeywordValue)), mapVH));
    const parse310 = either25(map35(either25(pair13(parseHorizontalKeywordValue, right10(Token.parseWhitespace, parseVerticalKeyword)), pair13(parseHorizontalKeyword, right10(Token.parseWhitespace, parseVerticalKeywordValue))), mapHV), map35(either25(pair13(parseVerticalKeywordValue, right10(Token.parseWhitespace, parseHorizontalKeyword)), pair13(parseVerticalKeyword, right10(Token.parseWhitespace, parseHorizontalKeywordValue))), mapVH));
    const parse210 = either25(map35(pair13(either25(parseHorizontalKeyword, Position3.Component.parseOffset(Keyword.of("left"))), right10(Token.parseWhitespace, either25(parseVerticalKeyword, Position3.Component.parseOffset(Keyword.of("top"))))), mapHV), map35(pair13(parseVerticalKeyword, right10(Token.parseWhitespace, parseHorizontalKeyword)), mapVH));
    const parse1 = either25(map35(parseHorizontalKeyword, (horizontal) => Position3.of(horizontal, Keyword.of("center"))), map35(parseVerticalKeyword, (vertical) => Position3.of(Keyword.of("center"), vertical)), map35(Position3.Component.parseOffset(Keyword.of("left")), (horizontal) => Position3.of(horizontal, Keyword.of("center"))));
    function parse57(legacySyntax = false) {
      return either25(parse410, legacySyntax ? parse310 : () => Err.of("Three-value syntax is not allowed"), parse210, parse1);
    }
    Position3.parse = parse57;
  })(Position2 || (Position2 = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/image/gradient/radial/extent.js
  var { map: map36 } = Parser;
  var Extent = class _Extent extends Value {
    static of(shape = _Extent.Shape.Circle, size = _Extent.Size.FarthestCorner) {
      return new _Extent(shape, size);
    }
    _shape;
    _size;
    constructor(shape, size) {
      super("extent", false);
      this._shape = shape;
      this._size = size;
    }
    get shape() {
      return this._shape;
    }
    get size() {
      return this._size;
    }
    resolve() {
      return this;
    }
    equals(value) {
      return value instanceof _Extent && value._shape === this._shape && value._size === this._size;
    }
    hash(hash2) {
      hash2.writeString(this._shape).writeString(this._size);
    }
    toJSON() {
      return {
        ...super.toJSON(),
        shape: this._shape,
        size: this._size
      };
    }
    toString() {
      return `${this._shape} ${this._size}`;
    }
  };
  (function(Extent2) {
    let Shape3;
    (function(Shape4) {
      Shape4["Circle"] = "circle";
      Shape4["Ellipse"] = "ellipse";
    })(Shape3 = Extent2.Shape || (Extent2.Shape = {}));
    let Size;
    (function(Size2) {
      Size2["ClosestSide"] = "closest-side";
      Size2["FarthestSide"] = "farthest-side";
      Size2["ClosestCorner"] = "closest-corner";
      Size2["FarthestCorner"] = "farthest-corner";
    })(Size = Extent2.Size || (Extent2.Size = {}));
    const parseShape = map36(Keyword.parse("circle", "ellipse"), (keyword) => keyword.value);
    const parseSize = map36(Keyword.parse("closest-side", "farthest-side", "closest-corner", "farthest-corner"), (keyword) => keyword.value);
    Extent2.parse = (input) => {
      let shape;
      let size;
      while (true) {
        for ([input] of Token.parseWhitespace(input)) {
        }
        if (shape === void 0) {
          const result = parseShape(input);
          if (result.isOk()) {
            [input, shape] = result.get();
            continue;
          }
        }
        if (size === void 0) {
          const result = parseSize(input);
          if (result.isOk()) {
            [input, size] = result.get();
            continue;
          }
        }
        break;
      }
      if (shape === void 0 && size === void 0) {
        return Err.of(`Expected either an extent shape or size`);
      }
      return Result.of([input, Extent2.of(shape, size)]);
    };
  })(Extent || (Extent = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/image/gradient/radial/circle.js
  var Circle = class _Circle extends Value {
    static of(radius) {
      return new _Circle(radius);
    }
    _radius;
    constructor(radius) {
      super("circle", Value.hasCalculation(radius));
      this._radius = radius;
    }
    get radius() {
      return this._radius;
    }
    resolve(resolver) {
      return new _Circle(this._radius.resolve(resolver));
    }
    equals(value) {
      return value instanceof _Circle && value._radius.equals(this._radius);
    }
    hash(hash2) {
      hash2.writeHashable(this._radius);
    }
    toJSON() {
      return {
        ...super.toJSON(),
        radius: this._radius.toJSON()
      };
    }
    toString() {
      return `circle ${this._radius}`;
    }
  };
  (function(Circle3) {
    const parseShape = Keyword.parse("circle");
    const parseRadius = Length2.parse;
    Circle3.parse = (input) => {
      let shape;
      let radius;
      while (true) {
        for ([input] of Token.parseWhitespace(input)) {
        }
        if (shape === void 0) {
          const result = parseShape(input);
          if (result.isOk()) {
            [input, shape] = result.get();
            continue;
          }
        }
        if (radius === void 0) {
          const result = parseRadius(input);
          if (result.isOk()) {
            [input, radius] = result.get();
            continue;
          }
        }
        break;
      }
      if (radius === void 0) {
        return Err.of(`Expected circle radius`);
      }
      return Result.of([input, Circle3.of(radius)]);
    };
  })(Circle || (Circle = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/image/gradient/radial/ellipse.js
  var { option: option14, separatedList: separatedList4 } = Parser;
  var Ellipse = class _Ellipse extends Value {
    static of(horizontal, vertical) {
      return new _Ellipse(horizontal, vertical);
    }
    _horizontal;
    _vertical;
    constructor(horizontal, vertical) {
      super("ellipse", Value.hasCalculation(horizontal, vertical));
      this._horizontal = horizontal;
      this._vertical = vertical;
    }
    get horizontal() {
      return this._horizontal;
    }
    get vertical() {
      return this._vertical;
    }
    resolve(resolver) {
      return new _Ellipse(LengthPercentage.resolve(resolver)(this._horizontal), LengthPercentage.resolve(resolver)(this._vertical));
    }
    partiallyResolve(resolver) {
      return new _Ellipse(LengthPercentage.partiallyResolve(resolver)(this._horizontal), LengthPercentage.partiallyResolve(resolver)(this._vertical));
    }
    equals(value) {
      return value instanceof _Ellipse && value._horizontal.equals(this._horizontal) && value._vertical.equals(this._vertical);
    }
    hash(hash2) {
      hash2.writeHashable(this._horizontal).writeHashable(this._vertical);
    }
    toJSON() {
      return {
        type: "ellipse",
        horizontal: this._horizontal.toJSON(),
        vertical: this._vertical.toJSON()
      };
    }
    toString() {
      return `ellipse ${this._horizontal} ${this._vertical}`;
    }
  };
  (function(Ellipse3) {
    function isEllipse(value) {
      return value instanceof Ellipse3;
    }
    Ellipse3.isEllipse = isEllipse;
    const parseShape = Keyword.parse("ellipse");
    const parseSize = separatedList4(LengthPercentage.parse, option14(Token.parseWhitespace), 2, 2);
    Ellipse3.parse = (input) => {
      let shape;
      let horizontal;
      let vertical;
      while (true) {
        for ([input] of Token.parseWhitespace(input)) {
        }
        if (shape === void 0) {
          const result = parseShape(input);
          if (result.isOk()) {
            [input, shape] = result.get();
            continue;
          }
        }
        if (horizontal === void 0 || vertical === void 0) {
          const result = parseSize(input);
          if (result.isOk()) {
            [input, [horizontal, vertical]] = result.get();
            continue;
          }
        }
        break;
      }
      if (horizontal === void 0 || vertical === void 0) {
        return Err.of(`Expected ellipse size`);
      }
      return Result.of([input, Ellipse3.of(horizontal, vertical)]);
    };
  })(Ellipse || (Ellipse = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/image/gradient/radial/shape.js
  var { either: either26 } = Parser;
  var Shape;
  (function(Shape3) {
    function partiallyResolve(resolver) {
      return (value) => Selective.of(value).if(Ellipse.isEllipse, (ellipse) => ellipse.partiallyResolve(resolver)).else((value2) => value2.resolve(resolver)).get();
    }
    Shape3.partiallyResolve = partiallyResolve;
    Shape3.parse = either26(Ellipse.parse, Circle.parse, Extent.parse);
  })(Shape || (Shape = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/image/gradient/radial/radial.js
  var { map: map37, either: either27, pair: pair14, option: option15, left: left7, right: right11, delimited: delimited10 } = Parser;
  var Radial = class _Radial extends Value {
    static of(shape, position, items, repeats) {
      return new _Radial(shape, position, Array.from(items), repeats);
    }
    _shape;
    _position;
    _items;
    _repeats;
    constructor(shape, position, items, repeats) {
      super("gradient", Value.hasCalculation(shape, position, ...items));
      this._shape = shape;
      this._position = position;
      this._items = items;
      this._repeats = repeats;
    }
    get kind() {
      return "radial";
    }
    get shape() {
      return this._shape;
    }
    get position() {
      return this._position;
    }
    get items() {
      return this._items;
    }
    get repeats() {
      return this._repeats;
    }
    resolve(resolver) {
      return new _Radial(this._shape.resolve(resolver), this._position.resolve(resolver), this._items.map(Item.resolve(resolver)), this._repeats);
    }
    partiallyResolve(resolver) {
      return new _Radial(Shape.partiallyResolve(resolver)(this._shape), this._position.partiallyResolve(resolver), Array.from(Iterable.map(this._items, (item) => item.partiallyResolve(resolver))), this._repeats);
    }
    equals(value) {
      return value instanceof _Radial && value._shape.equals(this._shape) && value._position.equals(this._position) && value._items.length === this._items.length && value._items.every((item, i) => item.equals(this._items[i])) && value._repeats === this._repeats;
    }
    hash(hash2) {
      hash2.writeHashable(this._shape).writeHashable(this._position);
      for (const item of this._items) {
        hash2.writeHashable(item);
      }
      hash2.writeUint32(this._items.length).writeBoolean(this._repeats);
    }
    toJSON() {
      return {
        ...super.toJSON(),
        kind: "radial",
        shape: this._shape.toJSON(),
        position: this._position.toJSON(),
        items: this._items.map((item) => item.toJSON()),
        repeats: this._repeats
      };
    }
    toString() {
      const args = [`${this._shape} at ${this._position}`, ...this._items].join(", ");
      return `${this._repeats ? "repeating-" : ""}radial-gradient(${args})`;
    }
  };
  (function(Radial2) {
    function isRadial(value) {
      return value instanceof Radial2;
    }
    Radial2.isRadial = isRadial;
    const parsePosition = right11(delimited10(option15(Token.parseWhitespace), Keyword.parse("at")), Position2.parse(
      false
      /* legacySyntax */
    ));
    Radial2.parse = map37(Function.parse((fn) => fn.value === "radial-gradient" || fn.value === "repeating-radial-gradient", pair14(option15(left7(either27(pair14(map37(Shape.parse, (shape) => Option.of(shape)), option15(delimited10(option15(Token.parseWhitespace), parsePosition))), map37(parsePosition, (position) => [None, Option.of(position)])), Comma.parse)), Item.parseList)), (result) => {
      const [fn, [shapeAndPosition, items]] = result;
      const shape = shapeAndPosition.flatMap(([shape2]) => shape2).getOrElse(() => Extent.of());
      const position = shapeAndPosition.flatMap(([, position2]) => position2).getOrElse(() => Position2.of(Keyword.of("center"), Keyword.of("center")));
      return Radial2.of(shape, position, items, fn.name.startsWith("repeating"));
    });
  })(Radial || (Radial = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/image/gradient/gradient.js
  var { either: either28 } = Parser;
  var Gradient;
  (function(Gradient2) {
    Gradient2.Item = Item;
    Gradient2.Linear = Linear;
    Gradient2.Radial = Radial;
    Gradient2.parse = either28(Gradient2.Linear.parse, Gradient2.Radial.parse);
  })(Gradient || (Gradient = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/textual/url.js
  var { map: map38, either: either29 } = Parser;
  var URL2 = class _URL extends Value {
    static of(url) {
      return new _URL(url);
    }
    _url;
    constructor(url) {
      super("url", false);
      this._url = url;
    }
    get url() {
      return this._url;
    }
    resolve() {
      return this;
    }
    equals(value) {
      return value instanceof _URL && value._url === this._url;
    }
    hash(hash2) {
      hash2.writeString(this._url);
    }
    toJSON() {
      return {
        ...super.toJSON(),
        url: this._url
      };
    }
    toString() {
      return `url(${this._url})`;
    }
  };
  (function(URL4) {
    function isURL(value) {
      return value instanceof URL4;
    }
    URL4.isURL = isURL;
    URL4.parse = map38(either29(Token.parseURL(), map38(Function.parse("url", Token.parseString()), ([_, url]) => url)), (url) => URL4.of(url.value));
  })(URL2 || (URL2 = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/image/image.js
  var { map: map39, either: either30 } = Parser;
  var Image = class _Image extends Value {
    static of(image) {
      return new _Image(image);
    }
    _image;
    constructor(image) {
      super("image", Value.hasCalculation(image));
      this._image = image;
    }
    get image() {
      return this._image;
    }
    resolve(resolver) {
      return new _Image(this._image.resolve(resolver));
    }
    partiallyResolve(resolver) {
      return _Image.of(Selective.of(this._image).if(URL2.isURL, (url) => url.resolve()).else((gradient) => gradient.partiallyResolve(resolver)).get());
    }
    equals(value) {
      return value instanceof _Image && value._image.equals(this._image);
    }
    hash(hash2) {
      hash2.writeHashable(this._image);
    }
    toJSON() {
      return {
        ...super.toJSON(),
        image: this._image.toJSON()
      };
    }
    toString() {
      return `${this._image}`;
    }
  };
  (function(Image2) {
    function isImage(value) {
      return value instanceof Image2;
    }
    Image2.isImage = isImage;
    Image2.parse = map39(either30(URL2.parse, Gradient.parse), Image2.of);
  })(Image || (Image = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/shadow.js
  var { parseIf: parseIf2, separatedList: separatedList5 } = Parser;
  var Shadow = class _Shadow extends Value {
    static of(horizontal, vertical, blur, spread, color, isInset) {
      return new _Shadow(horizontal, vertical, blur, spread, color, isInset);
    }
    _horizontal;
    _vertical;
    _blur;
    _spread;
    _color;
    _isInset;
    constructor(horizontal, vertical, blur, spread, color, isInset) {
      super("shadow", Value.hasCalculation(horizontal, vertical, blur, spread, color));
      this._horizontal = horizontal;
      this._vertical = vertical;
      this._blur = blur;
      this._spread = spread;
      this._color = color;
      this._isInset = isInset;
    }
    get horizontal() {
      return this._horizontal;
    }
    get vertical() {
      return this._vertical;
    }
    get blur() {
      return this._blur;
    }
    get spread() {
      return this._spread;
    }
    get color() {
      return this._color;
    }
    get isInset() {
      return this._isInset;
    }
    resolve(resolver) {
      return new _Shadow(this._horizontal.resolve(resolver), this._vertical.resolve(resolver), this._blur.resolve(resolver), this._spread.resolve(resolver), this._color.resolve(), this._isInset);
    }
    equals(value) {
      return value instanceof _Shadow && value._horizontal.equals(this._horizontal) && value._vertical.equals(this._vertical) && value._blur.equals(this._blur) && value._spread.equals(this._spread) && value._color.equals(this._color) && value._isInset === this._isInset;
    }
    hash(hash2) {
      hash2.writeHashable(this._horizontal).writeHashable(this._vertical).writeHashable(this._blur).writeHashable(this._spread).writeHashable(this._color).writeBoolean(this._isInset);
    }
    toJSON() {
      return {
        ...super.toJSON(),
        horizontal: this._horizontal.toJSON(),
        vertical: this._vertical.toJSON(),
        blur: this._blur.toJSON(),
        spread: this._spread.toJSON(),
        color: this._color.toJSON(),
        isInset: this._isInset
      };
    }
    toString() {
      return `${this._color} ${this._horizontal} ${this._vertical} ${this._blur} ${this._spread}${this._isInset ? " inset" : ""}`;
    }
  };
  (function(Shadow3) {
    function checkLength(max5) {
      return (array) => array.length >= 2 && array.length <= max5;
    }
    function parseLengths(max5) {
      return parseIf2(checkLength(max5), separatedList5(Length2.parse, Token.parseWhitespace), () => `Shadows must have between 2 and ${max5} lengths`);
    }
    function parse57(options) {
      const { withInset = true, withSpread = true } = options ?? {};
      return (input) => {
        let horizontal;
        let vertical;
        let blur;
        let spread;
        let color;
        let isInset;
        const skipWhitespace = () => {
          for (const [remainder] of Token.parseWhitespace(input)) {
            input = remainder;
          }
        };
        while (true) {
          skipWhitespace();
          if (horizontal === void 0) {
            const result = parseLengths(withSpread ? 4 : 3)(input);
            if (result.isOk()) {
              [input, [horizontal, vertical, blur, spread]] = result.get();
              continue;
            }
          }
          if (color === void 0) {
            const result = Color.parse(input);
            if (result.isOk()) {
              [input, color] = result.get();
              continue;
            }
          }
          if (isInset === void 0) {
            const result = Keyword.parse("inset")(input);
            if (result.isOk()) {
              if (!withInset) {
                return Err.of("Inset is not allowed in this shadow");
              }
              isInset = true;
              [input] = result.get();
              continue;
            }
          }
          break;
        }
        if (horizontal === void 0 || vertical === void 0) {
          return Err.of("Expected horizontal and vertical offset");
        }
        return Result.of([
          input,
          Shadow3.of(horizontal, vertical, blur ?? Length2.of(0, Unit.Length.Canonical), spread ?? Length2.of(0, Unit.Length.Canonical), color ?? Keyword.of("currentcolor"), isInset ?? false)
        ]);
      };
    }
    Shadow3.parse = parse57;
  })(Shadow || (Shadow = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/shape/basic-shape.js
  var BasicShape = class extends Value {
    _kind;
    constructor(kind, hasCalculation) {
      super("basic-shape", hasCalculation);
      this._kind = kind;
    }
    get kind() {
      return this._kind;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        kind: this._kind
      };
    }
  };

  // node_modules/@siteimprove/alfa-css/dist/value/shape/radius.js
  var { either: either31, filter: filter2, map: map40 } = Parser;
  var Radius = class _Radius extends BasicShape {
    static of(value) {
      return new _Radius(value);
    }
    _value;
    constructor(value) {
      super("radius", Value.hasCalculation(value));
      this._value = value;
    }
    get value() {
      return this._value;
    }
    resolve(resolver) {
      if (Keyword.isKeyword(this._value)) {
        return this;
      }
      const resolved = LengthPercentage.resolve(resolver)(this._value);
      return new _Radius(LengthPercentage.of(Real.clamp(resolved.value, 0, Infinity), resolved.unit));
    }
    partiallyResolve(resolver) {
      if (Keyword.isKeyword(this._value)) {
        return this;
      }
      const resolved = LengthPercentage.partiallyResolve(resolver)(this._value);
      if (resolved.hasCalculation()) {
        return _Radius.of(resolved);
      }
      const clamped = Real.clamp(resolved.value, 0, Infinity);
      return _Radius.of(LengthPercentage.isPercentage(resolved) ? LengthPercentage.of(clamped) : LengthPercentage.of(clamped, resolved.unit));
    }
    equals(value) {
      return value instanceof _Radius && value._value.equals(this._value);
    }
    hash(hash2) {
      hash2.writeHashable(this._value);
    }
    toJSON() {
      return {
        ...super.toJSON(),
        value: this._value.toJSON()
      };
    }
    toString() {
      return this.value.toString();
    }
  };
  (function(Radius2) {
    function isRadius(value) {
      return value instanceof Radius2;
    }
    Radius2.isRadius = isRadius;
    Radius2.parse = map40(either31(filter2(
      LengthPercentage.parse,
      // https://drafts.csswg.org/css-values/#calc-range
      (value) => value.hasCalculation() || value.value >= 0,
      () => "Radius cannot be negative"
    ), Keyword.parse("closest-side", "farthest-side")), (radius) => Radius2.of(radius));
  })(Radius || (Radius = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/shape/circle.js
  var { map: map41, option: option16, pair: pair15, right: right12 } = Parser;
  var Circle2 = class _Circle extends BasicShape {
    static of(radius, center) {
      return new _Circle(radius, center);
    }
    _radius;
    _center;
    constructor(radius, center) {
      super("circle", Value.hasCalculation(radius, center));
      this._radius = radius;
      this._center = center;
    }
    get radius() {
      return this._radius;
    }
    get center() {
      return this._center;
    }
    resolve(resolver) {
      return new _Circle(this._radius.resolve(resolver), this._center.resolve(resolver));
    }
    partiallyResolve(resolver) {
      return new _Circle(this._radius.partiallyResolve(resolver), this._center.partiallyResolve(resolver));
    }
    equals(value) {
      return value instanceof _Circle && value._radius.equals(this._radius) && value._center.equals(this._center);
    }
    hash(hash2) {
      hash2.writeHashable(this._radius).writeHashable(this._center);
    }
    toJSON() {
      return {
        ...super.toJSON(),
        radius: this._radius.toJSON(),
        center: this._center.toJSON()
      };
    }
    toString() {
      return `circle(${this._radius.toString()} at ${this._center.toString()})`;
    }
  };
  (function(Circle3) {
    function isCircle(value) {
      return value instanceof Circle3;
    }
    Circle3.isCircle = isCircle;
    Circle3.parse = map41(Function.parse("circle", pair15(option16(Radius.parse), option16(right12(option16(Token.parseWhitespace), right12(Keyword.parse("at"), right12(Token.parseWhitespace, Position2.parse())))))), ([_, [radius, center]]) => Circle3.of(radius.getOr(Radius.of(Keyword.of("closest-side"))), center.getOr(Position2.of(Keyword.of("center"), Keyword.of("center")))));
  })(Circle2 || (Circle2 = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/shape/ellipse.js
  var { map: map42, option: option17, pair: pair16, right: right13 } = Parser;
  var Ellipse2 = class _Ellipse extends BasicShape {
    static of(rx, ry, center) {
      return new _Ellipse(rx, ry, center);
    }
    _rx;
    _ry;
    _center;
    constructor(rx, ry, center) {
      super(
        "ellipse",
        // TS sees the first as Value.HasCalculation<[R, R, P]>
        Value.hasCalculation(rx, ry, center)
      );
      this._rx = rx;
      this._ry = ry;
      this._center = center;
    }
    get rx() {
      return this._rx;
    }
    get ry() {
      return this._ry;
    }
    get center() {
      return this._center;
    }
    resolve(resolver) {
      return new _Ellipse(this._rx.resolve(resolver), this._ry.resolve(resolver), this._center.resolve(resolver));
    }
    partiallyResolve(resolver) {
      return new _Ellipse(this._rx.partiallyResolve(resolver), this._ry.partiallyResolve(resolver), this._center.partiallyResolve(resolver));
    }
    equals(value) {
      return value instanceof _Ellipse && value._rx.equals(this._rx) && value._ry.equals(this._ry) && value._center.equals(this._center);
    }
    hash(hash2) {
      hash2.writeHashable(this._rx).writeHashable(this._ry).writeHashable(this._center);
    }
    toJSON() {
      return {
        ...super.toJSON(),
        rx: this._rx.toJSON(),
        ry: this._ry.toJSON(),
        center: this._center.toJSON()
      };
    }
    toString() {
      return `ellipse(${this._rx} ${this._ry} at ${this._center})`;
    }
  };
  (function(Ellipse3) {
    function isEllipse(value) {
      return value instanceof Ellipse3;
    }
    Ellipse3.isEllipse = isEllipse;
    Ellipse3.parse = map42(Function.parse("ellipse", pair16(option17(pair16(Radius.parse, right13(Token.parseWhitespace, Radius.parse))), option17(right13(option17(Token.parseWhitespace), right13(Keyword.parse("at"), right13(Token.parseWhitespace, Position2.parse())))))), ([_, [radii, center]]) => {
      const [rx, ry] = radii.getOr([
        Radius.of(Keyword.of("closest-side")),
        Radius.of(Keyword.of("closest-side"))
      ]);
      return Ellipse3.of(rx, ry, center.getOr(Position2.of(Keyword.of("center"), Keyword.of("center"))));
    });
  })(Ellipse2 || (Ellipse2 = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/shape/corner.js
  var Corner2;
  (function(Corner3) {
    function hasCalculation(corner) {
      return LengthPercentage.isLengthPercentage(corner) ? Value.hasCalculation(corner) : Value.hasCalculation(corner[0] || Value.hasCalculation(corner[1]));
    }
    Corner3.hasCalculation = hasCalculation;
    function resolve3(resolver) {
      function resolveAndClamp(radius) {
        const resolved = LengthPercentage.resolve(resolver)(radius);
        return LengthPercentage.of(Real.clamp(resolved.value, 0, Infinity), resolved.unit);
      }
      return (value) => LengthPercentage.isLengthPercentage(value) ? resolveAndClamp(value) : [resolveAndClamp(value[0]), resolveAndClamp(value[1])];
    }
    Corner3.resolve = resolve3;
    function partiallyResolve(resolver) {
      function resolveAndClamp(radius) {
        const resolved = LengthPercentage.partiallyResolve(resolver)(radius);
        if (resolved.hasCalculation()) {
          return resolved;
        }
        const clamped = Real.clamp(resolved.value, 0, Infinity);
        return LengthPercentage.isPercentage(resolved) ? LengthPercentage.of(clamped) : LengthPercentage.of(clamped, resolved.unit);
      }
      return (value) => LengthPercentage.isLengthPercentage(value) ? resolveAndClamp(value) : [resolveAndClamp(value[0]), resolveAndClamp(value[1])];
    }
    Corner3.partiallyResolve = partiallyResolve;
  })(Corner2 || (Corner2 = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/shape/inset.js
  var { delimited: delimited11, filter: filter3, map: map43, option: option18, pair: pair17, right: right14, separatedList: separatedList6 } = Parser;
  var { parseDelim, parseWhitespace } = Token;
  var Inset = class _Inset extends BasicShape {
    static of(offsets, corners) {
      return new _Inset(offsets, corners);
    }
    _offsets;
    _corners;
    constructor(offsets, corners) {
      super("inset", Value.hasCalculation(...offsets) || corners.some((corners2) => corners2.some(Corner2.hasCalculation)));
      this._offsets = offsets;
      this._corners = corners;
    }
    get offsets() {
      return this._offsets;
    }
    get corners() {
      return this._corners;
    }
    get top() {
      return this._offsets[0];
    }
    get right() {
      return this._offsets[1];
    }
    get bottom() {
      return this._offsets[2];
    }
    get left() {
      return this._offsets[3];
    }
    get topLeft() {
      return this._corners.map((corners) => corners[0]);
    }
    get topRight() {
      return this._corners.map((corners) => corners[1]);
    }
    get bottomRight() {
      return this._corners.map((corners) => corners[2]);
    }
    get bottomLeft() {
      return this._corners.map((corners) => corners[3]);
    }
    resolve(resolver) {
      return new _Inset(this._offsets.map(LengthPercentage.resolve(resolver)), this._corners.map((corners) => corners.map(Corner2.resolve(resolver))));
    }
    partiallyResolve(resolver) {
      return new _Inset(this._offsets.map(LengthPercentage.partiallyResolve(resolver)), this._corners.map((corners) => corners.map(Corner2.partiallyResolve(resolver))));
    }
    equals(value) {
      return value instanceof _Inset && Array2.equals(value._offsets, this._offsets) && value._corners.equals(this._corners);
    }
    hash(hash2) {
      Array2.hash(this._offsets, hash2);
      hash2.writeHashable(this._corners);
    }
    toJSON() {
      return {
        ...super.toJSON(),
        offsets: Array2.toJSON(this._offsets),
        corners: this._corners.toJSON()
      };
    }
    toString() {
      const result = `ellipse(${this.top} ${this.right} ${this.bottom} ${this.left}`;
      for (const corners of this._corners) {
        if (corners.some((corner) => Array2.isArray(corner))) {
          const [tlh, tlv] = Array2.isArray(this.topLeft) ? this.topLeft : [this.topLeft, this.topLeft];
          const [trh, trv] = Array2.isArray(this.topRight) ? this.topRight : [this.topRight, this.topRight];
          const [brh, brv] = Array2.isArray(this.bottomRight) ? this.bottomRight : [this.bottomRight, this.bottomRight];
          const [blh, blv] = Array2.isArray(this.bottomLeft) ? this.bottomLeft : [this.bottomLeft, this.bottomLeft];
          return result + `${tlh} ${trh} ${brh} ${blh} / ${tlv} ${trv} ${brv} ${blv})`;
        } else {
          return result + `${this.topLeft} ${this.topRight} ${this.bottomRight} ${this.bottomLeft})`;
        }
      }
      return result + ")";
    }
  };
  (function(Inset2) {
    function isInset(value) {
      return value instanceof Inset2;
    }
    Inset2.isInset = isInset;
    const parseOffsets = map43(separatedList6(LengthPercentage.parse, option18(parseWhitespace), 1, 4), ([top, right38 = top, bottom = top, left22 = right38]) => [top, right38, bottom, left22]);
    const parseRadius = filter3(
      LengthPercentage.parse,
      // https://drafts.csswg.org/css-values/#calc-range
      (value) => value.hasCalculation() || value.value >= 0,
      () => "Radius cannot be negative"
    );
    const parseRadii = map43(separatedList6(parseRadius, option18(parseWhitespace), 1, 4), ([topLeft, topRight = topLeft, bottomRight = topLeft, bottomLeft = topRight]) => [topLeft, topRight, bottomRight, bottomLeft]);
    const parseCorners = map43(pair17(parseRadii, option18(right14(delimited11(option18(parseWhitespace), parseDelim("/")), parseRadii))), ([horizontal, vertical]) => vertical.map((vertical2) => [
      [horizontal[0], vertical2[0]],
      [horizontal[1], vertical2[1]],
      [horizontal[2], vertical2[2]],
      [horizontal[3], vertical2[3]]
    ]).getOr(horizontal));
    Inset2.parse = map43(Function.parse("inset", pair17(parseOffsets, option18(right14(option18(Token.parseWhitespace), right14(Keyword.parse("round"), right14(Token.parseWhitespace, parseCorners)))))), ([_, [offsets, corners]]) => Inset2.of(offsets, corners));
  })(Inset || (Inset = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/shape/polygon.js
  var { left: left8, map: map44, option: option19, pair: pair18, right: right15, separated, separatedList: separatedList7 } = Parser;
  var { parseComma, parseWhitespace: parseWhitespace2 } = Token;
  var Polygon = class _Polygon extends BasicShape {
    static of(fill, vertices) {
      return new _Polygon(fill, Array2.from(vertices));
    }
    _fill;
    _vertices;
    constructor(fill, vertices) {
      super("polygon", vertices.reduce((calc, vertex) => calc || Value.hasCalculation(...vertex), false));
      this._fill = fill;
      this._vertices = vertices;
    }
    get fill() {
      return this._fill;
    }
    get vertices() {
      return this._vertices;
    }
    resolve(resolver) {
      return new _Polygon(this._fill, this._vertices.map((vertex) => (
        // map loses the fact that vertex has exactly two elements.
        vertex.map(LengthPercentage.resolve(resolver))
      )));
    }
    partiallyResolve(resolver) {
      return new _Polygon(this._fill, this._vertices.map((vertex) => (
        // map loses the fact that vertex has exactly two elements.
        vertex.map(LengthPercentage.partiallyResolve(resolver))
      )));
    }
    equals(value) {
      return value instanceof _Polygon && value._fill.equals(this._fill) && Array2.equals(value._vertices, this._vertices);
    }
    hash(hash2) {
      hash2.writeHashable(this._fill);
      Array2.hash(this._vertices, hash2);
    }
    toJSON() {
      return {
        ...super.toJSON(),
        fill: this._fill.toJSON(),
        vertices: Array2.toJSON(this._vertices)
      };
    }
    toString() {
      const fill = this._fill.reduce((_, fill2) => `${fill2}, `, "");
      const vertices = this._vertices.map(([h2, v]) => `${h2} ${v}`).join(" ");
      return `polygon(${fill}${vertices})`;
    }
  };
  (function(Polygon2) {
    function isPolygon(value) {
      return value instanceof Polygon2;
    }
    Polygon2.isPolygon = isPolygon;
    const parseVertex = separated(LengthPercentage.parse, parseWhitespace2, LengthPercentage.parse);
    Polygon2.parse = map44(Function.parse("polygon", pair18(option19(left8(Keyword.parse("nonzero", "evenodd"), parseComma)), right15(option19(parseWhitespace2), separatedList7(parseVertex, parseWhitespace2)))), ([_, [fill, vertices]]) => Polygon2.of(fill, vertices));
  })(Polygon || (Polygon = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/shape/rectangle.js
  var { either: either32, map: map45, option: option20, separatedList: separatedList8 } = Parser;
  var Rectangle = class _Rectangle extends BasicShape {
    static of(top, right38, bottom, left22) {
      return new _Rectangle(top, right38, bottom, left22);
    }
    _top;
    _right;
    _bottom;
    _left;
    constructor(top, right38, bottom, left22) {
      super("rectangle", Value.hasCalculation(top, right38, bottom, left22));
      this._top = top;
      this._right = right38;
      this._bottom = bottom;
      this._left = left22;
    }
    get top() {
      return this._top;
    }
    get right() {
      return this._right;
    }
    get bottom() {
      return this._bottom;
    }
    get left() {
      return this._left;
    }
    resolve(resolver) {
      return new _Rectangle(this._top.resolve(resolver), this._right.resolve(resolver), this._bottom.resolve(resolver), this._left.resolve(resolver));
    }
    equals(value) {
      return value instanceof _Rectangle && value._top.equals(this._top) && value._right.equals(this._right) && value._bottom.equals(this._bottom) && value._left.equals(this._left);
    }
    hash(hash2) {
      hash2.writeHashable(this._top).writeHashable(this._right).writeHashable(this._bottom).writeHashable(this._left);
    }
    toJSON() {
      return {
        ...super.toJSON(),
        top: this._top.toJSON(),
        right: this._right.toJSON(),
        bottom: this._bottom.toJSON(),
        left: this._left.toJSON()
      };
    }
    toString() {
      return `rect(${this._top}, ${this._right}, ${this._bottom}, ${this._left})`;
    }
  };
  (function(Rectangle3) {
    function isRectangle(value) {
      return value instanceof Rectangle3;
    }
    Rectangle3.isRectangle = isRectangle;
    const parseLengthAuto = either32(Length2.parse, Keyword.parse("auto"));
    Rectangle3.parse = map45(Function.parse("rect", either32(separatedList8(parseLengthAuto, option20(Token.parseWhitespace), 4, 4), separatedList8(parseLengthAuto, Comma.parse, 4, 4))), ([_, [top, right38, bottom, left22]]) => Rectangle3.of(top, right38, bottom, left22));
  })(Rectangle || (Rectangle = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/shape/shape.js
  var { either: either33 } = Parser;
  var Shape2 = class _Shape extends Value {
    static of(shape, box) {
      return new _Shape(shape, box);
    }
    _shape;
    _box;
    constructor(shape, box) {
      super("shape", Value.hasCalculation(shape));
      this._shape = shape;
      this._box = box;
    }
    get shape() {
      return this._shape;
    }
    get box() {
      return this._box;
    }
    resolve(resolver) {
      return new _Shape(this._shape.resolve(resolver), this._box);
    }
    partiallyResolve(resolver) {
      return _Shape.of(_Shape.Basic.partiallyResolve(resolver)(this._shape), this._box);
    }
    equals(value) {
      return value instanceof _Shape && value._shape.equals(this._shape) && value._box.equals(this._box);
    }
    hash(hash2) {
      hash2.writeHashable(this._shape).writeHashable(this._box);
    }
    toJSON() {
      return {
        ...super.toJSON(),
        shape: this._shape.toJSON(),
        box: this._box.toJSON()
      };
    }
    toString() {
      return `${this._shape.toString()} ${this._box.toString()}`;
    }
  };
  (function(Shape3) {
    let Basic;
    (function(Basic2) {
      function partiallyResolve(resolver) {
        return (value) => Selective.of(value).if(Rectangle.isRectangle, (rectangle) => rectangle.resolve(resolver)).else((value2) => value2.partiallyResolve(resolver)).get();
      }
      Basic2.partiallyResolve = partiallyResolve;
      Basic2.parse = either33(Circle2.parse, Ellipse2.parse, Inset.parse, Polygon.parse);
    })(Basic = Shape3.Basic || (Shape3.Basic = {}));
    Shape3.parse = (input) => {
      let shape;
      let box;
      const skipWhitespace = () => {
        for (const [remainder] of Token.parseWhitespace(input)) {
          input = remainder;
        }
      };
      while (true) {
        skipWhitespace();
        if (shape === void 0) {
          const result = Basic.parse(input);
          if (result.isOk()) {
            [input, shape] = result.get();
            continue;
          }
        }
        if (box === void 0) {
          const result = Box.parseGeometry(input);
          if (result.isOk()) {
            [input, box] = result.get();
            continue;
          }
        }
        break;
      }
      if (shape === void 0) {
        return Err.of("Expected a shape");
      }
      return Result.of([input, Shape3.of(shape, box ?? Keyword.of("border-box"))]);
    };
  })(Shape2 || (Shape2 = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/textual/custom-ident.js
  var { map: map46 } = Parser;
  var CustomIdent = class _CustomIdent extends Ident {
    static of(value) {
      return new _CustomIdent(value);
    }
    constructor(value) {
      super("custom-ident", value);
    }
    equals(value) {
      return value instanceof _CustomIdent && super.equals(value);
    }
  };
  (function(CustomIdent2) {
    function isCustomIdent(value) {
      return value instanceof CustomIdent2;
    }
    CustomIdent2.isCustomIdent = isCustomIdent;
    const illegalCustomIdents2 = ["initial", "inherit", "unset", "default"];
    function parse57(predicate = () => true) {
      return map46(Token.parseIdent((ident) => !illegalCustomIdents2.includes(String2.toLowerCase(ident.value)) && predicate(ident.value)), (ident) => CustomIdent2.of(ident.value));
    }
    CustomIdent2.parse = parse57;
  })(CustomIdent || (CustomIdent = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/textual/string.js
  var { map: map47 } = Parser;
  var String3 = class _String extends Value {
    static of(value) {
      return new _String(value);
    }
    _value;
    constructor(value) {
      super("string", false);
      this._value = value;
    }
    get value() {
      return this._value;
    }
    resolve() {
      return this;
    }
    equals(value) {
      return value instanceof _String && value._value === this._value;
    }
    hash(hash2) {
      hash2.writeString(this._value);
    }
    toJSON() {
      return {
        ...super.toJSON(),
        value: this._value
      };
    }
    toString() {
      return `"${this._value.replace(/"/g, '\\"')}"`;
    }
  };
  (function(String4) {
    function isString3(value) {
      return value instanceof String4;
    }
    String4.isString = isString3;
    String4.parse = map47(Token.parseString(), (string) => String4.of(string.value));
  })(String3 || (String3 = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/transform/function.js
  var Function3 = class extends Value {
    _kind;
    constructor(kind, hasCalculation) {
      super("transform", hasCalculation);
      this._kind = kind;
    }
    get kind() {
      return this._kind;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        kind: this._kind
      };
    }
  };

  // node_modules/@siteimprove/alfa-css/dist/value/transform/matrix.js
  var { map: map48, either: either34 } = Parser;
  var Matrix2 = class _Matrix extends Function3 {
    static of(...values) {
      return new _Matrix(values.map((row) => row.map((value) => value.resolve())));
    }
    _values;
    constructor(values) {
      super("matrix", false);
      this._values = values;
    }
    get values() {
      return this._values;
    }
    resolve() {
      return this;
    }
    equals(value) {
      return value instanceof _Matrix && value._values.every((row, i) => row.every((value2, j) => value2.equals(this._values[i][j])));
    }
    hash(hash2) {
      for (const row of this._values) {
        for (const number of row) {
          hash2.writeHashable(number);
        }
      }
    }
    toJSON() {
      return {
        ...super.toJSON(),
        values: this._values.map((row) => row.map((value) => value.toJSON()))
      };
    }
    toString() {
      const [[a, e, i, m], [b, f, j, n], [c, g, k, o], [d, h2, l, p]] = this._values;
      if (c.value === 0 && d.value === 0 && g.value === 0 && h2.value === 0 && i.value === 0 && j.value === 0 && k.value === 1 && l.value === 0 && o.value === 0 && p.value === 1) {
        return `matrix(${[a, b, e, f, m, n].join(", ")})`;
      }
      return `matrix3d(${[a, b, c, d, e, f, g, h2, i, j, k, l, m, n, o, p].join(", ")})`;
    }
  };
  (function(Matrix3) {
    function isMatrix(value) {
      return value instanceof Matrix3;
    }
    Matrix3.isMatrix = isMatrix;
    const _0 = Number3.of(0);
    const _1 = Number3.of(1);
    const parseValues = (name, quantity) => Function.parse(name, map48(List2.parseCommaSeparated(Number3.parse, quantity, quantity), (list) => list.values));
    const parseMatrix = map48(parseValues("matrix", 6), (result) => {
      const [_, [_a, _b, _c, _d, _e, _f]] = result;
      return Matrix3.of([_a, _c, _0, _e], [_b, _d, _0, _f], [_0, _0, _1, _0], [_0, _0, _0, _1]);
    });
    const parseMatrix3d = map48(parseValues("matrix3d", 16), (result) => {
      const [_, [_a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p]] = result;
      return Matrix3.of([_a, _e, _i, _m], [_b, _f, _j, _n], [_c, _g, _k, _o], [_d, _h, _l, _p]);
    });
    Matrix3.parse = either34(parseMatrix, parseMatrix3d);
  })(Matrix2 || (Matrix2 = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/transform/perspective.js
  var { map: map49, filter: filter4 } = Parser;
  var Perspective = class _Perspective extends Function3 {
    static of(depth) {
      return new _Perspective(depth);
    }
    _depth;
    constructor(depth) {
      super("perspective", Value.hasCalculation(depth));
      this._depth = depth;
    }
    get depth() {
      return this._depth;
    }
    resolve(resolver) {
      return new _Perspective(this._depth.resolve(resolver));
    }
    equals(value) {
      return value instanceof _Perspective && value._depth.equals(this._depth);
    }
    hash(hash2) {
      hash2.writeHashable(this._depth);
    }
    toJSON() {
      return {
        ...super.toJSON(),
        depth: this._depth.toJSON()
      };
    }
    toString() {
      return `perspective(${this._depth})`;
    }
  };
  (function(Perspective2) {
    function isPerspective(value) {
      return value instanceof Perspective2;
    }
    Perspective2.isPerspective = isPerspective;
    const parseDepth = filter4(
      Length2.parse,
      // {@link https://drafts.csswg.org/css-values/#calc-range}
      (length) => length.hasCalculation() || length.value >= 0,
      () => "Depth cannot be less than 0"
    );
    Perspective2.parse = map49(Function.parse("perspective", parseDepth), ([_, depth]) => Perspective2.of(depth));
    Perspective2.parseProp = map49(parseDepth, Perspective2.of);
  })(Perspective || (Perspective = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/transform/rotate.js
  var { map: map50, right: right16, pair: pair19, either: either35, delimited: delimited12, option: option21 } = Parser;
  var Rotate = class _Rotate extends Function3 {
    static of(x, y, z, angle) {
      return new _Rotate(x.resolve(), y.resolve(), z.resolve(), angle.resolve());
    }
    _x;
    _y;
    _z;
    _angle;
    constructor(x, y, z, angle) {
      super("rotate", false);
      this._x = x;
      this._y = y;
      this._z = z;
      this._angle = angle;
    }
    get x() {
      return this._x;
    }
    get y() {
      return this._y;
    }
    get z() {
      return this._z;
    }
    get angle() {
      return this._angle;
    }
    resolve() {
      return this;
    }
    equals(value) {
      return value instanceof _Rotate && value._x.equals(this._x) && value._y.equals(this._y) && value._z.equals(this._z) && value._angle.equals(this._angle);
    }
    hash(hash2) {
      hash2.writeHashable(this._x).writeHashable(this._y).writeHashable(this._z).writeHashable(this._angle);
    }
    toJSON() {
      return {
        ...super.toJSON(),
        x: this._x.toJSON(),
        y: this._y.toJSON(),
        z: this._z.toJSON(),
        angle: this._angle.toJSON()
      };
    }
    toString() {
      if (this._x.value === 0 && this._y.value === 0 && this._z.value === 1) {
        return `rotate(${this._angle})`;
      }
      return `rotate3d(${this._x}, ${this._y}, ${this._z}, ${this._angle})`;
    }
  };
  (function(Rotate2) {
    function isRotate(value) {
      return value instanceof Rotate2;
    }
    Rotate2.isRotate = isRotate;
    const _0 = Number3.of(0);
    const _1 = Number3.of(1);
    const parseAngleOrZero = either35(Angle2.parse, map50(Number3.parseZero, () => Angle2.of(0, "deg")));
    const parseAxis2 = (name) => map50(Function.parse(name, parseAngleOrZero), ([_, angle]) => angle);
    const parseRotate2 = map50(parseAxis2("rotate"), (angle) => Rotate2.of(_0, _0, _1, angle));
    const parseRotateX = map50(parseAxis2("rotateX"), (angle) => Rotate2.of(_1, _0, _0, angle));
    const parseRotateY = map50(parseAxis2("rotateY"), (angle) => Rotate2.of(_0, _1, _0, angle));
    const parseRotateZ = map50(parseAxis2("rotateZ"), (angle) => Rotate2.of(_0, _0, _1, angle));
    const parseRotate3d = map50(Function.parse("rotate3d", pair19(map50(List2.parseCommaSeparated(Number3.parse, 3, 3), (list) => list.values), right16(delimited12(option21(Token.parseWhitespace), Token.parseComma), parseAngleOrZero))), (result) => {
      const [_, [[x, y, z], angle]] = result;
      return Rotate2.of(x, y, z, angle);
    });
    Rotate2.parse = either35(parseRotate2, parseRotateX, parseRotateY, parseRotateZ, parseRotate3d);
  })(Rotate || (Rotate = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/transform/scale.js
  var { map: map51, either: either36 } = Parser;
  var Scale = class _Scale extends Function3 {
    static of(x, y, z) {
      return new _Scale(x.resolve(), y.resolve(), z?.resolve());
    }
    _x;
    _y;
    _z;
    constructor(x, y, z) {
      super("scale", false);
      this._x = x;
      this._y = y;
      this._z = Option.from(z);
    }
    get kind() {
      return "scale";
    }
    get x() {
      return this._x;
    }
    get y() {
      return this._y;
    }
    get z() {
      return this._z;
    }
    resolve() {
      return this;
    }
    equals(value) {
      return value instanceof _Scale && value._x.equals(this._x) && value._y.equals(this._y) && value._z.equals(this._z);
    }
    hash(hash2) {
      hash2.writeHashable(this._x).writeHashable(this._y).writeHashable(this._z);
    }
    toJSON() {
      return {
        ...super.toJSON(),
        x: this._x.toJSON(),
        y: this._y.toJSON(),
        ...this._z.isSome() ? { z: this._z.get().toJSON() } : {}
      };
    }
    toString() {
      if (this._z.isSome()) {
        return `scale3d(${this._x}, ${this._y}, ${this._z})`;
      }
      if (this._x.value === this._y.value) {
        return `scale(${this._x})`;
      }
      if (this._y.value === 1) {
        return `scaleX(${this._x})`;
      }
      if (this._x.value === 1) {
        return `scaleY(${this._y})`;
      }
      return `scale(${this._x}, ${this._y})`;
    }
  };
  (function(Scale2) {
    function isScale(value) {
      return value instanceof Scale2;
    }
    Scale2.isScale = isScale;
    const parseScaleFunc = map51(Function.parse("scale", map51(List2.parseCommaSeparated(either36(Number3.parse, Percentage2.parse), 1, 2), (list) => list.values)), ([_, [x, y]]) => Scale2.of(x, y ?? x));
    const parseScale3dFunc = map51(Function.parse("scale3d", map51(List2.parseCommaSeparated(either36(Number3.parse, Percentage2.parse), 3, 3), (list) => list.values)), ([_, [x, y, z]]) => Scale2.of(x, y, z));
    const parseScaleXFunc = map51(Function.parse("scaleX", either36(Number3.parse, Percentage2.parse)), ([_, x]) => Scale2.of(x, Number3.of(1)));
    const parseScaleYFunc = map51(Function.parse("scaleY", either36(Number3.parse, Percentage2.parse)), ([_, y]) => Scale2.of(Number3.of(1), y));
    const parseScaleZFunc = map51(Function.parse("scaleZ", either36(Number3.parse, Percentage2.parse)), ([_, z]) => Scale2.of(Number3.of(1), Number3.of(1), z));
    Scale2.parse = either36(parseScaleFunc, parseScaleXFunc, parseScaleYFunc, parseScale3dFunc, parseScaleZFunc);
    Scale2.parseProp = map51(List2.parseSpaceSeparated(either36(Number3.parse, Percentage2.parse), 1, 3), (list) => {
      const [x, y, z] = list.values;
      return Scale2.of(x, y ?? x, z);
    });
  })(Scale || (Scale = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/transform/skew.js
  var { map: map52, either: either37 } = Parser;
  var Skew = class _Skew extends Function3 {
    static of(x, y) {
      return new _Skew(x.resolve(), y.resolve());
    }
    _x;
    _y;
    constructor(x, y) {
      super("skew", false);
      this._x = x;
      this._y = y;
    }
    get x() {
      return this._x;
    }
    get y() {
      return this._y;
    }
    resolve() {
      return this;
    }
    equals(value) {
      return value instanceof _Skew && value._x.equals(this._x) && value._y.equals(this._y);
    }
    hash(hash2) {
      hash2.writeHashable(this._x).writeHashable(this._y);
    }
    toJSON() {
      return {
        ...super.toJSON(),
        x: this._x.toJSON(),
        y: this._y.toJSON()
      };
    }
    toString() {
      if (this._y.value === 0) {
        return `skewX(${this._x})`;
      }
      if (this._x.value === 0) {
        return `skewY(${this._y})`;
      }
      return `skew(${this._x}, ${this._y})`;
    }
  };
  (function(Skew2) {
    function isSkew(value) {
      return value instanceof Skew2;
    }
    Skew2.isSkew = isSkew;
    const _0 = Angle2.of(0, "deg");
    const parseAngleOrZero = either37(Angle2.parse, map52(Number3.parseZero, () => _0));
    const parseSkew = map52(Function.parse("skew", map52(List2.parseCommaSeparated(parseAngleOrZero, 1, 2), (list) => list.values)), ([_, [x, y]]) => Skew2.of(x, y ?? _0));
    const parseSkewX = map52(Function.parse("skewX", parseAngleOrZero), ([_, x]) => Skew2.of(x, _0));
    const parseSkewY = map52(Function.parse("skewY", parseAngleOrZero), ([_, y]) => Skew2.of(_0, y));
    Skew2.parse = either37(parseSkew, parseSkewX, parseSkewY);
  })(Skew || (Skew = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/transform/translate.js
  var { map: map53, either: either38, parseIf: parseIf3 } = Parser;
  var Translate = class _Translate extends Function3 {
    static of(x, y, z) {
      return new _Translate(x, y, z);
    }
    _x;
    _y;
    _z;
    constructor(x, y, z) {
      super("translate", Value.hasCalculation(x, y, z));
      this._x = x;
      this._y = y;
      this._z = z;
    }
    get x() {
      return this._x;
    }
    get y() {
      return this._y;
    }
    get z() {
      return this._z;
    }
    resolve(resolver) {
      return new _Translate(LengthPercentage.resolve(resolver)(this._x), LengthPercentage.resolve(resolver)(this._y), this._z.resolve(resolver));
    }
    partiallyResolve(resolver) {
      return new _Translate(LengthPercentage.partiallyResolve(resolver)(this._x), LengthPercentage.partiallyResolve(resolver)(this._x), this._z.resolve(resolver));
    }
    equals(value) {
      return value instanceof _Translate && value._x.equals(this._x) && value._y.equals(this._y) && value._z.equals(this._z);
    }
    hash(hash2) {
      hash2.writeHashable(this._x).writeHashable(this._y).writeHashable(this._z);
    }
    toJSON() {
      return {
        ...super.toJSON(),
        x: this._x.toJSON(),
        y: this._y.toJSON(),
        z: this._z.toJSON()
      };
    }
    toString() {
      if (!this._z.hasCalculation() && Numeric2.isZero(this._z)) {
        return `translate(${this._x}${!this._y.hasCalculation() && Numeric2.isZero(this._y) ? "" : `, ${this._y}`})`;
      }
      return `translate3d(${this._x}, ${this._y}, ${this._z})`;
    }
  };
  (function(Translate2) {
    function isTranslate(value) {
      return value instanceof Translate2;
    }
    Translate2.isTranslate = isTranslate;
    const _0 = Length2.of(0, Unit.Length.Canonical);
    const parseTranslate = map53(Function.parse("translate", map53(List2.parseCommaSeparated(LengthPercentage.parse, 1, 2), (list) => list.values)), ([_, [x, y]]) => Translate2.of(x, y ?? _0, _0));
    const parseTranslateX = map53(Function.parse("translateX", LengthPercentage.parse), ([_, x]) => Translate2.of(x, _0, _0));
    const parseTranslateY = map53(Function.parse("translateY", LengthPercentage.parse), ([_, y]) => Translate2.of(_0, y, _0));
    const parseTranslateZ = map53(Function.parse("translateZ", Length2.parse), ([_, z]) => Translate2.of(_0, _0, z));
    const parseTranslate3d = map53(
      Function.parse("translate3d", parseIf3((values) => Length2.isLength(values[2]), map53(List2.parseCommaSeparated(LengthPercentage.parse, 3, 3), (list) => list.values), () => "The z component of translate3d must be a length")),
      // The type of z is ensured by parseIf.
      ([_, [x, y, z]]) => Translate2.of(x, y, z)
    );
    Translate2.parse = either38(parseTranslate, parseTranslateX, parseTranslateY, parseTranslateZ, parseTranslate3d);
    const parseTranslateProp = map53(List2.parseSpaceSeparated(LengthPercentage.parse, 1, 2), (list) => {
      const [x, y] = list.values;
      return Translate2.of(x, y ?? _0, _0);
    });
    const parseTranslate3dProp = map53(
      parseIf3((values) => Length2.isLength(values[2]), map53(List2.parseSpaceSeparated(LengthPercentage.parse, 3, 3), (list) => list.values), () => "The z component of translate3d must be a length"),
      // The type of z is ensured by parseIf.
      ([x, y, z]) => Translate2.of(x, y, z)
    );
    Translate2.parseProp = either38(parseTranslate3dProp, parseTranslateProp);
  })(Translate || (Translate = {}));

  // node_modules/@siteimprove/alfa-css/dist/value/transform/transform.js
  var { either: either39 } = Parser;
  var Transform;
  (function(Transform2) {
    function resolve3(resolver) {
      return (value) => value.resolve(resolver);
    }
    Transform2.resolve = resolve3;
    function partiallyResolve(resolver) {
      return (value) => Translate.isTranslate(value) ? value.partiallyResolve(resolver) : value.resolve(resolver);
    }
    Transform2.partiallyResolve = partiallyResolve;
    function matrix(...values) {
      return Matrix2.of(...values);
    }
    Transform2.matrix = matrix;
    function perspective(depth) {
      return Perspective.of(depth);
    }
    Transform2.perspective = perspective;
    function rotate(x, y, z, angle) {
      return Rotate.of(x, y, z, angle);
    }
    Transform2.rotate = rotate;
    function scale(x, y) {
      return Scale.of(x, y);
    }
    Transform2.scale = scale;
    function skew(x, y) {
      return Skew.of(x, y);
    }
    Transform2.skew = skew;
    function translate(x, y, z) {
      return Translate.of(x, y, z);
    }
    Transform2.translate = translate;
    Transform2.parse = either39(Matrix2.parse, Perspective.parse, Rotate.parse, Scale.parse, Skew.parse, Translate.parse);
    Transform2.parseList = List2.parseSpaceSeparated(Transform2.parse);
  })(Transform || (Transform = {}));

  // node_modules/@siteimprove/alfa-dom/dist/style/declaration.js
  var Declaration2 = class _Declaration {
    static of(name, value, important = false) {
      return new _Declaration(name, value, important);
    }
    _name;
    _value;
    _important;
    /**
     * @remarks
     * If the declaration is in a style rule, point to it
     */
    _parent = None;
    /**
     * @remarks
     * If the declaration is in a style attribute on an element, point to it
     *
     * @remarks
     * "owner" use the same vocabulary as attribute's owner
     *
     * @remarks
     * Only one of _parent and _owner should be Some.
     */
    _owner = None;
    constructor(name, value, important) {
      this._name = name;
      this._value = value;
      this._important = important;
    }
    get name() {
      return this._name;
    }
    get value() {
      return this._value;
    }
    get important() {
      return this._important;
    }
    get parent() {
      return this._parent;
    }
    get owner() {
      return this._owner;
    }
    *ancestors() {
      for (const parent of this._parent) {
        yield parent;
        yield* parent.ancestors();
      }
    }
    /**
     * Parent rule or owner element are ignored for declaration equality.
     */
    equals(value) {
      return value instanceof _Declaration && value._name === this._name && value._value === this._value && value._important === this._important;
    }
    toJSON() {
      return {
        name: this._name,
        value: this._value,
        important: this._important
      };
    }
    toString() {
      return `${this._name}: ${this._value}${this._important ? " !important" : ""}`;
    }
    /**
     * @internal
     */
    _attachParent(parent) {
      if (this._parent.isSome() || this._owner.isSome()) {
        return false;
      }
      this._parent = Option.of(parent);
      return true;
    }
    /**
     * @internal
     */
    _attachOwner(owner) {
      if (this._parent.isSome() || this._owner.isSome()) {
        return false;
      }
      this._owner = Option.of(owner);
      return true;
    }
  };
  (function(Declaration3) {
    function from(json) {
      return Declaration3.of(json.name, json.value, json.important);
    }
    Declaration3.from = from;
  })(Declaration2 || (Declaration2 = {}));

  // node_modules/@siteimprove/alfa-dom/dist/style/block.js
  var Block2 = class _Block {
    static of(declarations) {
      return new _Block(Array.from(declarations));
    }
    _declarations;
    constructor(declarations) {
      this._declarations = declarations;
    }
    get declarations() {
      return this._declarations;
    }
    get size() {
      return this._declarations.length;
    }
    isEmpty() {
      return this._declarations.length === 0;
    }
    declaration(predicate) {
      return Option.from(this._declarations.find(typeof predicate === "string" ? (declaration) => declaration.name === predicate : predicate));
    }
    equals(value) {
      return value instanceof _Block && value._declarations.length === this._declarations.length && value._declarations.every((declaration, i) => declaration.equals(this._declarations[i]));
    }
    *[Symbol.iterator]() {
      yield* this._declarations;
    }
    toJSON() {
      return this._declarations.map((declaration) => declaration.toJSON());
    }
    toString() {
      return this._declarations.join(";\n");
    }
  };
  (function(Block4) {
    function from(jsonOrText) {
      if (typeof jsonOrText === "string") {
        return Block4.of(Iterable.map(Declaration.parseList(Lexer.lex(jsonOrText)).getUnsafe(`Could not parse CSS declarations "${jsonOrText}"`)[1], (declaration) => Declaration2.from({
          name: declaration.name,
          value: declaration.value.join(""),
          important: declaration.important
        })));
      } else {
        return Block4.of(jsonOrText.map(Declaration2.from));
      }
    }
    Block4.from = from;
  })(Block2 || (Block2 = {}));

  // node_modules/@siteimprove/alfa-dom/dist/style/rule.js
  var Rule2 = class {
    _owner = None;
    _parent = None;
    _type;
    constructor(type) {
      this._type = type;
    }
    get type() {
      return this._type;
    }
    get owner() {
      return this._owner;
    }
    get parent() {
      return this._parent;
    }
    *children() {
    }
    *descendants() {
      for (const child of this.children()) {
        yield child;
        yield* child.descendants();
      }
    }
    *ancestors() {
      for (const parent of this._parent) {
        yield parent;
        yield* parent.ancestors();
      }
    }
    *inclusiveAncestors() {
      yield this;
      yield* this.ancestors();
    }
    equals(value) {
      return value === this;
    }
    toJSON() {
      return { type: this._type };
    }
    /**
     * @internal
     */
    _attachOwner(owner) {
      if (this._owner.isSome()) {
        return false;
      }
      this._owner = Option.of(owner);
      return Iterable.every(this.children(), (rule) => rule._attachOwner(owner));
    }
    /**
     * @internal
     */
    _attachParent(parent) {
      if (this._parent.isSome()) {
        return false;
      }
      this._parent = Option.of(parent);
      return true;
    }
  };
  (function(Rule3) {
    function from(json) {
      return fromRule(json).run();
    }
    Rule3.from = from;
    function fromRule(json) {
      switch (json.type) {
        case "font-face":
          return FontFaceRule.fromFontFaceRule(json);
        case "import":
          return ImportRule.fromImportRule(json);
        case "keyframe":
          return KeyframeRule.fromKeyframeRule(json);
        case "keyframes":
          return KeyframesRule.fromKeyframesRule(json);
        case "layer-block":
          return Layer.BlockRule.fromLayerBlockRule(json);
        case "layer-statement":
          return Layer.StatementRule.fromLayerStatementRule(json);
        case "media":
          return MediaRule.fromMediaRule(json);
        case "namespace":
          return NamespaceRule.fromNamespaceRule(json);
        case "page":
          return PageRule.fromPageRule(json);
        case "style":
          return StyleRule.fromStyleRule(json);
        case "supports":
          return SupportsRule.fromSupportsRule(json);
        default:
          throw new Error(`Unexpected rule of type: ${json.type}`);
      }
    }
    Rule3.fromRule = fromRule;
  })(Rule2 || (Rule2 = {}));

  // node_modules/@siteimprove/alfa-dom/dist/style/rule/grouping.js
  var GroupingRule = class extends Rule2 {
    _rules;
    constructor(type, rules) {
      super(type);
      this._rules = rules.filter((rule) => rule._attachParent(this));
    }
    get rules() {
      return this._rules;
    }
    *children() {
      yield* this._rules;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        rules: Array2.toJSON(this._rules)
      };
    }
  };
  (function(GroupingRule2) {
    function isGroupingRule(value) {
      return value instanceof GroupingRule2;
    }
    GroupingRule2.isGroupingRule = isGroupingRule;
  })(GroupingRule || (GroupingRule = {}));

  // node_modules/@siteimprove/alfa-dom/dist/style/rule/condition.js
  var ConditionRule = class extends GroupingRule {
    _condition;
    constructor(type, condition, rules) {
      super(type, rules);
      this._condition = condition;
    }
    get condition() {
      return this._condition;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        condition: this._condition
      };
    }
  };
  (function(ConditionRule2) {
    function isConditionRule(value) {
      return value instanceof ConditionRule2;
    }
    ConditionRule2.isConditionRule = isConditionRule;
  })(ConditionRule || (ConditionRule = {}));

  // node_modules/@siteimprove/alfa-dom/dist/style/rule/font-face.js
  var FontFaceRule = class _FontFaceRule extends Rule2 {
    static of(declarations) {
      return new _FontFaceRule(Array.from(declarations));
    }
    _style;
    constructor(declarations) {
      super("font-face");
      this._style = Block2.of(declarations.filter((declaration) => declaration._attachParent(this)));
    }
    get style() {
      return this._style;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        style: this._style.toJSON()
      };
    }
    toString() {
      const style = this._style.toString();
      return `@font-face {${style === "" ? "" : `
${String2.indent(style)}
`}}`;
    }
  };
  (function(FontFaceRule2) {
    function isFontFaceRule(value) {
      return value instanceof FontFaceRule2;
    }
    FontFaceRule2.isFontFaceRule = isFontFaceRule;
    function fromFontFaceRule(json) {
      return Trampoline.done(FontFaceRule2.of(Block2.from(json.style)));
    }
    FontFaceRule2.fromFontFaceRule = fromFontFaceRule;
  })(FontFaceRule || (FontFaceRule = {}));

  // node_modules/@siteimprove/alfa-css-feature/dist/condition/and.js
  var { delimited: delimited13, option: option22, right: right17 } = Parser;
  var And = class _And {
    static of(left22, right38) {
      return new _And(left22, right38);
    }
    _left;
    _right;
    constructor(left22, right38) {
      this._left = left22;
      this._right = right38;
    }
    get left() {
      return this._left;
    }
    get right() {
      return this._right;
    }
    matches(device) {
      return this._left.matches(device) && this._right.matches(device);
    }
    equals(value) {
      return value instanceof _And && value._left.equals(this._left) && value._right.equals(this._right);
    }
    *iterator() {
      for (const condition of [this._left, this._right]) {
        yield* condition;
      }
    }
    [Symbol.iterator]() {
      return this.iterator();
    }
    toJSON() {
      return {
        type: "and",
        left: this._left.toJSON(),
        right: this._right.toJSON()
      };
    }
    toString() {
      return `(${this._left}) and (${this._right})`;
    }
  };
  (function(And2) {
    function isAnd(value) {
      return value instanceof And2;
    }
    And2.isAnd = isAnd;
    function parse57(parseInParens, featureParser) {
      return right17(delimited13(option22(Token.parseWhitespace), Token.parseIdent("and")), parseInParens(featureParser));
    }
    And2.parse = parse57;
  })(And || (And = {}));

  // node_modules/@siteimprove/alfa-css-feature/dist/condition/not.js
  var { delimited: delimited14, map: map54, option: option23, right: right18 } = Parser;
  var Not = class _Not {
    static of(condition) {
      return new _Not(condition);
    }
    _condition;
    constructor(condition) {
      this._condition = condition;
    }
    get condition() {
      return this._condition;
    }
    matches(device) {
      return !this._condition.matches(device);
    }
    equals(value) {
      return value instanceof _Not && value._condition.equals(this._condition);
    }
    *iterator() {
      yield* this._condition;
    }
    [Symbol.iterator]() {
      return this.iterator();
    }
    toJSON() {
      return {
        type: "not",
        condition: this._condition.toJSON()
      };
    }
    toString() {
      return `not (${this._condition})`;
    }
  };
  (function(Not3) {
    function isNot(value) {
      return value instanceof Not3;
    }
    Not3.isNot = isNot;
    function parse57(parseInParens, featureParser) {
      return map54(right18(delimited14(option23(Token.parseWhitespace), Token.parseIdent("not")), parseInParens(featureParser)), Not3.of);
    }
    Not3.parse = parse57;
  })(Not || (Not = {}));

  // node_modules/@siteimprove/alfa-css-feature/dist/condition/or.js
  var { delimited: delimited15, option: option24, right: right19 } = Parser;
  var Or = class _Or {
    static of(left22, right38) {
      return new _Or(left22, right38);
    }
    _left;
    _right;
    constructor(left22, right38) {
      this._left = left22;
      this._right = right38;
    }
    get left() {
      return this._left;
    }
    get right() {
      return this._right;
    }
    matches(device) {
      return this._left.matches(device) || this._right.matches(device);
    }
    equals(value) {
      return value instanceof _Or && value._left.equals(this._left) && value._right.equals(this._right);
    }
    *iterator() {
      for (const condition of [this._left, this._right]) {
        yield* condition;
      }
    }
    [Symbol.iterator]() {
      return this.iterator();
    }
    toJSON() {
      return {
        type: "or",
        left: this._left.toJSON(),
        right: this._right.toJSON()
      };
    }
    toString() {
      return `(${this._left}) or (${this._right})`;
    }
  };
  (function(Or2) {
    function isOr(value) {
      return value instanceof Or2;
    }
    Or2.isOr = isOr;
    function parse57(parseInParens, featureParser) {
      return right19(delimited15(option24(Token.parseWhitespace), Token.parseIdent("or")), parseInParens(featureParser));
    }
    Or2.parse = parse57;
  })(Or || (Or = {}));

  // node_modules/@siteimprove/alfa-css-feature/dist/condition/condition.js
  var { delimited: delimited16, either: either40, map: map55, oneOrMore: oneOrMore2, option: option25, pair: pair20, zeroOrMore: zeroOrMore4 } = Parser;
  var Condition;
  (function(Condition2) {
    function isCondition(value) {
      return And.isAnd(value) || Or.isOr(value) || Not.isNot(value);
    }
    Condition2.isCondition = isCondition;
    function parseInParens(featureParser) {
      return either40(delimited16(Token.parseOpenParenthesis, delimited16(option25(Token.parseWhitespace), (input) => parse57(featureParser)(input)), Token.parseCloseParenthesis), featureParser);
    }
    function parse57(featureParser) {
      return either40(Not.parse(parseInParens, featureParser), map55(pair20(parseInParens(featureParser), either40(map55(oneOrMore2(And.parse(parseInParens, featureParser)), (queries) => [And.of, queries]), map55(oneOrMore2(Or.parse(parseInParens, featureParser)), (queries) => [Or.of, queries]))), ([left22, [constructor, right38]]) => Iterable.reduce(right38, (left23, right39) => constructor(left23, right39), left22)), parseInParens(featureParser));
    }
    Condition2.parse = parse57;
    function parseWithoutOr(featureParser) {
      return either40(Not.parse(parseInParens, featureParser), map55(pair20(parseInParens(featureParser), zeroOrMore4(And.parse(parseInParens, featureParser))), ([left22, right38]) => [left22, ...right38].reduce((left23, right39) => And.of(left23, right39))));
    }
    Condition2.parseWithoutOr = parseWithoutOr;
  })(Condition || (Condition = {}));

  // node_modules/@siteimprove/alfa-css-feature/dist/media/feature/value/bound.js
  var Bound = class _Bound {
    static of(value, isInclusive) {
      return new _Bound(value, isInclusive);
    }
    _value;
    _isInclusive;
    constructor(value, isInclusive) {
      this._value = value;
      this._isInclusive = isInclusive;
    }
    get value() {
      return this._value;
    }
    get isInclusive() {
      return this._isInclusive;
    }
    map(mapper) {
      return new _Bound(mapper(this._value), this._isInclusive);
    }
    hasValue(refinement) {
      return refinement(this._value);
    }
    toJSON() {
      return {
        value: Serializable.toJSON(this._value),
        isInclusive: this._isInclusive
      };
    }
  };

  // node_modules/@siteimprove/alfa-css-feature/dist/media/feature/value/discrete.js
  var Discrete = class _Discrete {
    static of(value) {
      return new _Discrete(value);
    }
    _value;
    constructor(value) {
      this._value = value;
    }
    get value() {
      return this._value;
    }
    map(mapper) {
      return new _Discrete(mapper(this._value));
    }
    matches(value) {
      return Equatable.equals(this._value, value);
    }
    hasValue(refinement) {
      return refinement(this._value);
    }
    toJSON() {
      return {
        type: "discrete",
        value: Serializable.toJSON(this._value)
      };
    }
  };
  (function(Discrete4) {
    function isDiscrete(value) {
      return value instanceof Discrete4;
    }
    Discrete4.isDiscrete = isDiscrete;
  })(Discrete || (Discrete = {}));

  // node_modules/@siteimprove/alfa-css-feature/dist/media/feature/value/range.js
  var Range = class _Range {
    static of(minimum, maximum) {
      return new _Range(Option.of(minimum), Option.of(maximum));
    }
    static minimum(minimum) {
      return new _Range(Option.of(minimum), None);
    }
    static maximum(maximum) {
      return new _Range(None, Option.of(maximum));
    }
    _minimum;
    _maximum;
    constructor(minimum, maximum) {
      this._minimum = minimum;
      this._maximum = maximum;
    }
    get minimum() {
      return this._minimum;
    }
    get maximum() {
      return this._maximum;
    }
    map(mapper) {
      return new _Range(this._minimum.map((bound) => bound.map(mapper)), this._maximum.map((bound) => bound.map(mapper)));
    }
    toLength() {
      return this.map((bound) => Refinement.and(Number3.isNumber, (value) => !value.hasCalculation() && value.value === 0)(bound) ? Length2.of(0, "px") : bound);
    }
    matches(value) {
      if (!Comparable.isComparable(value)) {
        return false;
      }
      for (const minimum of this._minimum) {
        if (minimum.isInclusive) {
          if (value.compare(minimum.value) < 0) {
            return false;
          }
        } else {
          if (value.compare(minimum.value) <= 0) {
            return false;
          }
        }
      }
      for (const maximum of this._maximum) {
        if (maximum.isInclusive) {
          if (value.compare(maximum.value) > 0) {
            return false;
          }
        } else {
          if (value.compare(maximum.value) >= 0) {
            return false;
          }
        }
      }
      return true;
    }
    hasValue(refinement) {
      return this._minimum.every((bound) => refinement(bound.value)) && this._maximum.every((bound) => refinement(bound.value));
    }
    toJSON() {
      return {
        type: "range",
        minimum: this._minimum.map((bound) => bound.toJSON()).getOr(null),
        maximum: this._maximum.map((bound) => bound.toJSON()).getOr(null)
      };
    }
  };
  (function(Range3) {
    function isRange(value) {
      return value instanceof Range3;
    }
    Range3.isRange = isRange;
  })(Range || (Range = {}));

  // node_modules/@siteimprove/alfa-css-feature/dist/media/feature/value/value.js
  var Value3;
  (function(Value6) {
    Value6.Bound = Bound;
    Value6.Discrete = Discrete;
    Value6.Range = Range;
    Value6.discrete = Value6.Discrete.of, Value6.isDiscrete = Value6.Discrete.isDiscrete;
    Value6.range = Value6.Range.of, Value6.minimumRange = Value6.Range.minimum, Value6.maximumRange = Value6.Range.maximum, Value6.isRange = Value6.Range.isRange;
    Value6.bound = Value6.Bound.of;
  })(Value3 || (Value3 = {}));

  // node_modules/@siteimprove/alfa-css-feature/dist/media/feature/comparison.js
  var { delimited: delimited17, either: either41, map: map56, option: option26, right: right20 } = Parser;
  var Comparison2;
  (function(Comparison3) {
    Comparison3["LessThan"] = "<";
    Comparison3["LessThanOrEqual"] = "<=";
    Comparison3["Equal"] = "=";
    Comparison3["GreaterThan"] = ">";
    Comparison3["GreaterThanOrEqual"] = ">=";
  })(Comparison2 || (Comparison2 = {}));
  (function(Comparison3) {
    function isInclusive(comparison) {
      return comparison === Comparison3.LessThanOrEqual || comparison === Comparison3.GreaterThanOrEqual || comparison === Comparison3.Equal;
    }
    Comparison3.isInclusive = isInclusive;
    Comparison3.parseLessThan = map56(delimited17(option26(Token.parseWhitespace), right20(Token.parseDelim("<"), option26(Token.parseDelim("=")))), (equal) => equal.isNone() ? Comparison3.LessThan : Comparison3.LessThanOrEqual);
    Comparison3.parseGreaterThan = map56(delimited17(option26(Token.parseWhitespace), right20(Token.parseDelim(">"), option26(Token.parseDelim("=")))), (equal) => equal.isNone() ? Comparison3.GreaterThan : Comparison3.GreaterThanOrEqual);
    Comparison3.parseEqual = map56(delimited17(option26(Token.parseWhitespace), Token.parseDelim("=")), () => Comparison3.Equal);
    Comparison3.parse = either41(Comparison3.parseEqual, Comparison3.parseLessThan, Comparison3.parseGreaterThan);
  })(Comparison2 || (Comparison2 = {}));

  // node_modules/@siteimprove/alfa-css-feature/dist/media/feature/media.js
  var { delimited: delimited18, either: either42, filter: filter5, left: left9, map: map57, option: option27, pair: pair21, right: right21, separated: separated2 } = Parser;
  var Media = class _Media {
    _name;
    _value;
    constructor(name, value) {
      this._name = name;
      this._value = value;
    }
    get name() {
      return this._name;
    }
    get value() {
      return this._value;
    }
    equals(value) {
      return value instanceof _Media && value.name === this.name && value._value.equals(this._value);
    }
    *iterator() {
      yield this;
    }
    [Symbol.iterator]() {
      return this.iterator();
    }
    toJSON() {
      return {
        type: "feature",
        name: this._name,
        value: this._value.map((value) => value.toJSON()).getOr(null)
      };
    }
    toString() {
      return `${this.name}${this._value.map((value) => `: ${value}`).getOr("")}`;
    }
  };
  (function(Media5) {
    function isMedia(value) {
      return value instanceof Media5;
    }
    Media5.isMedia = isMedia;
    function parseName2(name, withRange = false) {
      return filter5(map57(Token.parseIdent(), (ident) => ident.value.toLowerCase()), (parsed) => parsed === name || withRange && (parsed === `min-${name}` || parsed === `max-${name}`), (parsed) => `Unknown feature ${parsed}`);
    }
    function parsePlain(name, parseValue, withRange, from) {
      return map57(separated2(parseName2(name, withRange), delimited18(option27(Token.parseWhitespace), Token.parseColon), parseValue), ([name2, value]) => {
        if (withRange && (name2.startsWith("min-") || name2.startsWith("max-"))) {
          const range = name2.startsWith("min-") ? Value3.minimumRange : Value3.maximumRange;
          return from(Option.of(range(Value3.bound(
            value,
            /* isInclusive */
            true
          ))));
        } else {
          return from(Option.of(Value3.discrete(value)));
        }
      });
    }
    function parseBoolean(name, from) {
      return map57(parseName2(name), () => from(None));
    }
    const parseLength = filter5(Length2.parse, (length) => !length.hasCalculation(), () => "Calculations no supported in media queries");
    function parseComparisonLengthBound(parseComparison) {
      return map57(pair21(parseComparison, parseLength), ([comparison, value]) => [
        Value3.bound(value, Comparison2.isInclusive(comparison)),
        comparison
      ]);
    }
    function parseLengthComparisonBound(parseComparison) {
      return map57(pair21(parseLength, parseComparison), ([value, comparison]) => [
        Value3.bound(value, Comparison2.isInclusive(comparison)),
        comparison
      ]);
    }
    function parseRange(name, from) {
      return either42(
        // <mf-value> <mf-lt> <mf-name> <mf-lt> <mf-value>
        map57(pair21(parseLengthComparisonBound(Comparison2.parseLessThan), right21(delimited18(option27(Token.parseWhitespace), parseName2(name)), parseComparisonLengthBound(Comparison2.parseLessThan))), ([[minimum], [maximum]]) => from(Option.of(Value3.range(minimum, maximum)))),
        // <mf-value> <mf-gt> <mf-name> <mf-gt> <mf-value>
        map57(pair21(parseLengthComparisonBound(Comparison2.parseGreaterThan), right21(delimited18(option27(Token.parseWhitespace), parseName2(name)), parseComparisonLengthBound(Comparison2.parseGreaterThan))), ([[maximum], [minimum]]) => from(Option.of(Value3.range(minimum, maximum)))),
        // <mf-name> <mf-comparison> <mf-value>
        map57(right21(parseName2(name), parseComparisonLengthBound(Comparison2.parse)), ([bound, comparison]) => {
          switch (comparison) {
            case Comparison2.Equal:
              return from(Option.of(Value3.range(bound, bound)));
            case Comparison2.LessThan:
            case Comparison2.LessThanOrEqual:
              return from(Option.of(Value3.maximumRange(bound)));
            case Comparison2.GreaterThan:
            case Comparison2.GreaterThanOrEqual:
              return from(Option.of(Value3.minimumRange(bound)));
          }
        }),
        // <mf-value> <mf-comparison> <mf-name>
        map57(left9(parseLengthComparisonBound(Comparison2.parse), parseName2(name)), ([bound, comparison]) => {
          switch (comparison) {
            case Comparison2.Equal:
              return from(Option.of(Value3.range(bound, bound)));
            case Comparison2.LessThan:
            case Comparison2.LessThanOrEqual:
              return from(Option.of(Value3.minimumRange(bound)));
            case Comparison2.GreaterThan:
            case Comparison2.GreaterThanOrEqual:
              return from(Option.of(Value3.maximumRange(bound)));
          }
        })
      );
    }
    function parseContinuous(name, from) {
      return either42(parseRange(name, from), parsePlain(name, parseLength, true, from), parseBoolean(name, from));
    }
    Media5.parseContinuous = parseContinuous;
    function parseDiscrete(name, from, ...values) {
      return either42(parsePlain(name, Keyword.parse(...values), false, from), parseBoolean(name, from));
    }
    Media5.parseDiscrete = parseDiscrete;
  })(Media || (Media = {}));

  // node_modules/@siteimprove/alfa-css-feature/dist/media/feature/resolver.js
  var Resolver;
  (function(Resolver3) {
    function length(device) {
      const { viewport } = device;
      const width = Length2.of(viewport.width, "px");
      const height = Length2.of(viewport.height, "px");
      const fontSize = Length2.of(16, "px");
      const rootFontSize = Length2.of(16, "px");
      return { length: Length2.resolver(fontSize, rootFontSize, width, height) };
    }
    Resolver3.length = length;
  })(Resolver || (Resolver = {}));

  // node_modules/@siteimprove/alfa-css-feature/dist/media/feature/height.js
  var Height = class _Height extends Media {
    static of(value) {
      return new _Height(Option.of(value));
    }
    static _boolean = new _Height(None);
    constructor(value) {
      super("height", value);
    }
    static boolean() {
      return _Height._boolean;
    }
    matches(device) {
      const { viewport: { height } } = device;
      const value = this._value.map((value2) => value2.map((length) => length.resolve(Resolver.length(device))));
      return height > 0 ? value.some((value2) => value2.matches(Length2.of(height, "px"))) : value.every((value2) => value2.matches(Length2.of(0, "px")));
    }
  };
  (function(Height2) {
    function from(value) {
      return value.map(Height2.of).getOrElse(Height2.boolean);
    }
    function isHeight2(value) {
      return value instanceof Height2;
    }
    Height2.isHeight = isHeight2;
    Height2.parse = Media.parseContinuous("height", from);
  })(Height || (Height = {}));

  // node_modules/@siteimprove/alfa-device/dist/display.js
  var Display = class _Display {
    static of(resolution, scan = _Display.Scan.Progressive) {
      return new _Display(resolution, scan);
    }
    _resolution;
    _scan;
    constructor(resolution, scan) {
      this._resolution = resolution;
      this._scan = scan;
    }
    /**
     * {@link https://www.w3.org/TR/mediaqueries/#resolution}
     */
    get resolution() {
      return this._resolution;
    }
    /**
     * {@link https://www.w3.org/TR/mediaqueries/#scan}
     */
    get scan() {
      return this._scan;
    }
    equals(value) {
      return value instanceof _Display && value._resolution === this._resolution && value._scan === this._scan;
    }
    hash(hash2) {
      hash2.writeUint8(this._resolution);
      switch (this._scan) {
        case _Display.Scan.Interlace:
          hash2.writeUint8(1);
          break;
        case _Display.Scan.Progressive:
          hash2.writeUint8(2);
      }
    }
    toJSON(options) {
      return {
        resolution: this._resolution,
        scan: this._scan
      };
    }
  };
  (function(Display2) {
    let Scan;
    (function(Scan2) {
      Scan2["Interlace"] = "interlace";
      Scan2["Progressive"] = "progressive";
    })(Scan = Display2.Scan || (Display2.Scan = {}));
    function from(json) {
      return Display2.of(json.resolution, json.scan);
    }
    Display2.from = from;
    function standard() {
      return Display2.of(1, Scan.Progressive);
    }
    Display2.standard = standard;
  })(Display || (Display = {}));

  // node_modules/@siteimprove/alfa-device/dist/preference.js
  var Preference = class _Preference {
    static of(name, value) {
      return new _Preference(name, value);
    }
    _name;
    _value;
    constructor(name, value) {
      this._name = name;
      this._value = value;
    }
    get name() {
      return this._name;
    }
    get value() {
      return this._value;
    }
    equals(value) {
      return value instanceof _Preference && value._name === this._name && value._value === this._value;
    }
    hash(hash2) {
      hash2.writeString(this._name).writeString(this._value);
    }
    toJSON(options) {
      return {
        name: this._name,
        value: this._value
      };
    }
  };
  (function(Preference2) {
    function isPreference(value, name) {
      return value instanceof Preference2 && (name === void 0 || value.name === name);
    }
    Preference2.isPreference = isPreference;
    function from(json) {
      return Preference2.of(json.name, json.value);
    }
    Preference2.from = from;
    Preference2.preferences = {
      /**
       * {@link https://drafts.csswg.org/mediaqueries-5/#forced-colors}
       */
      "forced-colors": ["none", "active"],
      /**
       * {@link https://drafts.csswg.org/mediaqueries-5/#inverted}
       */
      inverted: ["none", "inverted"],
      /**
       * {@link https://drafts.csswg.org/mediaqueries-5/#prefers-color-scheme}
       *
       * @remarks
       * For consistency, "no-preference" is also included.
       */
      "prefers-color-scheme": ["no-preference", "light", "dark"],
      /**
       * {@link https://drafts.csswg.org/mediaqueries-5/#prefers-contrast}
       *
       * @remarks
       * For consistency, "no-preference" is also included.
       */
      "prefers-contrast": ["no-preference", "less", "more", "custom"],
      /**
       * {@link https://drafts.csswg.org/mediaqueries-5/#prefers-reduced-motion}
       */
      "prefers-reduced-motion": ["no-preference", "reduce"],
      /**
       * {@link https://drafts.csswg.org/mediaqueries-5/#prefers-reduced-transparency}
       */
      "prefers-reduced-transparency": ["no-preference", "reduce"],
      /**
       * {@link https://drafts.csswg.org/mediaqueries-5/#prefers-reduced-data}
       */
      "prefers-reduced-data": ["no-preference", "reduce"]
    };
    function unset(name) {
      function unset2(name2) {
        switch (name2) {
          case "forced-colors":
          case "inverted":
            return "none";
          case "prefers-color-scheme":
          case "prefers-contrast":
          case "prefers-reduced-motion":
          case "prefers-reduced-transparency":
          case "prefers-reduced-data":
            return "no-preference";
        }
      }
      return unset2(name);
    }
    Preference2.unset = unset;
  })(Preference || (Preference = {}));

  // node_modules/@siteimprove/alfa-device/dist/scripting.js
  var Scripting = class _Scripting {
    static of(enabled) {
      return new _Scripting(enabled);
    }
    _enabled;
    constructor(enabled) {
      this._enabled = enabled;
    }
    get enabled() {
      return this._enabled;
    }
    equals(value) {
      return value instanceof _Scripting && value._enabled === this._enabled;
    }
    hash(hash2) {
      hash2.writeBoolean(this._enabled);
    }
    toJSON(options) {
      return {
        enabled: this._enabled
      };
    }
  };
  (function(Scripting3) {
    function isScripting(value) {
      return value instanceof Scripting3;
    }
    Scripting3.isScripting = isScripting;
    function from(json) {
      return Scripting3.of(json.enabled);
    }
    Scripting3.from = from;
  })(Scripting || (Scripting = {}));

  // node_modules/@siteimprove/alfa-device/dist/viewport.js
  var Viewport = class _Viewport {
    static of(width, height = width / (16 / 9), orientation = _Viewport.Orientation.Landscape) {
      return new _Viewport(width, height, orientation);
    }
    _width;
    _height;
    _orientation;
    constructor(width, height, orientation) {
      this._width = width;
      this._height = height;
      this._orientation = orientation;
    }
    /**
     * {@link https://www.w3.org/TR/mediaqueries/#width}
     */
    get width() {
      return this._width;
    }
    /**
     * {@link https://www.w3.org/TR/mediaqueries/#height}
     */
    get height() {
      return this._height;
    }
    /**
     * {@link https://www.w3.org/TR/mediaqueries/#orientation}
     */
    get orientation() {
      return this._orientation;
    }
    isLandscape() {
      return this._orientation === _Viewport.Orientation.Landscape;
    }
    isPortrait() {
      return this._orientation === _Viewport.Orientation.Portrait;
    }
    equals(value) {
      return value instanceof _Viewport && value._width === this._width && value._height === this._height && value._orientation === this._orientation;
    }
    hash(hash2) {
      hash2.writeUint32(this._width);
      hash2.writeUint32(this._height);
      switch (this._orientation) {
        case _Viewport.Orientation.Landscape:
          hash2.writeUint8(1);
          break;
        case _Viewport.Orientation.Portrait:
          hash2.writeUint8(2);
      }
    }
    toJSON(options) {
      return {
        width: this._width,
        height: this._height,
        orientation: this._orientation
      };
    }
  };
  (function(Viewport2) {
    let Orientation;
    (function(Orientation2) {
      Orientation2["Portrait"] = "portrait";
      Orientation2["Landscape"] = "landscape";
    })(Orientation = Viewport2.Orientation || (Viewport2.Orientation = {}));
    function from(json) {
      return Viewport2.of(json.width, json.height, json.orientation);
    }
    Viewport2.from = from;
    function standard() {
      return Viewport2.of(1280, 720, Orientation.Landscape);
    }
    Viewport2.standard = standard;
  })(Viewport || (Viewport = {}));

  // node_modules/@siteimprove/alfa-device/dist/device.js
  var Device = class _Device {
    /**
     * @remarks
     * If the iterable of preferences contains preferences with duplicate names,
     * the last preference with a given name will take precedence.
     */
    static of(type, viewport, display, scripting = Scripting.of(true), preferences = []) {
      return new _Device(type, viewport, display, scripting, Map2.from(Iterable.map(preferences, (preference) => [
        preference.name,
        preference
      ])));
    }
    _type;
    _viewport;
    _display;
    _scripting;
    _preferences;
    constructor(type, viewport, display, scripting, preferences) {
      this._type = type;
      this._viewport = viewport;
      this._display = display;
      this._scripting = scripting;
      this._preferences = preferences;
    }
    get type() {
      return this._type;
    }
    get viewport() {
      return this._viewport;
    }
    get display() {
      return this._display;
    }
    get scripting() {
      return this._scripting;
    }
    get preferences() {
      return this._preferences.values();
    }
    preference(name) {
      return this._preferences.get(name).getOrElse(() => Preference.unset(name));
    }
    equals(value) {
      return value instanceof _Device && value._type === this._type && value._viewport.equals(this._viewport) && value._display.equals(this._display) && value._scripting.equals(this._scripting) && value._preferences.equals(this._preferences);
    }
    hash(hash2) {
      switch (this._type) {
        case _Device.Type.Print:
          hash2.writeUint8(1);
          break;
        case _Device.Type.Screen:
          hash2.writeUint8(2);
          break;
        case _Device.Type.Speech:
          hash2.writeUint8(3);
      }
      hash2.writeHashable(this._viewport).writeHashable(this._display).writeHashable(this._scripting).writeHashable(this._preferences);
    }
    toJSON(options) {
      return {
        type: this._type,
        viewport: this._viewport.toJSON(options),
        display: this._display.toJSON(options),
        scripting: this._scripting.toJSON(options),
        preferences: [...this._preferences.values()].map((preferece) => preferece.toJSON(options))
      };
    }
  };
  (function(Device2) {
    let Type4;
    (function(Type5) {
      Type5["Print"] = "print";
      Type5["Screen"] = "screen";
      Type5["Speech"] = "speech";
    })(Type4 = Device2.Type || (Device2.Type = {}));
    function from(json) {
      return Device2.of(json.type, Viewport.from(json.viewport), Display.from(json.display), Scripting.from(json.scripting), json.preferences.map((json2) => Preference.from(json2)));
    }
    Device2.from = from;
    function standard() {
      return Device2.of(Type4.Screen, Viewport.standard(), Display.standard());
    }
    Device2.standard = standard;
  })(Device || (Device = {}));

  // node_modules/@siteimprove/alfa-css-feature/dist/media/feature/discrete.js
  var Discrete2;
  (function(Discrete4) {
    function discrete(name, keywords, getDeviceValue, booleanFalse) {
      return class Discrete5 extends Media {
        static of(value) {
          return new Discrete5(Option.of(value));
        }
        static _boolean = new Discrete5(None);
        constructor(value) {
          super(name, value);
        }
        static boolean() {
          return Discrete5._boolean;
        }
        matches(device) {
          const deviceValue = getDeviceValue(device);
          return this._value.map((value) => value.matches(Keyword.of(deviceValue))).getOr(deviceValue !== booleanFalse);
        }
        static _from(value) {
          return value.map(Discrete5.of).getOrElse(Discrete5.boolean);
        }
        static parse = Media.parseDiscrete(name, Discrete5._from, ...keywords);
      };
    }
    function userPreference(name) {
      return discrete(name, [...Preference.preferences[name]], (device) => device.preference(name).value, Preference.unset(name));
    }
    Discrete4.Orientation = discrete("orientation", ["landscape", "portrait"], (device) => device.viewport.orientation);
    Discrete4.ForcedColors = userPreference("forced-colors");
    Discrete4.Inverted = userPreference("inverted");
    Discrete4.PrefersColorScheme = userPreference("prefers-color-scheme");
    Discrete4.PrefersContrast = userPreference("prefers-contrast");
    Discrete4.PrefersReducedData = userPreference("prefers-reduced-data");
    Discrete4.PrefersReducedMotion = userPreference("prefers-reduced-motion");
    Discrete4.PrefersReducedTransparency = userPreference("prefers-reduced-transparency");
  })(Discrete2 || (Discrete2 = {}));

  // node_modules/@siteimprove/alfa-css-feature/dist/media/feature/scripting.js
  var Scripting2 = class _Scripting extends Media {
    static of(value) {
      return new _Scripting(Option.of(value));
    }
    static _boolean = new _Scripting(None);
    constructor(value) {
      super("scripting", value);
    }
    static boolean() {
      return _Scripting._boolean;
    }
    matches(device) {
      return device.scripting.enabled ? this._value.every((value) => value.matches(Keyword.of("enabled"))) : this._value.some((value) => value.matches(Keyword.of("none")));
    }
  };
  (function(Scripting3) {
    function from(value) {
      return value.map(Scripting3.of).getOrElse(Scripting3.boolean);
    }
    Scripting3.parse = Media.parseDiscrete("scripting", from, "none", "initial-only", "enabled");
  })(Scripting2 || (Scripting2 = {}));

  // node_modules/@siteimprove/alfa-css-feature/dist/media/feature/width.js
  var Width = class _Width extends Media {
    static of(value) {
      return new _Width(Option.of(value));
    }
    static _boolean = new _Width(None);
    constructor(value) {
      super("width", value);
    }
    static boolean() {
      return _Width._boolean;
    }
    matches(device) {
      const { viewport: { width } } = device;
      const value = this._value.map((value2) => value2.map((length) => length.resolve(Resolver.length(device))));
      return width > 0 ? value.some((value2) => value2.matches(Length2.of(width, "px"))) : value.every((value2) => value2.matches(Length2.of(0, "px")));
    }
  };
  (function(Width2) {
    function from(value) {
      return value.map(Width2.of).getOrElse(Width2.boolean);
    }
    function isWidth2(value) {
      return value instanceof Width2;
    }
    Width2.isWidth = isWidth2;
    Width2.parse = Media.parseContinuous("width", from);
  })(Width || (Width = {}));

  // node_modules/@siteimprove/alfa-css-feature/dist/media/feature/index.js
  var { delimited: delimited19, either: either43, option: option28 } = Parser;
  var Media2;
  (function(Media5) {
    Media5.Height = Height;
    Media5.Orientation = Discrete2.Orientation;
    Media5.Scripting = Scripting2;
    Media5.Width = Width;
    Media5.ForcedColors = Discrete2.ForcedColors;
    Media5.Inverted = Discrete2.Inverted;
    Media5.PrefersColorScheme = Discrete2.PrefersColorScheme;
    Media5.PrefersContrast = Discrete2.PrefersContrast;
    Media5.PrefersReducedData = Discrete2.PrefersReducedData;
    Media5.PrefersReducedMotion = Discrete2.PrefersReducedMotion;
    Media5.PrefersReducedTransparency = Discrete2.PrefersReducedTransparency;
    Media5.isHeight = Media5.Height.isHeight;
    Media5.isWidth = Media5.Width.isWidth;
    Media5.isMedia = Media.isMedia;
    Media5.parse = delimited19(Token.parseOpenParenthesis, delimited19(option28(Token.parseWhitespace), either43(Media5.Height.parse, Media5.Orientation.parse, Media5.Scripting.parse, Media5.Width.parse, Media5.ForcedColors.parse, Media5.Inverted.parse, Media5.PrefersColorScheme.parse, Media5.PrefersContrast.parse, Media5.PrefersReducedData.parse, Media5.PrefersReducedMotion.parse, Media5.PrefersReducedTransparency.parse)), Token.parseCloseParenthesis);
  })(Media2 || (Media2 = {}));

  // node_modules/@siteimprove/alfa-css-feature/dist/media/modifier.js
  var { either: either44, map: map58 } = Parser;
  var Modifier;
  (function(Modifier2) {
    Modifier2["Only"] = "only";
    Modifier2["Not"] = "not";
  })(Modifier || (Modifier = {}));
  (function(Modifier2) {
    Modifier2.parse = either44(map58(Token.parseIdent("only"), () => Modifier2.Only), map58(Token.parseIdent("not"), () => Modifier2.Not));
  })(Modifier || (Modifier = {}));

  // node_modules/@siteimprove/alfa-css-feature/dist/media/type.js
  var { map: map59 } = Parser;
  var Type = class _Type {
    static of(name) {
      return new _Type(name);
    }
    _name;
    constructor(name) {
      this._name = name;
    }
    get name() {
      return this._name;
    }
    matches(device) {
      switch (this._name) {
        case "screen":
          return device.type === Device.Type.Screen;
        case "print":
          return device.type === Device.Type.Print;
        case "speech":
          return device.type === Device.Type.Speech;
        case "all":
          return true;
        default:
          return false;
      }
    }
    *iterator() {
      yield this;
    }
    [Symbol.iterator]() {
      return this.iterator();
    }
    equals(value) {
      return value instanceof _Type && value._name === this._name;
    }
    toJSON() {
      return {
        name: this._name
      };
    }
    toString() {
      return this._name;
    }
  };
  (function(Type4) {
    function isType(value) {
      return value instanceof Type4;
    }
    Type4.isType = isType;
    Type4.parse = map59(Token.parseIdent((ident) => {
      switch (ident.value) {
        // These values are not allowed as media types.
        case "only":
        case "not":
        case "and":
        case "or":
          return false;
        default:
          return true;
      }
    }), (ident) => Type4.of(ident.value));
  })(Type || (Type = {}));

  // node_modules/@siteimprove/alfa-css-feature/dist/media/query.js
  var { delimited: delimited20, either: either45, end: end2, left: left10, map: map60, option: option29, pair: pair22, right: right22 } = Parser;
  var Query = class _Query {
    static of(modifier2, type, condition) {
      return new _Query(modifier2, type, condition);
    }
    _modifier;
    _type;
    _condition;
    constructor(modifier2, type, condition) {
      this._modifier = modifier2;
      this._type = type;
      this._condition = condition;
    }
    get modifier() {
      return this._modifier;
    }
    get type() {
      return this._type;
    }
    get condition() {
      return this._condition;
    }
    matches(device) {
      const negated = this._modifier.some((modifier2) => modifier2 === Modifier.Not);
      const type = this._type.every((type2) => type2.matches(device));
      const condition = this.condition.every((condition2) => condition2.matches(device));
      return negated !== (type && condition);
    }
    *iterator() {
      yield* this._condition;
    }
    [Symbol.iterator]() {
      return this.iterator();
    }
    equals(value) {
      return value instanceof _Query && value._modifier.equals(this._modifier) && value._type.equals(this._type) && value._condition.equals(this._condition);
    }
    toJSON() {
      return {
        modifier: this._modifier.getOr(null),
        type: this._type.map((type) => type.toJSON()).getOr(null),
        condition: this._condition.map((condition) => condition.toJSON()).getOr(null)
      };
    }
    toString() {
      const modifier2 = this._modifier.getOr("");
      const type = this._type.map((type2) => modifier2 === "" ? `${type2}` : `${modifier2} ${type2}`).getOr("");
      return this._condition.map((condition) => type === "" ? `${condition}` : `${type} and ${condition}`).getOr(type);
    }
  };
  (function(Query4) {
    function isQuery(value) {
      return value instanceof Query4;
    }
    Query4.isQuery = isQuery;
    Query4.notAll = Query4.of(Option.of(Modifier.Not), Option.of(Type.of("all")), None);
    Query4.parse = left10(either45(map60(Condition.parse(Media2.parse), (condition) => Query4.of(None, None, Option.of(condition))), map60(pair22(pair22(option29(delimited20(option29(Token.parseWhitespace), Modifier.parse)), Type.parse), option29(right22(delimited20(option29(Token.parseWhitespace), Token.parseIdent("and")), Condition.parseWithoutOr(Media2.parse)))), ([[modifier2, type], condition]) => Query4.of(modifier2, Option.of(type), condition))), end2(() => `Unexpected token`));
  })(Query || (Query = {}));

  // node_modules/@siteimprove/alfa-css-feature/dist/media/list.js
  var { either: either46, end: end3, map: map61, separatedList: separatedList9, takeUntil: takeUntil3 } = Parser;
  var List3 = class _List {
    static of(queries) {
      return new _List(queries);
    }
    _queries;
    constructor(queries) {
      this._queries = Array.from(queries);
    }
    get queries() {
      return this._queries;
    }
    matches(device) {
      return this._queries.length === 0 || this._queries.some((query) => query.matches(device));
    }
    equals(value) {
      return value instanceof _List && value._queries.length === this._queries.length && value._queries.every((query, i) => query.equals(this._queries[i]));
    }
    *[Symbol.iterator]() {
      yield* this._queries;
    }
    toJSON() {
      return this._queries.map((query) => query.toJSON());
    }
    toString() {
      return this._queries.join(", ");
    }
  };
  (function(List5) {
    function isList(value) {
      return value instanceof List5;
    }
    List5.isList = isList;
    List5.parse = map61(separatedList9(map61(takeUntil3(Component.consume, either46(Token.parseComma, end3(() => `Unexpected token`))), (components) => Iterable.flatten(components)), Token.parseComma), (queries) => List5.of(Iterable.map(queries, (tokens) => Query.parse(Slice.from(tokens).trim(Token.isWhitespace)).map(([, query]) => query).getOr(Query.notAll))));
  })(List3 || (List3 = {}));

  // node_modules/@siteimprove/alfa-css-feature/dist/media/index.js
  var Media3;
  (function(Media5) {
    Media5.Feature = Media2;
    Media5.List = List3;
    Media5.Modifier = Modifier;
    Media5.Query = Query;
    Media5.Type = Type;
    Media5.Value = Value3;
    Media5.type = Media5.Type.of, Media5.isType = Media5.Type.isType;
    Media5.isMedia = Media5.Feature.isMedia;
    Media5.query = Media5.Query.of, Media5.isQuery = Media5.Query.isQuery;
    Media5.list = Media5.List.of, Media5.isList = Media5.List.isList;
    Media5.parse = Media5.List.parse;
  })(Media3 || (Media3 = {}));

  // node_modules/@siteimprove/alfa-css-feature/dist/supports/feature/property.js
  var { delimited: delimited21, map: map62, option: option30, separated: separated3 } = Parser;
  var Property = class _Property {
    static of(name, value) {
      return new _Property(name, value);
    }
    _name;
    _value;
    constructor(name, value) {
      this._name = name;
      this._value = value;
    }
    get name() {
      return this._name;
    }
    get value() {
      return this._value;
    }
    matches() {
      return !this._name.startsWith("-");
    }
    *iterator() {
      yield this;
    }
    [Symbol.iterator]() {
      return this.iterator();
    }
    equals(value) {
      return value instanceof _Property && value._name === this._name && value._value === this._value;
    }
    toJSON() {
      return {
        type: "property",
        name: this._name,
        value: this._value
      };
    }
    toString() {
      return `${this._name}: ${this._value}`;
    }
  };
  (function(Property2) {
    function isProperty(value) {
      return value instanceof Property2;
    }
    Property2.isProperty = isProperty;
    const parseValue = (input) => {
      let count = 0;
      let value = "";
      let rest = input;
      while (!rest.isEmpty()) {
        const token = rest.first().getUnsafe();
        if (Token.isOpenParenthesis(token) || Token.isFunction(token)) {
          count++;
        } else if (Token.isCloseParenthesis(token)) {
          count--;
        }
        if (count < 0) {
          break;
        }
        rest = rest.rest();
        value += token.toString();
      }
      return count < 0 ? Ok.of([rest, value.trim()]) : Err.of("Unexpected end of input");
    };
    Property2.parse = map62(separated3(Token.parseIdent(), delimited21(option30(Token.parseWhitespace), Token.parseColon), parseValue), ([name, value]) => Property2.of(name.value, value));
  })(Property || (Property = {}));

  // node_modules/@siteimprove/alfa-css-feature/dist/supports/query.js
  var { end: end4, left: left11, map: map63 } = Parser;
  var Query2 = class _Query {
    static of(condition) {
      return new _Query(condition);
    }
    _condition;
    constructor(condition) {
      this._condition = condition;
    }
    get condition() {
      return this._condition;
    }
    matches(device) {
      return this._condition.matches(device);
    }
    *iterator() {
      yield* this._condition;
    }
    [Symbol.iterator]() {
      return this.iterator();
    }
    equals(value) {
      return value instanceof _Query && value._condition.equals(this._condition);
    }
    toJSON() {
      return { condition: this._condition.toJSON() };
    }
    toString() {
      return this._condition.toString();
    }
  };
  (function(Query4) {
    function isQuery(value) {
      return value instanceof Query4;
    }
    Query4.isQuery = isQuery;
    Query4.parse = left11(map63(Condition.parse(Property.parse), Query4.of), end4(() => `Unexpected token`));
  })(Query2 || (Query2 = {}));

  // node_modules/@siteimprove/alfa-css-feature/dist/supports/index.js
  var Supports;
  (function(Supports2) {
    Supports2.Property = Property;
    Supports2.Query = Query2;
    Supports2.isProperty = Supports2.Property.isProperty;
    Supports2.query = Supports2.Query.of, Supports2.isQuery = Supports2.Query.isQuery;
    Supports2.parse = Supports2.Query.parse;
  })(Supports || (Supports = {}));

  // node_modules/@siteimprove/alfa-css-feature/dist/index.js
  var Feature;
  (function(Feature3) {
    Feature3.Condition = Condition;
    Feature3.And = And;
    Feature3.Or = Or;
    Feature3.Not = Not;
    Feature3.Media = Media3;
    Feature3.Supports = Supports;
    Feature3.isMedia = Feature3.Media.isMedia;
    Feature3.isProperty = Feature3.Supports.isProperty;
    Feature3.and = Feature3.And.of, Feature3.isAnd = Feature3.And.isAnd;
    Feature3.or = Feature3.Or.of, Feature3.isOr = Feature3.Or.isOr;
    Feature3.not = Feature3.Not.of, Feature3.isNot = Feature3.Not.isNot;
    Feature3.isCondition = Feature3.Condition.isCondition;
    Feature3.parseMediaQuery = Feature3.Media.parse;
    Feature3.parseSupportsQuery = Feature3.Supports.parse;
  })(Feature || (Feature = {}));

  // node_modules/@siteimprove/alfa-dom/dist/style/sheet.js
  var Sheet = class _Sheet {
    static of(rules, disabled = false, condition = None) {
      return new _Sheet(Array.from(rules), disabled, condition);
    }
    static empty() {
      return new _Sheet([], false, None);
    }
    _rules;
    _disabled;
    _condition;
    constructor(rules, disabled, condition) {
      this._rules = rules.filter((rule) => rule._attachOwner(this));
      this._disabled = disabled;
      this._condition = condition;
    }
    get rules() {
      return this._rules;
    }
    get disabled() {
      return this._disabled;
    }
    get condition() {
      return this._condition;
    }
    *children() {
      yield* this._rules;
    }
    *descendants() {
      for (const child of this.children()) {
        yield child;
        yield* child.descendants();
      }
    }
    equals(value) {
      return value instanceof _Sheet && value._disabled === this._disabled && value._condition.equals(this._condition) && value._rules.length === this._rules.length && value._rules.every((rule, i) => rule.equals(this._rules[i]));
    }
    toJSON() {
      return {
        rules: [...this._rules].map((rule) => rule.toJSON()),
        disabled: this._disabled,
        condition: this._condition.getOr(null)
      };
    }
    toString() {
      return this._rules.join("\n");
    }
  };
  (function(Sheet2) {
    function from(json) {
      return Sheet2.of(json.rules.map(Rule2.from), json.disabled, Option.from(json.condition));
    }
    Sheet2.from = from;
  })(Sheet || (Sheet = {}));

  // node_modules/@siteimprove/alfa-dom/dist/style/rule/import.js
  var { and: and2 } = Predicate;
  var ImportRule = class _ImportRule extends ConditionRule {
    static of(href, sheet, mediaCondition = None, supportCondition = None, layer = None) {
      return new _ImportRule(href, sheet, mediaCondition, supportCondition, layer);
    }
    _href;
    _sheet;
    _mediaQueries;
    _supportCondition;
    // There may be no support condition, or an unparsable (i.e. non-supported) one.
    // The former is None, the later is Some(None).
    _supportQuery;
    // Anonymous layers are represented with the empty string, matching the
    // CSSImportRule interface
    _layer;
    constructor(href, sheet, mediaCondition, supportCondition, layer) {
      super("import", mediaCondition.getOr("all"), []);
      this._href = href;
      this._sheet = sheet;
      this._supportCondition = supportCondition;
      this._layer = layer;
      this._mediaQueries = mediaCondition.flatMap((condition) => Feature.parseMediaQuery(Lexer.lex(condition)).ok()).map(([, queries]) => queries).getOr(Feature.Media.List.of([]));
      this._supportQuery = supportCondition.map((condition) => Feature.parseSupportsQuery(
        // We're not sure where the condition comes from, but Alfa only parses
        // them when they are parenthesised, while CSSImportRule.supportsText
        // provides the raw text. Extra parenthesis don't block parsing.
        // In doubt, adding some to avoid potential problems.
        Lexer.lex(`(${condition})`)
      ).ok().map(([, query]) => query));
    }
    get supportCondition() {
      return this._supportCondition;
    }
    get mediaQueries() {
      return this._mediaQueries;
    }
    get supportQuery() {
      return this._supportQuery;
    }
    get layer() {
      return this._layer;
    }
    get rules() {
      return this._sheet.rules;
    }
    get href() {
      return this._href;
    }
    get sheet() {
      return this._sheet;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        href: this._href,
        // We match the CSSImportRule interface returning null when no support
        // text exist
        supportText: this._supportCondition.getOr(null),
        // We match the CSSImportRule interface returning null when no layer
        // is declared, and "" for an anonymous layer.
        layer: this._layer.getOr(null)
      };
    }
    toString() {
      return `@import url(${this._href}) ${this._layer.map((layer) => `layer${layer === "" ? "" : `(${layer}) `}`)}${this._supportCondition.map((condition) => `supports(${condition}) `).getOr("")}${this._condition}`;
    }
  };
  (function(ImportRule2) {
    function isImportRule2(value) {
      return value instanceof ImportRule2;
    }
    ImportRule2.isImportRule = isImportRule2;
    function matchesMedia(device) {
      return (rule) => rule.mediaQueries.matches(device);
    }
    function matchesSupport(device) {
      return (rule) => rule.supportQuery.every((option64) => option64.some((query) => query.matches(device)));
    }
    function matches(device) {
      return and2(matchesMedia(device), matchesSupport(device));
    }
    ImportRule2.matches = matches;
    function fromImportRule(json) {
      return Trampoline.traverse(json.rules, Rule2.fromRule).map((rules) => ImportRule2.of(json.href, Sheet.of(rules), Option.of(json.condition), Option.from(json.supportText), Option.from(json.layer)));
    }
    ImportRule2.fromImportRule = fromImportRule;
  })(ImportRule || (ImportRule = {}));

  // node_modules/@siteimprove/alfa-dom/dist/style/rule/keyframe.js
  var KeyframeRule = class _KeyframeRule extends Rule2 {
    static of(key, declarations) {
      return new _KeyframeRule(key, Array.from(declarations));
    }
    _key;
    _style;
    constructor(key, declarations) {
      super("keyframe");
      this._key = key;
      this._style = Block2.of(declarations.filter((declaration) => declaration._attachParent(this)));
    }
    get key() {
      return this._key;
    }
    get style() {
      return this._style;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        key: this._key,
        style: this._style.toJSON()
      };
    }
    toString() {
      const style = this._style.toString();
      return `@keyframe ${this._key} {${style === "" ? "" : `
${String2.indent(style)}
`}}`;
    }
  };
  (function(KeyframeRule2) {
    function isKeyframeRule(value) {
      return value instanceof KeyframeRule2;
    }
    KeyframeRule2.isKeyframeRule = isKeyframeRule;
    function fromKeyframeRule(json) {
      return Trampoline.done(KeyframeRule2.of(json.key, Block2.from(json.style).declarations));
    }
    KeyframeRule2.fromKeyframeRule = fromKeyframeRule;
  })(KeyframeRule || (KeyframeRule = {}));

  // node_modules/@siteimprove/alfa-dom/dist/style/rule/keyframes.js
  var KeyframesRule = class _KeyframesRule extends GroupingRule {
    static of(name, rules) {
      return new _KeyframesRule(name, Array.from(rules));
    }
    _name;
    constructor(name, rules) {
      super("keyframes", rules);
      this._name = name;
    }
    get name() {
      return this._name;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        name: this._name
      };
    }
    toString() {
      const rules = this._rules.map((rule) => String2.indent(rule.toString())).join("\n\n");
      return `@keyframes ${this._name} {${rules === "" ? "" : `
${rules}
`}}`;
    }
  };
  (function(KeyframesRule2) {
    function isKeyframesRule(value) {
      return value instanceof KeyframesRule2;
    }
    KeyframesRule2.isKeyframesRule = isKeyframesRule;
    function fromKeyframesRule(json) {
      return Trampoline.traverse(json.rules, Rule2.fromRule).map((rules) => KeyframesRule2.of(json.name, rules));
    }
    KeyframesRule2.fromKeyframesRule = fromKeyframesRule;
  })(KeyframesRule || (KeyframesRule = {}));

  // node_modules/@siteimprove/alfa-dom/dist/style/rule/layer.js
  var Layer;
  (function(Layer4) {
    class StatementRule extends Rule2 {
      static of(layers) {
        return new StatementRule(Array2.from(layers));
      }
      _layers;
      constructor(layers) {
        super("layer-statement");
        this._layers = layers;
      }
      get layers() {
        return this._layers;
      }
      toJSON() {
        return {
          ...super.toJSON(),
          layers: this._layers
        };
      }
      toString() {
        return `@layer ${this._layers.join(", ")};`;
      }
    }
    Layer4.StatementRule = StatementRule;
    (function(StatementRule2) {
      function fromLayerStatementRule(json) {
        return Trampoline.done(StatementRule2.of(json.layers));
      }
      StatementRule2.fromLayerStatementRule = fromLayerStatementRule;
      function isLayerStatementRule2(value) {
        return value instanceof StatementRule2;
      }
      StatementRule2.isLayerStatementRule = isLayerStatementRule2;
    })(StatementRule = Layer4.StatementRule || (Layer4.StatementRule = {}));
    class BlockRule extends GroupingRule {
      static of(rules, layer) {
        return new BlockRule(Option.from(layer), Array2.from(rules));
      }
      _layer;
      constructor(layer, rules) {
        super("layer-block", rules);
        this._layer = layer;
      }
      get layer() {
        return this._layer;
      }
      equals(value) {
        return value instanceof BlockRule && value._layer.equals(this._layer) && super.equals(value);
      }
      toJSON() {
        return {
          ...super.toJSON(),
          layer: this._layer.getOr(null)
        };
      }
      toString() {
        const rules = this._rules.map((rule) => String2.indent(rule.toString())).join("\n\n");
        return `@layer ${this._layer.isSome() ? this._layer.getUnsafe() + " " : ""}{${rules === "" ? "" : `
${rules}
`}}`;
      }
    }
    Layer4.BlockRule = BlockRule;
    (function(BlockRule2) {
      function fromLayerBlockRule(json) {
        return Trampoline.traverse(json.rules, Rule2.fromRule).map((rules) => BlockRule2.of(rules, json.layer));
      }
      BlockRule2.fromLayerBlockRule = fromLayerBlockRule;
      function isLayerBlockRule2(value) {
        return value instanceof BlockRule2;
      }
      BlockRule2.isLayerBlockRule = isLayerBlockRule2;
    })(BlockRule = Layer4.BlockRule || (Layer4.BlockRule = {}));
  })(Layer || (Layer = {}));

  // node_modules/@siteimprove/alfa-dom/dist/style/rule/media.js
  var MediaRule = class _MediaRule extends ConditionRule {
    static of(condition, rules) {
      return new _MediaRule(condition, Array.from(rules));
    }
    _queries;
    constructor(condition, rules) {
      super("media", condition, rules);
      this._queries = Feature.parseMediaQuery(Lexer.lex(condition)).map(([, queries]) => queries).getOr(Feature.Media.List.of([]));
    }
    get queries() {
      return this._queries;
    }
    toJSON() {
      return super.toJSON();
    }
    toString() {
      const rules = this._rules.map((rule) => String2.indent(rule.toString())).join("\n\n");
      return `@media ${this._condition} {${rules === "" ? "" : `
${rules}
`}}`;
    }
  };
  (function(MediaRule2) {
    function isMediaRule2(value) {
      return value instanceof MediaRule2;
    }
    MediaRule2.isMediaRule = isMediaRule2;
    function matches(device) {
      return (rule) => rule.queries.matches(device);
    }
    MediaRule2.matches = matches;
    function fromMediaRule(json) {
      return Trampoline.traverse(json.rules, Rule2.fromRule).map((rules) => MediaRule2.of(json.condition, rules));
    }
    MediaRule2.fromMediaRule = fromMediaRule;
  })(MediaRule || (MediaRule = {}));

  // node_modules/@siteimprove/alfa-dom/dist/style/rule/namespace.js
  var NamespaceRule = class _NamespaceRule extends Rule2 {
    static of(namespace, prefix) {
      return new _NamespaceRule(namespace, prefix);
    }
    _namespace;
    _prefix;
    constructor(namespace, prefix) {
      super("namespace");
      this._namespace = namespace;
      this._prefix = prefix;
    }
    get namespace() {
      return this._namespace;
    }
    get prefix() {
      return this._prefix;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        namespace: this._namespace,
        prefix: this._prefix.getOr(null)
      };
    }
    toString() {
      const prefix = this._prefix.map((prefix2) => ` ${prefix2}`).getOr("");
      return `@namespace ${prefix}url(${this._namespace})`;
    }
  };
  (function(NamespaceRule2) {
    function isNamespaceRule(value) {
      return value instanceof NamespaceRule2;
    }
    NamespaceRule2.isNamespaceRule = isNamespaceRule;
    function fromNamespaceRule(json) {
      return Trampoline.done(NamespaceRule2.of(json.namespace, Option.from(json.prefix)));
    }
    NamespaceRule2.fromNamespaceRule = fromNamespaceRule;
  })(NamespaceRule || (NamespaceRule = {}));

  // node_modules/@siteimprove/alfa-dom/dist/style/rule/page.js
  var PageRule = class _PageRule extends Rule2 {
    static of(selector, declarations) {
      return new _PageRule(selector, Array.from(declarations));
    }
    _selector;
    _style;
    constructor(selector, declarations) {
      super("page");
      this._selector = selector;
      this._style = Block2.of(declarations.filter((declaration) => declaration._attachParent(this)));
    }
    get selector() {
      return this._selector;
    }
    get style() {
      return this._style;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        selector: this._selector,
        style: this._style.toJSON()
      };
    }
    toString() {
      const style = this._style.toString();
      return `@page ${this._selector} {${style === "" ? "" : `
${String2.indent(style)}
`}}`;
    }
  };
  (function(PageRule2) {
    function isPageRule(value) {
      return value instanceof PageRule2;
    }
    PageRule2.isPageRule = isPageRule;
    function fromPageRule(json) {
      return Trampoline.done(PageRule2.of(json.selector, Block2.from(json.style)));
    }
    PageRule2.fromPageRule = fromPageRule;
  })(PageRule || (PageRule = {}));

  // node_modules/@siteimprove/alfa-dom/dist/style/rule/style.js
  var StyleRule = class _StyleRule extends Rule2 {
    static of(selector, declarations, hint = false) {
      return new _StyleRule(selector, Array.from(declarations), hint);
    }
    _selector;
    _style;
    _hint;
    constructor(selector, declarations, hint) {
      super("style");
      this._selector = selector;
      this._style = Block2.of(declarations.filter((declaration) => declaration._attachParent(this)));
      this._hint = hint;
    }
    get selector() {
      return this._selector;
    }
    get style() {
      return this._style;
    }
    get hint() {
      return this._hint;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        selector: this._selector,
        style: this._style.toJSON()
      };
    }
    toString() {
      const style = this._style.toString();
      return `${this._selector} {${style === "" ? "" : `
${String2.indent(style)}
`}}`;
    }
  };
  (function(StyleRule2) {
    function isStyleRule2(value) {
      return value instanceof StyleRule2;
    }
    StyleRule2.isStyleRule = isStyleRule2;
    function isEmpty10(rule) {
      return rule.style.isEmpty();
    }
    StyleRule2.isEmpty = isEmpty10;
    function fromStyleRule(json) {
      return Trampoline.done(StyleRule2.of(json.selector, Block2.from(json.style)));
    }
    StyleRule2.fromStyleRule = fromStyleRule;
  })(StyleRule || (StyleRule = {}));

  // node_modules/@siteimprove/alfa-dom/dist/style/rule/supports.js
  var SupportsRule = class _SupportsRule extends ConditionRule {
    static of(condition, rules) {
      return new _SupportsRule(condition, Array.from(rules));
    }
    _query;
    constructor(condition, rules) {
      super("supports", condition, rules);
      this._query = Feature.parseSupportsQuery(Lexer.lex(condition)).map(([, query]) => query).ok();
    }
    get query() {
      return this._query;
    }
    toJSON() {
      return super.toJSON();
    }
    toString() {
      const rules = this._rules.map((rule) => String2.indent(rule.toString())).join("\n\n");
      return `@supports ${this._condition} {${rules === "" ? "" : `
${rules}
`}}`;
    }
  };
  (function(SupportsRule2) {
    function isSupportsRule2(value) {
      return value instanceof SupportsRule2;
    }
    SupportsRule2.isSupportsRule = isSupportsRule2;
    function matches(device) {
      return (rule) => rule.query.some((query) => query.matches(device));
    }
    SupportsRule2.matches = matches;
    function fromSupportsRule(json) {
      return Trampoline.traverse(json.rules, Rule2.fromRule).map((rules) => SupportsRule2.of(json.condition, rules));
    }
    SupportsRule2.fromSupportsRule = fromSupportsRule;
  })(SupportsRule || (SupportsRule = {}));

  // node_modules/@siteimprove/alfa-cache/dist/cache.js
  var Cache2 = class _Cache {
    static empty() {
      return new _Cache();
    }
    _storage = /* @__PURE__ */ new WeakMap();
    constructor() {
    }
    get(key, ifMissing) {
      if (this._storage.has(key)) {
        const value2 = this._storage.get(key);
        if (ifMissing === void 0) {
          return Option.of(value2);
        }
        return value2;
      }
      if (ifMissing === void 0) {
        return None;
      }
      const value = ifMissing(this);
      this._storage.set(key, value);
      return value;
    }
    has(key) {
      return this._storage.has(key);
    }
    set(key, value) {
      this._storage.set(key, value);
      return this;
    }
    merge(iterable) {
      return Iterable.reduce(iterable, (cache16, [key, value]) => cache16.set(key, value), this);
    }
  };
  (function(Cache3) {
    function from(iterable) {
      return Cache3.empty().merge(iterable);
    }
    Cache3.from = from;
  })(Cache2 || (Cache2 = {}));

  // node_modules/@siteimprove/alfa-flags/dist/flags.js
  var Flags = class _Flags {
    _value;
    constructor(value) {
      this._value = value;
    }
    /**
     * A compact representation of the set of flags as a number
     */
    get value() {
      return this._value;
    }
    /**
     * Test whether a given flag is present (or set) in the set of flags
     */
    has(flag) {
      return (this._value & flag) === flag;
    }
    /**
     * Test whether a given flag is present (or set) in the set of flags
     */
    isSet = this.has;
    /**
     * Adds a list of flags to the set, and return a new one.
     */
    add(...flags) {
      return new this.constructor(this._value | _Flags._reduce(...flags));
    }
    /**
     * Adds a list of flags to the set (aka sets the flags), and return a new one.
     */
    set = this.add;
    /**
     * Removes a list of flags from the set, and return a new one.
     */
    remove(...flags) {
      return new this.constructor(this._value & ~_Flags._reduce(...flags));
    }
    /**
     * Removes a list of flags to the set (aka unsets the flags), and return a new one.
     */
    unset = this.remove;
    /**
     * Reduces a list of flags into a single number representing all of them
     * (with only the corresponding bits set to 1).
     */
    static _reduce(...flags) {
      return Array2.reduce(flags, (prev, cur) => prev | cur, 0);
    }
    equals(value) {
      return value instanceof _Flags && this._value === value._value;
    }
    toJSON() {
      return {};
    }
  };

  // node_modules/@siteimprove/alfa-tree/dist/tree.js
  var { equals: equals3 } = Refinement;
  var Node3 = class {
    _children;
    _parent = None;
    _type;
    // Externally provided data.
    _externalId;
    _extraData;
    _internalId;
    /**
     * Whether the node is frozen.
     *
     * @remarks
     * As nodes are initialized without a parent and possibly attached to a parent
     * after construction, this makes hierarchies of nodes mutable. That is, a
     * node without a parent node may be assigned one by being passed as a child
     * to a parent node. When this happens, a node becomes frozen. Nodes can also
     * become frozen before being assigned a parent by using the `Node#freeze()`
     * method.
     */
    _frozen = false;
    constructor(children, type, externalId, internalId, extraData) {
      this._children = children.filter((child) => child._attachParent(this));
      this._type = type;
      this._externalId = externalId;
      this._extraData = extraData;
      this._internalId = internalId ?? crypto.randomUUID();
    }
    get type() {
      return this._type;
    }
    get externalId() {
      return this._externalId;
    }
    get extraData() {
      return this._extraData;
    }
    get internalId() {
      return this._internalId;
    }
    /**
     * @deprecated Aliases to {@link Node#internalId}.
     */
    get serializationId() {
      return this.internalId;
    }
    get frozen() {
      return this._frozen;
    }
    /**
     * Freeze the node. This prevents further expansion of the node hierarchy,
     * meaning that the node can no longer be passed as a child to a parent node.
     */
    freeze() {
      this._frozen = this._frozen || true;
      return this;
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-parent}
     */
    parent(options) {
      return this._parent;
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-parent}
     */
    isParentOf(node, options) {
      return node.parent(options).includes(this);
    }
    _lastKnownRoot = [];
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-root}
     */
    // Since root is looking upward, it may change between calls.
    // So we cache the last known root, try again from here and update the result
    // if necessary. Once the tree is fully frozen, this only cost an extra look
    // through this.parent which is not expensive.
    root(options) {
      const value = options?.value ?? 0;
      let lastKnownRoot = this._lastKnownRoot[value] ?? this;
      for (const parent of lastKnownRoot.parent(options)) {
        lastKnownRoot = parent.root(options);
      }
      this._lastKnownRoot[value] = lastKnownRoot;
      return lastKnownRoot;
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-root}
     */
    isRootOf(node, options) {
      return node.root(options) === this;
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-child}
     */
    children(options) {
      return Sequence.from(this._children);
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-child}
     */
    isChildOf(node, options) {
      return node.children(options).includes(this);
    }
    _descendants = [];
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-descendant}
     */
    // While this is lazily built, actually generating the sequence takes time to
    // walk through the tree and resolve all the continuations.
    // Caching it saves a lot of time by generating the sequence only once.
    descendants(options) {
      const value = options?.value ?? 0;
      if (this._descendants[value] === void 0) {
        this._descendants[value] = this.children(options).flatMap((child) => Sequence.of(child, Lazy.of(() => child.descendants(options))));
      }
      return this._descendants[value];
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-descendant}
     */
    isDescendantOf(node, options) {
      return node.descendants(options).includes(this);
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-inclusive-descendant}
     */
    inclusiveDescendants(options) {
      return Sequence.of(this, Lazy.of(() => this.descendants(options)));
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-inclusive-descendant}
     */
    isInclusiveDescendantsOf(node, options) {
      return node.inclusiveDescendants(options).includes(this);
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-ancestor}
     */
    ancestors(options) {
      for (const parent of this.parent(options)) {
        return Sequence.of(parent, Lazy.of(() => parent.ancestors(options)));
      }
      return Sequence.empty();
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-ancestor}
     */
    isAncestorOf(node, options) {
      return node.ancestors(options).includes(this);
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-inclusive-ancestor}
     */
    inclusiveAncestors(options) {
      return Sequence.of(this, Lazy.of(() => this.ancestors(options)));
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-inclusive-ancestor}
     */
    isInclusiveAncestorOf(node, options) {
      return node.inclusiveAncestors(options).includes(this);
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-sibling}
     */
    siblings(options) {
      return this.inclusiveSiblings(options).reject(equals3(this));
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-sibling}
     */
    isSiblingOf(node, options) {
      return node.siblings(options).includes(this);
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-inclusive-sibling}
     */
    inclusiveSiblings(options) {
      for (const parent of this.parent(options)) {
        return parent.children(options);
      }
      return Sequence.empty();
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-inclusive-sibling}
     */
    isInclusiveSiblingOf(node, options) {
      return node.inclusiveSiblings(options).includes(this);
    }
    _preceding = [];
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-preceding}
     */
    // Due to reversing, this is not lazy and is costly at build time.
    // This only looks in frozen parts of the tree.
    preceding(options) {
      const value = options?.value ?? 0;
      if (this._preceding[value] === void 0) {
        this._preceding[value] = this.inclusiveSiblings(options).takeUntil(equals3(this)).reverse();
      }
      return this._preceding[value];
    }
    _following = [];
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-following}
     */
    // Due to skipUntil, this is not fully lazy and is costly at build time.
    // This only looks in frozen parts of the tree.
    following(options) {
      const value = options?.value ?? 0;
      if (this._following[value] === void 0) {
        this._following[value] = this.inclusiveSiblings(options).skipUntil(equals3(this)).rest();
      }
      return this._following[value];
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-first-child}
     */
    // Sequence.first() is fast and doesn't need caching
    first(options) {
      return this.children(options).first();
    }
    _last = [];
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-last-child}
     */
    // Due to last, this is not lazy and is costly at build time.
    // This only looks in frozen parts of the tree.
    last(options) {
      const value = options?.value ?? 0;
      if (this._last[value] === void 0) {
        this._last[value] = this.children(options).last();
      }
      return this._last[value];
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-previous-sibling}
     */
    previous(options) {
      return this.preceding(options).first();
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-next-sibling}
     */
    next(options) {
      return this.following(options).first();
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-index}
     */
    index(options) {
      return this.preceding(options).size;
    }
    /**
     * {@link https://dom.spec.whatwg.org/#dom-element-closest}
     */
    closest(predicate, options) {
      return this.inclusiveAncestors(options).find(predicate);
    }
    *[Symbol.iterator]() {
      yield* this.descendants();
    }
    equals(value) {
      return value === this;
    }
    hash(hash2) {
      hash2.writeObject(this);
    }
    toJSON(options) {
      const verbosity = options?.verbosity ?? Serializable.Verbosity.Medium;
      const result = {
        type: this._type
      };
      if (verbosity < Serializable.Verbosity.Medium) {
        result.internalId = this._internalId;
        result.serializationId = this.serializationId;
        return result;
      }
      result.children = this._children.map((child) => child.toJSON(options));
      if (this._externalId !== void 0) {
        result.externalId = this._externalId;
      }
      if (verbosity >= Serializable.Verbosity.High) {
        result.internalId = this._internalId;
        result.serializationId = this.serializationId;
      }
      return result;
    }
    /**
     * @internal
     */
    _attachParent(parent) {
      if (this._frozen || this._parent.isSome()) {
        return false;
      }
      this._parent = Option.of(parent);
      this._frozen = true;
      return true;
    }
  };

  // node_modules/@siteimprove/alfa-dom/dist/node/predicate/has-child.js
  function hasChild(predicate, options = Node4.Traversal.empty) {
    return (node) => node.children(options).some(predicate);
  }

  // node_modules/@siteimprove/alfa-dom/dist/node/predicate/has-descendant.js
  function hasDescendant(predicate, options = Node4.Traversal.empty) {
    return (node) => node.descendants(options).some(predicate);
  }

  // node_modules/@siteimprove/alfa-dom/dist/node/predicate/has-inclusive-descendant.js
  function hasInclusiveDescendant(predicate, options = Node4.Traversal.empty) {
    return (node) => node.inclusiveDescendants(options).some(predicate);
  }

  // node_modules/@siteimprove/alfa-dom/dist/node/predicate/has-text-content.js
  var { isEmpty } = Iterable;
  var { not: not13 } = Predicate;
  function hasTextContent(predicate = not13(isEmpty), options = Node4.Traversal.empty) {
    return (node) => predicate(node.textContent(options));
  }

  // node_modules/@siteimprove/alfa-dom/dist/node/predicate/is-root.js
  function isRoot(options) {
    return (node) => node.parent(options).isNone();
  }

  // node_modules/@siteimprove/alfa-dom/dist/node/traversal/lowest-common-ancestor.js
  function lowestCommonAncestor(node1, node2, options = Node4.Traversal.empty) {
    return node1.inclusiveAncestors(options).reverse().zip(node2.inclusiveAncestors(options).reverse()).reduceWhile(([first1, first2]) => first1.equals(first2), (_, [node]) => Option.of(node), None);
  }

  // node_modules/@siteimprove/alfa-dom/dist/node/traversal/get-nodes-between.js
  var { equals: equals4, or } = Predicate;
  function getNodesBetween(node1, node2, includeOptions = { includeFirst: false, includeSecond: false }, treeOptions = Node4.fullTree) {
    let between = getNodesInclusivelyBetween(node1, node2, treeOptions);
    if (between.isEmpty()) {
      return between;
    }
    if (!includeOptions.includeFirst) {
      const first = between.first().getUnsafe();
      between = first.closest((ancestor) => ancestor.next(treeOptions).isSome(), treeOptions).flatMap((node) => node.next(treeOptions)).map((next) => between.skipUntil((node) => node.equals(next))).getOrElse(Sequence.empty);
    }
    between = includeOptions.includeSecond || between.isEmpty() ? between : between.skipLast(1);
    return between;
  }
  function getNodesInclusivelyBetween(node1, node2, treeOptions) {
    const isFrontier = or(equals4(node1), equals4(node2));
    return lowestCommonAncestor(node1, node2, treeOptions).map((context) => context.inclusiveDescendants(treeOptions).skipUntil(isFrontier).skipLastUntil(isFrontier)).getOrElse(Sequence.empty);
  }

  // node_modules/@siteimprove/alfa-dom/dist/node.js
  var Node4 = class _Node extends Node3 {
    constructor(children, type, externalId, internalId, extraData) {
      super(children, type, externalId, internalId, extraData);
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-descendant-text-content}
     */
    textContent(options = _Node.Traversal.empty) {
      return String2.flatten(this.descendants(options).filter(Text.isText).join(""));
    }
    /**
     * Construct a sequence of descendants of this node sorted by tab index. Only
     * nodes with a non-negative tab index are included in the sequence.
     *
     * {@link https://html.spec.whatwg.org/multipage/#tabindex-value}
     */
    tabOrder() {
      function candidates(node) {
        if (Element.isElement(node)) {
          const element = node;
          const tabIndex = element.tabIndex();
          if (element.shadow.isSome()) {
            if (tabIndex.some((i) => i < 0)) {
              return Sequence.empty();
            } else {
              return Sequence.of([element, tabIndex]);
            }
          }
          if (element.content.isSome()) {
            return Sequence.of([element, tabIndex]);
          }
          if (Slot.isSlot(element)) {
            return Sequence.from(element.assignedNodes()).filter(Element.isElement).map((element2) => [element2, tabIndex]);
          }
          if (tabIndex.some((i) => i >= 0)) {
            return Sequence.of([element, tabIndex], Lazy.of(() => element.children().flatMap(candidates)));
          }
        }
        return node.children().flatMap(candidates);
      }
      const comparer = ([, a], [, b]) => {
        const aValue = a.getOr(0);
        const bValue = b.getOr(0);
        return aValue === 0 ? (
          // "normal order" must come after any "specific order",
          // i.e., 0 is greater than any positive number.
          bValue === 0 ? Comparison.Equal : Comparison.Greater
        ) : bValue === 0 ? (
          // aValue cannot be 0 anymore.
          Comparison.Less
        ) : (
          // If none are 0, simply compare the values.
          Comparable.compare(aValue, bValue)
        );
      };
      function expand([element, tabIndex]) {
        for (const shadow of element.shadow) {
          if (tabIndex.some((i) => i >= 0)) {
            return Sequence.of(element, Lazy.of(() => shadow.tabOrder()));
          } else {
            return shadow.tabOrder();
          }
        }
        for (const content of element.content) {
          return content.tabOrder();
        }
        return Sequence.of(element);
      }
      return candidates(this).sortWith(comparer).flatMap(expand);
    }
    parent(options = _Node.Traversal.empty) {
      const parent = this._parent;
      if (options.isSet(_Node.Traversal.flattened)) {
        return parent.flatMap((parent2) => {
          if (Shadow2.isShadow(parent2)) {
            return parent2.host;
          }
          if (Element.isElement(parent2) && parent2.shadow.isSome() && Slotable.isSlotable(this)) {
            return this.assignedSlot().flatMap((slot) => slot.parent(options));
          }
          return Option.of(parent2);
        });
      }
      return parent;
    }
    _path = [];
    /**
     * @internal
     */
    _internalPath(options) {
      let path = this.parent(options).map((parent) => parent.path(options)).getOr("/");
      path += path === "/" ? "" : "/";
      path += "node()";
      path += `[${this.index(options) + 1}]`;
      return path;
    }
    /**
     * Get an XPath that uniquely identifies the node across descendants of its
     * root.
     */
    // path may change if the subtree is attached to a parent, so we shouldn't
    // cache it.
    // However, path is a fairly "final" serialisation operation that makes
    // little sense in the context of an incomplete tree.
    // For the sake of simplicity, and until we encounter errors due to this,
    // we accept the risk of caching the value assuming that it will only be
    // computed on fully frozen trees.
    path(options = _Node.Traversal.empty) {
      if (this._path[options.value] !== void 0) {
        return this._path[options.value];
      } else {
        this._path[options.value] = this._internalPath(options);
        return this._internalPath(options);
      }
    }
    equals(value) {
      return value === this;
    }
    toEARL() {
      return {
        "@context": {
          ptr: "http://www.w3.org/2009/pointers#"
        },
        "@type": [
          "ptr:Pointer",
          "ptr:SinglePointer",
          "ptr:ExpressionPointer",
          "ptr:XPathPointer"
        ],
        "ptr:expression": this.path()
      };
    }
    toSARIF() {
      return {
        logicalLocations: [
          {
            fullyQualifiedName: this.path()
          }
        ]
      };
    }
  };
  (function(Node6) {
    function isNode(value) {
      return value instanceof Node6;
    }
    Node6.isNode = isNode;
    class Traversal extends Flags {
      static of(...flags) {
        return new Traversal(Flags._reduce(...flags));
      }
    }
    Node6.Traversal = Traversal;
    (function(Traversal2) {
      Traversal2.none = 0;
      Traversal2.composed = 1 << 0;
      Traversal2.flattened = 1 << 1;
      Traversal2.nested = 1 << 2;
      Traversal2.empty = Traversal2.of(Traversal2.none);
    })(Traversal = Node6.Traversal || (Node6.Traversal = {}));
    Node6.flatTree = Traversal.of(Traversal.flattened);
    Node6.fullTree = Traversal.of(Traversal.flattened, Traversal.nested);
    Node6.composedNested = Traversal.of(Traversal.composed, Traversal.nested);
    const cacheWithDevice = Cache2.empty();
    const cacheWithoutDevice = Cache2.empty();
    function from(json, device) {
      return device === void 0 ? cacheWithoutDevice.get(json, () => fromNode2(json, device).run()) : cacheWithDevice.get(json, Cache2.empty).get(device, () => fromNode2(json, device).run());
    }
    Node6.from = from;
    function fromNode2(json, device) {
      switch (json.type) {
        case "element":
          return Element.fromElement(json, device);
        case "attribute":
          return Attribute.fromAttribute(json);
        case "text":
          return Text.fromText(json);
        case "comment":
          return Comment.fromComment(json);
        case "document":
          return Document.fromDocument(json, device);
        case "type":
          return Type2.fromType(json);
        case "fragment":
          return Fragment.fromFragment(json, device);
        default:
          throw new Error(`Unexpected node of type: ${json.type}`);
      }
    }
    Node6.fromNode = fromNode2;
    function clone(node, options, device) {
      return cloneNode(node, options, device).run();
    }
    Node6.clone = clone;
    function cloneNode(node, options = {
      predicate: () => false,
      newElements: []
    }, device) {
      return Selective.of(node).if(Element.isElement, Element.cloneElement(options, device)).if(Attribute.isAttribute, Attribute.cloneAttribute).if(Text.isText, Text.cloneText).if(Comment.isComment, Comment.cloneComment).if(Document.isDocument, Document.cloneDocument(options, device)).if(Type2.isType, Type2.cloneType).if(Fragment.isFragment, Fragment.cloneFragment(options, device)).if(Shadow2.isShadow, Shadow2.cloneShadow(options, device)).else(() => {
        throw new Error(`Unexpected node of type: ${node.type}`);
      }).get();
    }
    Node6.cloneNode = cloneNode;
    Node6.getNodesBetween = getNodesBetween;
    Node6.hasChild = hasChild, Node6.hasDescendant = hasDescendant, Node6.hasInclusiveDescendant = hasInclusiveDescendant, Node6.hasTextContent = hasTextContent, Node6.isRoot = isRoot;
  })(Node4 || (Node4 = {}));

  // node_modules/@siteimprove/alfa-rectangle/dist/rectangle.js
  var { max: max2, min: min2 } = Math;
  var Rectangle2 = class _Rectangle {
    static of(x, y, width, height) {
      return new _Rectangle(x, y, width, height);
    }
    static _empty = new _Rectangle(Infinity, Infinity, 0, 0);
    static empty() {
      return this._empty;
    }
    static _full = new _Rectangle(-Infinity, -Infinity, Infinity, Infinity);
    static full() {
      return this._full;
    }
    _x;
    _y;
    _width;
    _height;
    constructor(x, y, width, height) {
      this._x = x;
      this._y = y;
      this._width = width;
      this._height = height;
    }
    get x() {
      return this._x;
    }
    get y() {
      return this._y;
    }
    get width() {
      return this._width;
    }
    get height() {
      return this._height;
    }
    get top() {
      if (this._y === Infinity && this._height === -Infinity) {
        return -Infinity;
      }
      return this._height > 0 ? this._y : this._y + this._height;
    }
    get right() {
      if (this._x === -Infinity && this._width === Infinity) {
        return Infinity;
      }
      return this._width > 0 ? this._x + this._width : this._x;
    }
    get bottom() {
      if (this._y === -Infinity && this._height === Infinity) {
        return Infinity;
      }
      return this._height > 0 ? this._y + this._height : this._y;
    }
    get left() {
      if (this._x === Infinity && this._width === -Infinity) {
        return -Infinity;
      }
      return this._width > 0 ? this._x : this._x + this._width;
    }
    get center() {
      return {
        x: this._x + this._width / 2,
        y: this._y + this._height / 2
      };
    }
    get area() {
      return this._width * this._height;
    }
    isEmpty() {
      return this.equals(_Rectangle.empty());
    }
    isFull() {
      return this.equals(_Rectangle.full());
    }
    contains(other) {
      if (other.isEmpty() || this.isFull()) {
        return true;
      }
      return this.left <= other.left && this.top <= other.top && other.right <= this.right && other.bottom <= this.bottom;
    }
    intersects(other) {
      return other.left <= this.right && other.top <= this.bottom && other.right >= this.left && other.bottom >= this.top;
    }
    union(other) {
      if (this.contains(other)) {
        return this;
      }
      if (other.contains(this)) {
        return other;
      }
      const minLeft = min2(this.left, other.left);
      const minTop = min2(this.top, other.top);
      const maxRight = max2(this.right, other.right);
      const maxBottom = max2(this.bottom, other.bottom);
      return _Rectangle.of(minLeft, minTop, maxRight - minLeft, maxBottom - minTop);
    }
    intersection(other) {
      if (!this.intersects(other)) {
        return _Rectangle.empty();
      }
      if (this.contains(other)) {
        return other;
      }
      if (other.contains(this)) {
        return this;
      }
      const maxLeft = max2(this.left, other.left);
      const maxTop = max2(this.top, other.top);
      const minRight = min2(this.right, other.right);
      const minBottom = min2(this.bottom, other.bottom);
      return _Rectangle.of(maxLeft, maxTop, minRight - maxLeft, minBottom - maxTop);
    }
    /**
     * Checks if the rectangle intersects a given circle.
     *
     * @remarks
     * @see ../docs/circle-rectangle-intersection.png for a visual explanation of the case
     * where the circle center lies in one of the corners of the padded rectangle.
     *
     * @privateRemarks
      * To check intersection, we pad the rectangle by the radius of the circle and divide the problem into three cases:
      *
      * 1. The circle center is outside the padded rectangle.
      * 2. The circle center is inside the padded rectangle, but not in one of the corners.
      * 3. The circle center lies in one of the corners of the padded rectangle in which case we need to compute the distance to the corner
      *
      *                 r
      *              +-------+-------------------------+-------+
      *              |       |                         |       |
      *     1        |       |                         |       |
      *              +-------+-------------------------+-------+
      *              |       |                         |       |
      *              |       |                         |       |
      *              |       |                         |       |
      *              |       |                         |       |
      *              |       |                         |       |
      *              +-------+-------------------------+-------+
      *              |       |            2            |       |
      *              | 3     |                         |       |
      *              +-------+-------------------------+-------+
     */
    intersectsCircle(cx, cy, r) {
      const center = this.center;
      const halfWidth = this.width / 2;
      const halfHeight = this.height / 2;
      const dx = Math.abs(cx - center.x);
      const dy = Math.abs(cy - center.y);
      if (dx > halfWidth + r || dy > halfHeight + r) {
        return false;
      }
      if (dx <= halfWidth || dy <= halfHeight) {
        return true;
      }
      return (dx - halfWidth) ** 2 + (dy - halfHeight) ** 2 <= r ** 2;
    }
    /**
     * Computes the squared distance between the centers of two rectangles.
     *
     * @remarks
     * The squared distance is used to avoid the expensive square root operation.
     * If the actual distance is needed, the square root of the squared distance can be taken.
     */
    distanceSquared(other) {
      const c1 = this.center;
      const c2 = other.center;
      return (c1.x - c2.x) ** 2 + (c1.y - c2.y) ** 2;
    }
    equals(value) {
      return value === this || value instanceof _Rectangle && value.top === this.top && value.left === this.left && value.bottom === this.bottom && value.right === this.right;
    }
    hash(hash2) {
      hash2.writeNumber(this._x).writeNumber(this._y).writeNumber(this._width).writeNumber(this._height);
    }
    toJSON() {
      return {
        type: "rectangle",
        x: this._x,
        y: this._y,
        width: this._width,
        height: this._height
      };
    }
  };
  (function(Rectangle3) {
    function from(json) {
      return Rectangle3.of(json.x, json.y, json.width, json.height);
    }
    Rectangle3.from = from;
    function isRectangle(value) {
      return value instanceof Rectangle3;
    }
    Rectangle3.isRectangle = isRectangle;
    function union(...rectangles) {
      return rectangles.reduce((previous, current) => previous.union(current), Rectangle3.empty());
    }
    Rectangle3.union = union;
    function intersection(...rectangles) {
      return rectangles.reduce((previous, current) => previous.intersection(current), Rectangle3.full());
    }
    Rectangle3.intersection = intersection;
  })(Rectangle2 || (Rectangle2 = {}));

  // node_modules/@siteimprove/alfa-dom/dist/node/attribute/predicate/has-name.js
  function hasName(nameOrPredicate, ...names) {
    let predicate;
    if (typeof nameOrPredicate === "function") {
      predicate = nameOrPredicate;
    } else {
      names.unshift(nameOrPredicate);
      predicate = (name, attribute) => names.some((candidate) => Attribute.foldCase(candidate, attribute.owner) === name);
    }
    return (attribute) => predicate(attribute.name, attribute);
  }

  // node_modules/@siteimprove/alfa-dom/dist/node/attribute.js
  var { isEmpty: isEmpty2 } = Iterable;
  var { equals: equals5, not: not14 } = Predicate;
  var Attribute = class _Attribute extends Node4 {
    static of(namespace, prefix, name, value, externalId, internalId, extraData) {
      return new _Attribute(namespace, prefix, name, value, externalId, internalId, extraData);
    }
    _namespace;
    _prefix;
    _name;
    _value;
    _owner = None;
    constructor(namespace, prefix, name, value, externalId, internalId, extraData) {
      super([], "attribute", externalId, internalId, extraData);
      this._namespace = namespace;
      this._prefix = prefix;
      this._name = name;
      this._value = value;
    }
    get namespace() {
      return this._namespace;
    }
    get prefix() {
      return this._prefix;
    }
    get name() {
      return _Attribute.foldCase(this._name, this._owner);
    }
    get qualifiedName() {
      return this._prefix.reduce((name, prefix) => `${prefix}:${name}`, this._name);
    }
    get value() {
      return this._value;
    }
    get owner() {
      return this._owner;
    }
    /**
     * {@link https://html.spec.whatwg.org/#boolean-attribute}
     */
    isBoolean() {
      switch (this.name) {
        case "allowfullscreen":
        case "allowpaymentrequest":
        case "async":
        case "autofocus":
        case "autoplay":
        case "checked":
        case "controls":
        case "default":
          return true;
        default:
          return false;
      }
    }
    /**
     * @internal
     **/
    _internalPath(options) {
      let path = this.owner.map((owner) => owner.path(options)).getOr("/");
      path += path === "/" ? "" : "/";
      path += `@${this.name}`;
      return path;
    }
    /**
     * {@link https://html.spec.whatwg.org/#space-separated-tokens}
     */
    tokens(separator = /\s+/) {
      return Sequence.from(this._value.trim().split(separator).filter(not14(isEmpty2)));
    }
    enumerate(...valid) {
      const value = this._value.toLowerCase();
      return valid.length === 0 || valid.includes(value) ? Option.of(value) : None;
    }
    toJSON(options) {
      const result = {
        ...super.toJSON(options)
      };
      delete result.children;
      const verbosity = options?.verbosity ?? Serializable.Verbosity.Medium;
      if (verbosity < Serializable.Verbosity.Medium) {
        return result;
      }
      result.namespace = this._namespace.getOr(null);
      result.prefix = this._prefix.getOr(null);
      result.name = this._name;
      result.value = this._value;
      return result;
    }
    toString() {
      const name = this.qualifiedName;
      if (this.isBoolean()) {
        return name;
      }
      return `${name}="${this._value.replace(/"/g, "&quot;")}"`;
    }
    /**
     * @internal
     */
    _attachParent() {
      return false;
    }
    /**
     * @internal
     */
    _attachOwner(owner) {
      if (this._frozen || this._owner.isSome()) {
        return false;
      }
      this._owner = Option.of(owner);
      this._frozen = true;
      return true;
    }
  };
  (function(Attribute4) {
    function isAttribute(value) {
      return value instanceof Attribute4;
    }
    Attribute4.isAttribute = isAttribute;
    function fromAttribute(attribute) {
      return Trampoline.done(Attribute4.of(Option.from(attribute.namespace), Option.from(attribute.prefix), attribute.name, attribute.value, attribute.externalId, attribute.internalId));
    }
    Attribute4.fromAttribute = fromAttribute;
    function cloneAttribute(attribute) {
      return Trampoline.done(Attribute4.of(attribute.namespace, attribute.prefix, attribute.name, attribute.value, attribute.externalId, attribute.internalId, attribute.extraData));
    }
    Attribute4.cloneAttribute = cloneAttribute;
    function foldCase(name, owner) {
      return owner.some((owner2) => owner2.namespace.some(equals5(Namespace.HTML))) ? name.toLowerCase() : name;
    }
    Attribute4.foldCase = foldCase;
    Attribute4.hasName = hasName;
  })(Attribute || (Attribute = {}));

  // node_modules/@siteimprove/alfa-dom/dist/node/document.js
  var Document = class _Document extends Node4 {
    static of(children, style = [], externalId, internalId, extraData) {
      return new _Document(Array2.from(children), style, externalId, internalId, extraData);
    }
    static empty() {
      return new _Document([], []);
    }
    _style;
    _frame = None;
    constructor(children, style, externalId, internalId, extraData) {
      super(children, "document", externalId, internalId, extraData);
      this._style = Array2.from(style);
    }
    get style() {
      return this._style;
    }
    get frame() {
      return this._frame;
    }
    parent(options = Node4.Traversal.empty) {
      return options.isSet(Node4.Traversal.nested) ? this.frame : super.parent(options);
    }
    /**
     * @internal
     **/
    _internalPath(options = Node4.Traversal.empty) {
      if (options.isSet(Node4.Traversal.nested)) {
        return this._frame.map((frame) => frame.path(options) + "/document-node()").getOr("/");
      }
      return "/";
    }
    toJSON(options) {
      const result = {
        ...super.toJSON(options)
      };
      const verbosity = options?.verbosity ?? Serializable.Verbosity.Medium;
      if (verbosity < Serializable.Verbosity.Medium) {
        return result;
      }
      result.style = this._style.map((sheet) => sheet.toJSON());
      return result;
    }
    toString() {
      const children = this._children.map((child) => String2.indent(child.toString())).join("\n");
      return `#document${children === "" ? "" : `
${children}`}`;
    }
    /**
     * @internal
     */
    _attachParent() {
      return false;
    }
    /**
     * @internal
     */
    _attachFrame(frame) {
      if (this._frozen || this._frame.isSome()) {
        return false;
      }
      this._frame = Option.of(frame);
      this._frozen = true;
      return true;
    }
  };
  (function(Document2) {
    function isDocument(value) {
      return value instanceof Document2;
    }
    Document2.isDocument = isDocument;
    function fromDocument(json, device) {
      return Trampoline.traverse(json.children ?? [], (child) => Node4.fromNode(child, device)).map((children) => Document2.of(children, json.style.map(Sheet.from), json.externalId, json.internalId));
    }
    Document2.fromDocument = fromDocument;
    function cloneDocument(options, device) {
      return (document2) => Trampoline.traverse(document2.children(), (child) => {
        if (Element.isElement(child) && options.predicate(child)) {
          return Trampoline.done(Array2.from(options.newElements));
        }
        return Node4.cloneNode(child, options, device).map((node) => [node]);
      }).map((children) => {
        return Document2.of(Iterable.flatten(children), document2.style, document2.externalId, document2.internalId, document2.extraData);
      });
    }
    Document2.cloneDocument = cloneDocument;
  })(Document || (Document = {}));

  // node_modules/@siteimprove/alfa-dom/dist/node/shadow.js
  var Shadow2 = class _Shadow extends Node4 {
    static of(children, style = [], mode = _Shadow.Mode.Open, externalId, internalId, extraData) {
      return new _Shadow(Array.from(children), Array.from(style), mode, externalId, internalId, extraData);
    }
    static empty() {
      return new _Shadow([], [], _Shadow.Mode.Open);
    }
    _mode;
    _host = None;
    _style;
    constructor(children, style, mode, externalId, internalId, extraData) {
      super(children, "shadow", externalId, internalId, extraData);
      this._mode = mode;
      this._style = style;
    }
    get mode() {
      return this._mode;
    }
    get host() {
      return this._host;
    }
    get style() {
      return this._style;
    }
    parent(options = Node4.Traversal.empty) {
      if (options.isSet(Node4.Traversal.composed)) {
        return this._host;
      }
      return None;
    }
    /**
     * @internal
     **/
    _internalPath(options = Node4.Traversal.empty) {
      if (options.isSet(Node4.Traversal.composed)) {
        return this._host.map((host) => host.path(options)).getOr("") + "/shadow-root()";
      }
      if (options.isSet(Node4.Traversal.flattened)) {
        return this._host.map((host) => host.path(options)).getOr("/");
      }
      return "/";
    }
    toJSON(options) {
      const result = {
        ...super.toJSON(options)
      };
      const verbosity = options?.verbosity ?? Serializable.Verbosity.Medium;
      if (verbosity < Serializable.Verbosity.Medium) {
        return result;
      }
      result.mode = this._mode;
      result.style = this._style.map((sheet) => sheet.toJSON());
      return result;
    }
    toString() {
      const children = this._children.map((child) => String2.indent(child.toString())).join("\n");
      return `#shadow-root (${this._mode})${children === "" ? "" : `
${children}`}`;
    }
    /**
     * @internal
     */
    _attachParent() {
      return false;
    }
    /**
     * @internal
     */
    _attachHost(host) {
      if (this._frozen || this._host.isSome()) {
        return false;
      }
      this._host = Option.of(host);
      this._frozen = true;
      return true;
    }
  };
  (function(Shadow3) {
    let Mode;
    (function(Mode2) {
      Mode2["Open"] = "open";
      Mode2["Closed"] = "closed";
    })(Mode = Shadow3.Mode || (Shadow3.Mode = {}));
    function isShadow(value) {
      return value instanceof Shadow3;
    }
    Shadow3.isShadow = isShadow;
    function fromShadow(json, device) {
      return Trampoline.traverse(json.children ?? [], (child) => Node4.fromNode(child, device)).map((children) => Shadow3.of(children, json.style.map(Sheet.from), json.mode, json.externalId, json.internalId));
    }
    Shadow3.fromShadow = fromShadow;
    function cloneShadow(options, device) {
      return (shadow) => Trampoline.traverse(shadow.children(), (child) => {
        if (Element.isElement(child) && options.predicate(child)) {
          return Trampoline.done(Array.from(options.newElements));
        }
        return Node4.cloneNode(child, options, device).map((node) => [node]);
      }).map((children) => {
        return Shadow3.of(Iterable.flatten(children), shadow.style, shadow.mode, shadow.externalId, shadow.extraData, shadow.internalId);
      });
    }
    Shadow3.cloneShadow = cloneShadow;
  })(Shadow2 || (Shadow2 = {}));

  // node_modules/@siteimprove/alfa-dom/dist/node/text.js
  var Text = class _Text extends Node4 {
    static of(data, externalId, internalId, extraData) {
      return new _Text(data, externalId, internalId, extraData);
    }
    static empty() {
      return new _Text("");
    }
    _data;
    constructor(data, externalId, internalId, extraData) {
      super([], "text", externalId, internalId, extraData);
      this._data = data;
    }
    get data() {
      return this._data;
    }
    assignedSlot() {
      return Slotable.findSlot(this);
    }
    /**
     * @internal
     **/
    _internalPath(options) {
      let path = this.parent(options).map((parent) => parent.path(options)).getOr("/");
      path += path === "/" ? "" : "/";
      path += "text()";
      const index = this.preceding(options).count(_Text.isText);
      path += `[${index + 1}]`;
      return path;
    }
    toJSON(options) {
      const result = {
        ...super.toJSON(options)
      };
      delete result.children;
      const verbosity = options?.verbosity ?? Serializable.Verbosity.Medium;
      if (verbosity < Serializable.Verbosity.Medium) {
        return result;
      }
      result.data = this.data;
      return result;
    }
    toString() {
      const value = this.data;
      if (value.match(/\s+/) !== null) {
        return value;
      }
      return value.trim();
    }
  };
  (function(Text3) {
    function isText16(value) {
      return value instanceof Text3;
    }
    Text3.isText = isText16;
    function fromText2(json) {
      return Trampoline.done(Text3.of(json.data, json.externalId, void 0, json.internalId));
    }
    Text3.fromText = fromText2;
    function cloneText(text) {
      return Trampoline.done(Text3.of(text.data, text.externalId, text.extraData, text.internalId));
    }
    Text3.cloneText = cloneText;
  })(Text || (Text = {}));

  // node_modules/@siteimprove/alfa-dom/dist/node/slotable.js
  var Slotable;
  (function(Slotable2) {
    function isSlotable(value) {
      return Element.isElement(value) || Text.isText(value);
    }
    Slotable2.isSlotable = isSlotable;
    function name(slotable) {
      return Element.isElement(slotable) ? slotable.attribute("slot").map((slot) => slot.value).getOr("") : "";
    }
    Slotable2.name = name;
    function findSlot(slotable) {
      const name2 = Slotable2.name(slotable);
      return slotable.parent().filter(Element.isElement).flatMap((parent) => parent.shadow.flatMap((shadow) => shadow.descendants().filter(Slot.isSlot).find((slot) => Slot.name(slot) === name2)));
    }
    Slotable2.findSlot = findSlot;
  })(Slotable || (Slotable = {}));

  // node_modules/@siteimprove/alfa-dom/dist/node/element/predicate/has-attribute.js
  var { property } = Predicate;
  function hasAttribute(nameOrPredicate, value = () => true) {
    if (typeof nameOrPredicate === "function") {
      return (element) => element.attribute(nameOrPredicate).isSome();
    }
    const name = nameOrPredicate;
    const predicate = property("value", value);
    return (element) => element.attribute(name).some(predicate);
  }

  // node_modules/@siteimprove/alfa-dom/dist/node/element/predicate/has-box.js
  function hasBox(predicate = () => true, device) {
    return (element) => element.getBoundingBox(device).some(predicate);
  }

  // node_modules/@siteimprove/alfa-dom/dist/node/element/predicate/has-display-size.js
  function hasDisplaySize(valueOrPredicate) {
    const predicate = typeof valueOrPredicate === "function" ? valueOrPredicate : (size) => valueOrPredicate === size;
    return (element) => {
      return predicate(element.displaySize());
    };
  }

  // node_modules/@siteimprove/alfa-dom/dist/node/element/predicate/has-id.js
  var { equals: equals6 } = Predicate;
  function hasId(idOrPredicate = () => true, ...ids2) {
    let predicate;
    if (typeof idOrPredicate === "function") {
      predicate = idOrPredicate;
    } else if (typeof idOrPredicate === "string") {
      predicate = equals6(idOrPredicate, ...ids2);
    } else {
      predicate = (value) => Iterable.includes(ids2, value);
    }
    return (element) => element.id.some(predicate);
  }

  // node_modules/@siteimprove/alfa-dom/dist/node/element/predicate/has-name.js
  var { equals: equals7 } = Predicate;
  function hasName2(nameOrPredicate, ...names) {
    let predicate;
    if (typeof nameOrPredicate === "function") {
      predicate = nameOrPredicate;
    } else {
      predicate = equals7(nameOrPredicate, ...names);
    }
    return (element) => predicate(element.name);
  }

  // node_modules/@siteimprove/alfa-dom/dist/node/element/predicate/has-input-type.js
  var { equals: equals8, test: test5 } = Predicate;
  var { and: and3 } = Refinement;
  function hasInputType(inputTypeOrPredicate, ...inputTypes) {
    let predicate;
    if (typeof inputTypeOrPredicate === "function") {
      predicate = inputTypeOrPredicate;
    } else {
      predicate = equals8(inputTypeOrPredicate, ...inputTypes);
    }
    return and3(hasName2("input"), (element) => test5(predicate, element.inputType()));
  }

  // node_modules/@siteimprove/alfa-dom/dist/node/element/predicate/has-namespace.js
  var { equals: equals9 } = Predicate;
  function hasNamespace(namespaceOrPredicate, ...namespaces) {
    let predicate;
    if (typeof namespaceOrPredicate === "function") {
      predicate = namespaceOrPredicate;
    } else {
      predicate = equals9(namespaceOrPredicate, ...namespaces);
    }
    return (element) => element.namespace.some(predicate);
  }

  // node_modules/@siteimprove/alfa-dom/dist/node/element/predicate/has-tab-index.js
  function hasTabIndex(predicateOrNumber = () => true, ...rest) {
    const predicate = typeof predicateOrNumber === "number" ? (n) => Array2.append(rest, predicateOrNumber).includes(n) : predicateOrNumber;
    return (element) => element.tabIndex().some(predicate);
  }

  // node_modules/@siteimprove/alfa-dom/dist/node/element/predicate/has-unique-id.js
  var { and: and4 } = Predicate;
  var uniques = Cache2.empty();
  var hasUniqueId = and4(hasId(), (element) => uniques.get(element.root(), () => {
    const counts = /* @__PURE__ */ new Map();
    for (const node of element.root().descendants()) {
      if (Element.isElement(node) && node.id.isSome()) {
        const id = node.id.get();
        const count = counts.get(id);
        if (count === void 0) {
          counts.set(id, 1);
        } else {
          counts.set(id, 1 + count);
        }
      }
    }
    return new Set(Iterable.map(Iterable.filter(counts, ([, count]) => count === 1), ([id]) => id));
  }).has(element.id.getOr("impossible id due to spaces")));

  // node_modules/@siteimprove/alfa-dom/dist/node/element/predicate/is-browsing-context-container.js
  function isBrowsingContextContainer(element) {
    switch (element.name) {
      // <iframe> elements are _always_ browsing context containers as they will
      // _always_ have a content document, although it might be empty.
      case "iframe":
        return true;
      // <object> elements are only browsing context containers if they have a
      // content document.
      case "object":
        return element.content.isSome();
      default:
        return false;
    }
  }

  // node_modules/@siteimprove/alfa-dom/dist/node/element/predicate/is-replaced.js
  var { test: test6 } = Refinement;
  function isReplaced(element) {
    return test6(hasName2("audio", "canvas", "embed", "iframe", "img", "input", "object", "video"), element);
  }

  // node_modules/@siteimprove/alfa-dom/dist/node/element/predicate/is-content.js
  var { or: or2 } = Predicate;
  var { and: and5 } = Refinement;
  function isContent(options = Node4.Traversal.empty) {
    return or2((node) => node.children(options).isEmpty(), and5(Element.isElement, isReplaced));
  }

  // node_modules/@siteimprove/alfa-dom/dist/node/element/predicate/is-actually-disabled.js
  var { equals: equals10 } = Predicate;
  function isActuallyDisabled(element) {
    switch (element.name) {
      // https://html.spec.whatwg.org/multipage#concept-fe-disabled
      case "button":
      case "input":
      case "select":
      case "textarea":
      // https://html.spec.whatwg.org/#attr-optgroup-disabled
      case "optgroup":
        return element.attribute("disabled").isSome();
      // https://html.spec.whatwg.org/multipage#concept-fieldset-disabled
      case "fieldset":
        if (element.attribute("disabled").isSome()) {
          return true;
        }
        return element.ancestors().filter(Element.isElement).find(Element.hasName("fieldset")).reject(isActuallyDisabled).flatMap((fieldset) => fieldset.descendants().filter(Element.isElement).find(Element.hasName("legend"))).some((legend) => legend.descendants().some(equals10(element)));
      // https://html.spec.whatwg.org/multipage#concept-option-disabled
      case "option":
        if (element.attribute("disabled").isSome()) {
          return true;
        }
        return element.inclusiveAncestors().filter(Element.isElement).find(Element.hasName("optgroup")).some(isActuallyDisabled);
    }
    return false;
  }

  // node_modules/@siteimprove/alfa-dom/dist/node/element/predicate/is-document-element.js
  var { and: and6, test: test7 } = Refinement;
  function isDocumentElement(value) {
    return test7(and6(Element.isElement, and6(hasName2("html"), hasNamespace(Namespace.HTML))), value);
  }

  // node_modules/@siteimprove/alfa-dom/dist/node/element/predicate/is-draggable.js
  function isDraggable(element) {
    return element.attribute("draggable").map((attribute) => attribute.enumerate("true", "false", "auto").getOr("auto")).some((draggable) => {
      switch (draggable) {
        case "true":
          return true;
        case "false":
          return false;
        case "auto":
          switch (element.name) {
            case "img":
              return true;
            case "a":
              return element.attribute("href").isSome();
            default:
              return false;
          }
      }
    });
  }

  // node_modules/@siteimprove/alfa-dom/dist/node/element/predicate/is-editing-host.js
  function isEditingHost(element) {
    return element.attribute("contenteditable").flatMap((attribute) => attribute.enumerate("", "true", "false")).some((contenteditable) => {
      switch (contenteditable) {
        case "":
        case "true":
          return true;
        case "false":
          return false;
      }
    });
  }

  // node_modules/@siteimprove/alfa-dom/dist/node/element/predicate/is-fallback.js
  var { not: not15, or: or3, test: test8 } = Predicate;
  var { and: and7 } = Refinement;
  function isFallback(node) {
    return test8(or3(hasParentName("iframe"), and7(hasParentName("audio", "video"), not15(and7(Element.isElement, hasName2("track", "source"))))), node);
  }
  function hasParentName(name, ...names) {
    return (node) => node.parent().filter(Element.isElement).some(hasName2(name, ...names));
  }

  // node_modules/@siteimprove/alfa-dom/dist/node/element/predicate/is-scoped-to.js
  function isScopedTo(name, ...rest) {
    return (element) => element.ancestors().filter(Element.isElement).some(Element.hasName(name, ...rest));
  }

  // node_modules/@siteimprove/alfa-dom/dist/node/element/predicate/is-suggested-focusable.js
  function isSuggestedFocusable(element) {
    switch (element.name) {
      case "a":
      case "link":
        return element.attribute("href").isSome();
      case "input":
        return element.attribute("type").flatMap((attribute) => attribute.enumerate("hidden")).isNone();
      case "audio":
      case "video":
        return element.attribute("controls").isSome();
      case "button":
      case "select":
      case "textarea":
        return true;
      case "summary":
        return element.parent().filter(Element.isElement).some((parent) => parent.name === "details" && // Checking that element is the first <summary> child of parent.
        parent.children().filter(Element.isElement).find(Element.hasName("summary")).includes(element));
    }
    return Element.isEditingHost(element) || Element.isBrowsingContextContainer(element);
  }

  // node_modules/@siteimprove/alfa-dom/dist/node/element.js
  var { isEmpty: isEmpty3 } = Iterable;
  var { not: not16 } = Predicate;
  var Element = class _Element extends Node4 {
    static of(namespace, prefix, name, attributes = [], children = [], style = None, box = None, device = None, externalId, internalId, extraData) {
      return new _Element(namespace, prefix, name, Array.from(attributes), Array.from(children), style, box, device, externalId, internalId, extraData);
    }
    _namespace;
    _prefix;
    _name;
    _attributes;
    _style;
    _shadow = None;
    _content = None;
    _id;
    _classes;
    _boxes;
    constructor(namespace, prefix, name, attributes, children, style, box, device, externalId, internalId, extraData) {
      super(children, "element", externalId, internalId, extraData);
      this._namespace = namespace;
      this._prefix = prefix;
      this._name = name;
      this._attributes = new Map(attributes.filter((attribute) => attribute._attachOwner(this)).map((attribute) => [attribute.qualifiedName, attribute]));
      style.forEach((block) => Iterable.forEach(block, (declaration) => declaration._attachOwner(this)));
      this._style = style;
      this._id = this.attribute("id").map((attr) => attr.value);
      this._classes = this.attribute("class").map((attr) => attr.value.trim().split(/\s+/)).getOr([]);
      this._boxes = Cache2.from(device.isSome() && box.isSome() ? [[device.get(), box.get()]] : []);
    }
    get namespace() {
      return this._namespace;
    }
    get prefix() {
      return this._prefix;
    }
    get name() {
      return this._name;
    }
    get qualifiedName() {
      return this._prefix.reduce((name, prefix) => `${prefix}:${name}`, this._name);
    }
    get attributes() {
      return Sequence.from(this._attributes.values());
    }
    get style() {
      return this._style;
    }
    get shadow() {
      return this._shadow;
    }
    get content() {
      return this._content;
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-id}
     */
    get id() {
      return this._id;
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-class}
     */
    get classes() {
      return Sequence.from(this._classes);
    }
    getBoundingBox(device) {
      return this._boxes.get(device);
    }
    children(options = Node4.Traversal.empty) {
      const treeChildren = this._children;
      const children = [];
      if (options.isSet(Node4.Traversal.flattened)) {
        if (this._shadow.isSome()) {
          return this._shadow.get().children(options);
        }
        if (Slot.isSlot(this)) {
          return Sequence.from(this.assignedNodes());
        }
        for (const child of treeChildren) {
          if (Slot.isSlot(child)) {
            children.push(...child.children(options));
          } else {
            children.push(child);
          }
        }
      } else {
        if (options.isSet(Node4.Traversal.composed) && this._shadow.isSome()) {
          children.push(this._shadow.get());
        }
        children.push(...treeChildren);
      }
      if (options.isSet(Node4.Traversal.nested) && this._content.isSome()) {
        children.push(this._content.get());
      }
      return Sequence.from(children);
    }
    attribute(nameOrPredicate) {
      if (typeof nameOrPredicate === "string") {
        return Option.from(this._attributes.get(nameOrPredicate));
      } else {
        return Iterable.find(this._attributes.values(), nameOrPredicate);
      }
    }
    /**
     * {@link https://html.spec.whatwg.org/#void-elements}
     */
    isVoid() {
      switch (this._name) {
        case "area":
        case "base":
        case "basefont":
        case "bgsound":
        case "br":
        case "col":
        case "embed":
        case "frame":
        case "hr":
        case "img":
        case "input":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          return true;
        default:
          return false;
      }
    }
    /**
     * {@link https://html.spec.whatwg.org/#dom-tabindex}
     */
    tabIndex() {
      for (const tabIndex of this.attribute("tabindex")) {
        const number = parseInt(tabIndex.value, 10);
        if (number === number && number === (number | 0)) {
          return Some.of(number);
        }
      }
      if (_Element.isSuggestedFocusable(this)) {
        return Some.of(0);
      }
      return None;
    }
    /*
     * This collects caches for methods that are specific to some kind of elements.
     * The actual methods are declared in element/augment.ts to de-clutter this
     * class. However, we need to declare the variables here as they would
     * otherwise be public which exposes too much. And they must be `protected`
     * to be accessible by the augments.
     */
    _inputType;
    _displaySize;
    _optionsList;
    /*
     * End of caches for methods specific to some kind of elements.
     */
    /**
     * {@link https://dom.spec.whatwg.org/#dom-slotable-assignedslot}
     */
    assignedSlot() {
      return Slotable.findSlot(this);
    }
    /**
     * {@link https://html.spec.whatwg.org/#dom-slot-assignednodes}
     */
    assignedNodes() {
      return Slot.findSlotables(this);
    }
    /**
     * @internal
     **/
    _internalPath(options) {
      let path = this.parent(options).map((parent) => parent.path(options)).getOr("/");
      path += path === "/" ? "" : "/";
      path += this._name;
      const index = this.preceding(options).filter(_Element.isElement).count((element) => element._name === this._name);
      path += `[${index + 1}]`;
      return path;
    }
    toJSON(options) {
      const verbosity = options?.verbosity ?? Serializable.Verbosity.Medium;
      const result = super.toJSON(options);
      if (verbosity < Serializable.Verbosity.Medium) {
        return result;
      }
      if (verbosity >= Serializable.Verbosity.High) {
        result.assignedSlot = this.assignedSlot().map((slot) => slot.toJSON({ verbosity: Serializable.Verbosity.Minimal })).getOr(null);
      }
      return {
        ...result,
        namespace: this._namespace.getOr(null),
        prefix: this._prefix.getOr(null),
        name: this._name,
        attributes: [...this._attributes.values()].map((attribute) => attribute.toJSON(options)),
        style: this._style.map((style) => style.toJSON()).getOr(null),
        shadow: this._shadow.map((shadow) => shadow.toJSON(options)).getOr(null),
        content: this._content.map((content) => content.toJSON(options)).getOr(null),
        box: options?.device === void 0 ? null : this._boxes.get(options.device).map((box) => box.toJSON()).getOr(null)
      };
    }
    toString() {
      const name = this.qualifiedName;
      const attributes = [...this._attributes.values()].map((attribute) => ` ${attribute.toString()}`).join("");
      if (this.isVoid()) {
        return `<${name}${attributes}>`;
      }
      const children = [...this._shadow, ...this._children, ...this._content].map((child) => {
        const value = child.toString();
        if (value.match(/\s+/) !== null) {
          return value;
        }
        return value.trim();
      }).filter(not16(isEmpty3)).map(String2.indent).join("\n");
      return `<${name}${attributes}>${children === "" ? "" : `
${children}
`}</${name}>`;
    }
    /**
     * @internal
     */
    _attachShadow(shadow) {
      if (this._frozen || this._shadow.isSome() || !shadow._attachHost(this)) {
        return false;
      }
      this._shadow = Option.of(shadow);
      return true;
    }
    /**
     * @internal
     */
    _attachContent(document2) {
      if (this._frozen || this._content.isSome() || !document2._attachFrame(this)) {
        return false;
      }
      this._content = Option.of(document2);
      return true;
    }
  };
  (function(Element3) {
    function isElement64(value) {
      return value instanceof Element3;
    }
    Element3.isElement = isElement64;
    function fromElement2(json, device) {
      return Trampoline.traverse(json.children ?? [], (child) => Node4.fromNode(child, device)).map((children) => {
        const element = Element3.of(Option.from(json.namespace), Option.from(json.prefix), json.name, json.attributes.map((attribute) => Attribute.fromAttribute(attribute).run()), children, json.style?.length === 0 ? None : Option.from(json.style).map(Block2.from), Option.from(json.box).map(Rectangle2.from), Option.from(device), json.externalId, json.internalId);
        if (json.shadow !== null) {
          element._attachShadow(Shadow2.fromShadow(json.shadow, device).run());
        }
        if (json.content !== null) {
          element._attachContent(Document.fromDocument(json.content, device).run());
        }
        return element;
      });
    }
    Element3.fromElement = fromElement2;
    function cloneElement(options, device) {
      return (element) => Trampoline.traverse(element.children(), (child) => {
        if (Element3.isElement(child) && options.predicate(child)) {
          return Trampoline.done(Array.from(options.newElements));
        }
        return Node4.cloneNode(child, options, device).map((node) => [node]);
      }).map((children) => {
        const deviceOption = Option.from(device);
        const clonedElement = Element3.of(element.namespace, element.prefix, element.name, element.attributes.map((attribute) => Attribute.clone(attribute, options, device)), Iterable.flatten(children), element.style.map((block) => {
          return Block2.of(Iterable.map(block.declarations, (declaration) => Declaration2.of(declaration.name, declaration.value, declaration.important)));
        }), deviceOption.flatMap((d) => element.getBoundingBox(d)), deviceOption, element.externalId, element.internalId, element.extraData);
        if (element.shadow.isSome()) {
          clonedElement._attachShadow(Shadow2.clone(element.shadow.get(), options, device));
        }
        if (element.content.isSome()) {
          clonedElement._attachContent(Document.clone(element.content.get(), options, device));
        }
        return clonedElement;
      });
    }
    Element3.cloneElement = cloneElement;
    Element3.hasAttribute = hasAttribute, Element3.hasBox = hasBox, Element3.hasDisplaySize = hasDisplaySize, Element3.hasId = hasId, Element3.hasInputType = hasInputType, Element3.hasName = hasName2, Element3.hasNamespace = hasNamespace, Element3.hasTabIndex = hasTabIndex, Element3.hasUniqueId = hasUniqueId, Element3.isBrowsingContextContainer = isBrowsingContextContainer, Element3.isContent = isContent, Element3.isActuallyDisabled = isActuallyDisabled, Element3.isDocumentElement = isDocumentElement, Element3.isDraggable = isDraggable, Element3.isEditingHost = isEditingHost, Element3.isFallback = isFallback, Element3.isScopedTo = isScopedTo, Element3.isSuggestedFocusable = isSuggestedFocusable, Element3.isReplaced = isReplaced;
  })(Element || (Element = {}));

  // node_modules/@siteimprove/alfa-dom/dist/node/slot.js
  var Slot;
  (function(Slot3) {
    function isSlot(value) {
      return Element.isElement(value) && value.name === "slot";
    }
    Slot3.isSlot = isSlot;
    function name(slot) {
      return slot.attribute("name").map((name2) => name2.value).getOr("");
    }
    Slot3.name = name;
    function* findSlotables(slot) {
      const root = slot.root();
      if (Shadow2.isShadow(root)) {
        for (const host of root.host) {
          for (const child of host.children()) {
            if (Slotable.isSlotable(child) && child.assignedSlot().includes(slot)) {
              yield child;
            }
          }
        }
      }
    }
    Slot3.findSlotables = findSlotables;
  })(Slot || (Slot = {}));

  // node_modules/@siteimprove/alfa-dom/dist/node/comment.js
  var Comment = class _Comment extends Node4 {
    static of(data, externalId, internalId, extraData) {
      return new _Comment(data, externalId, internalId, extraData);
    }
    static empty() {
      return new _Comment("");
    }
    _data;
    constructor(data, externalId, internalId, extraData) {
      super([], "comment", externalId, internalId, extraData);
      this._data = data;
    }
    get data() {
      return this._data;
    }
    /**
     * @internal
     **/
    _internalPath(options) {
      let path = this.parent(options).map((parent) => parent.path(options)).getOr("/");
      path += path === "/" ? "" : "/";
      path += "comment()";
      const index = this.preceding(options).count(_Comment.isComment);
      path += `[${index + 1}]`;
      return path;
    }
    toJSON(options) {
      const result = {
        ...super.toJSON(options)
      };
      delete result.children;
      const verbosity = options?.verbosity ?? Serializable.Verbosity.Medium;
      if (verbosity < Serializable.Verbosity.Medium) {
        return result;
      }
      result.data = this._data;
      return result;
    }
    toString() {
      return `<!--${this._data}-->`;
    }
  };
  (function(Comment2) {
    function isComment(value) {
      return value instanceof Comment2;
    }
    Comment2.isComment = isComment;
    function fromComment(json) {
      return Trampoline.done(Comment2.of(json.data, json.externalId, json.internalId));
    }
    Comment2.fromComment = fromComment;
    function cloneComment(comment) {
      return Trampoline.done(Comment2.of(comment.data, comment.externalId, comment.internalId, comment.extraData));
    }
    Comment2.cloneComment = cloneComment;
  })(Comment || (Comment = {}));

  // node_modules/@siteimprove/alfa-dom/dist/node/element/augment.js
  Element.prototype.inputType = function() {
    if (this._inputType === void 0) {
      this._inputType = this.attribute("type").flatMap((attribute) => attribute.enumerate("hidden", "search", "tel", "url", "email", "password", "date", "month", "week", "time", "datetime-local", "number", "range", "color", "checkbox", "radio", "file", "submit", "image", "reset", "button", "text")).getOr("text");
    }
    return this._inputType;
  };
  Element.prototype.displaySize = function() {
    if (this._displaySize === void 0) {
      this._displaySize = this.attribute("size").flatMap((attribute) => {
        const size = parseInt(attribute.value, 10);
        if (size === size && size === (size | 0)) {
          return Some.of(size);
        }
        return None;
      }).getOrElse(() => this.attribute("multiple").isSome() ? 4 : 1);
    }
    return this._displaySize;
  };
  Element.prototype.optionsList = function() {
    if (this._optionsList === void 0) {
      this._optionsList = this.children().filter(Element.isElement).flatMap((child) => {
        switch (child.name) {
          case "option":
            return Sequence.from([child]);
          case "optgroup":
            return child.children().filter(Element.isElement).filter(
              // We cannot really use `Element.hasName` here as it would
              // create a circular dependency.
              (grandchild) => grandchild.name === "option"
            );
          default:
            return Sequence.empty();
        }
      });
    }
    return this._optionsList;
  };

  // node_modules/@siteimprove/alfa-dom/dist/node/fragment.js
  var Fragment = class _Fragment extends Node4 {
    static of(children, externalId, internalId, extraData) {
      return new _Fragment(Array.from(children), externalId, internalId, extraData);
    }
    static empty() {
      return new _Fragment([]);
    }
    constructor(children, externalId, internalId, extraData) {
      super(children, "fragment", externalId, internalId, extraData);
    }
    /**
     * @internal
     **/
    _internalPath() {
      return "/";
    }
    toString() {
      const children = this._children.map((child) => String2.indent(child.toString())).join("\n");
      return `#document-fragment${children === "" ? "" : `
${children}`}`;
    }
    /**
     * @internal
     */
    _attachParent() {
      return false;
    }
  };
  (function(Fragment2) {
    function isFragment(value) {
      return value instanceof Fragment2;
    }
    Fragment2.isFragment = isFragment;
    function fromFragment(json, device) {
      return Trampoline.traverse(json.children ?? [], (child) => Node4.fromNode(child, device)).map((children) => Fragment2.of(children));
    }
    Fragment2.fromFragment = fromFragment;
    function cloneFragment(options, device) {
      return (fragment) => Trampoline.traverse(fragment.children(), (child) => {
        if (Element.isElement(child) && options.predicate(child)) {
          return Trampoline.done(Array.from(options.newElements));
        }
        return Node4.cloneNode(child, options, device).map((node) => [node]);
      }).map((children) => {
        return Fragment2.of(Iterable.flatten(children), fragment.externalId);
      });
    }
    Fragment2.cloneFragment = cloneFragment;
  })(Fragment || (Fragment = {}));

  // node_modules/@siteimprove/alfa-dom/dist/node/type.js
  var Type2 = class _Type extends Node4 {
    static of(name, publicId = None, systemId = None, externalId, internalId, extraData) {
      return new _Type(name, publicId, systemId, externalId, internalId, extraData);
    }
    static empty() {
      return new _Type("html", None, None);
    }
    _name;
    _publicId;
    _systemId;
    constructor(name, publicId, systemId, externalId, internalId, extraData) {
      super([], "type", externalId, internalId, extraData);
      this._name = name;
      this._publicId = publicId;
      this._systemId = systemId;
    }
    get name() {
      return this._name;
    }
    get publicId() {
      return this._publicId;
    }
    get systemId() {
      return this._systemId;
    }
    toJSON(options) {
      const result = {
        ...super.toJSON(options)
      };
      delete result.children;
      const verbosity = options?.verbosity ?? Serializable.Verbosity.Medium;
      if (verbosity < Serializable.Verbosity.Medium) {
        return result;
      }
      result.name = this.name;
      result.publicId = this._publicId.getOr(null);
      result.systemId = this._systemId.getOr(null);
      return result;
    }
    toString() {
      return `<!doctype ${this._name}>`;
    }
  };
  (function(Type4) {
    function isType(value) {
      return value instanceof Type4;
    }
    Type4.isType = isType;
    function fromType(json) {
      return Trampoline.done(Type4.of(json.name, Option.from(json.publicId), Option.from(json.systemId), json.externalId, json.internalId));
    }
    Type4.fromType = fromType;
    function cloneType(type) {
      return Trampoline.done(Type4.of(type.name, type.publicId, type.systemId, type.externalId, type.internalId));
    }
    Type4.cloneType = cloneType;
  })(Type2 || (Type2 = {}));

  // node_modules/@siteimprove/alfa-dom/dist/node/query/descendants.js
  var _descendantsCache = Cache2.empty();
  function getDescendants(predicate) {
    return (node, options = Node4.Traversal.empty) => {
      const optionsMap = _descendantsCache.get(predicate, Cache2.empty).get(node, () => []);
      if (optionsMap[options.value] === void 0) {
        optionsMap[options.value] = node.descendants(options).filter(predicate);
      }
      return optionsMap[options.value];
    };
  }
  var getElementDescendants = getDescendants(Element.isElement);
  function getInclusiveElementDescendants(node, options = Node4.Traversal.empty) {
    return getElementDescendants(node, options).prepend(node);
  }

  // node_modules/@siteimprove/alfa-dom/dist/node/query/element-id-map.js
  var elementMapCache = Cache2.empty();
  function getElementIdMap(node) {
    if (Document.isDocument(node)) {
      return elementMapCache.get(node, () => buildElementIdMap(node));
    }
    return buildElementIdMap(node);
  }
  function buildElementIdMap(node) {
    return Map2.from(getElementDescendants(node).collect((element) => element.id.map((id) => [id, element])).reverse());
  }

  // node_modules/@siteimprove/alfa-dom/dist/node/query/index.js
  var Query3;
  (function(Query4) {
    Query4.getDescendants = getDescendants;
    Query4.getElementDescendants = getElementDescendants;
    Query4.getElementIdMap = getElementIdMap;
    Query4.getInclusiveElementDescendants = getInclusiveElementDescendants;
  })(Query3 || (Query3 = {}));

  // node_modules/@siteimprove/alfa-dom/dist/h.js
  var { entries } = Object;
  var { nor } = Predicate;
  function h(name, attributes, children, style, box, device = Device.standard(), externalId, internalId, extraData) {
    return h.element(name, attributes, children, style, void 0, box, device, externalId, internalId, extraData);
  }
  (function(h2) {
    function element(name, attributes = [], children = [], style = [], namespace, box, device, externalId, internalId, extraData) {
      attributes = Array.isArray(attributes) ? attributes : entries(attributes).reduce((attributes2, [name2, value]) => {
        if (value === false) {
          return attributes2;
        }
        return [
          ...attributes2,
          h2.attribute(hyphenate(name2), value === true ? "" : value)
        ];
      }, []);
      const block2 = h2.block(style);
      if (block2.size > 0) {
        attributes = [...attributes, h2.attribute("style", block2.toString())];
      }
      namespace = namespace ?? Option.from(attributes.find((attribute2) => attribute2.name === "xmlns")).map((attribute2) => attribute2.value).filter(Namespace.isNamespace).getOr(defaultNamespace(name));
      const content = children.find(Document.isDocument);
      const shadow2 = children.find(Shadow2.isShadow);
      const element2 = Element.of(Option.of(namespace), None, name, attributes, children.filter(nor(Document.isDocument, Shadow2.isShadow)).map((child) => typeof child === "string" ? h2.text(child) : child), Array.isArray(style) && style.length === 0 || Object.keys(style).length === 0 ? None : Option.of(block2), Option.from(box), Option.from(device), externalId, internalId, extraData);
      if (content !== void 0) {
        element2._attachContent(content);
      }
      if (shadow2 !== void 0) {
        element2._attachShadow(shadow2);
      }
      return element2;
    }
    h2.element = element;
    function attribute(name, value, externalId, internalId, extraData) {
      return Attribute.of(None, None, name, value, externalId, internalId, extraData);
    }
    h2.attribute = attribute;
    function text(data, externalId, internalId, extraData) {
      return Text.of(data, externalId, internalId, extraData);
    }
    h2.text = text;
    function document2(children, style, externalId, internalId, extraData) {
      return Document.of(children.map((child) => typeof child === "string" ? text(child) : child), style, externalId, internalId, extraData);
    }
    h2.document = document2;
    function shadow(children, style, mode, externalId, internalId, extraData) {
      return Shadow2.of(children.map((child) => typeof child === "string" ? text(child) : child), style, mode, externalId, internalId, extraData);
    }
    h2.shadow = shadow;
    function type(name, publicId, systemId, externalId, internalId, extraData) {
      return Type2.of(name, Option.from(publicId), Option.from(systemId), externalId, internalId, extraData);
    }
    h2.type = type;
    function fragment(children, externalId, extraData) {
      return Fragment.of(children.map((child) => typeof child === "string" ? text(child) : child), externalId, extraData);
    }
    h2.fragment = fragment;
    function sheet(rules, disabled, condition) {
      return Sheet.of(rules, disabled, Option.from(condition));
    }
    h2.sheet = sheet;
    function block(declarations) {
      return Block2.of(Array.isArray(declarations) ? declarations : entries(declarations).map(([name, value]) => {
        const important = value.endsWith("!important");
        value = value.replace(/!important$/, "").trim();
        if (!name.startsWith("--")) {
          name = hyphenate(name);
        }
        return Declaration2.of(name, value, important);
      }));
    }
    h2.block = block;
    function declaration(name, value, important) {
      return Declaration2.of(name, value, important);
    }
    h2.declaration = declaration;
    let rule;
    (function(rule2) {
      function fontFace(declarations) {
        return FontFaceRule.of(block(declarations));
      }
      rule2.fontFace = fontFace;
      function importRule(url, sheet2, mediaCondition, supportCondition, layer) {
        return ImportRule.of(url, sheet2, Option.from(mediaCondition), Option.from(supportCondition), Option.from(layer));
      }
      rule2.importRule = importRule;
      function keyframe(key, declarations) {
        return KeyframeRule.of(key, block(declarations));
      }
      rule2.keyframe = keyframe;
      function keyframes(name, rules) {
        return KeyframesRule.of(name, rules);
      }
      rule2.keyframes = keyframes;
      function layerBlock(rules, layer) {
        return Layer.BlockRule.of(rules, layer);
      }
      rule2.layerBlock = layerBlock;
      function layerStatement(layers) {
        return Layer.StatementRule.of(layers);
      }
      rule2.layerStatement = layerStatement;
      function media(condition, rules) {
        return MediaRule.of(condition, rules);
      }
      rule2.media = media;
      function namespace(namespace2, prefix) {
        return NamespaceRule.of(namespace2, Option.from(prefix));
      }
      rule2.namespace = namespace;
      function page(selector, declarations) {
        return PageRule.of(selector, block(declarations));
      }
      rule2.page = page;
      function style(selector, declarations, hint) {
        return StyleRule.of(selector, block(declarations), hint);
      }
      rule2.style = style;
      function supports(condition, rules) {
        return SupportsRule.of(condition, rules);
      }
      rule2.supports = supports;
    })(rule = h2.rule || (h2.rule = {}));
  })(h || (h = {}));
  function hyphenate(value) {
    return value.replace(/[A-Z]/g, (letter) => `-${letter.toLowerCase()}`);
  }
  function defaultNamespace(name) {
    switch (name) {
      // The <a> element exists both in SVG and HTML namespaces.
      // It is defaulted in the HTML namespace and must be explicitly built in
      // the SVG one if needed.
      case "circle":
      case "ellipse":
      case "foreignObject":
      case "g":
      case "image":
      case "line":
      case "mesh":
      case "path":
      case "polygon":
      case "polyline":
      case "rect":
      case "svg":
      case "symbol":
      case "text":
      case "textPath":
      case "use":
        return Namespace.SVG;
      case "annotation":
      case "annotation-xml":
      case "maction":
      case "math":
      case "merror":
      case "mfrac":
      case "mi":
      case "mmultiscripts":
      case "mn":
      case "mo":
      case "mover":
      case "mpadded":
      case "mphantom":
      case "mprescripts":
      case "mroot":
      case "mrow":
      case "ms":
      case "mspace":
      case "msqrt":
      case "mstyle":
      case "msub":
      case "msubsup":
      case "msup":
      case "mtable":
      case "mtd":
      case "mtext":
      case "mtr":
      case "munder":
      case "munderover":
      case "none":
      case "semantics":
        return Namespace.MathML;
      default:
        return Namespace.HTML;
    }
  }

  // node_modules/@siteimprove/alfa-dom/dist/jsx.js
  var { entries: entries2 } = Object;

  // node_modules/@siteimprove/alfa-dom/dist/native.js
  var Native;
  (function(Native2) {
    async function fromNode2(node = globalThis.window.document, options) {
      const { withCrossOrigin = false } = options ?? {};
      return toNode(node);
      async function toNode(node2) {
        switch (node2.nodeType) {
          case node2.ELEMENT_NODE:
            return toElement(node2);
          case node2.ATTRIBUTE_NODE:
            return toAttribute(node2);
          case node2.TEXT_NODE:
            return toText(node2);
          case node2.COMMENT_NODE:
            return toComment(node2);
          case node2.DOCUMENT_NODE:
            return toDocument(node2);
          case node2.DOCUMENT_TYPE_NODE:
            return toType(node2);
        }
        throw new Error(`Unsupported node of type: ${node2.nodeType}`);
      }
      async function toElement(element) {
        return {
          type: "element",
          namespace: element.namespaceURI,
          prefix: element.prefix,
          name: element.localName,
          attributes: map126(element.attributes, toAttribute),
          style: "style" in element ? toBlock(element.style) : null,
          children: await mapAsync(element.childNodes, toNode),
          shadow: element.shadowRoot !== null ? await toShadow(element.shadowRoot) : null,
          content: "contentDocument" in element && element.contentDocument !== null ? await toDocument(element.contentDocument) : null,
          box: toRectangle(element.getBoundingClientRect())
        };
      }
      function toAttribute(attribute) {
        return {
          type: "attribute",
          namespace: attribute.namespaceURI,
          prefix: attribute.prefix,
          name: attribute.localName,
          value: attribute.value
        };
      }
      function toText(text) {
        return {
          type: "text",
          data: text.data
        };
      }
      function toComment(comment) {
        return {
          type: "comment",
          data: comment.data
        };
      }
      async function toDocument(document2) {
        if (withCrossOrigin) {
          await ensureCrossOrigin(document2);
        }
        return {
          type: "document",
          children: await mapAsync(document2.childNodes, toNode),
          style: getStyleSheets(document2)
        };
      }
      function toType(type) {
        return {
          type: "type",
          name: type.name,
          publicId: type.publicId === "" ? null : type.publicId,
          systemId: type.systemId === "" ? null : type.systemId
        };
      }
      async function toShadow(shadow) {
        if (withCrossOrigin) {
          await ensureCrossOrigin(document);
        }
        return {
          type: "shadow",
          mode: shadow.mode,
          children: await mapAsync(shadow.childNodes, toNode),
          style: getStyleSheets(shadow)
        };
      }
      function getStyleSheets(docOrShadow) {
        return [
          ...map126(docOrShadow.styleSheets, toSheet),
          // `adoptedStyleSheets` generated by JSDOM can be undefined despite it violating the type.
          // It seems this part of the specification is still not fully implemented in JSDOM as of July 2024.
          // https://github.com/jsdom/jsdom/issues/3444
          ...map126(docOrShadow.adoptedStyleSheets ?? [], toSheet)
        ];
      }
      function toSheet(sheet) {
        let rules;
        try {
          rules = map126(sheet.cssRules, toRule);
        } catch {
          rules = [];
        }
        return {
          rules,
          disabled: sheet.disabled,
          condition: (
            // Sheets generated by pre-renderers like JSDOM do not contain media
            // at all.
            // OTOH, the MediaList.mediaText interface treat null as the empty
            // string, so we must do the same here (in the other direction).
            (sheet?.media?.mediaText ?? "") === "" ? null : sheet.media.mediaText
          )
        };
      }
      function toRule(rule) {
        switch (rule.constructor.name) {
          case "CSSFontFaceRule":
            return toFontFaceRule(rule);
          case "CSSImportRule":
            return toImportRule(rule);
          case "CSSKeyframeRule":
            return toKeyframeRule(rule);
          case "CSSKeyframesRule":
            return toKeyframesRule(rule);
          case "CSSLayerBlockRule":
            return toLayerBlockRule(rule);
          case "CSSLayerStatementRule":
            return toLayerStatementRule(rule);
          case "CSSMediaRule":
            return toMediaRule(rule);
          case "CSSNamespaceRule":
            return toNamespaceRule(rule);
          case "CSSPageRule":
            return toPageRule(rule);
          case "CSSStyleRule":
            return toStyleRule(rule);
          case "CSSSupportsRule":
            return toSupportsRule(rule);
        }
        switch (Object.prototype.toString.apply(rule)) {
          case "[object CSSFontFaceRule]":
            return toFontFaceRule(rule);
          case "[object CSSImportRule]":
            return toImportRule(rule);
          case "[object CSSKeyframeRule]":
            return toKeyframeRule(rule);
          case "[object CSSKeyframesRule]":
            return toKeyframesRule(rule);
          case "[object CSSLayerBlockRule]":
            return toLayerBlockRule(rule);
          case "[object CSSLayerStatementRule]":
            return toLayerStatementRule(rule);
          case "[object CSSMediaRule]":
            return toMediaRule(rule);
          case "[object CSSNamespaceRule]":
            return toNamespaceRule(rule);
          case "[object CSSPageRule]":
            return toPageRule(rule);
          case "[object CSSStyleRule]":
            return toStyleRule(rule);
          case "[object CSSSupportsRule]":
            return toSupportsRule(rule);
        }
        switch (rule.type) {
          case CSSRule.FONT_FACE_RULE:
            return toFontFaceRule(rule);
          case CSSRule.IMPORT_RULE:
            return toImportRule(rule);
          case CSSRule.KEYFRAME_RULE:
            return toKeyframeRule(rule);
          case CSSRule.KEYFRAMES_RULE:
            return toKeyframesRule(rule);
          // case "CSSLayerBlockRule":
          //   return toLayerBlockRule(rule);
          // case "CSSLayerStatementRule":
          //   return toLayerStatementRule(rule);
          case CSSRule.MEDIA_RULE:
            return toMediaRule(rule);
          case CSSRule.NAMESPACE_RULE:
            return toNamespaceRule(rule);
          case CSSRule.PAGE_RULE:
            return toPageRule(rule);
          case CSSRule.STYLE_RULE:
            return toStyleRule(rule);
          case CSSRule.SUPPORTS_RULE:
            return toSupportsRule(rule);
        }
        throw new Error(`Unsupported rule of type: ${rule.constructor.name} / ${Object.prototype.toString.apply(rule)} / ${rule.type}`);
      }
      function toFontFaceRule(rule) {
        return {
          type: "font-face",
          style: toBlock(rule.style)
        };
      }
      function toImportRule(rule) {
        return {
          type: "import",
          rules: rule.styleSheet === null ? [] : toSheet(rule.styleSheet).rules,
          condition: rule.media.mediaText === "" ? "all" : rule.media.mediaText,
          href: rule.href,
          supportText: rule.supportsText,
          layer: rule.layerName
        };
      }
      function toKeyframeRule(rule) {
        return {
          type: "keyframe",
          key: rule.keyText,
          style: toBlock(rule.style)
        };
      }
      function toKeyframesRule(rule) {
        let rules;
        try {
          rules = map126(rule.cssRules, toRule);
        } catch {
          rules = [];
        }
        return {
          type: "keyframes",
          rules,
          name: rule.name
        };
      }
      function toLayerBlockRule(rule) {
        return {
          type: "layer-block",
          layer: rule.name,
          rules: map126(rule.cssRules, toRule)
        };
      }
      function toLayerStatementRule(rule) {
        return {
          type: "layer-statement",
          layers: [...rule.nameList]
        };
      }
      function toMediaRule(rule) {
        let rules;
        try {
          rules = map126(rule.cssRules, toRule);
        } catch {
          rules = [];
        }
        return {
          type: "media",
          condition: rule.conditionText,
          rules
        };
      }
      function toNamespaceRule(rule) {
        return {
          type: "namespace",
          namespace: rule.namespaceURI,
          prefix: rule.prefix
        };
      }
      function toPageRule(rule) {
        return {
          type: "page",
          selector: rule.selectorText,
          style: toBlock(rule.style)
        };
      }
      function toStyleRule(styleRule) {
        return {
          type: "style",
          selector: styleRule.selectorText,
          style: toBlock(styleRule.style)
        };
      }
      function toSupportsRule(rule) {
        let rules;
        try {
          rules = map126(rule.cssRules, toRule);
        } catch {
          rules = [];
        }
        return {
          type: "supports",
          condition: rule.conditionText,
          rules
        };
      }
      function toBlock(block) {
        return block.cssText;
      }
      function toRectangle(domRect) {
        return {
          type: "rectangle",
          x: domRect.x,
          y: domRect.y,
          width: domRect.width,
          height: domRect.height
        };
      }
      function map126(arrayLike, mapper) {
        const result = new Array(arrayLike.length);
        for (let i = 0, n = arrayLike.length; i < n; i++) {
          result[i] = mapper(arrayLike[i]);
        }
        return result;
      }
      async function mapAsync(arrayLike, mapper) {
        const result = new Array(arrayLike.length);
        for (let i = 0, n = arrayLike.length; i < n; i++) {
          result[i] = await mapper(arrayLike[i]);
        }
        return result;
      }
      async function ensureCrossOrigin(documentOrShadowRoot) {
        const links = documentOrShadowRoot.querySelectorAll("link");
        for (let i = 0; i < links.length; i++) {
          const link = links[i];
          if (link.crossOrigin !== null) {
            continue;
          }
          const clone = link.cloneNode();
          clone.crossOrigin = "anonymous";
          link.parentNode.replaceChild(clone, link);
          if (shouldAwait(link)) {
            await new Promise((resolve3) => ["load", "error"].forEach((event) => clone.addEventListener(event, () => resolve3())));
          }
        }
        function shouldAwait(link) {
          if (link.getAttribute("href")?.trim() === "") {
            return false;
          }
          if (link.rel === "stylesheet") {
            return true;
          }
          return false;
        }
      }
    }
    Native2.fromNode = fromNode2;
  })(Native || (Native = {}));

  // node_modules/@siteimprove/alfa-http/dist/body.js
  var { isObject: isObject7 } = Refinement;
  var Body;
  (function(Body2) {
    function isBody2(value) {
      return isObject7(value) && value.body instanceof ArrayBuffer;
    }
    Body2.isBody = isBody2;
  })(Body || (Body = {}));

  // node_modules/@siteimprove/alfa-http/dist/cookie.js
  var Cookie = class _Cookie {
    static of(name, value) {
      return new _Cookie(name, value);
    }
    _name;
    _value;
    constructor(name, value) {
      this._name = name;
      this._value = value;
    }
    get name() {
      return this._name;
    }
    get value() {
      return this._value;
    }
    equals(value) {
      return value instanceof _Cookie && value._name === this._name && value._value === this._value;
    }
    toJSON() {
      return {
        name: this._name,
        value: this._value
      };
    }
    toString() {
      return `${this._name}=${this._value}`;
    }
  };
  (function(Cookie2) {
    function from(json) {
      return Cookie2.of(json.name, json.value);
    }
    Cookie2.from = from;
    function isCookie(value) {
      return value instanceof Cookie2;
    }
    Cookie2.isCookie = isCookie;
  })(Cookie || (Cookie = {}));

  // node_modules/@siteimprove/alfa-http/dist/cookies.js
  var Cookies = class _Cookies {
    /**
     * @remarks
     * If the iterable contains cookies with duplicate names, the last cookie with
     * a given name will take precedence.
     */
    static of(cookies) {
      return new _Cookies(Map2.from(Iterable.map(cookies, (cookie) => [cookie.name, cookie])));
    }
    static _empty = new _Cookies(Map2.empty());
    static empty() {
      return this._empty;
    }
    _cookies;
    constructor(cookies) {
      this._cookies = cookies;
    }
    get(name) {
      return this._cookies.get(name);
    }
    has(name) {
      return this._cookies.has(name);
    }
    add(cookie) {
      return new _Cookies(this._cookies.set(cookie.name, cookie));
    }
    delete(name) {
      return new _Cookies(this._cookies.delete(name));
    }
    *[Symbol.iterator]() {
      yield* this._cookies.values();
    }
    toArray() {
      return [...this];
    }
    toJSON() {
      return this.toArray().map((cookie) => cookie.toJSON());
    }
    toString() {
      return this.toArray().map((cookie) => cookie.toString()).join("; ");
    }
  };
  (function(Cookies2) {
    function from(json) {
      return Cookies2.of(json.map((cookie) => Cookie.from(cookie)));
    }
    Cookies2.from = from;
    function isCookies(value) {
      return value instanceof Cookies2;
    }
    Cookies2.isCookies = isCookies;
  })(Cookies || (Cookies = {}));

  // node_modules/@siteimprove/alfa-http/dist/header.js
  var Header = class _Header {
    static of(name, value) {
      return new _Header(name, value);
    }
    _name;
    _value;
    constructor(name, value) {
      this._name = name;
      this._value = value;
    }
    get name() {
      return this._name;
    }
    get value() {
      return this._value;
    }
    equals(value) {
      return value instanceof _Header && value._name === this._name && value._value === this._value;
    }
    toJSON(options) {
      return {
        name: this._name,
        value: this._value
      };
    }
    toEARL() {
      return {
        "@context": {
          http: "http://www.w3.org/2011/http#"
        },
        "@type": "http:MessageHeader",
        "http:fieldName": this._name,
        "http:fieldValue": this._value
      };
    }
    toString() {
      return `${this._name}: ${this._value}`;
    }
  };
  (function(Header2) {
    function from(json) {
      return Header2.of(json.name, json.value);
    }
    Header2.from = from;
    function isHeader(value) {
      return value instanceof Header2;
    }
    Header2.isHeader = isHeader;
  })(Header || (Header = {}));

  // node_modules/@siteimprove/alfa-http/dist/headers.js
  var Headers = class _Headers {
    /**
     * @remarks
     * If the iterable contains headers with duplicate names, the last header with
     * a given name will take precedence.
     */
    static of(headers) {
      return new _Headers(Map2.from(Iterable.map(headers, (header) => [header.name, header])));
    }
    static _empty = new _Headers(Map2.empty());
    static empty() {
      return this._empty;
    }
    _headers;
    constructor(headers) {
      this._headers = headers;
    }
    get(name) {
      return this._headers.get(name);
    }
    has(name) {
      return this._headers.has(name);
    }
    add(header) {
      return new _Headers(this._headers.set(header.name, header));
    }
    delete(name) {
      return new _Headers(this._headers.delete(name));
    }
    *[Symbol.iterator]() {
      yield* this._headers.values();
    }
    toArray() {
      return [...this];
    }
    toJSON(options) {
      return this.toArray().map((header) => header.toJSON(options));
    }
    toEARL() {
      return {
        "@context": {
          http: "http://www.w3.org/2011/http#"
        },
        "@list": this.toArray().map((header) => header.toEARL())
      };
    }
    toString() {
      return this.toArray().map((header) => header.toString()).join("\n");
    }
  };
  (function(Headers2) {
    function from(json) {
      return Headers2.of(json.map((header) => Header.from(header)));
    }
    Headers2.from = from;
    function isHeaders(value) {
      return value instanceof Headers2;
    }
    Headers2.isHeaders = isHeaders;
  })(Headers || (Headers = {}));

  // node_modules/@siteimprove/alfa-url/dist/builtin.js
  var Builtin3 = URL;

  // node_modules/@siteimprove/alfa-url/dist/url.js
  var { isEmpty: isEmpty4 } = Iterable;
  var URL3 = class _URL {
    static of(scheme, username = None, password = None, host = None, port = None, path = [], query = None, fragment = None, cannotBeABase = false) {
      return new _URL(scheme, username, password, host, port, Sequence.from(path), query, fragment, cannotBeABase);
    }
    /**
     * {@link https://tools.ietf.org/html/rfc2606#section-3}
     */
    static example() {
      return _URL.parse("https://example.com").getUnsafe();
    }
    /**
     * {@link https://tools.ietf.org/html/rfc6694#section-3}
     */
    static blank() {
      return _URL.parse("about:blank").getUnsafe();
    }
    _scheme;
    _username;
    _password;
    _host;
    _port;
    _path;
    _query;
    _fragment;
    _cannotBeABase;
    constructor(scheme, username, password, host, port, path, query, fragment, cannotBeABase) {
      this._scheme = scheme;
      this._username = username;
      this._password = password;
      this._host = host;
      this._port = port;
      this._path = path;
      this._query = query;
      this._fragment = fragment;
      this._cannotBeABase = cannotBeABase;
    }
    /**
     * {@link https://url.spec.whatwg.org/#concept-url-scheme}
     */
    get scheme() {
      return this._scheme;
    }
    /**
     * {@link https://url.spec.whatwg.org/#concept-url-username}
     */
    get username() {
      return this._username;
    }
    /**
     * {@link https://url.spec.whatwg.org/#concept-url-password}
     */
    get password() {
      return this._password;
    }
    /**
     * {@link https://url.spec.whatwg.org/#concept-url-host}
     */
    get host() {
      return this._host;
    }
    /**
     * {@link https://url.spec.whatwg.org/#concept-url-port}
     */
    get port() {
      return this._port;
    }
    /**
     * {@link https://url.spec.whatwg.org/#concept-url-path}
     */
    get path() {
      return this._path;
    }
    /**
     * {@link https://url.spec.whatwg.org/#concept-url-query}
     */
    get query() {
      return this._query;
    }
    /**
     * {@link https://url.spec.whatwg.org/#concept-url-fragment}
     */
    get fragment() {
      return this._fragment;
    }
    /**
     * {@link https://url.spec.whatwg.org/#url-cannot-be-a-base-url-flag}
     */
    get cannotBeABase() {
      return this._cannotBeABase;
    }
    /**
     * {@link https://url.spec.whatwg.org/#is-special}
     */
    isSpecial() {
      return _URL.isSpecialScheme(this._scheme);
    }
    /**
     * {@link https://url.spec.whatwg.org/#include-credentials}
     */
    hasCredentials() {
      return this._username.isSome() || this._password.isSome();
    }
    /**
     * Remove the fragment portion of this URL.
     *
     * @remarks
     * This method is useful for contexts in which the fragment portion of the URL,
     * which isn't passed from client to server, is of no interest.
     */
    withoutFragment() {
      if (this._fragment.isNone()) {
        return this;
      }
      return new _URL(this._scheme, this._username, this._password, this._host, this._port, this._path, this._query, None, this._cannotBeABase);
    }
    equals(value) {
      return value instanceof _URL && value._scheme === this._scheme && value._username.equals(this._username) && value._password.equals(this._password) && value._host.equals(this._host) && value._port.equals(this._port) && value._path.equals(this._path) && value._query.equals(this._query) && value._fragment.equals(this._fragment) && value._cannotBeABase === this._cannotBeABase;
    }
    hash(hash2) {
      hash2.writeString(this._scheme).writeHashable(this._username).writeHashable(this._password).writeHashable(this._host).writeHashable(this._port).writeHashable(this._path).writeHashable(this._query).writeHashable(this._fragment).writeBoolean(this._cannotBeABase);
    }
    toJSON() {
      return {
        scheme: this._scheme,
        username: this._username.getOr(null),
        password: this._password.getOr(null),
        host: this._host.getOr(null),
        port: this._port.getOr(null),
        path: this._path.toArray(),
        query: this._query.getOr(null),
        fragment: this._fragment.getOr(null),
        cannotBeABase: this._cannotBeABase
      };
    }
    /**
     * {@link https://url.spec.whatwg.org/#concept-url-serializer}
     */
    toString() {
      let output = this._scheme + ":";
      for (const host of this._host) {
        output += "//";
        if (this.hasCredentials()) {
          for (const username of this._username) {
            output += username;
          }
          for (const password of this._password) {
            output += ":" + password;
          }
          output += "@";
        }
        output += host;
        for (const port of this._port) {
          output += ":" + port.toString(10);
        }
      }
      if (this._cannotBeABase) {
        output += this._path.get(0).getOr("");
      } else {
        if (this._host.isNone() && this._path.size > 1 && this._path.first().includes("")) {
          output += "/.";
        }
        for (const segment of this._path) {
          output += "/" + segment;
        }
      }
      for (const query of this._query) {
        output += "?" + query;
      }
      for (const fragment of this._fragment) {
        output += "#" + fragment;
      }
      return output;
    }
  };
  (function(URL4) {
    function from(json) {
      return URL4.of(json.scheme, Option.from(json.username), Option.from(json.password), Option.from(json.host), Option.from(json.port), json.path, Option.from(json.query), Option.from(json.fragment));
    }
    URL4.from = from;
    function parse57(url, base3) {
      if (typeof base3 === "string") {
        const result = parse57(base3);
        if (!result.isOk()) {
          return result;
        }
        base3 = result.get();
      }
      try {
        const {
          // https://url.spec.whatwg.org/#dom-url-protocol
          protocol,
          // https://url.spec.whatwg.org/#dom-url-username
          username,
          // https://url.spec.whatwg.org/#dom-url-password
          password,
          // https://url.spec.whatwg.org/#dom-url-hostname
          hostname,
          // https://url.spec.whatwg.org/#dom-url-port
          port,
          // https://url.spec.whatwg.org/#dom-url-pathname
          pathname,
          // https://url.spec.whatwg.org/#dom-url-search
          search,
          // https://url.spec.whatwg.org/#dom-url-hash
          hash: hash2
        } = new Builtin3(url, base3?.toString());
        const scheme = protocol.replace(/:$/, "");
        return Result.of(URL4.of(
          scheme,
          // `URL#username` `URL#password` expose the username and password
          // as-is and so the only thing we need to do is reject them when
          // empty.
          Option.of(username).reject(isEmpty4),
          Option.of(password).reject(isEmpty4),
          // `URL#hostname` exposes the host as an empty string if the host is
          // `null`. For the `file` scheme, however, the empty string is
          // significant and we therefore don't translate it into `None`.
          scheme === "file" ? Option.of(hostname) : Option.of(hostname).reject(isEmpty4),
          // `URL#port` exposes the port number as a string to we convert it to
          // a number.
          Option.of(port).reject(isEmpty4).map(Number),
          // `URL#pathname` exposes the path segments with a leading "/" and
          // joins the segments with "/". We therefore remove the leading "/"
          // and split the segments by "/" into an array.
          pathname.replace(/^\//, "").split("/"),
          // `URL#search` exposes the query portion of the URL with a leading
          // "?" which we need to remove.
          Option.of(search).reject(isEmpty4).map((search2) => search2.replace(/^\?/, "")),
          // `URL#hash` exposes the fragment portion of the URL with a leading
          // "#" which we need to remove.
          Option.of(hash2).reject(isEmpty4).map((hash3) => hash3.replace(/^#/, "")),
          // The URL cannot be used as a base URL when the scheme isn't
          // special and the pathname doesn't start with a leading "/".
          !isSpecialScheme(scheme) && pathname[0] !== "/"
        ));
      } catch (err) {
        if (err instanceof Error) {
          return Err.of(err.message);
        } else {
          return Err.of(`${err}`);
        }
      }
    }
    URL4.parse = parse57;
    function isSpecialScheme(scheme) {
      switch (scheme) {
        case "ftp":
        case "file":
        case "http":
        case "https":
        case "ws":
        case "wss":
          return true;
        default:
          return false;
      }
    }
    URL4.isSpecialScheme = isSpecialScheme;
  })(URL3 || (URL3 = {}));

  // node_modules/@siteimprove/alfa-http/dist/request.js
  var Request = class _Request {
    static of(method, url, headers = Headers.empty(), body = new ArrayBuffer(0)) {
      return new _Request(method, url, headers, body);
    }
    static _empty = _Request.of("GET", URL3.blank());
    static empty() {
      return this._empty;
    }
    _method;
    _url;
    _headers;
    _body;
    constructor(method, url, headers, body) {
      this._method = method;
      this._url = url;
      this._headers = headers;
      this._body = body;
    }
    /**
     * {@link https://fetch.spec.whatwg.org/#dom-request-method}
     */
    get method() {
      return this._method;
    }
    /**
     * {@link https://fetch.spec.whatwg.org/#dom-request-url}
     */
    get url() {
      return this._url;
    }
    /**
     * {@link https://fetch.spec.whatwg.org/#dom-request-headers}
     */
    get headers() {
      return this._headers;
    }
    /**
     * {@link https://fetch.spec.whatwg.org/#dom-body-body}
     */
    get body() {
      return this._body;
    }
    toJSON(options) {
      return {
        method: this._method,
        url: this._url.toString(),
        headers: this._headers.toJSON(options),
        body: Decoder.decode(new Uint8Array(this._body))
      };
    }
    toEARL() {
      return {
        "@context": {
          http: "http://www.w3.org/2011/http#"
        },
        "@type": ["http:Message", "http:Request"],
        "http:methodName": this._method,
        "http:requestURI": this._url.toString(),
        "http:headers": this._headers.toEARL(),
        "http:body": {
          "@context": {
            cnt: "http://www.w3.org/2011/content#"
          },
          "@type": ["cnt:Content", "cnt:ContentAsText"],
          "cnt:characterEncoding": "utf-8",
          "cnt:chars": Decoder.decode(new Uint8Array(this._body))
        }
      };
    }
    toString() {
      let request = `${this._method} ${this._url} HTTP/1.1`;
      request += "\n" + this._headers.toString();
      request += "\n";
      request += Decoder.decode(new Uint8Array(this._body));
      return request;
    }
  };
  (function(Request2) {
    function from(json) {
      return URL3.parse(json.url).map((url) => Request2.of(json.method, url, Headers.from(json.headers), Encoder.encode(json.body)));
    }
    Request2.from = from;
    function isRequest(value) {
      return value instanceof Request2;
    }
    Request2.isRequest = isRequest;
  })(Request || (Request = {}));

  // node_modules/@siteimprove/alfa-http/dist/response.js
  var Response = class _Response {
    static of(url, status, headers = Headers.empty(), body = new ArrayBuffer(0)) {
      return new _Response(url, status, headers, body);
    }
    static _empty = _Response.of(URL3.blank(), 200);
    static empty() {
      return this._empty;
    }
    _url;
    _status;
    _headers;
    _body;
    constructor(url, status, headers, body) {
      this._url = url;
      this._status = status;
      this._headers = headers;
      this._body = body;
    }
    /**
     * {@link https://fetch.spec.whatwg.org/#dom-response-url}
     */
    get url() {
      return this._url;
    }
    /**
     * {@link https://fetch.spec.whatwg.org/#dom-response-status}
     */
    get status() {
      return this._status;
    }
    /**
     * {@link https://fetch.spec.whatwg.org/#dom-response-headers}
     */
    get headers() {
      return this._headers;
    }
    /**
     * {@link https://fetch.spec.whatwg.org/#dom-body-body}
     */
    get body() {
      return this._body;
    }
    toJSON(options) {
      return {
        url: this._url.toString(),
        status: this._status,
        headers: this._headers.toJSON(options),
        body: Decoder.decode(new Uint8Array(this._body))
      };
    }
    toEARL() {
      return {
        "@context": {
          http: "http://www.w3.org/2011/http#"
        },
        "@type": ["http:Message", "http:Response"],
        "http:statusCodeValue": this._status,
        "http:headers": this._headers.toEARL(),
        "http:body": {
          "@context": {
            cnt: "http://www.w3.org/2011/content#"
          },
          "@type": ["cnt:Content", "cnt:ContentAsText"],
          "cnt:characterEncoding": "utf-8",
          "cnt:chars": Decoder.decode(new Uint8Array(this._body))
        }
      };
    }
    toString() {
      let response = `HTTP/1.1 ${this._status}`;
      response += "\n" + this._headers.toString();
      response += "\n";
      response += Decoder.decode(new Uint8Array(this._body));
      return response;
    }
  };
  (function(Response2) {
    function from(json) {
      return URL3.parse(json.url).map((url) => Response2.of(url, json.status, Headers.from(json.headers), Encoder.encode(json.body)));
    }
    Response2.from = from;
    function isResponse(value) {
      return value instanceof Response2;
    }
    Response2.isResponse = isResponse;
  })(Response || (Response = {}));

  // node_modules/@siteimprove/alfa-web/dist/page.js
  var Page = class _Page {
    static of(request, response, document2, device) {
      return new _Page(request, response, document2, device);
    }
    _request;
    _response;
    _document;
    _device;
    constructor(request, response, document2, device) {
      this._request = request;
      this._response = response;
      this._document = document2;
      this._device = device;
    }
    get request() {
      return this._request;
    }
    get response() {
      return this._response;
    }
    get document() {
      return this._document;
    }
    get device() {
      return this._device;
    }
    toJSON(options) {
      return {
        request: this._request.toJSON(options),
        response: this._response.toJSON(options),
        document: this._document.toJSON({
          device: this._device,
          ...options ?? {}
        }),
        device: this._device.toJSON(options)
      };
    }
    toEARL() {
      return {
        "@context": {
          earl: "http://www.w3.org/ns/earl#",
          dct: "http://purl.org/dc/terms/"
        },
        "@type": ["earl:TestSubject"],
        "@id": this.response.url.toString(),
        "dct:source": this.response.url.toString(),
        "dct:hasPart": [this._request.toEARL(), this._response.toEARL()]
      };
    }
    toSARIF() {
      return {
        location: {
          uri: this.response.url.toString()
        },
        contents: {
          text: Decoder.decode(new Uint8Array(this.response.body))
        }
      };
    }
  };
  (function(Page2) {
    const cache16 = Cache2.empty();
    function from(json) {
      return cache16.get(json, () => {
        const device = Device.from(json.device);
        return Request.from(json.request).andThen((request) => Response.from(json.response).map((response) => Page2.of(request, response, Document.from(json.document, device), device)));
      });
    }
    Page2.from = from;
    function isPage(value) {
      return value instanceof Page2;
    }
    Page2.isPage = isPage;
  })(Page || (Page = {}));

  // node_modules/@siteimprove/alfa-web/dist/resource.js
  var { isObject: isObject8 } = Refinement;
  var Resource;
  (function(Resource2) {
    function isResource(value) {
      return isObject8(value) && Request.isRequest(value.request) && Response.isResponse(value.response);
    }
    Resource2.isResource = isResource;
  })(Resource || (Resource = {}));

  // node_modules/@siteimprove/alfa-rules/dist/tags/scope.js
  var Scope = class _Scope extends Tag {
    static of(scope) {
      return new _Scope(scope);
    }
    _scope;
    constructor(scope) {
      super();
      this._scope = scope;
    }
    get type() {
      return "scope";
    }
    get scope() {
      return this._scope;
    }
    equals(value) {
      return value instanceof _Scope && value._scope === this._scope;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        scope: this._scope
      };
    }
  };
  (function(Scope3) {
    Scope3.Page = Scope3.of("page");
    Scope3.Component = Scope3.of("component");
  })(Scope || (Scope = {}));

  // node_modules/@siteimprove/alfa-rules/dist/tags/stability.js
  var Stability = class _Stability extends Tag {
    static of(stability) {
      return new _Stability(stability);
    }
    _stability;
    constructor(stability) {
      super();
      this._stability = stability;
    }
    get type() {
      return "stability";
    }
    get stability() {
      return this._stability;
    }
    equals(value) {
      return value instanceof _Stability && value._stability === this._stability;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        stability: this._stability
      };
    }
  };
  (function(Stability2) {
    Stability2.Experimental = Stability2.of("experimental");
    Stability2.Stable = Stability2.of("stable");
    Stability2.Deprecated = Stability2.of("deprecated");
  })(Stability || (Stability = {}));

  // node_modules/@siteimprove/alfa-rules/dist/tags/version.js
  var Version = class _Version extends Tag {
    static of(version) {
      return new _Version(version);
    }
    _version;
    constructor(version) {
      super();
      this._version = version;
    }
    get type() {
      return "version";
    }
    get version() {
      return this._version;
    }
    equals(value) {
      return value instanceof _Version && value._version === this._version;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        version: this._version
      };
    }
  };
  (function(Version2) {
    function isVersion(value) {
      return value instanceof Version2;
    }
    Version2.isVersion = isVersion;
  })(Version || (Version = {}));

  // node_modules/@siteimprove/alfa-rules/dist/requirements/aria.js
  var ARIA = class _ARIA extends Requirement {
    static of(uri) {
      return new _ARIA(uri);
    }
    constructor(uri) {
      super("ARIA", uri);
    }
    toJSON() {
      return super.toJSON();
    }
  };
  (function(ARIA2) {
    function isARIA(value) {
      return value instanceof ARIA2;
    }
    ARIA2.isARIA = isARIA;
  })(ARIA || (ARIA = {}));

  // node_modules/@siteimprove/alfa-rules/dist/requirements/best-practice.js
  var BestPractice = class _BestPractice extends Requirement {
    static of(uri) {
      return new _BestPractice(uri);
    }
    constructor(uri) {
      super("best practice", uri);
    }
    toJSON() {
      return super.toJSON();
    }
  };
  (function(BestPractice2) {
    function isBestPractice(value) {
      return value instanceof BestPractice2;
    }
    BestPractice2.isBestPractice = isBestPractice;
  })(BestPractice || (BestPractice = {}));

  // node_modules/@siteimprove/alfa-style/dist/resolver.js
  var Resolver2;
  (function(Resolver3) {
    function lengthResolver(style) {
      const { viewport } = style.device;
      const width = Length2.of(viewport.width, "px");
      const height = Length2.of(viewport.height, "px");
      const fontSize = style.computed("font-size").value;
      const rootFontSize = style.root().computed("font-size").value;
      return Length2.resolver(fontSize, rootFontSize, width, height);
    }
    function length(style) {
      return { length: lengthResolver(style) };
    }
    Resolver3.length = length;
    function lengthPercentage(base3, style) {
      return { percentageBase: base3, length: lengthResolver(style) };
    }
    Resolver3.lengthPercentage = lengthPercentage;
  })(Resolver2 || (Resolver2 = {}));

  // node_modules/@siteimprove/alfa-style/dist/value.js
  var Value4 = class _Value {
    static of(value, source = None) {
      return new _Value(value, source);
    }
    _value;
    _source;
    constructor(value, source) {
      this._value = value;
      this._source = source;
    }
    get value() {
      return this._value;
    }
    get source() {
      return this._source;
    }
    map(mapper) {
      return new _Value(mapper(this._value, this._source), this._source);
    }
    resolve(resolver) {
      return new _Value(this._value.resolve(resolver), this._source);
    }
    apply(mapper) {
      return mapper.map((mapper2) => mapper2(this._value));
    }
    flatMap(mapper) {
      return mapper(this._value, this._source);
    }
    flatten() {
      return this._value;
    }
    includes(value) {
      return Equatable.equals(this._value, value);
    }
    some(predicate) {
      return predicate(this._value, this._source);
    }
    none(predicate) {
      return !predicate(this._value, this._source);
    }
    equals(value) {
      return value instanceof _Value && Equatable.equals(value._value, this._value) && value._source.equals(this._source);
    }
    *[Symbol.iterator]() {
      yield this._value;
    }
    toJSON() {
      return {
        value: Serializable.toJSON(this._value),
        source: this._source.map((source) => source.toJSON()).getOr(null)
      };
    }
    toString() {
      return `${this._value}`;
    }
  };

  // node_modules/@siteimprove/alfa-style/dist/longhand.js
  var { left: left12, either: either47, end: end5 } = Parser;
  var Longhand = class _Longhand {
    static of(initial, parse57, compute2, options = {}) {
      const { inherits = false, use = Option.of } = options;
      return new _Longhand(initial, parse57, compute2, inherits, use);
    }
    static extend(property16, overrides = {}) {
      const { initial = property16._initial, parse: parse57 = property16._parseBase, compute: compute2 = property16._compute, inherits = property16._inherits, use = property16._use } = overrides;
      return new _Longhand(initial, parse57, compute2, inherits, use);
    }
    _initial;
    _parseBase;
    _parse;
    _compute;
    _inherits;
    _use;
    constructor(initial, parseBase, compute2, inherits, use) {
      this._initial = initial;
      this._parseBase = parseBase;
      this._parse = left12(either47(_Longhand.parseDefaults, parseBase), end5(() => "Expected end of input"));
      this._compute = compute2;
      this._inherits = inherits;
      this._use = use;
    }
    get initial() {
      return this._initial;
    }
    get parse() {
      return this._parse;
    }
    /**
     * Return the base parser of the property, which does not parse the global
     * default values. This is often useful when building parsers for shorthands.
     *
     * @internal
     */
    get parseBase() {
      return this._parseBase;
    }
    get compute() {
      return this._compute;
    }
    get inherits() {
      return this._inherits;
    }
    get use() {
      return this._use;
    }
  };
  (function(Longhand2) {
    Longhand2.parseDefaults = Keyword.parse("initial", "inherit", "revert", "unset");
    function fromKeywords(options, initial, ...other) {
      return Longhand2.of(Keyword.of(initial), Keyword.parse(initial, ...other), (value) => value, options);
    }
    Longhand2.fromKeywords = fromKeywords;
  })(Longhand || (Longhand = {}));

  // node_modules/@siteimprove/alfa-style/dist/property/background-attachment.js
  var parse = Keyword.parse("fixed", "local", "scroll");
  var parseList = List2.parseCommaSeparated(parse);
  var initialItem = Keyword.of("scroll");
  var background_attachment_default = Longhand.of(List2.of([initialItem], ", "), parseList, (value) => value);

  // node_modules/@siteimprove/alfa-style/dist/property/background-clip.js
  var parse2 = Box.parse;
  var initialItem2 = Keyword.of("border-box");
  var background_clip_default = Longhand.of(List2.of([initialItem2], ", "), List2.parseCommaSeparated(parse2), (value) => value);

  // node_modules/@siteimprove/alfa-style/dist/property/background-color.js
  var parse3 = Color.parse;
  var background_color_default = Longhand.of(Color.rgb(Percentage2.of(0), Percentage2.of(0), Percentage2.of(0), Percentage2.of(0)), parse3, (value, style) => value.resolve(Resolver2.length(style)));

  // node_modules/@siteimprove/alfa-style/dist/property/background-image.js
  var { either: either48 } = Parser;
  var parse4 = either48(Keyword.parse("none"), Image.parse);
  var parseList2 = List2.parseCommaSeparated(parse4);
  var initialItem3 = Keyword.of("none");
  var background_image_default = Longhand.of(List2.of([initialItem3], ", "), parseList2, (value, style) => value.map((images) => images.map((image) => Selective.of(image).if(Image.isImage, (image2) => image2.partiallyResolve(Resolver2.length(style))).get())));

  // node_modules/@siteimprove/alfa-style/dist/property/background-origin.js
  var parse5 = Box.parse;
  var initialItem4 = Keyword.of("padding-box");
  var background_origin_default = Longhand.of(List2.of([initialItem4], ", "), List2.parseCommaSeparated(parse5), (value) => value);

  // node_modules/@siteimprove/alfa-style/dist/property/background-position-x.js
  var parse6 = List2.parseCommaSeparated(Position2.Component.parseHorizontal);
  var initialItem5 = Position2.Side.of(Keyword.of("left"), Percentage2.of(0));
  var background_position_x_default = Longhand.of(List2.of([initialItem5]), parse6, (value, style) => value.map((positions) => positions.map(Position2.Component.partiallyResolve(Resolver2.length(style)))));

  // node_modules/@siteimprove/alfa-style/dist/property/background-position-y.js
  var parse7 = List2.parseCommaSeparated(Position2.Component.parseVertical);
  var initialItem6 = Position2.Side.of(Keyword.of("top"), Percentage2.of(0));
  var background_position_y_default = Longhand.of(List2.of([initialItem6]), parse7, (value, style) => value.map((positions) => positions.map(Position2.Component.partiallyResolve(Resolver2.length(style)))));

  // node_modules/@siteimprove/alfa-style/dist/property/background-repeat-x.js
  var parse8 = Keyword.parse("repeat", "space", "round", "no-repeat");
  var parseList3 = List2.parseCommaSeparated(parse8);
  var initialItem7 = Keyword.of("repeat");
  var background_repeat_x_default = Longhand.of(List2.of([initialItem7]), parseList3, (value) => value);

  // node_modules/@siteimprove/alfa-style/dist/property/background-repeat-y.js
  var background_repeat_y_default = Longhand.extend(background_repeat_x_default);

  // node_modules/@siteimprove/alfa-style/dist/property/background-size.js
  var { map: map64, either: either49, option: option31, pair: pair23, right: right23 } = Parser;
  var parseDimension = either49(LengthPercentage.parse, Keyword.parse("auto"));
  var parse9 = either49(map64(pair23(parseDimension, map64(option31(right23(Token.parseWhitespace, parseDimension)), (y) => y.getOrElse(() => Keyword.of("auto")))), ([x, y]) => Tuple2.of(x, y)), Keyword.parse("contain", "cover"));
  var parseList4 = List2.parseCommaSeparated(parse9);
  var initialItem8 = Tuple2.of(Keyword.of("auto"), Keyword.of("auto"));
  var background_size_default = Longhand.of(List2.of([initialItem8], ", "), parseList4, (value, style) => value.map((sizes) => sizes.map((size) => {
    if (Keyword.isKeyword(size)) {
      return size;
    }
    const [x, y] = size.values;
    const resolver = Resolver2.length(style);
    return Tuple2.of(Keyword.isKeyword(x) ? x : LengthPercentage.partiallyResolve(resolver)(x), Keyword.isKeyword(y) ? y : LengthPercentage.partiallyResolve(resolver)(y));
  })));

  // node_modules/@siteimprove/alfa-style/dist/property/border-top-color.js
  var parse10 = Color.parse;
  var border_top_color_default = Longhand.of(Color.current, parse10, (value, style) => value.resolve(Resolver2.length(style)));

  // node_modules/@siteimprove/alfa-style/dist/property/border-block-end-color.js
  var border_block_end_color_default = Longhand.extend(border_top_color_default);

  // node_modules/@siteimprove/alfa-style/dist/property/border-top-style.js
  var border_top_style_default = Longhand.fromKeywords({ inherits: false }, "none", "hidden", "dotted", "dashed", "solid", "double", "groove", "ridge", "inset", "outset");

  // node_modules/@siteimprove/alfa-style/dist/property/border-block-end-style.js
  var border_block_end_style_default = Longhand.extend(border_top_style_default);

  // node_modules/@siteimprove/alfa-style/dist/property/border-top-width.js
  var { either: either50 } = Parser;
  var parse11 = either50(Keyword.parse("thin", "medium", "thick"), Length2.parse);
  var border_top_width_default = Longhand.of(Length2.of(3, "px"), parse11, (borderWidth, style) => {
    const borderStyle = style.computed("border-top-style");
    return compute(borderStyle, borderWidth, style);
  });
  function compute(styleProperty, specified, style) {
    return specified.map((value) => {
      if (styleProperty.some(({ value: value2 }) => value2 === "none" || value2 === "hidden")) {
        return Length2.of(0, "px");
      }
      if (Length2.isLength(value)) {
        return value.resolve(Resolver2.length(style));
      }
      switch (value.value) {
        case "thin":
          return Length2.of(1, "px");
        case "medium":
          return Length2.of(3, "px");
        case "thick":
          return Length2.of(5, "px");
      }
    });
  }

  // node_modules/@siteimprove/alfa-style/dist/property/border-block-end-width.js
  var border_block_end_width_default = Longhand.extend(border_top_width_default, {
    compute: (borderWidth, style) => {
      const borderStyle = style.computed("border-block-end-style");
      return compute(borderStyle, borderWidth, style);
    }
  });

  // node_modules/@siteimprove/alfa-style/dist/property/border-block-start-color.js
  var border_block_start_color_default = Longhand.extend(border_top_color_default);

  // node_modules/@siteimprove/alfa-style/dist/property/border-block-start-style.js
  var border_block_start_style_default = Longhand.extend(border_top_style_default);

  // node_modules/@siteimprove/alfa-style/dist/property/border-block-start-width.js
  var border_block_start_width_default = Longhand.extend(border_top_width_default, {
    compute: (borderWidth, style) => {
      const borderStyle = style.computed("border-block-start-style");
      return compute(borderStyle, borderWidth, style);
    }
  });

  // node_modules/@siteimprove/alfa-style/dist/property/border-bottom-color.js
  var border_bottom_color_default = Longhand.extend(border_top_color_default);

  // node_modules/@siteimprove/alfa-style/dist/property/border-top-left-radius.js
  var { takeBetween, map: map65, delimited: delimited22, option: option32 } = Parser;
  var parse12 = map65(takeBetween(delimited22(option32(Token.parseWhitespace), LengthPercentage.parse), 1, 2), ([horizontal, vertical = horizontal]) => Tuple2.of(horizontal, vertical));
  var border_top_left_radius_default = Longhand.of(Tuple2.of(Length2.of(0, "px"), Length2.of(0, "px")), parse12, (value, style) => value.map(({ values: [h2, v] }) => Tuple2.of(LengthPercentage.partiallyResolve(Resolver2.length(style))(h2), LengthPercentage.partiallyResolve(Resolver2.length(style))(v))));

  // node_modules/@siteimprove/alfa-style/dist/property/border-bottom-left-radius.js
  var border_bottom_left_radius_default = Longhand.extend(border_top_left_radius_default);

  // node_modules/@siteimprove/alfa-style/dist/property/border-bottom-right-radius.js
  var border_bottom_right_radius_default = Longhand.extend(border_top_left_radius_default);

  // node_modules/@siteimprove/alfa-style/dist/property/border-bottom-style.js
  var border_bottom_style_default = Longhand.extend(border_top_style_default);

  // node_modules/@siteimprove/alfa-style/dist/property/border-bottom-width.js
  var border_bottom_width_default = Longhand.extend(border_top_width_default, {
    compute: (borderWidth, style) => {
      const borderStyle = style.computed("border-bottom-style");
      return compute(borderStyle, borderWidth, style);
    }
  });

  // node_modules/@siteimprove/alfa-style/dist/property/border-collapse.js
  var border_collapse_default = Longhand.fromKeywords({ inherits: true }, "separate", "collapse");

  // node_modules/@siteimprove/alfa-style/dist/property/border-end-end-radius.js
  var border_end_end_radius_default = Longhand.extend(border_top_left_radius_default);

  // node_modules/@siteimprove/alfa-style/dist/property/border-end-start-radius.js
  var border_end_start_radius_default = Longhand.extend(border_top_left_radius_default);

  // node_modules/@siteimprove/alfa-style/dist/property/border-image-outset.js
  var { takeBetween: takeBetween2, either: either51, map: map66, filter: filter6, delimited: delimited23, option: option33 } = Parser;
  var parse13 = map66(takeBetween2(delimited23(option33(Token.parseWhitespace), filter6(either51(Length2.parse, Number3.parse), (size) => size.hasCalculation() || size.value >= 0, () => `Negative sizes are not allowed`)), 1, 4), ([top, right38 = top, bottom = top, left22 = right38]) => Tuple2.of(top, right38, bottom, left22));
  var border_image_outset_default = Longhand.of(Tuple2.of(Number3.of(0), Number3.of(0), Number3.of(0), Number3.of(0)), parse13, (value, style) => value.resolve(Resolver2.length(style)));

  // node_modules/@siteimprove/alfa-style/dist/property/border-image-repeat.js
  var { delimited: delimited24, map: map67, option: option34, takeBetween: takeBetween3 } = Parser;
  var parse14 = map67(takeBetween3(delimited24(option34(Token.parseWhitespace), Keyword.parse("stretch", "repeat", "round", "space")), 1, 2), ([vertical, horizontal = vertical]) => Tuple2.of(vertical, horizontal));
  var border_image_repeat_default = Longhand.of(Tuple2.of(Keyword.of("stretch"), Keyword.of("stretch")), parse14, (value) => value);

  // node_modules/@siteimprove/alfa-style/dist/property/border-image-slice.js
  var { either: either52, filter: filter7 } = Parser;
  var parseItem = filter7(either52(Number3.parse, Percentage2.parse), (size) => size.hasCalculation() || size.value >= 0, () => `Negative sizes are not allowed`);
  var parseFill = Keyword.parse("fill");
  var parse15 = (input) => {
    let top;
    let right38;
    let bottom;
    let left22;
    let fill;
    while (true) {
      for ([input] of Token.parseWhitespace(input)) {
      }
      const result = parseItem(input);
      if (result.isOk()) {
        if (top === void 0) {
          [input, top] = result.get();
          continue;
        }
        if (right38 === void 0) {
          [input, right38] = result.get();
          continue;
        }
        if (bottom === void 0) {
          [input, bottom] = result.get();
          continue;
        }
        if (left22 === void 0) {
          [input, left22] = result.get();
          continue;
        }
      } else if (fill === void 0) {
        const result2 = parseFill(input);
        if (result2.isOk()) {
          [input, fill] = result2.get();
          continue;
        }
      }
      break;
    }
    if (top === void 0) {
      return Err.of(`Expected an image slice`);
    }
    right38 = right38 ?? top;
    bottom = bottom ?? top;
    left22 = left22 ?? right38;
    return Result.of([
      input,
      fill ? Tuple2.of(top, right38, bottom, left22, fill) : Tuple2.of(top, right38, bottom, left22)
    ]);
  };
  var border_image_slice_default = Longhand.of(Tuple2.of(Percentage2.of(1), Percentage2.of(1), Percentage2.of(1), Percentage2.of(1)), parse15, (value, style) => value.resolve(Resolver2.length(style)));

  // node_modules/@siteimprove/alfa-style/dist/property/border-image-source.js
  var { either: either53 } = Parser;
  var parse16 = either53(Keyword.parse("none"), Image.parse);
  var border_image_source_default = Longhand.of(Keyword.of("none"), parse16, (value, style) => value.map((image) => Selective.of(image).if(Image.isImage, (image2) => image2.partiallyResolve(Resolver2.length(style))).get()));

  // node_modules/@siteimprove/alfa-style/dist/property/border-image-width.js
  var { takeBetween: takeBetween4, either: either54, map: map68, filter: filter8, delimited: delimited25, option: option35 } = Parser;
  var parse17 = map68(takeBetween4(delimited25(option35(Token.parseWhitespace), either54(filter8(either54(LengthPercentage.parse, Number3.parse), (size) => size.hasCalculation() || size.value >= 0, () => `Negative sizes are not allowed`), Keyword.parse("auto"))), 1, 4), ([top, right38 = top, bottom = top, left22 = right38]) => Tuple2.of(top, right38, bottom, left22));
  var border_image_width_default = Longhand.of(Tuple2.of(Number3.of(1), Number3.of(1), Number3.of(1), Number3.of(1)), parse17, (value, style) => value.map(({ values: [t, r, b, l] }) => {
    const resolver = resolve2(style);
    return Tuple2.of(resolver(t), resolver(r), resolver(b), resolver(l));
  }));
  function resolve2(style) {
    return (specified) => Selective.of(specified).if(LengthPercentage.isLengthPercentage, LengthPercentage.partiallyResolve(Resolver2.length(style))).if(Number3.isNumber, (num) => num.resolve()).get();
  }

  // node_modules/@siteimprove/alfa-style/dist/property/border-inline-end-color.js
  var border_inline_end_color_default = Longhand.extend(border_top_color_default);

  // node_modules/@siteimprove/alfa-style/dist/property/border-inline-end-style.js
  var border_inline_end_style_default = Longhand.extend(border_top_style_default);

  // node_modules/@siteimprove/alfa-style/dist/property/border-inline-end-width.js
  var border_inline_end_width_default = Longhand.extend(border_top_width_default, {
    compute: (borderWidth, style) => {
      const borderStyle = style.computed("border-inline-end-style");
      return compute(borderStyle, borderWidth, style);
    }
  });

  // node_modules/@siteimprove/alfa-style/dist/property/border-inline-start-color.js
  var border_inline_start_color_default = Longhand.extend(border_top_color_default);

  // node_modules/@siteimprove/alfa-style/dist/property/border-inline-start-style.js
  var border_inline_start_style_default = Longhand.extend(border_top_style_default);

  // node_modules/@siteimprove/alfa-style/dist/property/border-inline-start-width.js
  var border_inline_start_width_default = Longhand.extend(border_top_width_default, {
    compute: (borderWidth, style) => {
      const borderStyle = style.computed("border-inline-start-style");
      return compute(borderStyle, borderWidth, style);
    }
  });

  // node_modules/@siteimprove/alfa-style/dist/property/border-left-color.js
  var border_left_color_default = Longhand.extend(border_top_color_default);

  // node_modules/@siteimprove/alfa-style/dist/property/border-left-style.js
  var border_left_style_default = Longhand.extend(border_top_style_default);

  // node_modules/@siteimprove/alfa-style/dist/property/border-left-width.js
  var border_left_width_default = Longhand.extend(border_top_width_default, {
    compute: (borderWidth, style) => {
      const borderStyle = style.computed("border-left-style");
      return compute(borderStyle, borderWidth, style);
    }
  });

  // node_modules/@siteimprove/alfa-style/dist/property/border-right-color.js
  var border_right_color_default = Longhand.extend(border_top_color_default);

  // node_modules/@siteimprove/alfa-style/dist/property/border-right-style.js
  var border_right_style_default = Longhand.extend(border_top_style_default);

  // node_modules/@siteimprove/alfa-style/dist/property/border-right-width.js
  var border_right_width_default = Longhand.extend(border_top_width_default, {
    compute: (borderWidth, style) => {
      const borderStyle = style.computed("border-block-end-style");
      return compute(borderStyle, borderWidth, style);
    }
  });

  // node_modules/@siteimprove/alfa-style/dist/property/border-start-end-radius.js
  var border_start_end_radius_default = Longhand.extend(border_top_left_radius_default);

  // node_modules/@siteimprove/alfa-style/dist/property/border-start-start-radius.js
  var border_start_start_radius_default = Longhand.extend(border_top_left_radius_default);

  // node_modules/@siteimprove/alfa-style/dist/property/border-top-right-radius.js
  var border_top_right_radius_default = Longhand.extend(border_top_left_radius_default);

  // node_modules/@siteimprove/alfa-style/dist/property/top.js
  var { either: either55 } = Parser;
  var parse18 = either55(Keyword.parse("auto"), LengthPercentage.parse);
  var top_default = Longhand.of(Keyword.of("auto"), parse18, (top, style) => top.map((top2) => Selective.of(top2).if(LengthPercentage.isLengthPercentage, LengthPercentage.partiallyResolve(Resolver2.length(style))).get()));

  // node_modules/@siteimprove/alfa-style/dist/property/bottom.js
  var bottom_default = Longhand.extend(top_default);

  // node_modules/@siteimprove/alfa-style/dist/property/box-shadow.js
  var { either: either56 } = Parser;
  var parseList5 = List2.parseCommaSeparated(Shadow.parse());
  var box_shadow_default = Longhand.of(Keyword.of("none"), either56(Keyword.parse("none"), parseList5), (value, style) => value.resolve(Resolver2.length(style)));

  // node_modules/@siteimprove/alfa-style/dist/property/clip.js
  var { either: either57, map: map69 } = Parser;
  var parse19 = either57(Keyword.parse("auto"), map69(Rectangle.parse, (rectangle) => Shape2.of(rectangle, Keyword.of("border-box"))));
  var clip_default = Longhand.of(Keyword.of("auto"), parse19, (value, style) => {
    const position = style.computed("position").value;
    return position.equals(Keyword.of("absolute")) || position.equals(Keyword.of("fixed")) ? value : Value4.of(Keyword.of("auto"));
  });

  // node_modules/@siteimprove/alfa-style/dist/property/clip-path.js
  var { either: either58 } = Parser;
  var parse20 = either58(URL2.parse, either58(Shape2.parse, Keyword.parse("none")));
  var clip_path_default = Longhand.of(Keyword.of("none"), parse20, (value) => value);

  // node_modules/@siteimprove/alfa-style/dist/property/color.js
  var color_default = Longhand.of(Color.system("canvastext"), Color.parse, (value, style) => value.resolve(Resolver2.length(style)), {
    inherits: true
  });

  // node_modules/@siteimprove/alfa-style/dist/property/contain.js
  var contain_default = Longhand.of(Keyword.of("none"), Contain.parse, (value) => value, { inherits: false });

  // node_modules/@siteimprove/alfa-style/dist/property/container-type.js
  var container_type_default = Longhand.fromKeywords({ inherits: false }, "normal", "size", "inline-size");

  // node_modules/@siteimprove/alfa-style/dist/property/cursor.js
  var { left: left13, map: map70, option: option36, pair: pair24, right: right24, separated: separated4, zeroOrMore: zeroOrMore5 } = Parser;
  var { parseComma: parseComma2, parseWhitespace: parseWhitespace3 } = Token;
  var parseBuiltin = Keyword.parse("auto", "default", "none", "context-menu", "help", "pointer", "progress", "wait", "cell", "crosshair", "text", "vertical-text", "alias", "copy", "move", "no-drop", "not-allowed", "grab", "grabbing", "e-resize", "n-resize", "ne-resize", "nw-resize", "s-resize", "se-resize", "sw-resize", "w-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "col-resize", "row-resize", "all-scroll", "zoom-in", "zoom-out");
  var parseCustom = map70(pair24(URL2.parse, option36(right24(parseWhitespace3, separated4(Number3.parse, parseWhitespace3)))), ([url, coordinates]) => coordinates.isSome() ? Tuple2.of(url, ...coordinates.get()) : url);
  var parseCustomList = map70(zeroOrMore5(left13(parseCustom, pair24(parseComma2, option36(parseWhitespace3)))), (list) => List2.of(list, ","));
  var parse21 = map70(separated4(parseCustomList, option36(parseWhitespace3), parseBuiltin), ([custom, fallback]) => Tuple2.of(custom, fallback));
  var cursor_default = Longhand.of(Tuple2.of(List2.of([], ","), Keyword.of("auto")), parse21, (value, style) => value.resolve(Resolver2.length(style)), { inherits: true });

  // node_modules/@siteimprove/alfa-style/dist/property/display.js
  var { map: map71, either: either59 } = Parser;
  var parseOutside = Keyword.parse("block", "inline", "run-in");
  var parseInside = Keyword.parse("flow", "flow-root", "table", "flex", "grid", "ruby");
  var parseListItem = Keyword.parse("list-item");
  var parseInternal = Keyword.parse("table-row-group", "table-header-group", "table-footer-group", "table-row", "table-cell", "table-column-group", "table-column", "table-caption", "ruby-base", "ruby-text", "ruby-base-container", "ruby-text-container");
  var parseBox = Keyword.parse("contents", "none");
  var parseLegacy = Keyword.parse("inline-block", "inline-table", "inline-flex", "inline-grid");
  var parse22 = either59((input) => {
    let outside;
    let inside;
    let listItem;
    while (true) {
      for ([input] of Token.parseWhitespace(input)) {
      }
      if (outside === void 0) {
        const result = parseOutside(input);
        if (result.isOk()) {
          [input, outside] = result.get();
          continue;
        }
      }
      if (inside === void 0) {
        const result = parseInside(input);
        if (result.isOk()) {
          [input, inside] = result.get();
          continue;
        }
      }
      if (listItem === void 0) {
        const result = parseListItem(input);
        if (result.isOk()) {
          [input, listItem] = result.get();
          continue;
        }
      }
      break;
    }
    if (outside === void 0 && inside === void 0 && listItem === void 0) {
      return Err.of(`Expected an outer or inner display type or a list marker`);
    }
    if (inside === void 0) {
      inside = Keyword.of("flow");
    }
    if (outside === void 0) {
      outside = inside.value === "ruby" ? Keyword.of("inline") : Keyword.of("block");
    }
    if (listItem === void 0) {
      return Result.of([input, Tuple2.of(outside, inside)]);
    }
    switch (inside.value) {
      case "flow":
      case "flow-root":
        break;
      default:
        return Err.of(`Unexpected inner display type for list marker`);
    }
    return Result.of([input, Tuple2.of(outside, inside, listItem)]);
  }, map71(parseInternal, (keyword) => {
    switch (keyword.value) {
      case "table-row-group":
      case "table-header-group":
      case "table-footer-group":
      case "table-row":
      case "table-cell":
      case "table-column-group":
      case "table-column":
      case "table-caption":
        return Tuple2.of(keyword, Keyword.of("flow-root"));
      case "ruby-base":
      case "ruby-text":
      case "ruby-base-container":
      case "ruby-text-container":
        return Tuple2.of(keyword, Keyword.of("flow"));
    }
  }), map71(parseBox, (keyword) => Tuple2.of(keyword)), map71(parseLegacy, (keyword) => {
    const inline = Keyword.of("inline");
    switch (keyword.value) {
      case "inline-block":
        return Tuple2.of(inline, Keyword.of("flow-root"));
      case "inline-table":
        return Tuple2.of(inline, Keyword.of("table"));
      case "inline-flex":
        return Tuple2.of(inline, Keyword.of("flex"));
      case "inline-grid":
        return Tuple2.of(inline, Keyword.of("grid"));
    }
  }));
  var display_default = Longhand.of(Tuple2.of(Keyword.of("inline"), Keyword.of("flow")), parse22, (value, style) => {
    const position = style.computed("position").value;
    const float = style.computed("float").value;
    return position.equals(Keyword.of("absolute")) || position.equals(Keyword.of("fixed")) || !float.equals(Keyword.of("none")) ? (
      // 4th condition of https://drafts.csswg.org/css2/#dis-pos-flo needs
      // to know whether the element is the root element, which is not
      // currently doable at that level.
      value.map(displayTable)
    ) : style.owner.some(Element.hasName("button")) ? value.map(buttonLayout) : value;
  });
  function displayTable(value) {
    if (value.values.length === 1) {
      return value;
    }
    const [outside, inside] = value.values;
    switch (outside.value) {
      case "inline":
        switch (inside.value) {
          case "table":
            return Tuple2.of(Keyword.of("block"), Keyword.of("table"));
          case "flow":
          // => inline-flow
          case "flow-root":
            return Tuple2.of(Keyword.of("block"), Keyword.of("flow"));
          default:
            return value;
        }
      case "table-row-group":
      case "table-header-group":
      case "table-footer-group":
      case "table-row":
      case "table-cell":
      case "table-column-group":
      case "table-column":
      case "table-caption":
        return Tuple2.of(Keyword.of("block"), Keyword.of("flow"));
      default:
        return value;
    }
  }
  function buttonLayout(value) {
    const [outside, inside] = value.values;
    if (inside?.is("flex", "grid")) {
      return value;
    }
    if (outside.is("contents", "none")) {
      return value;
    }
    if (outside.is("inline")) {
      return Tuple2.of(Keyword.of("inline"), Keyword.of("flow-root"));
    }
    return Tuple2.of(Keyword.of("block"), Keyword.of("flow-root"));
  }

  // node_modules/@siteimprove/alfa-style/dist/property/flex-direction.js
  var flex_direction_default = Longhand.fromKeywords({ inherits: false }, "row", "row-reverse", "column", "column-reverse");

  // node_modules/@siteimprove/alfa-style/dist/predicate/is-block-container.js
  function isBlockContainer(style) {
    const [outside, inside] = style.computed("display").value.values;
    return (
      // block
      outside.is("block") || // inline-block
      outside.is("inline") && (inside?.is("flow-root") ?? false)
    );
  }

  // node_modules/@siteimprove/alfa-style/dist/predicate/is-flex-container.js
  function isFlexContainer(style) {
    const [_, inside] = style.computed("display").value.values;
    return inside?.value === "flex";
  }

  // node_modules/@siteimprove/alfa-style/dist/predicate/is-grid-container.js
  function isGridContainer(style) {
    const [_, inside] = style.computed("display").value.values;
    return inside?.value === "grid";
  }

  // node_modules/@siteimprove/alfa-style/dist/property/flex-wrap.js
  var flex_wrap_default = Longhand.fromKeywords({
    inherits: false,
    use: (value, style) => Option.conditional(value, () => isFlexContainer(style))
  }, "nowrap", "wrap", "wrap-reverse");

  // node_modules/@siteimprove/alfa-style/dist/property/float.js
  var base = Longhand.fromKeywords({ inherits: false }, "none", "left", "right");
  var float_default = Longhand.extend(base, {
    compute: (value, style) => {
      const position = style.computed("position").value;
      return position.equals(Keyword.of("absolute")) || position.equals(Keyword.of("fixed")) ? Value4.of(Keyword.of("none")) : value;
    }
  });

  // node_modules/@siteimprove/alfa-style/dist/property/font-family.js
  var { either: either60, map: map72, separatedList: separatedList10 } = Parser;
  var parse23 = List2.parseCommaSeparated(either60(Keyword.parse("serif", "sans-serif", "cursive", "fantasy", "monospace"), either60(String3.parse, map72(separatedList10(Token.parseIdent(), Token.parseWhitespace), (idents) => String3.of(idents.map((ident) => ident.value).join(" "))))));
  var font_family_default = Longhand.of(List2.of([Keyword.of("serif")], ", "), parse23, (fontFamily) => fontFamily, {
    inherits: true
  });

  // node_modules/@siteimprove/alfa-style/dist/property/font-size.js
  var { either: either61 } = Parser;
  var parse24 = either61(Keyword.parse("xx-small", "x-small", "small", "medium", "large", "x-large", "xx-large", "xxx-large"), Keyword.parse("larger", "smaller"), LengthPercentage.parse);
  var bases = {
    serif: 16,
    "sans-serif": 16,
    monospace: 13,
    cursive: 16,
    fantasy: 16
  };
  var factors = {
    "xx-small": 3 / 5,
    "x-small": 3 / 4,
    small: 8 / 9,
    medium: 1,
    large: 6 / 5,
    "x-large": 3 / 2,
    "xx-large": 2 / 1,
    "xxx-large": 3 / 1
  };
  var property2 = Longhand.of(Length2.of(16, "px"), parse24, (fontSize, style) => fontSize.map((fontSize2) => {
    const parent = style.parent.computed("font-size").value;
    if (LengthPercentage.isLengthPercentage(fontSize2)) {
      return LengthPercentage.resolve(Resolver2.lengthPercentage(parent, style.parent))(fontSize2);
    }
    switch (fontSize2.value) {
      case "larger":
        return parent.scale(1.2);
      case "smaller":
        return parent.scale(0.85);
      default: {
        const factor = factors[fontSize2.value];
        const [family] = style.computed("font-family").value.values;
        const base3 = family.type === "keyword" ? bases[family.value] : bases.serif;
        return Length2.of(factor * base3, "px");
      }
    }
  }), {
    inherits: true
  });
  var font_size_default = property2;

  // node_modules/@siteimprove/alfa-style/dist/property/font-stretch.js
  var { either: either62 } = Parser;
  var parseAbsolute = Keyword.parse("ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded");
  var parse25 = either62(Percentage2.parse, parseAbsolute);
  var font_stretch_default = Longhand.of(Percentage2.of(1), parse25, (fontStretch) => fontStretch.map((fontStretch2) => {
    if (fontStretch2.type === "percentage") {
      return fontStretch2;
    }
    switch (fontStretch2.value) {
      case "ultra-condensed":
        return Percentage2.of(0.5);
      case "extra-condensed":
        return Percentage2.of(0.625);
      case "condensed":
        return Percentage2.of(0.75);
      case "semi-condensed":
        return Percentage2.of(0.875);
      case "normal":
        return Percentage2.of(1);
      case "semi-expanded":
        return Percentage2.of(1.125);
      case "expanded":
        return Percentage2.of(1.25);
      case "extra-expanded":
        return Percentage2.of(1.5);
      case "ultra-expanded":
        return Percentage2.of(2);
    }
  }), {
    inherits: true
  });

  // node_modules/@siteimprove/alfa-style/dist/property/font-style.js
  var font_style_default = Longhand.fromKeywords({ inherits: true }, "normal", "italic", "oblique");

  // node_modules/@siteimprove/alfa-style/dist/property/font-variant-caps.js
  var font_variant_caps_default = Longhand.fromKeywords({ inherits: true }, "normal", "small-caps", "all-small-caps", "petite-caps", "all-petite-caps", "unicase", "titling-caps");

  // node_modules/@siteimprove/alfa-style/dist/property/font-variant-east-asian.js
  var { either: either63 } = Parser;
  var parseVariant = Keyword.parse("jis78", "jis83", "jis90", "jis04", "simplified", "traditional");
  var parseWidth = Keyword.parse("proportional-width", "full-width");
  var parseEastAsian = (input) => {
    let variant;
    let width;
    let ruby;
    while (true) {
      for (const [remainder] of Token.parseWhitespace(input)) {
        input = remainder;
      }
      if (variant === void 0) {
        const result = parseVariant(input);
        if (result.isOk()) {
          [input, variant] = result.get();
          continue;
        }
      }
      if (width === void 0) {
        const result = parseWidth(input);
        if (result.isOk()) {
          [input, width] = result.get();
          continue;
        }
      }
      if (ruby === void 0) {
        const result = Keyword.parse("ruby")(input);
        if (result.isOk()) {
          [input, ruby] = result.get();
          continue;
        }
      }
      break;
    }
    if (variant === void 0 && width === void 0 && ruby === void 0) {
      return Err.of("At least one East Asian variant value must be provided");
    }
    return Result.of([
      input,
      List2.of([variant, width, ruby].filter((value) => value !== void 0), " ")
    ]);
  };
  var parse26 = either63(Keyword.parse("normal"), parseEastAsian);
  var font_variant_east_asian_default = Longhand.of(Keyword.of("normal"), parse26, (numeric) => numeric, { inherits: true });

  // node_modules/@siteimprove/alfa-style/dist/property/font-variant-ligatures.js
  var { either: either64 } = Parser;
  var parseCommon = Keyword.parse("common-ligatures", "no-common-ligatures");
  var parseDiscretionary = Keyword.parse("discretionary-ligatures", "no-discretionary-ligatures");
  var parseHistorical = Keyword.parse("historical-ligatures", "no-historical-ligatures");
  var parseContextual = Keyword.parse("contextual", "no-contextual");
  var parseLigature = (input) => {
    let common;
    let discretionary;
    let historical;
    let contextual;
    while (true) {
      for (const [remainder] of Token.parseWhitespace(input)) {
        input = remainder;
      }
      if (common === void 0) {
        const result = parseCommon(input);
        if (result.isOk()) {
          [input, common] = result.get();
          continue;
        }
      }
      if (discretionary === void 0) {
        const result = parseDiscretionary(input);
        if (result.isOk()) {
          [input, discretionary] = result.get();
          continue;
        }
      }
      if (historical === void 0) {
        const result = parseHistorical(input);
        if (result.isOk()) {
          [input, historical] = result.get();
          continue;
        }
      }
      if (contextual === void 0) {
        const result = parseContextual(input);
        if (result.isOk()) {
          [input, contextual] = result.get();
          continue;
        }
      }
      break;
    }
    if (common === void 0 && discretionary === void 0 && historical === void 0 && contextual === void 0) {
      return Err.of("At least one ligature value must be provided");
    }
    return Result.of([
      input,
      List2.of([common, discretionary, historical, contextual].filter((value) => value !== void 0), " ")
    ]);
  };
  var parse27 = either64(Keyword.parse("none", "normal"), parseLigature);
  var font_variant_ligatures_default = Longhand.of(Keyword.of("normal"), parse27, (ligatures) => ligatures, { inherits: true });

  // node_modules/@siteimprove/alfa-style/dist/property/font-variant-numeric.js
  var { either: either65 } = Parser;
  var parseFigure = Keyword.parse("lining-nums", "oldstyle-nums");
  var parseSpacing = Keyword.parse("proportional-nums", "tabular-nums");
  var parseFraction = Keyword.parse("diagonal-fractions", "stacked-fractions");
  var parseNumeric = (input) => {
    let figure;
    let spacing;
    let fraction;
    let ordinal;
    let slashed;
    while (true) {
      for (const [remainder] of Token.parseWhitespace(input)) {
        input = remainder;
      }
      if (figure === void 0) {
        const result = parseFigure(input);
        if (result.isOk()) {
          [input, figure] = result.get();
          continue;
        }
      }
      if (spacing === void 0) {
        const result = parseSpacing(input);
        if (result.isOk()) {
          [input, spacing] = result.get();
          continue;
        }
      }
      if (fraction === void 0) {
        const result = parseFraction(input);
        if (result.isOk()) {
          [input, fraction] = result.get();
          continue;
        }
      }
      if (ordinal === void 0) {
        const result = Keyword.parse("ordinal")(input);
        if (result.isOk()) {
          [input, ordinal] = result.get();
          continue;
        }
      }
      if (slashed === void 0) {
        const result = Keyword.parse("slashed-zero")(input);
        if (result.isOk()) {
          [input, slashed] = result.get();
          continue;
        }
      }
      break;
    }
    if (figure === void 0 && spacing === void 0 && fraction === void 0 && ordinal === void 0 && slashed === void 0) {
      return Err.of("At least one numeric value must be provided");
    }
    return Result.of([
      input,
      List2.of([figure, spacing, fraction, ordinal, slashed].filter((value) => value !== void 0), " ")
    ]);
  };
  var parse28 = either65(Keyword.parse("normal"), parseNumeric);
  var font_variant_numeric_default = Longhand.of(Keyword.of("normal"), parse28, (numeric) => numeric, { inherits: true });

  // node_modules/@siteimprove/alfa-style/dist/property/font-variant-position.js
  var font_variant_position_default = Longhand.fromKeywords({ inherits: true }, "normal", "sub", "super");

  // node_modules/@siteimprove/alfa-style/dist/property/font-weight.js
  var { either: either66 } = Parser;
  var parse29 = either66(Number3.parse, Keyword.parse("normal", "bold", "bolder", "lighter"));
  var font_weight_default = Longhand.of(Number3.of(400), parse29, (fontWeight, style) => fontWeight.map((fontWeight2) => {
    if (Number3.isNumber(fontWeight2)) {
      return fontWeight2.resolve(Resolver2.length(style));
    }
    switch (fontWeight2.value) {
      case "normal":
        return Number3.of(400);
      case "bold":
        return Number3.of(700);
      // https://drafts.csswg.org/css-fonts/#relative-weights
      default: {
        const bolder = fontWeight2.value === "bolder";
        const parent = style.parent.computed("font-weight").value;
        if (parent.value < 100) {
          return Number3.of(bolder ? 400 : parent.value);
        }
        if (parent.value < 350) {
          return Number3.of(bolder ? 400 : 100);
        }
        if (parent.value < 550) {
          return Number3.of(bolder ? 700 : 100);
        }
        if (parent.value < 750) {
          return Number3.of(bolder ? 900 : 400);
        }
        if (parent.value < 900) {
          return Number3.of(bolder ? 900 : 700);
        }
        return Number3.of(bolder ? parent.value : 700);
      }
    }
  }), {
    inherits: true
  });

  // node_modules/@siteimprove/alfa-style/dist/property/height.js
  var { either: either67 } = Parser;
  var parse30 = either67(Keyword.parse("auto"), LengthPercentage.parse);
  var height_default = Longhand.of(Keyword.of("auto"), parse30, (value, style) => value.map((height) => Selective.of(height).if(LengthPercentage.isLengthPercentage, LengthPercentage.partiallyResolve(Resolver2.length(style))).get()));

  // node_modules/@siteimprove/alfa-style/dist/property/inset-block-end.js
  var inset_block_end_default = Longhand.extend(top_default);

  // node_modules/@siteimprove/alfa-style/dist/property/inset-block-start.js
  var inset_block_start_default = Longhand.extend(top_default);

  // node_modules/@siteimprove/alfa-style/dist/property/inset-inline-end.js
  var inset_inline_end_default = Longhand.extend(top_default);

  // node_modules/@siteimprove/alfa-style/dist/property/inset-inline-start.js
  var inset_inline_start_default = Longhand.extend(top_default);

  // node_modules/@siteimprove/alfa-style/dist/property/isolation.js
  var isolation_default = Longhand.fromKeywords({ inherits: false }, "auto", "isolate");

  // node_modules/@siteimprove/alfa-style/dist/property/left.js
  var left_default = Longhand.extend(top_default);

  // node_modules/@siteimprove/alfa-style/dist/property/letter-spacing.js
  var { either: either68 } = Parser;
  var parse31 = either68(Keyword.parse("normal"), Length2.parse);
  var letter_spacing_default = Longhand.of(Length2.of(0, "px"), parse31, (value, style) => value.map((spacing) => Selective.of(spacing).if(Length2.isLength, (spacing2) => spacing2.resolve(Resolver2.length(style))).else(() => Length2.of(0, "px")).get()), {
    inherits: true
  });

  // node_modules/@siteimprove/alfa-style/dist/property/line-height.js
  var { either: either69 } = Parser;
  var parse32 = either69(Keyword.parse("normal"), Number3.parse, LengthPercentage.parse);
  var line_height_default = Longhand.of(Keyword.of("normal"), parse32, (value, style) => value.map((height) => {
    const fontSize = style.computed("font-size").value;
    return Selective.of(height).if(LengthPercentage.isLengthPercentage, LengthPercentage.resolve(Resolver2.lengthPercentage(fontSize, style))).if(Number3.isNumber, (value2) => value2.resolve()).get();
  }), {
    inherits: true
  });

  // node_modules/@siteimprove/alfa-style/dist/property/margin-top.js
  var { either: either70 } = Parser;
  var parse33 = either70(Keyword.parse("auto"), Length2.parse, Percentage2.parse);
  var margin_top_default = Longhand.of(Length2.of(0, "px"), parse33, (marginTop, style) => marginTop.map((top) => {
    switch (top.type) {
      case "keyword":
      case "percentage":
        return top;
      case "length":
        return top.resolve(Resolver2.length(style));
    }
  }));

  // node_modules/@siteimprove/alfa-style/dist/property/margin-bottom.js
  var margin_bottom_default = Longhand.extend(margin_top_default);

  // node_modules/@siteimprove/alfa-style/dist/property/margin-left.js
  var margin_left_default = Longhand.extend(margin_top_default);

  // node_modules/@siteimprove/alfa-style/dist/property/margin-right.js
  var margin_right_default = Longhand.extend(margin_top_default);

  // node_modules/@siteimprove/alfa-style/dist/property/min-height.js
  var { either: either71 } = Parser;
  var parse34 = either71(Keyword.parse("auto", "fit-content", "max-content", "min-content"), either71(Length2.parse, Percentage2.parse));
  var min_height_default = Longhand.of(Keyword.of("auto"), parse34, (value, style) => value.map((height) => {
    switch (height.type) {
      case "keyword":
      case "percentage":
        return height;
      case "length":
        return height.resolve(Resolver2.length(style));
    }
  }));

  // node_modules/@siteimprove/alfa-style/dist/property/min-width.js
  var min_width_default = Longhand.extend(min_height_default);

  // node_modules/@siteimprove/alfa-style/dist/property/mix-blend-mode.js
  var mix_blend_mode_default = Longhand.fromKeywords({ inherits: false }, "normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity", "plus-darker", "plus-lighter");

  // node_modules/@siteimprove/alfa-style/dist/property/opacity.js
  var { either: either72 } = Parser;
  var opacity_default = Longhand.of(Number3.of(1), either72(Number3.parse, Percentage2.parse), (value) => value.map((opacity) => Number3.of(Real.clamp(opacity.resolve().value, 0, 1))), { inherits: true });

  // node_modules/@siteimprove/alfa-style/dist/property/outline-color.js
  var outline_color_default = Longhand.of(Keyword.of("invert"), Color.parse, (value, style) => value.resolve(Resolver2.length(style)));

  // node_modules/@siteimprove/alfa-style/dist/property/outline-offset.js
  var outline_offset_default = Longhand.of(Length2.of(0, "px"), Length2.parse, (value, style) => value.resolve(Resolver2.length(style)));

  // node_modules/@siteimprove/alfa-style/dist/property/outline-style.js
  var outline_style_default = Longhand.fromKeywords({ inherits: false }, "none", "auto", "dotted", "dashed", "solid", "double", "groove", "ridge", "inset", "outset");

  // node_modules/@siteimprove/alfa-style/dist/property/outline-width.js
  var { either: either73 } = Parser;
  var parse35 = either73(Keyword.parse("thin", "medium", "thick"), Length2.parse);
  var outline_width_default = Longhand.of(Length2.of(3, "px"), parse35, (value, style) => {
    if (style.computed("outline-style").some(({ value: value2 }) => value2 === "none")) {
      return Value4.of(Length2.of(0, "px"));
    }
    return value.map((width) => {
      if (Length2.isLength(width)) {
        return width.resolve(Resolver2.length(style));
      }
      switch (width.value) {
        case "thin":
          return Length2.of(1, "px");
        case "medium":
          return Length2.of(3, "px");
        case "thick":
          return Length2.of(5, "px");
      }
    });
  });

  // node_modules/@siteimprove/alfa-style/dist/property/overflow-x.js
  var { or: or4 } = Predicate;
  var base2 = Longhand.fromKeywords({ inherits: false }, "visible", "hidden", "clip", "scroll", "auto");
  var isContainer = or4(isBlockContainer, isFlexContainer, isGridContainer);
  var overflow_x_default = Longhand.extend(base2, {
    compute: (overflowX, style) => overflowX.map((x) => {
      if (x.value !== "visible" && x.value !== "clip") {
        return x;
      }
      const y = style.specified("overflow-y").value;
      if (y.value === "visible" || y.value === "clip") {
        return x;
      }
      return x.value === "visible" ? Keyword.of("auto") : Keyword.of("hidden");
    }),
    use: (value, style) => Option.conditional(value, () => isContainer(style))
  });

  // node_modules/@siteimprove/alfa-style/dist/property/overflow-y.js
  var { or: or5 } = Predicate;
  var isContainer2 = or5(isBlockContainer, isFlexContainer, isGridContainer);
  var overflow_y_default = Longhand.extend(overflow_x_default, {
    compute: (overflowY, style) => overflowY.map((y) => {
      if (y.value !== "visible" && y.value !== "clip") {
        return y;
      }
      const x = style.specified("overflow-x").value;
      if (x.value === "visible" || x.value === "clip") {
        return y;
      }
      return y.value === "visible" ? Keyword.of("auto") : Keyword.of("hidden");
    }),
    use: (value, style) => isContainer2(style) ? Option.of(value) : None
  });

  // node_modules/@siteimprove/alfa-style/dist/property/perspective.js
  var { either: either74 } = Parser;
  var perspective_default = Longhand.of(Keyword.of("none"), either74(Keyword.parse("none"), Perspective.parseProp), (value) => value, { inherits: false });

  // node_modules/@siteimprove/alfa-style/dist/property/pointer-events.js
  var pointer_events_default = Longhand.fromKeywords({ inherits: true }, "auto", "none");

  // node_modules/@siteimprove/alfa-style/dist/property/position.js
  var position_default = Longhand.fromKeywords({ inherits: false }, "static", "relative", "absolute", "sticky", "fixed");

  // node_modules/@siteimprove/alfa-style/dist/property/right.js
  var right_default = Longhand.extend(top_default);

  // node_modules/@siteimprove/alfa-style/dist/property/rotate.js
  var { either: either75, left: left14, map: map73, mapResult: mapResult2, option: option37, pair: pair25, separatedList: separatedList11 } = Parser;
  function takeThree(array) {
    return array.length === 3 ? Ok.of(array) : Err.of("Wrong number of coordinates in rotate axis");
  }
  var parseAxis = either75(
    Keyword.parse("x"),
    Keyword.parse("y"),
    Keyword.parse("z"),
    // We need to not consume the last whitespace which is expected by parseRotate,
    // so we can hardly use Parser.take.
    mapResult2(separatedList11(Number3.parse, Token.parseWhitespace), takeThree)
  );
  function delta(keyword, data) {
    return keyword.value === data ? 1 : 0;
  }
  var parseRotate = map73(pair25(option37(left14(parseAxis, Token.parseWhitespace)), Angle2.parse), ([axis, angle]) => {
    for (const value of axis) {
      if (Keyword.isKeyword(value)) {
        return Rotate.of(Number3.of(delta(value, "x")), Number3.of(delta(value, "y")), Number3.of(delta(value, "z")), angle);
      }
      return Rotate.of(value[0], value[1], value[2], angle);
    }
    return Rotate.of(Number3.of(0), Number3.of(0), Number3.of(1), angle);
  });
  var parse36 = either75(Keyword.parse("none"), parseRotate);
  var rotate_default = Longhand.of(Keyword.of("none"), parse36, (rotate) => rotate);

  // node_modules/@siteimprove/alfa-style/dist/property/scale.js
  var { either: either76 } = Parser;
  var scale_default = Longhand.of(Keyword.of("none"), either76(Keyword.parse("none"), Scale.parseProp), (value) => value, { inherits: false });

  // node_modules/@siteimprove/alfa-style/dist/property/text-align.js
  var text_align_default = Longhand.fromKeywords({ inherits: true }, "start", "end", "left", "right", "center", "justify");

  // node_modules/@siteimprove/alfa-style/dist/property/text-decoration-color.js
  var text_decoration_color_default = Longhand.of(Color.current, Color.parse, (value, style) => value.resolve(Resolver2.length(style)));

  // node_modules/@siteimprove/alfa-style/dist/property/text-decoration-line.js
  var { either: either77 } = Parser;
  var parse37 = either77(Keyword.parse("none"), (input) => {
    const keywords = [];
    while (true) {
      for (const [remainder] of Token.parseWhitespace(input)) {
        input = remainder;
      }
      const result = Keyword.parse("underline", "overline", "line-through", "blink")(input);
      if (result.isOk()) {
        const [remainder, value] = result.get();
        if (keywords.every((keyword) => !keyword.equals(value))) {
          keywords.push(value);
          input = remainder;
          continue;
        }
      }
      break;
    }
    if (keywords.length === 0) {
      return Err.of(`Expected one of underline, overline, line-through, or blink`);
    }
    return Result.of([input, List2.of(keywords)]);
  });
  var text_decoration_line_default = Longhand.of(Keyword.of("none"), parse37, (textDecorationLine) => textDecorationLine);

  // node_modules/@siteimprove/alfa-style/dist/property/text-decoration-style.js
  var text_decoration_style_default = Longhand.fromKeywords({ inherits: false }, "solid", "double", "dotted", "dashed", "wavy");

  // node_modules/@siteimprove/alfa-style/dist/property/text-decoration-thickness.js
  var { either: either78 } = Parser;
  var parse38 = either78(Keyword.parse("auto", "from-font"), LengthPercentage.parse);
  var longhand = Longhand.of(Keyword.of("auto"), parse38, (value, style) => value.map((value2) => Selective.of(value2).if(LengthPercentage.isLengthPercentage, LengthPercentage.resolve(Resolver2.lengthPercentage(style.computed("font-size").value, style))).get()));
  var text_decoration_thickness_default = longhand;

  // node_modules/@siteimprove/alfa-style/dist/property/text-indent.js
  var text_indent_default = Longhand.of(Length2.of(0, "px"), LengthPercentage.parse, (textIndent, style) => textIndent.map(LengthPercentage.partiallyResolve(Resolver2.length(style))), { inherits: true });

  // node_modules/@siteimprove/alfa-style/dist/property/text-overflow.js
  var text_overflow_default = Longhand.fromKeywords({
    inherits: false,
    use: (value, style) => Option.conditional(value, () => isBlockContainer(style))
  }, "clip", "ellipsis");

  // node_modules/@siteimprove/alfa-style/dist/property/text-shadow.js
  var { either: either79 } = Parser;
  var parseList6 = List2.parseCommaSeparated(Shadow.parse({ withInset: false, withSpread: false }));
  var text_shadow_default = Longhand.of(Keyword.of("none"), either79(Keyword.parse("none"), parseList6), (value, style) => value.resolve(Resolver2.length(style)), { inherits: true });

  // node_modules/@siteimprove/alfa-style/dist/property/text-transform.js
  var text_transform_default = Longhand.fromKeywords({ inherits: true }, "none", "capitalize", "uppercase", "lowercase");

  // node_modules/@siteimprove/alfa-style/dist/property/transform.js
  var { either: either80 } = Parser;
  var parse39 = either80(Keyword.parse("none"), Transform.parseList);
  var transform_default = Longhand.of(Keyword.of("none"), parse39, (transform, style) => transform.map((transform2) => Keyword.isKeyword(transform2) ? transform2 : transform2.map(Transform.partiallyResolve(Resolver2.length(style)))));

  // node_modules/@siteimprove/alfa-style/dist/property/translate.js
  var { either: either81 } = Parser;
  var translate_default = Longhand.of(Keyword.of("none"), either81(Keyword.parse("none"), Translate.parseProp), (value) => value, { inherits: false });

  // node_modules/@siteimprove/alfa-style/dist/property/vertical-align.js
  var { either: either82 } = Parser;
  var parse40 = either82(Keyword.parse("baseline", "sub", "super", "text-top", "text-bottom", "middle", "top", "bottom"), LengthPercentage.parse);
  var vertical_align_default = Longhand.of(Keyword.of("baseline"), parse40, (value, style) => value.map((verticalAlign) => {
    const lineHeight = style.computed("line-height").value;
    const fontSize = style.computed("font-size").value;
    const base3 = Selective.of(lineHeight).if(isNormal, () => fontSize.scale(1.2)).if(Number3.isNumber, (value2) => fontSize.scale(value2.value)).get();
    return Selective.of(verticalAlign).if(LengthPercentage.isLengthPercentage, LengthPercentage.resolve(Resolver2.lengthPercentage(base3, style))).get();
  }));
  function isNormal(value) {
    return Keyword.isKeyword(value) && value.value === "normal";
  }

  // node_modules/@siteimprove/alfa-style/dist/property/visibility.js
  var visibility_default = Longhand.fromKeywords({ inherits: true }, "visible", "hidden", "collapse");

  // node_modules/@siteimprove/alfa-style/dist/property/white-space.js
  var white_space_default = Longhand.fromKeywords({ inherits: true }, "normal", "pre", "nowrap", "pre-wrap", "break-spaces", "pre-line");

  // node_modules/@siteimprove/alfa-style/dist/property/width.js
  var { either: either83 } = Parser;
  var parse41 = either83(Keyword.parse("auto"), LengthPercentage.parse);
  var width_default = Longhand.of(Keyword.of("auto"), parse41, (width, style) => width.map((width2) => Selective.of(width2).if(LengthPercentage.isLengthPercentage, LengthPercentage.partiallyResolve(Resolver2.length(style))).get()));

  // node_modules/@siteimprove/alfa-style/dist/property/will-change.js
  var { either: either84 } = Parser;
  var illegalCustomIdents = [
    "will-change",
    "auto",
    "scroll-position",
    "contents"
  ];
  var animatableFeature = either84(Keyword.parse("scroll-position", "contents"), CustomIdent.parse((ident) => !illegalCustomIdents.includes(ident)));
  var parse42 = either84(Keyword.parse("auto"), List2.parseCommaSeparated(animatableFeature));
  var will_change_default = Longhand.of(Keyword.of("auto"), parse42, (value) => value);

  // node_modules/@siteimprove/alfa-style/dist/property/word-spacing.js
  var { either: either85 } = Parser;
  var parse43 = either85(Keyword.parse("normal"), Length2.parse);
  var word_spacing_default = Longhand.of(Length2.of(0, "px"), parse43, (value, style) => value.resolve(Resolver2.length(style)).map((wordSpacing) => Keyword.isKeyword(wordSpacing) ? Length2.of(0, "px") : wordSpacing), {
    inherits: true
  });

  // node_modules/@siteimprove/alfa-style/dist/property/z-index.js
  var { either: either86 } = Parser;
  var parse44 = either86(Keyword.parse("auto"), Integer2.parse);
  var z_index_default = Longhand.of(Keyword.of("auto"), parse44, (value, style) => value.map((zIndex) => zIndex.resolve(Resolver2.length(style))), { inherits: false });

  // node_modules/@siteimprove/alfa-style/dist/longhands.js
  var Longhands;
  (function(Longhands2) {
    const longHands = {
      "background-attachment": background_attachment_default,
      "background-clip": background_clip_default,
      "background-color": background_color_default,
      "background-image": background_image_default,
      "background-origin": background_origin_default,
      "background-position-x": background_position_x_default,
      "background-position-y": background_position_y_default,
      "background-repeat-x": background_repeat_x_default,
      "background-repeat-y": background_repeat_y_default,
      "background-size": background_size_default,
      "border-block-end-color": border_block_end_color_default,
      "border-block-end-style": border_block_end_style_default,
      "border-block-end-width": border_block_end_width_default,
      "border-block-start-color": border_block_start_color_default,
      "border-block-start-style": border_block_start_style_default,
      "border-block-start-width": border_block_start_width_default,
      "border-bottom-color": border_bottom_color_default,
      "border-bottom-left-radius": border_bottom_left_radius_default,
      "border-bottom-right-radius": border_bottom_right_radius_default,
      "border-bottom-style": border_bottom_style_default,
      "border-bottom-width": border_bottom_width_default,
      "border-collapse": border_collapse_default,
      "border-end-end-radius": border_end_end_radius_default,
      "border-end-start-radius": border_end_start_radius_default,
      "border-image-outset": border_image_outset_default,
      "border-image-repeat": border_image_repeat_default,
      "border-image-slice": border_image_slice_default,
      "border-image-source": border_image_source_default,
      "border-image-width": border_image_width_default,
      "border-inline-end-color": border_inline_end_color_default,
      "border-inline-end-style": border_inline_end_style_default,
      "border-inline-end-width": border_inline_end_width_default,
      "border-inline-start-color": border_inline_start_color_default,
      "border-inline-start-style": border_inline_start_style_default,
      "border-inline-start-width": border_inline_start_width_default,
      "border-left-color": border_left_color_default,
      "border-left-style": border_left_style_default,
      "border-left-width": border_left_width_default,
      "border-right-color": border_right_color_default,
      "border-right-style": border_right_style_default,
      "border-right-width": border_right_width_default,
      "border-start-end-radius": border_start_end_radius_default,
      "border-start-start-radius": border_start_start_radius_default,
      "border-top-color": border_top_color_default,
      "border-top-left-radius": border_top_left_radius_default,
      "border-top-right-radius": border_top_right_radius_default,
      "border-top-style": border_top_style_default,
      "border-top-width": border_top_width_default,
      bottom: bottom_default,
      "box-shadow": box_shadow_default,
      "clip-path": clip_path_default,
      clip: clip_default,
      color: color_default,
      contain: contain_default,
      "container-type": container_type_default,
      cursor: cursor_default,
      display: display_default,
      "flex-direction": flex_direction_default,
      "flex-wrap": flex_wrap_default,
      float: float_default,
      "font-family": font_family_default,
      "font-size": font_size_default,
      "font-stretch": font_stretch_default,
      "font-style": font_style_default,
      "font-variant-caps": font_variant_caps_default,
      "font-variant-east-asian": font_variant_east_asian_default,
      "font-variant-ligatures": font_variant_ligatures_default,
      "font-variant-numeric": font_variant_numeric_default,
      "font-variant-position": font_variant_position_default,
      "font-weight": font_weight_default,
      height: height_default,
      "inset-block-end": inset_block_end_default,
      "inset-block-start": inset_block_start_default,
      "inset-inline-end": inset_inline_end_default,
      "inset-inline-start": inset_inline_start_default,
      isolation: isolation_default,
      left: left_default,
      "letter-spacing": letter_spacing_default,
      "line-height": line_height_default,
      "margin-bottom": margin_bottom_default,
      "margin-left": margin_left_default,
      "margin-right": margin_right_default,
      "margin-top": margin_top_default,
      "min-height": min_height_default,
      "min-width": min_width_default,
      "mix-blend-mode": mix_blend_mode_default,
      opacity: opacity_default,
      "outline-color": outline_color_default,
      "outline-offset": outline_offset_default,
      "outline-style": outline_style_default,
      "outline-width": outline_width_default,
      "overflow-x": overflow_x_default,
      "overflow-y": overflow_y_default,
      perspective: perspective_default,
      "pointer-events": pointer_events_default,
      position: position_default,
      right: right_default,
      rotate: rotate_default,
      scale: scale_default,
      "text-align": text_align_default,
      "text-decoration-color": text_decoration_color_default,
      "text-decoration-line": text_decoration_line_default,
      "text-decoration-style": text_decoration_style_default,
      "text-decoration-thickness": text_decoration_thickness_default,
      "text-indent": text_indent_default,
      "text-overflow": text_overflow_default,
      "text-shadow": text_shadow_default,
      "text-transform": text_transform_default,
      top: top_default,
      transform: transform_default,
      translate: translate_default,
      "vertical-align": vertical_align_default,
      visibility: visibility_default,
      "white-space": white_space_default,
      width: width_default,
      "will-change": will_change_default,
      "word-spacing": word_spacing_default,
      "z-index": z_index_default
    };
    function isName2(name) {
      return name in longHands;
    }
    Longhands2.isName = isName2;
    function get(name) {
      return longHands[name];
    }
    Longhands2.get = get;
  })(Longhands || (Longhands = {}));

  // node_modules/@siteimprove/alfa-style/dist/shorthand.js
  var { either: either87, end: end6, left: left15 } = Parser;
  var Shorthand = class _Shorthand {
    static of(properties, parse57) {
      return new _Shorthand(properties, left15(either87(Longhand.parseDefaults, parse57), end6(() => "Expected end of input")));
    }
    _properties;
    _parse;
    constructor(properties, parse57) {
      this._properties = properties;
      this._parse = parse57;
    }
    get properties() {
      return this._properties;
    }
    get parse() {
      return this._parse;
    }
  };

  // node_modules/@siteimprove/alfa-style/dist/property/background-position.js
  var { map: map74 } = Parser;
  var parse45 = Position2.parse(
    /* legacySyntax */
    true
  );
  var parseList7 = List2.parseCommaSeparated(parse45);
  var background_position_default = Shorthand.of(["background-position-x", "background-position-y"], map74(parseList7, (positions) => {
    const xs = [];
    const ys = [];
    for (const position of positions) {
      xs.push(position.horizontal);
      ys.push(position.vertical);
    }
    return [
      ["background-position-x", List2.of(xs, ", ")],
      ["background-position-y", List2.of(ys, ", ")]
    ];
  }));

  // node_modules/@siteimprove/alfa-style/dist/property/background-repeat.js
  var Y;
  (function(Y2) {
    Y2.parse = parse8;
  })(Y || (Y = {}));
  var { map: map75, either: either88, delimited: delimited26, option: option38, pair: pair26 } = Parser;
  var parse46 = either88(map75(pair26(parse8, option38(delimited26(option38(Token.parseWhitespace), Y.parse))), ([x, y]) => Tuple2.of(x, y.getOr(x))), map75(Keyword.parse("repeat-x"), () => Tuple2.of(Keyword.of("repeat"), Keyword.of("no-repeat"))), map75(Keyword.parse("repeat-y"), () => Tuple2.of(Keyword.of("no-repeat"), Keyword.of("repeat"))));
  var parseList8 = List2.parseCommaSeparated(parse46);
  var background_repeat_default = Shorthand.of(["background-repeat-x", "background-repeat-y"], map75(parseList8, (repeats) => {
    const xs = [];
    const ys = [];
    for (const repeat of repeats) {
      const [x, y] = repeat.values;
      xs.push(x);
      ys.push(y);
    }
    return [
      ["background-repeat-x", List2.of(xs, ", ")],
      ["background-repeat-y", List2.of(ys, ", ")]
    ];
  }));

  // node_modules/@siteimprove/alfa-style/dist/property/background.js
  var RepeatY;
  (function(RepeatY2) {
    RepeatY2.initialItem = initialItem7;
  })(RepeatY || (RepeatY = {}));
  var { map: map76, filter: filter9, delimited: delimited27, option: option39, right: right25, separatedList: separatedList12 } = Parser;
  var parse47 = (input) => {
    let color;
    let image;
    let positionX;
    let positionY;
    let size;
    let repeatX;
    let repeatY;
    let attachment;
    let origin;
    let clip;
    while (true) {
      for (const [remainder] of Token.parseWhitespace(input)) {
        input = remainder;
      }
      if (color === void 0) {
        const result = parse3(input);
        if (result.isOk()) {
          [input, color] = result.get();
          continue;
        }
      }
      if (image === void 0) {
        const result = parse4(input);
        if (result.isOk()) {
          [input, image] = result.get();
          continue;
        }
      }
      if (positionX === void 0 || positionY === void 0) {
        const result = parse45(input);
        if (result.isOk()) {
          [input, { horizontal: positionX, vertical: positionY }] = result.get();
          {
            const result2 = delimited27(option39(Token.parseWhitespace), right25(delimited27(option39(Token.parseWhitespace), Token.parseDelim("/")), parse9))(input);
            if (result2.isOk()) {
              [input, size] = result2.get();
            }
          }
          continue;
        }
      }
      if (repeatX === void 0 || repeatY === void 0) {
        const result = parse46(input);
        if (result.isOk()) {
          let repeat;
          [input, repeat] = result.get();
          [repeatX, repeatY] = repeat.values;
          continue;
        }
      }
      if (attachment === void 0) {
        const result = parse(input);
        if (result.isOk()) {
          [input, attachment] = result.get();
          continue;
        }
      }
      if (origin === void 0) {
        const result = parse5(input);
        if (result.isOk()) {
          [input, origin] = result.get();
          {
            const result2 = delimited27(option39(Token.parseWhitespace), parse2)(input);
            if (result2.isOk()) {
              [input, clip] = result2.get();
            }
          }
          continue;
        }
      }
      break;
    }
    if ([
      color,
      image,
      positionX,
      positionY,
      repeatX,
      repeatY,
      attachment,
      origin,
      clip
    ].every((property16) => property16 === void 0)) {
      return Err.of(`Expected one of color, image, position, repeat, attachment, origin, or clip`);
    }
    return Result.of([
      input,
      [
        color,
        image,
        positionX,
        positionY,
        size,
        repeatX,
        repeatY,
        attachment,
        origin,
        clip ?? origin
      ]
    ]);
  };
  var parseList9 = filter9(separatedList12(parse47, delimited27(option39(Token.parseWhitespace), Token.parseComma)), (layers) => [...layers].slice(0, -1).every((layer) => layer[0] === void 0), () => "Only the last layer may contain a color");
  var background_default = Shorthand.of([
    "background-color",
    "background-image",
    "background-position-x",
    "background-position-y",
    "background-size",
    "background-repeat-x",
    "background-repeat-y",
    "background-attachment",
    "background-origin",
    "background-clip"
  ], map76(parseList9, (layers) => {
    let color;
    const image = [];
    const positionX = [];
    const positionY = [];
    const size = [];
    const repeatX = [];
    const repeatY = [];
    const attachment = [];
    const origin = [];
    const clip = [];
    for (const layer of layers) {
      color = layer[0];
      image.push(layer[1] ?? initialItem3);
      positionX.push(layer[2] ?? initialItem5);
      positionY.push(layer[3] ?? initialItem6);
      size.push(layer[4] ?? initialItem8);
      repeatX.push(layer[5] ?? initialItem7);
      repeatY.push(layer[6] ?? RepeatY.initialItem);
      attachment.push(layer[7] ?? initialItem);
      origin.push(layer[8] ?? initialItem4);
      clip.push(layer[9] ?? initialItem2);
    }
    return [
      ["background-color", color ?? Longhands.get("background-color").initial],
      ["background-image", List2.of(image, ", ")],
      ["background-position-x", List2.of(positionX, ", ")],
      ["background-position-y", List2.of(positionY, ", ")],
      ["background-size", List2.of(size, ", ")],
      ["background-repeat-x", List2.of(repeatX, ", ")],
      ["background-repeat-y", List2.of(repeatY, ", ")],
      ["background-attachment", List2.of(attachment, ", ")],
      ["background-origin", List2.of(origin, ", ")],
      ["background-clip", List2.of(clip, ", ")]
    ];
  }));

  // node_modules/@siteimprove/alfa-style/dist/property/border-block-color.js
  var { delimited: delimited28, map: map77, option: option40, takeBetween: takeBetween5 } = Parser;
  var border_block_color_default = Shorthand.of(["border-block-start-color", "border-block-end-color"], map77(takeBetween5(delimited28(option40(Token.parseWhitespace), parse10), 1, 2), ([start, end10 = start]) => [
    ["border-block-start-color", start],
    ["border-block-end-color", end10]
  ]));

  // node_modules/@siteimprove/alfa-style/dist/property/border-top.js
  var { doubleBar, map: map78 } = Parser;
  var parse48 = map78(doubleBar(Token.parseWhitespace, parse10, border_top_style_default.parseBase, parse11), ([color, style, width]) => [
    color ?? Keyword.of("initial"),
    style ?? Keyword.of("initial"),
    width ?? Keyword.of("initial")
  ]);
  var border_top_default = Shorthand.of(["border-top-color", "border-top-style", "border-top-width"], map78(parse48, ([color, style, width]) => [
    ["border-top-color", color],
    ["border-top-style", style],
    ["border-top-width", width]
  ]));

  // node_modules/@siteimprove/alfa-style/dist/property/border-block-end.js
  var { map: map79 } = Parser;
  var border_block_end_default = Shorthand.of([
    "border-block-end-color",
    "border-block-end-style",
    "border-block-end-width"
  ], map79(parse48, ([color, style, width]) => [
    ["border-block-end-color", color],
    ["border-block-end-style", style],
    ["border-block-end-width", width]
  ]));

  // node_modules/@siteimprove/alfa-style/dist/property/border-block-start.js
  var { map: map80 } = Parser;
  var border_block_start_default = Shorthand.of([
    "border-block-start-color",
    "border-block-start-style",
    "border-block-start-width"
  ], map80(parse48, ([color, style, width]) => [
    ["border-block-start-color", color],
    ["border-block-start-style", style],
    ["border-block-start-width", width]
  ]));

  // node_modules/@siteimprove/alfa-style/dist/property/border-block-style.js
  var { delimited: delimited29, map: map81, option: option41, takeBetween: takeBetween6 } = Parser;
  var border_block_style_default = Shorthand.of(["border-block-start-style", "border-block-end-style"], map81(takeBetween6(delimited29(option41(Token.parseWhitespace), border_top_style_default.parseBase), 1, 2), ([start, end10 = start]) => [
    ["border-block-start-style", start],
    ["border-block-end-style", end10]
  ]));

  // node_modules/@siteimprove/alfa-style/dist/property/border-block.js
  var { map: map82 } = Parser;
  var border_block_default = Shorthand.of([
    "border-block-start-color",
    "border-block-start-style",
    "border-block-start-width",
    "border-block-end-color",
    "border-block-end-style",
    "border-block-end-width"
  ], map82(parse48, ([color, style, width]) => [
    ["border-block-start-color", color],
    ["border-block-start-style", style],
    ["border-block-start-width", width],
    ["border-block-end-color", color],
    ["border-block-end-style", style],
    ["border-block-end-width", width]
  ]));

  // node_modules/@siteimprove/alfa-style/dist/property/border-block-width.js
  var { delimited: delimited30, map: map83, option: option42, takeBetween: takeBetween7 } = Parser;
  var border_block_width_default = Shorthand.of(["border-block-start-width", "border-block-end-width"], map83(takeBetween7(delimited30(option42(Token.parseWhitespace), parse11), 1, 2), ([start, end10 = start]) => [
    ["border-block-start-width", start],
    ["border-block-end-width", end10]
  ]));

  // node_modules/@siteimprove/alfa-style/dist/property/border-bottom.js
  var { map: map84 } = Parser;
  var border_bottom_default = Shorthand.of(["border-bottom-color", "border-bottom-style", "border-bottom-width"], map84(parse48, ([color, style, width]) => [
    ["border-bottom-color", color],
    ["border-bottom-style", style],
    ["border-bottom-width", width]
  ]));

  // node_modules/@siteimprove/alfa-style/dist/property/border-color.js
  var { delimited: delimited31, map: map85, option: option43, takeBetween: takeBetween8 } = Parser;
  var border_color_default = Shorthand.of([
    "border-top-color",
    "border-right-color",
    "border-bottom-color",
    "border-left-color"
  ], map85(takeBetween8(delimited31(option43(Token.parseWhitespace), Color.parse), 1, 4), ([top, right38 = top, bottom = top, left22 = right38]) => [
    ["border-top-color", top],
    ["border-right-color", right38],
    ["border-bottom-color", bottom],
    ["border-left-color", left22]
  ]));

  // node_modules/@siteimprove/alfa-style/dist/property/border-image.js
  var { delimited: delimited32, either: either89, map: map86, option: option44, pair: pair27, right: right26 } = Parser;
  var parseSlash = delimited32(option44(Token.parseWhitespace), Token.parseDelim("/"));
  var parseWidthOutset = map86(option44(right26(
    parseSlash,
    // we need the longest first so it can fail and default to shortest
    either89(map86(pair27(option44(parse17), right26(parseSlash, parse13)), ([width, outset]) => [width, Option.of(outset)]), map86(parse17, (width) => [Option.of(width), None]))
  )), (result) => result.getOr([None, None]));
  var parse49 = (input) => {
    let source;
    let slice;
    let width = None;
    let outset = None;
    let repeat;
    while (true) {
      for (const [remainder] of Token.parseWhitespace(input)) {
        input = remainder;
      }
      if (source === void 0) {
        const result = parse16(input);
        if (result.isOk()) {
          [input, source] = result.get();
          continue;
        }
      }
      if (slice === void 0) {
        const result = pair27(parse15, parseWidthOutset)(input);
        if (result.isOk()) {
          [input, [slice, [width, outset]]] = result.get();
          continue;
        }
      }
      if (repeat === void 0) {
        const result = parse14(input);
        if (result.isOk()) {
          [input, repeat] = result.get();
          continue;
        }
      }
      break;
    }
    return Result.of([
      input,
      [
        source ?? Keyword.of("initial"),
        slice ?? Keyword.of("initial"),
        width.getOr(Keyword.of("initial")),
        outset.getOr(Keyword.of("initial")),
        repeat ?? Keyword.of("initial")
      ]
    ]);
  };
  var border_image_default = Shorthand.of([
    "border-image-source",
    "border-image-slice",
    "border-image-width",
    "border-image-outset",
    "border-image-repeat"
  ], map86(parse49, ([source, slice, width, outset, repeat]) => [
    ["border-image-source", source],
    ["border-image-slice", slice],
    ["border-image-width", width],
    ["border-image-outset", outset],
    ["border-image-repeat", repeat]
  ]));

  // node_modules/@siteimprove/alfa-style/dist/property/border-inline-color.js
  var { delimited: delimited33, map: map87, option: option45, takeBetween: takeBetween9 } = Parser;
  var border_inline_color_default = Shorthand.of(["border-inline-start-color", "border-inline-end-color"], map87(takeBetween9(delimited33(option45(Token.parseWhitespace), parse10), 1, 2), ([start, end10 = start]) => [
    ["border-inline-start-color", start],
    ["border-inline-end-color", end10]
  ]));

  // node_modules/@siteimprove/alfa-style/dist/property/border-inline-end.js
  var { map: map88 } = Parser;
  var border_inline_end_default = Shorthand.of([
    "border-inline-end-color",
    "border-inline-end-style",
    "border-inline-end-width"
  ], map88(parse48, ([color, style, width]) => [
    ["border-inline-end-color", color],
    ["border-inline-end-style", style],
    ["border-inline-end-width", width]
  ]));

  // node_modules/@siteimprove/alfa-style/dist/property/border-inline-start.js
  var { map: map89 } = Parser;
  var border_inline_start_default = Shorthand.of([
    "border-inline-start-color",
    "border-inline-start-style",
    "border-inline-start-width"
  ], map89(parse48, ([color, style, width]) => [
    ["border-inline-start-color", color],
    ["border-inline-start-style", style],
    ["border-inline-start-width", width]
  ]));

  // node_modules/@siteimprove/alfa-style/dist/property/border-inline-style.js
  var { delimited: delimited34, map: map90, option: option46, takeBetween: takeBetween10 } = Parser;
  var border_inline_style_default = Shorthand.of(["border-inline-start-style", "border-inline-end-style"], map90(takeBetween10(delimited34(option46(Token.parseWhitespace), border_top_style_default.parseBase), 1, 2), ([start, end10 = start]) => [
    ["border-inline-start-style", start],
    ["border-inline-end-style", end10]
  ]));

  // node_modules/@siteimprove/alfa-style/dist/property/border-inline.js
  var { map: map91 } = Parser;
  var border_inline_default = Shorthand.of([
    "border-inline-start-color",
    "border-inline-start-style",
    "border-inline-start-width",
    "border-inline-end-color",
    "border-inline-end-style",
    "border-inline-end-width"
  ], map91(parse48, ([color, style, width]) => [
    ["border-inline-start-color", color],
    ["border-inline-start-style", style],
    ["border-inline-start-width", width],
    ["border-inline-end-color", color],
    ["border-inline-end-style", style],
    ["border-inline-end-width", width]
  ]));

  // node_modules/@siteimprove/alfa-style/dist/property/border-inline-width.js
  var { delimited: delimited35, map: map92, option: option47, takeBetween: takeBetween11 } = Parser;
  var border_inline_width_default = Shorthand.of(["border-inline-start-width", "border-inline-end-width"], map92(takeBetween11(delimited35(option47(Token.parseWhitespace), parse11), 1, 2), ([start, end10 = start]) => [
    ["border-inline-start-width", start],
    ["border-inline-end-width", end10]
  ]));

  // node_modules/@siteimprove/alfa-style/dist/property/border-left.js
  var { map: map93 } = Parser;
  var border_left_default = Shorthand.of(["border-left-color", "border-left-style", "border-left-width"], map93(parse48, ([color, style, width]) => [
    ["border-left-color", color],
    ["border-left-style", style],
    ["border-left-width", width]
  ]));

  // node_modules/@siteimprove/alfa-style/dist/property/border-radius.js
  var { delimited: delimited36, map: map94, option: option48, pair: pair28, right: right27, takeBetween: takeBetween12 } = Parser;
  var parse50 = map94(pair28(takeBetween12(delimited36(option48(Token.parseWhitespace), LengthPercentage.parse), 1, 4), option48(right27(Token.parseDelim("/"), takeBetween12(delimited36(option48(Token.parseWhitespace), LengthPercentage.parse), 1, 4)))), ([horizontal, vertical]) => {
    const [tlh, trh = tlh, brh = tlh, blh = trh] = horizontal;
    let tlv, trv, brv, blv;
    if (vertical.isSome()) {
      const v = vertical.get();
      tlv = v[0];
      trv = v?.[1] ?? tlv;
      brv = v?.[2] ?? tlv;
      blv = v?.[3] ?? trv;
    } else {
      [tlv, trv, brv, blv] = [tlh, trh, brh, blh];
    }
    return [
      Tuple2.of(tlh, tlv),
      Tuple2.of(trh, trv),
      Tuple2.of(brh, brv),
      Tuple2.of(blh, blv)
    ];
  });
  var border_radius_default = Shorthand.of([
    "border-top-left-radius",
    "border-top-right-radius",
    "border-bottom-right-radius",
    "border-bottom-left-radius"
  ], map94(parse50, ([topLeft, topRight, bottomRight, bottomLeft]) => [
    ["border-top-left-radius", topLeft],
    ["border-top-right-radius", topRight],
    ["border-bottom-right-radius", bottomRight],
    ["border-bottom-left-radius", bottomLeft]
  ]));

  // node_modules/@siteimprove/alfa-style/dist/property/border-right.js
  var { map: map95 } = Parser;
  var border_right_default = Shorthand.of(["border-right-color", "border-right-style", "border-right-width"], map95(parse48, ([color, style, width]) => [
    ["border-right-color", color],
    ["border-right-style", style],
    ["border-right-width", width]
  ]));

  // node_modules/@siteimprove/alfa-style/dist/property/border-style.js
  var { delimited: delimited37, map: map96, option: option49, takeBetween: takeBetween13 } = Parser;
  var border_style_default = Shorthand.of([
    "border-top-style",
    "border-right-style",
    "border-bottom-style",
    "border-left-style"
  ], map96(takeBetween13(delimited37(option49(Token.parseWhitespace), border_top_style_default.parseBase), 1, 4), ([top, right38 = top, bottom = top, left22 = right38]) => [
    ["border-top-style", top],
    ["border-right-style", right38],
    ["border-bottom-style", bottom],
    ["border-left-style", left22]
  ]));

  // node_modules/@siteimprove/alfa-style/dist/property/border.js
  var { map: map97 } = Parser;
  var border_default = Shorthand.of([
    "border-top-color",
    "border-top-style",
    "border-top-width",
    "border-right-color",
    "border-right-style",
    "border-right-width",
    "border-bottom-color",
    "border-bottom-style",
    "border-bottom-width",
    "border-left-color",
    "border-left-style",
    "border-left-width"
  ], map97(parse48, ([color, style, width]) => [
    ["border-top-color", color],
    ["border-top-style", style],
    ["border-top-width", width],
    ["border-right-color", color],
    ["border-right-style", style],
    ["border-right-width", width],
    ["border-bottom-color", color],
    ["border-bottom-style", style],
    ["border-bottom-width", width],
    ["border-left-color", color],
    ["border-left-style", style],
    ["border-left-width", width]
  ]));

  // node_modules/@siteimprove/alfa-style/dist/property/border-width.js
  var { delimited: delimited38, map: map98, option: option50, takeBetween: takeBetween14 } = Parser;
  var border_width_default = Shorthand.of([
    "border-top-width",
    "border-right-width",
    "border-bottom-width",
    "border-left-width"
  ], map98(takeBetween14(delimited38(option50(Token.parseWhitespace), parse11), 1, 4), ([top, right38 = top, bottom = top, left22 = right38]) => [
    ["border-top-width", top],
    ["border-right-width", right38],
    ["border-bottom-width", bottom],
    ["border-left-width", left22]
  ]));

  // node_modules/@siteimprove/alfa-style/dist/property/flex-flow.js
  var { map: map99 } = Parser;
  var parse51 = (input) => {
    let direction;
    let wrap;
    while (true) {
      for (const [remainder] of Token.parseWhitespace(input)) {
        input = remainder;
      }
      if (direction === void 0) {
        const result = flex_direction_default.parseBase(input);
        if (result.isOk()) {
          [input, direction] = result.get();
          continue;
        }
      }
      if (wrap === void 0) {
        const result = flex_wrap_default.parseBase(input);
        if (result.isOk()) {
          [input, wrap] = result.get();
          continue;
        }
      }
      break;
    }
    return Result.of([
      input,
      [direction ?? Keyword.of("initial"), wrap ?? Keyword.of("initial")]
    ]);
  };
  var flex_flow_default = Shorthand.of(["flex-direction", "flex-wrap"], map99(parse51, ([direction, wrap]) => [
    ["flex-direction", direction],
    ["flex-wrap", wrap]
  ]));

  // node_modules/@siteimprove/alfa-style/dist/property/font.js
  var { map: map100, option: option51, pair: pair29, right: right28, delimited: delimited39 } = Parser;
  var parsePrelude = (input) => {
    let style;
    let variant;
    let weight;
    let stretch;
    while (true) {
      for (const [remainder] of Token.parseWhitespace(input)) {
        input = remainder;
      }
      if (style === void 0) {
        const result = font_style_default.parseBase(input);
        if (result.isOk()) {
          [input, style] = result.get();
          continue;
        }
      }
      if (variant === void 0) {
        const result = Keyword.parse("normal", "small-caps")(input);
        if (result.isOk()) {
          [input, variant] = result.get();
          continue;
        }
      }
      if (weight === void 0) {
        const result = font_weight_default.parseBase(input);
        if (result.isOk()) {
          [input, weight] = result.get();
          continue;
        }
      }
      if (stretch === void 0) {
        const result = parseAbsolute(input);
        if (result.isOk()) {
          [input, stretch] = result.get();
          continue;
        }
      }
      break;
    }
    return Result.of([
      input,
      [
        ["font-stretch", stretch ?? Keyword.of("initial")],
        ["font-style", style ?? Keyword.of("initial")],
        ["font-variant-caps", variant ?? Keyword.of("initial")],
        ["font-weight", weight ?? Keyword.of("initial")]
      ]
    ]);
  };
  var parse52 = pair29(parsePrelude, pair29(delimited39(option51(Token.parseWhitespace), font_size_default.parseBase), pair29(option51(right28(delimited39(option51(Token.parseWhitespace), Token.parseDelim("/")), line_height_default.parseBase)), delimited39(option51(Token.parseWhitespace), font_family_default.parseBase))));
  var font_default = Shorthand.of([
    "font-family",
    "font-size",
    "font-stretch",
    "font-style",
    "font-variant-caps",
    "font-variant-east-asian",
    "font-variant-ligatures",
    "font-variant-numeric",
    "font-variant-position",
    "font-weight",
    "line-height"
  ], map100(parse52, ([prelude, [size, [lineHeight, family]]]) => [
    ...prelude,
    ["font-size", size],
    ["line-height", lineHeight.getOr(Keyword.of("initial"))],
    ["font-family", family]
  ]));

  // node_modules/@siteimprove/alfa-style/dist/property/font-variant.js
  var parse53 = (input) => {
    let caps;
    let variant;
    let width;
    let ruby;
    let common;
    let discretionary;
    let historical;
    let contextual;
    let figure;
    let spacing;
    let fraction;
    let ordinal;
    let slashed;
    while (true) {
      for (const [remainder] of Token.parseWhitespace(input)) {
        input = remainder;
      }
      if (caps === void 0) {
        const result = font_variant_caps_default.parseBase(input);
        if (result.isOk()) {
          [input, caps] = result.get();
          continue;
        }
      }
      if (variant === void 0) {
        const result = parseVariant(input);
        if (result.isOk()) {
          [input, variant] = result.get();
          continue;
        }
      }
      if (width === void 0) {
        const result = parseWidth(input);
        if (result.isOk()) {
          [input, width] = result.get();
          continue;
        }
      }
      if (ruby === void 0) {
        const result = Keyword.parse("ruby")(input);
        if (result.isOk()) {
          [input, ruby] = result.get();
          continue;
        }
      }
      if (common === void 0) {
        const result = parseCommon(input);
        if (result.isOk()) {
          [input, common] = result.get();
          continue;
        }
      }
      if (discretionary === void 0) {
        const result = parseDiscretionary(input);
        if (result.isOk()) {
          [input, discretionary] = result.get();
          continue;
        }
      }
      if (historical === void 0) {
        const result = parseHistorical(input);
        if (result.isOk()) {
          [input, historical] = result.get();
          continue;
        }
      }
      if (contextual === void 0) {
        const result = parseContextual(input);
        if (result.isOk()) {
          [input, contextual] = result.get();
          continue;
        }
      }
      if (figure === void 0) {
        const result = parseFigure(input);
        if (result.isOk()) {
          [input, figure] = result.get();
          continue;
        }
      }
      if (spacing === void 0) {
        const result = parseSpacing(input);
        if (result.isOk()) {
          [input, spacing] = result.get();
          continue;
        }
      }
      if (fraction === void 0) {
        const result = parseFraction(input);
        if (result.isOk()) {
          [input, fraction] = result.get();
          continue;
        }
      }
      if (ordinal === void 0) {
        const result = Keyword.parse("ordinal")(input);
        if (result.isOk()) {
          [input, ordinal] = result.get();
          continue;
        }
      }
      if (slashed === void 0) {
        const result = Keyword.parse("slashed-zero")(input);
        if (result.isOk()) {
          [input, slashed] = result.get();
          continue;
        }
      }
      break;
    }
    if (caps === void 0 && variant === void 0 && width === void 0 && ruby === void 0 && common === void 0 && discretionary === void 0 && historical === void 0 && contextual === void 0 && figure === void 0 && spacing === void 0 && fraction === void 0 && ordinal === void 0 && slashed === void 0) {
      return Err.of("At least one Font variant value must be provided");
    }
    function list(...values) {
      const cleaned = values.filter((value) => value !== void 0);
      return cleaned.length > 0 ? List2.of(cleaned, " ") : Keyword.of("initial");
    }
    return Result.of([
      input,
      [
        ["font-variant-caps", caps ?? Keyword.of("initial")],
        [
          "font-variant-east-asian",
          list(variant, width, ruby)
        ],
        [
          "font-variant-ligatures",
          list(common, discretionary, historical, contextual)
        ],
        [
          "font-variant-numeric",
          list(figure, spacing, fraction, ordinal, slashed)
        ]
      ]
    ]);
  };
  var font_variant_default = Shorthand.of([
    "font-variant-caps",
    "font-variant-east-asian",
    "font-variant-ligatures",
    "font-variant-numeric"
  ], parse53);

  // node_modules/@siteimprove/alfa-style/dist/property/inset-block.js
  var { takeBetween: takeBetween15, map: map101, delimited: delimited40, option: option52 } = Parser;
  var inset_block_default = Shorthand.of(["inset-block-start", "inset-block-end"], map101(takeBetween15(delimited40(option52(Token.parseWhitespace), parse18), 1, 2), ([start, end10 = start]) => [
    ["inset-block-start", start],
    ["inset-block-end", end10]
  ]));

  // node_modules/@siteimprove/alfa-style/dist/property/inset-inline.js
  var { takeBetween: takeBetween16, map: map102, delimited: delimited41, option: option53 } = Parser;
  var inset_inline_default = Shorthand.of(["inset-inline-start", "inset-inline-end"], map102(takeBetween16(delimited41(option53(Token.parseWhitespace), parse18), 1, 2), ([start, end10 = start]) => [
    ["inset-inline-start", start],
    ["inset-inline-end", end10]
  ]));

  // node_modules/@siteimprove/alfa-style/dist/property/inset.js
  var { map: map103, option: option54, delimited: delimited42, takeBetween: takeBetween17 } = Parser;
  var parse54 = takeBetween17(delimited42(option54(Token.parseWhitespace), parse18), 1, 4);
  var inset_default = Shorthand.of(["top", "right", "bottom", "left"], map103(parse54, ([top, right38 = top, bottom = top, left22 = right38]) => [
    ["top", top],
    ["right", right38],
    ["bottom", bottom],
    ["left", left22]
  ]));

  // node_modules/@siteimprove/alfa-style/dist/property/margin.js
  var { map: map104, option: option55, delimited: delimited43, takeBetween: takeBetween18 } = Parser;
  var parse55 = takeBetween18(delimited43(option55(Token.parseWhitespace), parse33), 1, 4);
  var margin_default = Shorthand.of(["margin-top", "margin-right", "margin-bottom", "margin-left"], map104(parse55, ([top, right38 = top, bottom = top, left22 = right38]) => [
    ["margin-top", top],
    ["margin-right", right38],
    ["margin-bottom", bottom],
    ["margin-left", left22]
  ]));

  // node_modules/@siteimprove/alfa-style/dist/property/outline.js
  var outline_default = Shorthand.of(["outline-width", "outline-style", "outline-color"], (input) => {
    let width;
    let style;
    let color;
    while (true) {
      for (const [remainder] of Token.parseWhitespace(input)) {
        input = remainder;
      }
      if (width === void 0) {
        const result = outline_width_default.parseBase(input);
        if (result.isOk()) {
          [input, width] = result.get();
          continue;
        }
      }
      if (style === void 0) {
        const result = outline_style_default.parseBase(input);
        if (result.isOk()) {
          [input, style] = result.get();
          continue;
        }
      }
      if (color === void 0) {
        const result = outline_color_default.parseBase(input);
        if (result.isOk()) {
          [input, color] = result.get();
          continue;
        }
      }
      break;
    }
    if (width === void 0 && style === void 0 && color === void 0) {
      return Err.of(`Expected one of width, style, or color`);
    }
    return Result.of([
      input,
      [
        ["outline-width", width ?? Keyword.of("initial")],
        ["outline-style", style ?? Keyword.of("initial")],
        ["outline-color", color ?? Keyword.of("initial")]
      ]
    ]);
  });

  // node_modules/@siteimprove/alfa-style/dist/property/overflow.js
  var { map: map105, option: option56, pair: pair30, delimited: delimited44 } = Parser;
  var parse56 = pair30(overflow_x_default.parseBase, option56(delimited44(option56(Token.parseWhitespace), overflow_y_default.parseBase)));
  var overflow_default = Shorthand.of(["overflow-x", "overflow-y"], map105(parse56, (result) => {
    const [x, y] = result;
    return [
      ["overflow-x", x],
      ["overflow-y", y.getOr(x)]
    ];
  }));

  // node_modules/@siteimprove/alfa-style/dist/property/text-decoration.js
  var text_decoration_default = Shorthand.of([
    "text-decoration-line",
    "text-decoration-style",
    "text-decoration-color",
    "text-decoration-thickness"
  ], (input) => {
    let line;
    let style;
    let color;
    let thickness;
    while (true) {
      for (const [remainder] of Token.parseWhitespace(input)) {
        input = remainder;
      }
      if (line === void 0) {
        const result = text_decoration_line_default.parseBase(input);
        if (result.isOk()) {
          [input, line] = result.get();
          continue;
        }
      }
      if (style === void 0) {
        const result = text_decoration_style_default.parseBase(input);
        if (result.isOk()) {
          [input, style] = result.get();
          continue;
        }
      }
      if (color === void 0) {
        const result = text_decoration_color_default.parseBase(input);
        if (result.isOk()) {
          [input, color] = result.get();
          continue;
        }
      }
      if (thickness === void 0) {
        const result = text_decoration_thickness_default.parseBase(input);
        if (result.isOk()) {
          [input, thickness] = result.get();
          continue;
        }
      }
      break;
    }
    if (line === void 0 && style === void 0 && color === void 0 && thickness === void 0) {
      return Err.of(`Expected one of line, style, color, or thickness`);
    }
    return Result.of([
      input,
      [
        ["text-decoration-line", line ?? Keyword.of("initial")],
        ["text-decoration-style", style ?? Keyword.of("initial")],
        ["text-decoration-color", color ?? Keyword.of("initial")],
        ["text-decoration-thickness", thickness ?? Keyword.of("initial")]
      ]
    ]);
  });

  // node_modules/@siteimprove/alfa-style/dist/shorthands.js
  var Shorthands;
  (function(Shorthands2) {
    Shorthands2.shortHands = {
      background: background_default,
      "background-position": background_position_default,
      "background-repeat": background_repeat_default,
      "border-block-color": border_block_color_default,
      "border-block-end": border_block_end_default,
      "border-block-start": border_block_start_default,
      "border-block-style": border_block_style_default,
      "border-block": border_block_default,
      "border-block-width": border_block_width_default,
      "border-bottom": border_bottom_default,
      "border-color": border_color_default,
      "border-image": border_image_default,
      "border-inline-color": border_inline_color_default,
      "border-inline-end": border_inline_end_default,
      "border-inline-start": border_inline_start_default,
      "border-inline-style": border_inline_style_default,
      "border-inline": border_inline_default,
      "border-inline-width": border_inline_width_default,
      "border-left": border_left_default,
      "border-radius": border_radius_default,
      "border-right": border_right_default,
      "border-style": border_style_default,
      "border-top": border_top_default,
      border: border_default,
      "border-width": border_width_default,
      "flex-flow": flex_flow_default,
      font: font_default,
      "font-variant": font_variant_default,
      "inset-block": inset_block_default,
      "inset-inline": inset_inline_default,
      inset: inset_default,
      margin: margin_default,
      outline: outline_default,
      overflow: overflow_default,
      "text-decoration": text_decoration_default
    };
    function isName2(name) {
      return name in Shorthands2.shortHands;
    }
    Shorthands2.isName = isName2;
    function get(name) {
      return Shorthands2.shortHands[name];
    }
    Shorthands2.get = get;
  })(Shorthands || (Shorthands = {}));

  // node_modules/@siteimprove/alfa-selector/dist/context.js
  var Context = class _Context {
    static of(state) {
      return new _Context(Map2.from(state));
    }
    static _empty = new _Context(Map2.empty());
    static empty() {
      return this._empty;
    }
    _state;
    constructor(state) {
      this._state = state;
    }
    isEmpty() {
      return this._state.isEmpty();
    }
    hasState(element, state) {
      return this._state.get(element).some((found) => (found & state) !== 0);
    }
    getState(element) {
      return this._state.get(element).getOr(_Context.State.None);
    }
    setState(element, state) {
      return new _Context(this._state.set(element, state));
    }
    addState(element, state) {
      return this.setState(element, this.getState(element) | state);
    }
    *withState(state) {
      yield* this._state.filter((found) => (found & state) !== 0).keys();
    }
    hover(element) {
      return this.addState(element, _Context.State.Hover);
    }
    static hover(element) {
      return this.empty().hover(element);
    }
    isHovered(element) {
      return this.hasState(element, _Context.State.Hover);
    }
    active(element) {
      return this.addState(element, _Context.State.Active);
    }
    static active(element) {
      return this.empty().active(element);
    }
    isActive(element) {
      return this.hasState(element, _Context.State.Active);
    }
    focus(element) {
      return this.addState(element, _Context.State.Focus);
    }
    static focus(element) {
      return this.empty().focus(element);
    }
    isFocused(element) {
      return this.hasState(element, _Context.State.Focus);
    }
    visit(element) {
      return this.addState(element, _Context.State.Visited);
    }
    static visit(element) {
      return this.empty().visit(element);
    }
    isVisited(element) {
      return this.hasState(element, _Context.State.Visited);
    }
  };
  (function(Context2) {
    let State4;
    (function(State5) {
      State5[State5["None"] = 0] = "None";
      State5[State5["Hover"] = 1] = "Hover";
      State5[State5["Active"] = 2] = "Active";
      State5[State5["Focus"] = 4] = "Focus";
      State5[State5["Visited"] = 8] = "Visited";
    })(State4 = Context2.State || (Context2.State = {}));
  })(Context || (Context = {}));

  // node_modules/@siteimprove/alfa-selector/dist/specificity.js
  var componentBits = 10;
  var componentMax = (1 << componentBits) - 1;
  var Specificity = class _Specificity {
    static of(a, b, c) {
      return new _Specificity(a, b, c);
    }
    static _empty = new _Specificity(0, 0, 0);
    static empty() {
      return _Specificity._empty;
    }
    _a;
    _b;
    _c;
    _value;
    constructor(a, b, c) {
      this._a = a;
      this._b = b;
      this._c = c;
      this._value = Math.min(a, componentMax) << componentBits * 2 | Math.min(b, componentMax) << componentBits * 1 | Math.min(c, componentMax);
    }
    get a() {
      return this._a;
    }
    get b() {
      return this._b;
    }
    get c() {
      return this._c;
    }
    get value() {
      return this._value;
    }
    equals(value) {
      return value instanceof _Specificity && value._value === this._value;
    }
    hash(hash2) {
      hash2.writeInt32(this._value);
    }
    toJSON() {
      return { a: this._a, b: this._b, c: this._c };
    }
    toString() {
      return `(${this._a}, ${this._b}, ${this._c})`;
    }
  };
  (function(Specificity2) {
    function isSpecificity(value) {
      return value instanceof Specificity2;
    }
    Specificity2.isSpecificity = isSpecificity;
    function sum(...specificities) {
      if (specificities.length === 0) {
        return Specificity2.empty();
      }
      const [first, ...rest] = specificities;
      return rest.reduce((pre, cur) => Specificity2.of(pre.a + cur.a, pre.b + cur.b, pre.c + cur.c), first);
    }
    Specificity2.sum = sum;
    function max5(...specificities) {
      if (specificities.length === 0) {
        return Specificity2.empty();
      }
      const [first, ...rest] = specificities;
      return rest.reduce((pre, cur) => pre.value > cur.value ? pre : cur, first);
    }
    Specificity2.max = max5;
    Specificity2.compare = (a, b) => Comparable.compareNumber(a.value, b.value);
  })(Specificity || (Specificity = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/combinator.js
  var { delimited: delimited45, either: either90, map: map106, option: option57 } = Parser;
  var Combinator;
  (function(Combinator2) {
    Combinator2["Descendant"] = " ";
    Combinator2["DirectDescendant"] = ">";
    Combinator2["Sibling"] = "~";
    Combinator2["DirectSibling"] = "+";
  })(Combinator || (Combinator = {}));
  (function(Combinator2) {
    Combinator2.parseCombinator = either90(delimited45(option57(Token.parseWhitespace), either90(map106(Token.parseDelim(">"), () => Combinator2.DirectDescendant), map106(Token.parseDelim("~"), () => Combinator2.Sibling), map106(Token.parseDelim("+"), () => Combinator2.DirectSibling))), map106(Token.parseWhitespace, () => Combinator2.Descendant));
  })(Combinator || (Combinator = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/selector.js
  var Selector = class _Selector {
    _type;
    _specificity;
    /**
     * The key selector is used to optimise matching of complex (and compound)
     * selectors.
     *
     * @remarks
     * The key selector is the rightmost simple selector in a complex selector,
     * or the leftmost simple selector in a compound selector. In order for an
     * element to match a complex selector, it must match the key selector.
     *
     * For example, consider selector `main .foo + div`. Any element matching it
     * must necessarily be a `<div>`, and for other elements there is no need to
     * waste time traversing the DOM tree to check siblings or ancestors.
     *
     * For compound selectors, e.g. `.foo.bar`, any part could be taken, and we
     * arbitrarily pick the leftmost.
     *
     * Conversely, an `<img id="image" class="foo bar">` can only match selectors
     * whose key selector is `img`, `#image`, `.foo`, or `.bar`. So we can
     * pre-filter these when attempting matching.
     *
     * @privateRemarks
     * Key selectors are not part of the CSS specification, but are a useful tool
     * for optimising selector matching.
     *
     * Key selectors relate to cascading more than selector syntax and matching,
     * but they only depend on selector and thus make sense as instance properties.
     *
     * {@link http://doc.servo.org/style/selector_map/struct.SelectorMap.html}
     */
    _key = None;
    constructor(type, specificity) {
      this._type = type;
      this._specificity = specificity;
    }
    get type() {
      return this._type;
    }
    get specificity() {
      return this._specificity;
    }
    get key() {
      return this._key;
    }
    equals(value) {
      return value instanceof _Selector && value._type === this._type && value._specificity.equals(this._specificity);
    }
    toJSON() {
      return {
        type: this._type,
        specificity: this._specificity.toJSON(),
        ...this._key.isSome() ? { key: `${this._key.get()}` } : {}
      };
    }
  };
  var WithName = class _WithName extends Selector {
    _name;
    constructor(type, name, specificity) {
      super(type, specificity);
      this._name = name;
    }
    get name() {
      return this._name;
    }
    matches(element, context) {
      return false;
    }
    equals(value) {
      return value instanceof _WithName && super.equals(value) && value._name === this._name;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        name: this._name
      };
    }
  };

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/parser.js
  var { either: either91, left: left16, map: map107, option: option58, pair: pair31 } = Parser;
  var parseNamespace = map107(left16(option58(either91(Token.parseIdent(), Token.parseDelim("*"))), Token.parseDelim("|")), (token) => token.map((token2) => token2.toString()).getOr(""));
  var parseName = pair31(option58(parseNamespace), map107(Token.parseIdent(), (ident) => ident.value));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/attribute.js
  var { delimited: delimited46, either: either92, left: left17, map: map108, option: option59, pair: pair32 } = Parser;
  var { and: and8, equals: equals11, property: property3 } = Predicate;
  var Attribute2 = class _Attribute extends WithName {
    static of(namespace, name, value = None, matcher = None, modifier2 = None) {
      return new _Attribute(namespace, name, value, matcher, modifier2);
    }
    _namespace;
    _value;
    _matcher;
    _modifier;
    constructor(namespace, name, value, matcher, modifier2) {
      super("attribute", name, Specificity.of(0, 1, 0));
      this._namespace = namespace;
      this._value = value;
      this._matcher = matcher;
      this._modifier = modifier2;
    }
    get namespace() {
      return this._namespace;
    }
    get value() {
      return this._value;
    }
    get matcher() {
      return this._matcher;
    }
    get modifier() {
      return this._modifier;
    }
    matches(element) {
      for (const namespace of this._namespace) {
        let predicate;
        switch (namespace) {
          case "*":
            predicate = property3("name", equals11(this._name));
            break;
          case "":
            predicate = and8(property3("name", equals11(this._name)), property3("namespace", equals11(None)));
            break;
          default:
            predicate = and8(property3("name", equals11(this._name)), property3("namespace", equals11(namespace)));
        }
        return Iterable.some(element.attributes, and8(predicate, (attribute) => this.matchesValue(attribute.value)));
      }
      return element.attribute(this._name).some((attribute) => this.matchesValue(attribute.value));
    }
    matchesValue(value) {
      for (const modifier2 of this._modifier) {
        switch (modifier2) {
          case _Attribute.Modifier.CaseInsensitive:
            value = value.toLowerCase();
        }
      }
      for (const match of this._value) {
        switch (this._matcher.getOr(_Attribute.Matcher.Equal)) {
          case _Attribute.Matcher.Equal:
            return value === match;
          case _Attribute.Matcher.Prefix:
            return value.startsWith(match);
          case _Attribute.Matcher.Suffix:
            return value.endsWith(match);
          case _Attribute.Matcher.Substring:
            return value.includes(match);
          case _Attribute.Matcher.DashMatch:
            return value === match || value.startsWith(`${match}-`);
          case _Attribute.Matcher.Includes:
            return value.split(/\s+/).some(equals11(match));
        }
      }
      return true;
    }
    equals(value) {
      return value instanceof _Attribute && value._namespace.equals(this._namespace) && value._name === this._name && value._value.equals(this._value) && value._matcher.equals(this._matcher) && value._modifier.equals(this._modifier);
    }
    *[Symbol.iterator]() {
      yield this;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        namespace: this._namespace.getOr(null),
        value: this._value.getOr(null),
        matcher: this._matcher.getOr(null),
        modifier: this._modifier.getOr(null)
      };
    }
    toString() {
      const namespace = this._namespace.map((namespace2) => `${namespace2}|`).getOr("");
      const value = this._value.map((value2) => `"${JSON.stringify(value2)}"`).getOr("");
      const matcher = this._matcher.getOr("");
      const modifier2 = this._modifier.map((modifier3) => ` ${modifier3}`).getOr("");
      return `[${namespace}${this._name}${matcher}${value}${modifier2}]`;
    }
  };
  (function(Attribute4) {
    let Matcher;
    (function(Matcher2) {
      Matcher2["Equal"] = "=";
      Matcher2["Includes"] = "~=";
      Matcher2["DashMatch"] = "|=";
      Matcher2["Prefix"] = "^=";
      Matcher2["Suffix"] = "$=";
      Matcher2["Substring"] = "*=";
    })(Matcher = Attribute4.Matcher || (Attribute4.Matcher = {}));
    let Modifier2;
    (function(Modifier3) {
      Modifier3["CaseInsensitive"] = "i";
      Modifier3["CaseSensitive"] = "s";
    })(Modifier2 = Attribute4.Modifier || (Attribute4.Modifier = {}));
    function isAttribute(value) {
      return value instanceof Attribute4;
    }
    Attribute4.isAttribute = isAttribute;
    const parseMatcher = map108(left17(option59(either92(Token.parseDelim("~"), Token.parseDelim("|"), Token.parseDelim("^"), Token.parseDelim("$"), Token.parseDelim("*"))), Token.parseDelim("=")), (delim) => delim.isSome() ? `${delim.get()}=` : Attribute4.Matcher.Equal);
    const parseModifier = either92(map108(Token.parseIdent("i"), () => Attribute4.Modifier.CaseInsensitive), map108(Token.parseIdent("s"), () => Attribute4.Modifier.CaseSensitive));
    Attribute4.parse = map108(delimited46(Token.parseOpenSquareBracket, pair32(parseName, option59(pair32(pair32(parseMatcher, either92(Token.parseString(), Token.parseIdent())), delimited46(option59(Token.parseWhitespace), option59(parseModifier))))), Token.parseCloseSquareBracket), (result) => {
      const [[namespace, name], rest] = result;
      if (rest.isSome()) {
        const [[matcher, value], modifier2] = rest.get();
        return Attribute4.of(namespace, name, Option.of(value.value), Option.of(matcher), modifier2);
      }
      return Attribute4.of(namespace, name);
    });
  })(Attribute2 || (Attribute2 = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/class.js
  var { map: map109, right: right29 } = Parser;
  var Class = class _Class extends WithName {
    static of(name) {
      return new _Class(name);
    }
    _key;
    constructor(name) {
      super("class", name, Specificity.of(0, 1, 0));
      this._key = Option.of(this);
    }
    matches(element) {
      return Iterable.includes(element.classes, this._name);
    }
    equals(value) {
      return value instanceof _Class && value._name === this._name;
    }
    *[Symbol.iterator]() {
      yield this;
    }
    toJSON() {
      return {
        ...super.toJSON()
      };
    }
    toString() {
      return `.${this._name}`;
    }
  };
  (function(Class2) {
    function isClass(value) {
      return value instanceof Class2;
    }
    Class2.isClass = isClass;
    Class2.parse = map109(right29(Token.parseDelim("."), Token.parseIdent()), (ident) => Class2.of(ident.value));
  })(Class || (Class = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/id.js
  var { map: map110 } = Parser;
  var Id = class _Id extends WithName {
    static of(name) {
      return new _Id(name);
    }
    _key;
    constructor(name) {
      super("id", name, Specificity.of(1, 0, 0));
      this._key = Option.of(this);
    }
    matches(element) {
      return element.id.includes(this._name);
    }
    equals(value) {
      return value instanceof _Id && value._name === this._name;
    }
    *[Symbol.iterator]() {
      yield this;
    }
    toJSON() {
      return {
        ...super.toJSON()
      };
    }
    toString() {
      return `#${this._name}`;
    }
  };
  (function(Id2) {
    function isId(value) {
      return value instanceof Id2;
    }
    Id2.isId = isId;
    Id2.parse = map110(Token.parseHash((hash2) => hash2.isIdentifier), (hash2) => Id2.of(hash2.value));
  })(Id || (Id = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-class/pseudo-class.js
  var { delimited: delimited47, end: end7, left: left18, map: map111, option: option60, pair: pair33, right: right30 } = Parser;
  var { parseColon, parseIdent, parseWhitespace: parseWhitespace4 } = Token;
  var PseudoClassSelector = class _PseudoClassSelector extends WithName {
    // Some pseudo-class manipulate specificity, so we cannot just set it
    // to (0, 1, 0) for all and must allow for overwriting it.
    // https://www.w3.org/TR/selectors/#specificity
    constructor(name, specificity) {
      super("pseudo-class", name, specificity ?? Specificity.of(0, 1, 0));
    }
    equals(value) {
      return value instanceof _PseudoClassSelector && super.equals(value);
    }
    toJSON() {
      return {
        ...super.toJSON()
      };
    }
    toString() {
      return `:${this._name}`;
    }
  };
  (function(PseudoClassSelector2) {
    function parseNonFunctional(name, of) {
      return map111(
        right30(parseColon, parseIdent(name)),
        // We explicitly need to discard the parsed identifier and not pass it
        // to a function that may use it (but was super-typed as a Thunk).
        () => of()
      );
    }
    PseudoClassSelector2.parseNonFunctional = parseNonFunctional;
  })(PseudoClassSelector || (PseudoClassSelector = {}));
  var WithIndex = class _WithIndex extends PseudoClassSelector {
    // For pseudo-classes that do not filter the set of elements, we can use a static
    // map of sibling positions.
    // For pseudo-classes that may filter the set of elements, we need this to be
    // an instance map since two instances may have different extra selector and
    // set of candidates.
    static _indices = /* @__PURE__ */ new WeakMap();
    _index;
    constructor(name, nth, specificity) {
      super(name, specificity);
      this._index = nth;
    }
    equals(value) {
      return value instanceof _WithIndex && value._index.equals(this._index);
    }
    toJSON() {
      return {
        ...super.toJSON(),
        index: this._index.toJSON()
      };
    }
    toString() {
      return `:${this.name}(${this._index})`;
    }
  };
  var parseNth = left18(Nth.parse, end7((token) => `Unexpected token ${token}`));
  (function(WithIndex2) {
    function parseWithIndex(name, of) {
      return map111(right30(parseColon, Function.parse(name, parseNth)), ([, nth]) => of(nth));
    }
    WithIndex2.parseWithIndex = parseWithIndex;
  })(WithIndex || (WithIndex = {}));
  var WithSelector = class _WithSelector extends PseudoClassSelector {
    _selector;
    constructor(name, selector, specificity) {
      super(name, specificity);
      this._selector = selector;
    }
    get selector() {
      return this._selector;
    }
    equals(value) {
      return value instanceof _WithSelector && value._selector.equals(this._selector);
    }
    toJSON() {
      return {
        ...super.toJSON(),
        selector: Serializable.toJSON(this._selector)
      };
    }
    toString() {
      return `:${this.name}(${this._selector})`;
    }
  };
  (function(WithSelector2) {
    function parseWithSelector(name, parseSelector, of) {
      return map111(right30(parseColon, Function.parse(name, parseSelector)), ([, selector]) => of(selector));
    }
    WithSelector2.parseWithSelector = parseWithSelector;
  })(WithSelector || (WithSelector = {}));
  var WithIndexAndSelector = class _WithIndexAndSelector extends WithIndex {
    _selector;
    constructor(name, nth, selector, specificity = Specificity.sum(Specificity.of(0, 1, 0), selector.map((s) => s.specificity).getOr(Specificity.of(0, 0, 0)))) {
      super(name, nth, specificity);
      this._selector = selector;
    }
    get selector() {
      return this._selector;
    }
    equals(value) {
      return value instanceof _WithIndexAndSelector && super.equals(value) && value._selector.equals(this._selector);
    }
    toJSON() {
      return {
        ...super.toJSON(),
        ...this._selector.isSome() ? { selector: this._selector.get().toJSON() } : {}
      };
    }
    toString() {
      return `:${this.name}(${this._index} of ${this._selector})`;
    }
  };
  (function(WithIndexAndSelector2) {
    function parseWithIndexAndSelector(name, parseSelector, of) {
      return map111(right30(parseColon, Function.parse(name, () => pair33(Nth.parse, option60(right30(delimited47(parseWhitespace4, parseIdent("of")), parseSelector()))))), ([, [nth, selector]]) => of(nth, selector));
    }
    WithIndexAndSelector2.parseWithIndexAndSelector = parseWithIndexAndSelector;
  })(WithIndexAndSelector || (WithIndexAndSelector = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-class/active.js
  var Active = class _Active extends PseudoClassSelector {
    static of() {
      return new _Active();
    }
    constructor() {
      super("active");
    }
    *[Symbol.iterator]() {
      yield this;
    }
    matches(element, context = Context.empty()) {
      return context.isActive(element);
    }
    toJSON() {
      return super.toJSON();
    }
  };
  (function(Active2) {
    Active2.parse = PseudoClassSelector.parseNonFunctional("active", Active2.of);
  })(Active || (Active = {}));

  // node_modules/@siteimprove/alfa-selector/dist/common/is-link.js
  function isLink(element) {
    switch (element.name) {
      case "a":
      case "area":
      case "link":
        return element.attribute("href").isSome();
    }
    return false;
  }

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-class/any-link.js
  var AnyLink = class _AnyLink extends PseudoClassSelector {
    static of() {
      return new _AnyLink();
    }
    constructor() {
      super("any-link");
    }
    *[Symbol.iterator]() {
      yield this;
    }
    matches(element) {
      return isLink(element);
    }
    toJSON() {
      return super.toJSON();
    }
  };
  (function(AnyLink2) {
    AnyLink2.parse = PseudoClassSelector.parseNonFunctional("any-link", AnyLink2.of);
  })(AnyLink || (AnyLink = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-class/checked.js
  var { hasAttribute: hasAttribute2, hasInputType: hasInputType2, hasName: hasName3 } = Element;
  var { and: and9, or: or6 } = Predicate;
  var Checked = class _Checked extends PseudoClassSelector {
    static of() {
      return new _Checked();
    }
    constructor() {
      super("checked");
    }
    *[Symbol.iterator]() {
      yield this;
    }
    /**
     * @privateRemarks
     * Checkedness and selectedness can change during the lifecycle of an element,
     * but we do not have access to that. We rely on the content attributes being
     * correctly set in the snapshot we test.
     */
    matches = or6(and9(hasInputType2("checkbox", "radio"), hasAttribute2("checked")), and9(hasName3("option"), hasAttribute2("selected")));
    toJSON() {
      return super.toJSON();
    }
  };
  (function(Checked2) {
    Checked2.parse = PseudoClassSelector.parseNonFunctional("checked", Checked2.of);
  })(Checked || (Checked = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-class/disabled.js
  var Disabled = class _Disabled extends PseudoClassSelector {
    static of() {
      return new _Disabled();
    }
    constructor() {
      super("disabled");
    }
    *[Symbol.iterator]() {
      yield this;
    }
    matches(element, context = Context.empty()) {
      return Element.isActuallyDisabled(element);
    }
    toJSON() {
      return super.toJSON();
    }
  };
  (function(Disabled2) {
    Disabled2.parse = PseudoClassSelector.parseNonFunctional("disabled", Disabled2.of);
  })(Disabled || (Disabled = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-class/empty.js
  var Empty5 = class _Empty extends PseudoClassSelector {
    static of() {
      return new _Empty();
    }
    constructor() {
      super("empty");
    }
    *[Symbol.iterator]() {
      yield this;
    }
    matches(element) {
      return element.children().isEmpty();
    }
    toJSON() {
      return super.toJSON();
    }
  };
  (function(Empty6) {
    Empty6.parse = PseudoClassSelector.parseNonFunctional("empty", Empty6.of);
  })(Empty5 || (Empty5 = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-class/enabled.js
  var { hasName: hasName4 } = Element;
  var { and: and10, not: not17, test: test9 } = Predicate;
  var Enabled = class _Enabled extends PseudoClassSelector {
    static of() {
      return new _Enabled();
    }
    constructor() {
      super("enabled");
    }
    *[Symbol.iterator]() {
      yield this;
    }
    matches(element, context = Context.empty()) {
      return test9(and10(hasName4("button", "input", "select", "textarea", "optgroup", "option", "fieldset"), not17(Element.isActuallyDisabled)), element);
    }
    toJSON() {
      return super.toJSON();
    }
  };
  (function(Enabled2) {
    Enabled2.parse = PseudoClassSelector.parseNonFunctional("enabled", Enabled2.of);
  })(Enabled || (Enabled = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-class/first-child.js
  var { isElement } = Element;
  var FirstChild = class _FirstChild extends PseudoClassSelector {
    static of() {
      return new _FirstChild();
    }
    constructor() {
      super("first-child");
    }
    *[Symbol.iterator]() {
      yield this;
    }
    matches(element) {
      return element.inclusiveSiblings().filter(isElement).first().includes(element);
    }
    toJSON() {
      return super.toJSON();
    }
  };
  (function(FirstChild2) {
    FirstChild2.parse = PseudoClassSelector.parseNonFunctional("first-child", FirstChild2.of);
  })(FirstChild || (FirstChild = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-class/first-of-type.js
  var { hasName: hasName5, isElement: isElement2 } = Element;
  var FirstOfType = class _FirstOfType extends PseudoClassSelector {
    static of() {
      return new _FirstOfType();
    }
    constructor() {
      super("first-of-type");
    }
    *[Symbol.iterator]() {
      yield this;
    }
    matches(element) {
      return element.inclusiveSiblings().filter(isElement2).filter(hasName5(element.name)).first().includes(element);
    }
    toJSON() {
      return super.toJSON();
    }
  };
  (function(FirstOfType2) {
    FirstOfType2.parse = PseudoClassSelector.parseNonFunctional("first-of-type", FirstOfType2.of);
  })(FirstOfType || (FirstOfType = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-class/focus.js
  var Focus = class _Focus extends PseudoClassSelector {
    static of() {
      return new _Focus();
    }
    constructor() {
      super("focus");
    }
    *[Symbol.iterator]() {
      yield this;
    }
    matches(element, context = Context.empty()) {
      return context.isFocused(element);
    }
    toJSON() {
      return super.toJSON();
    }
  };
  (function(Focus2) {
    Focus2.parse = PseudoClassSelector.parseNonFunctional("focus", Focus2.of);
  })(Focus || (Focus = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-class/focus-visible.js
  var FocusVisible = class _FocusVisible extends PseudoClassSelector {
    static of() {
      return new _FocusVisible();
    }
    constructor() {
      super("focus-visible");
    }
    *[Symbol.iterator]() {
      yield this;
    }
    matches(element, context = Context.empty()) {
      return context.isFocused(element);
    }
  };
  (function(FocusVisible2) {
    FocusVisible2.parse = PseudoClassSelector.parseNonFunctional("focus-visible", FocusVisible2.of);
  })(FocusVisible || (FocusVisible = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-class/focus-within.js
  var { State } = Context;
  var FocusWithin = class _FocusWithin extends PseudoClassSelector {
    static of() {
      return new _FocusWithin();
    }
    constructor() {
      super("focus-within");
    }
    static _cache = Cache2.empty();
    *[Symbol.iterator]() {
      yield this;
    }
    matches(element, context = Context.empty()) {
      return _FocusWithin._cache.get(element, Cache2.empty).get(context, () => {
        const focused = Sequence.from(context.withState(State.Focus));
        return focused.size !== 0 && element.inclusiveDescendants(Node4.fullTree).some((descendant) => focused.includes(descendant));
      });
    }
    toJSON() {
      return super.toJSON();
    }
  };
  (function(FocusWithin2) {
    FocusWithin2.parse = PseudoClassSelector.parseNonFunctional("focus-within", FocusWithin2.of);
  })(FocusWithin || (FocusWithin = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-class/has.js
  var Has = class _Has extends WithSelector {
    static of(selector) {
      return new _Has(selector);
    }
    constructor(selector) {
      super("has", selector, selector.specificity);
    }
    *[Symbol.iterator]() {
      yield this;
    }
    equals(value) {
      return value instanceof _Has && value._selector.equals(this._selector);
    }
    toJSON() {
      return {
        ...super.toJSON()
      };
    }
  };
  (function(Has2) {
    Has2.parse = (parseSelector) => WithSelector.parseWithSelector("has", parseSelector, Has2.of);
  })(Has || (Has = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-class/host.js
  var { either: either93, map: map112, right: right31 } = Parser;
  var { parseColon: parseColon2 } = Token;
  var Host = class _Host extends PseudoClassSelector {
    static of(selector) {
      return new _Host(Option.from(selector));
    }
    _selector;
    constructor(selector) {
      super("host", Specificity.sum(selector.map((selector2) => selector2.specificity).getOr(Specificity.empty()), Specificity.of(0, 1, 0)));
      this._selector = selector;
    }
    get selector() {
      return this._selector;
    }
    /**
     * @remarks
     * `:host` never matches anything in its own tree.
     */
    matches() {
      return false;
    }
    /**
     * Checks whether a shadow host matches.
     *
     * @remarks
     * This must be called with `element` being the shadow host of
     * the Document that defines the selector.
     */
    matchHost(element, context = Context.empty()) {
      return this._selector.every((selector) => selector.matches(element, context));
    }
    *[Symbol.iterator]() {
      yield this;
    }
    equals(value) {
      return value instanceof _Host && value._selector.equals(this._selector);
    }
    toJSON() {
      return {
        ...super.toJSON(),
        ...this._selector.isSome() ? { selector: this._selector.get().toJSON() } : {}
      };
    }
  };
  (function(Host2) {
    function isHost(value) {
      return value instanceof Host2;
    }
    Host2.isHost = isHost;
    Host2.parse = (parseSelector) => either93(
      // We need to try the functional variant first to avoid the non-functional
      // greedily passing.
      map112(right31(parseColon2, Function.parse("host", parseSelector)), ([, selector]) => Host2.of(selector)),
      PseudoClassSelector.parseNonFunctional("host", Host2.of)
    );
  })(Host || (Host = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-class/host-context.js
  var HostContext = class _HostContext extends WithSelector {
    static of(selector) {
      return new _HostContext(selector);
    }
    constructor(selector) {
      super("host-context", selector, Specificity.sum(selector.specificity, Specificity.of(0, 1, 0)));
    }
    *[Symbol.iterator]() {
      yield this;
    }
    /**
     * @remarks
     * `:host-context` never matches anything in its own tree.
     */
    matches(element, context) {
      return false;
    }
    matchHost(element, context = Context.empty()) {
      return element.inclusiveAncestors(Node4.Traversal.of(Node4.Traversal.composed)).filter(Element.isElement).some((ancestor) => this._selector.matches(ancestor, context));
    }
    equals(value) {
      return value instanceof _HostContext && value._selector.equals(this._selector);
    }
    toJSON() {
      return {
        ...super.toJSON()
      };
    }
  };
  (function(HostContext2) {
    function isHostContext(value) {
      return value instanceof HostContext2;
    }
    HostContext2.isHostContext = isHostContext;
    HostContext2.parse = (parseSelector) => WithSelector.parseWithSelector("host-context", parseSelector, HostContext2.of);
  })(HostContext || (HostContext = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-class/hover.js
  var { State: State2 } = Context;
  var Hover = class _Hover extends PseudoClassSelector {
    static of() {
      return new _Hover();
    }
    constructor() {
      super("hover");
    }
    static _cache = Cache2.empty();
    *[Symbol.iterator]() {
      yield this;
    }
    matches(element, context = Context.empty()) {
      return _Hover._cache.get(element, Cache2.empty).get(context, () => {
        const hovered = Sequence.from(context.withState(State2.Hover));
        return hovered.size !== 0 && element.inclusiveDescendants(Node4.fullTree).some((descendant) => hovered.includes(descendant));
      });
    }
    toJSON() {
      return super.toJSON();
    }
  };
  (function(Hover2) {
    Hover2.parse = PseudoClassSelector.parseNonFunctional("hover", Hover2.of);
  })(Hover || (Hover = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-class/is.js
  var Is = class _Is extends WithSelector {
    static of(selector) {
      return new _Is(selector);
    }
    constructor(selector) {
      super("is", selector, selector.specificity);
    }
    *[Symbol.iterator]() {
      yield this;
    }
    matches(element, context) {
      return this._selector.matches(element, context);
    }
    equals(value) {
      return value instanceof _Is && value._selector.equals(this._selector);
    }
    toJSON() {
      return {
        ...super.toJSON()
      };
    }
  };
  (function(Is2) {
    Is2.parse = (parseSelector) => WithSelector.parseWithSelector("is", parseSelector, Is2.of);
  })(Is || (Is = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-class/last-child.js
  var { isElement: isElement3 } = Element;
  var LastChild = class _LastChild extends PseudoClassSelector {
    static of() {
      return new _LastChild();
    }
    constructor() {
      super("last-child");
    }
    *[Symbol.iterator]() {
      yield this;
    }
    matches(element) {
      return element.inclusiveSiblings().filter(isElement3).last().includes(element);
    }
    toJSON() {
      return super.toJSON();
    }
  };
  (function(LastChild2) {
    LastChild2.parse = PseudoClassSelector.parseNonFunctional("last-child", LastChild2.of);
  })(LastChild || (LastChild = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-class/last-of-type.js
  var { hasName: hasName6, isElement: isElement4 } = Element;
  var LastOfType = class _LastOfType extends PseudoClassSelector {
    static of() {
      return new _LastOfType();
    }
    constructor() {
      super("last-of-type");
    }
    *[Symbol.iterator]() {
      yield this;
    }
    matches(element) {
      return element.inclusiveSiblings().filter(isElement4).filter(hasName6(element.name)).last().includes(element);
    }
    toJSON() {
      return super.toJSON();
    }
  };
  (function(LastOfType2) {
    LastOfType2.parse = PseudoClassSelector.parseNonFunctional("last-of-type", LastOfType2.of);
  })(LastOfType || (LastOfType = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-class/link.js
  var Link = class _Link extends PseudoClassSelector {
    static of() {
      return new _Link();
    }
    constructor() {
      super("link");
    }
    *[Symbol.iterator]() {
      yield this;
    }
    matches(element, context = Context.empty()) {
      return isLink(element) && !context.hasState(element, Context.State.Visited);
    }
    toJSON() {
      return super.toJSON();
    }
  };
  (function(Link2) {
    Link2.parse = PseudoClassSelector.parseNonFunctional("link", Link2.of);
  })(Link || (Link = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-class/not.js
  var Not2 = class _Not extends WithSelector {
    static of(selector) {
      return new _Not(selector);
    }
    constructor(selector) {
      super("not", selector, selector.specificity);
    }
    *[Symbol.iterator]() {
      yield this;
    }
    matches(element, context) {
      return !this._selector.matches(element, context);
    }
    equals(value) {
      return value instanceof _Not && value._selector.equals(this._selector);
    }
    toJSON() {
      return {
        ...super.toJSON()
      };
    }
  };
  (function(Not3) {
    Not3.parse = (parseSelector) => WithSelector.parseWithSelector("not", parseSelector, Not3.of);
  })(Not2 || (Not2 = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-class/nth-child.js
  var { isElement: isElement5 } = Element;
  var NthChild = class _NthChild extends WithIndexAndSelector {
    static of(index, selector = None) {
      return new _NthChild(index, Maybe.toOption(selector));
    }
    _indices = /* @__PURE__ */ new WeakMap();
    constructor(index, selector) {
      super("nth-child", index, selector);
    }
    *[Symbol.iterator]() {
      yield this;
    }
    matches(element, context) {
      if (!this._indices.has(element)) {
        element.inclusiveSiblings().filter(isElement5).filter((element2) => this._selector.getOr(Universal.of(Option.of("*"))).matches(element2, context)).forEach((element2, i) => {
          this._indices.set(element2, i + 1);
        });
      }
      if (!this._indices.has(element)) {
        return false;
      }
      return this._index.matches(this._indices.get(element));
    }
    equals(value) {
      return value instanceof _NthChild && super.equals(value);
    }
    toJSON() {
      return super.toJSON();
    }
  };
  (function(NthChild2) {
    NthChild2.parse = (parseSelector) => WithIndexAndSelector.parseWithIndexAndSelector("nth-child", parseSelector, NthChild2.of);
  })(NthChild || (NthChild = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-class/nth-last-child.js
  var { isElement: isElement6 } = Element;
  var NthLastChild = class _NthLastChild extends WithIndexAndSelector {
    static of(index, selector = None) {
      return new _NthLastChild(index, Maybe.toOption(selector));
    }
    _indices = /* @__PURE__ */ new WeakMap();
    constructor(nth, selector) {
      super("nth-last-child", nth, selector);
    }
    *[Symbol.iterator]() {
      yield this;
    }
    matches(element, context) {
      if (!this._indices.has(element)) {
        element.inclusiveSiblings().filter(isElement6).filter((element2) => this._selector.getOr(Universal.of(Option.of("*"))).matches(element2, context)).reverse().forEach((element2, i) => {
          this._indices.set(element2, i + 1);
        });
      }
      if (!this._indices.has(element)) {
        return false;
      }
      return this._index.matches(this._indices.get(element));
    }
    equals(value) {
      return value instanceof _NthLastChild && super.equals(value);
    }
    toJSON() {
      return super.toJSON();
    }
  };
  (function(NthLastChild2) {
    NthLastChild2.parse = (parseSelector) => WithIndexAndSelector.parseWithIndexAndSelector("nth-last-child", parseSelector, NthLastChild2.of);
  })(NthLastChild || (NthLastChild = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-class/nth-last-of-type.js
  var { hasName: hasName7, isElement: isElement7 } = Element;
  var NthLastOfType = class _NthLastOfType extends WithIndex {
    static of(index) {
      return new _NthLastOfType(index);
    }
    constructor(index) {
      super("nth-last-of-type", index);
    }
    *[Symbol.iterator]() {
      yield this;
    }
    matches(element) {
      const indices = _NthLastOfType._indices;
      if (!indices.has(element)) {
        element.inclusiveSiblings().filter(isElement7).filter(hasName7(element.name)).reverse().forEach((element2, i) => {
          indices.set(element2, i + 1);
        });
      }
      return this._index.matches(indices.get(element));
    }
    equals(value) {
      return value instanceof _NthLastOfType && value._index.equals(this._index);
    }
    toJSON() {
      return {
        ...super.toJSON()
      };
    }
  };
  (function(NthLastOfType2) {
    NthLastOfType2.parse = WithIndex.parseWithIndex("nth-last-of-type", NthLastOfType2.of);
  })(NthLastOfType || (NthLastOfType = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-class/nth-of-type.js
  var { hasName: hasName8, isElement: isElement8 } = Element;
  var NthOfType = class _NthOfType extends WithIndex {
    static of(index) {
      return new _NthOfType(index);
    }
    constructor(index) {
      super("nth-of-type", index);
    }
    *[Symbol.iterator]() {
      yield this;
    }
    matches(element) {
      const indices = _NthOfType._indices;
      if (!indices.has(element)) {
        element.inclusiveSiblings().filter(isElement8).filter(hasName8(element.name)).forEach((element2, i) => {
          indices.set(element2, i + 1);
        });
      }
      return this._index.matches(indices.get(element));
    }
    equals(value) {
      return value instanceof _NthOfType && value._index.equals(this._index);
    }
    toJSON() {
      return {
        ...super.toJSON()
      };
    }
  };
  (function(NthOfType2) {
    NthOfType2.parse = WithIndex.parseWithIndex("nth-of-type", NthOfType2.of);
  })(NthOfType || (NthOfType = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-class/only-child.js
  var { isElement: isElement9 } = Element;
  var OnlyChild = class _OnlyChild extends PseudoClassSelector {
    static of() {
      return new _OnlyChild();
    }
    constructor() {
      super("only-child");
    }
    *[Symbol.iterator]() {
      yield this;
    }
    matches(element) {
      return element.inclusiveSiblings().filter(isElement9).size === 1;
    }
    toJSON() {
      return super.toJSON();
    }
  };
  (function(OnlyChild2) {
    OnlyChild2.parse = PseudoClassSelector.parseNonFunctional("only-child", OnlyChild2.of);
  })(OnlyChild || (OnlyChild = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-class/only-of-type.js
  var { hasName: hasName9, isElement: isElement10 } = Element;
  var OnlyOfType = class _OnlyOfType extends PseudoClassSelector {
    static of() {
      return new _OnlyOfType();
    }
    constructor() {
      super("only-of-type");
    }
    *[Symbol.iterator]() {
      yield this;
    }
    matches(element) {
      return element.inclusiveSiblings().filter(isElement10).filter(hasName9(element.name)).size === 1;
    }
    toJSON() {
      return super.toJSON();
    }
  };
  (function(OnlyOfType2) {
    OnlyOfType2.parse = PseudoClassSelector.parseNonFunctional("only-of-type", OnlyOfType2.of);
  })(OnlyOfType || (OnlyOfType = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-class/root.js
  var { isElement: isElement11 } = Element;
  var { not: not18 } = Predicate;
  var Root = class _Root extends PseudoClassSelector {
    static of() {
      return new _Root();
    }
    constructor() {
      super("root");
    }
    *[Symbol.iterator]() {
      yield this;
    }
    matches(element) {
      return element.parent().every(not18(isElement11));
    }
    toJSON() {
      return super.toJSON();
    }
  };
  (function(Root2) {
    Root2.parse = PseudoClassSelector.parseNonFunctional("root", Root2.of);
  })(Root || (Root = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-class/visited.js
  var Visited = class _Visited extends PseudoClassSelector {
    static of() {
      return new _Visited();
    }
    constructor() {
      super("visited");
    }
    *[Symbol.iterator]() {
      yield this;
    }
    matches(element, context = Context.empty()) {
      return isLink(element) && context.hasState(element, Context.State.Visited);
    }
    toJSON() {
      return super.toJSON();
    }
  };
  (function(Visited2) {
    Visited2.parse = PseudoClassSelector.parseNonFunctional("visited", Visited2.of);
  })(Visited || (Visited = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-class/where.js
  var Where = class _Where extends WithSelector {
    static of(selector) {
      return new _Where(selector);
    }
    constructor(selector) {
      super("where", selector, Specificity.of(0, 0, 0));
    }
    *[Symbol.iterator]() {
      yield this;
    }
    matches(element, context) {
      return this._selector.matches(element, context);
    }
    equals(value) {
      return value instanceof _Where && value._selector.equals(this._selector);
    }
    toJSON() {
      return {
        ...super.toJSON()
      };
    }
  };
  (function(Where2) {
    Where2.parse = (parseSelector) => WithSelector.parseWithSelector("where", parseSelector, Where2.of);
  })(Where || (Where = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-class/index.js
  var { either: either94, filter: filter10 } = Parser;
  var { or: or7 } = Refinement;
  var PseudoClass;
  (function(PseudoClass2) {
    function isPseudoClass(value) {
      return value instanceof PseudoClassSelector;
    }
    PseudoClass2.isPseudoClass = isPseudoClass;
    PseudoClass2.isHost = Host.isHost;
    function parse57(parseSelector) {
      return either94(Active.parse, AnyLink.parse, Checked.parse, Disabled.parse, Empty5.parse, Enabled.parse, FirstChild.parse, FirstOfType.parse, Focus.parse, FocusVisible.parse, FocusWithin.parse, Host.parse(() => filter10(parseSelector(), or7(Compound.isCompound, Simple.isSimple), () => ":host() only accepts compound selectors")), HostContext.parse(() => filter10(parseSelector(), or7(Compound.isCompound, Simple.isSimple), () => ":host-context() only accepts compound selectors")), Hover.parse, LastChild.parse, LastOfType.parse, Link.parse, OnlyChild.parse, OnlyOfType.parse, Root.parse, Visited.parse, NthChild.parse(parseSelector), NthLastChild.parse(parseSelector), NthLastOfType.parse, NthOfType.parse, Has.parse(parseSelector), Is.parse(parseSelector), Not2.parse(parseSelector), Where.parse(parseSelector));
    }
    PseudoClass2.parse = parse57;
  })(PseudoClass || (PseudoClass = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-element/pseudo-element.js
  var { map: map113, right: right32, take: take5, takeBetween: takeBetween19 } = Parser;
  var { parseColon: parseColon3, parseIdent: parseIdent2 } = Token;
  var PseudoElementSelector = class _PseudoElementSelector extends WithName {
    constructor(name, specificity = Specificity.of(0, 0, 1)) {
      super("pseudo-element", name, specificity);
    }
    equals(value) {
      return value instanceof _PseudoElementSelector && super.equals(value);
    }
    toJSON() {
      return {
        ...super.toJSON()
      };
    }
    toString() {
      return `::${this._name}`;
    }
  };
  (function(PseudoElementSelector2) {
    function parseNonLegacy(name, of) {
      return map113(right32(take5(parseColon3, 2), parseIdent2(name)), of);
    }
    PseudoElementSelector2.parseNonLegacy = parseNonLegacy;
    function parseLegacy2(name, of) {
      return map113(right32(takeBetween19(Token.parseColon, 1, 2), Token.parseIdent(name)), of);
    }
    PseudoElementSelector2.parseLegacy = parseLegacy2;
  })(PseudoElementSelector || (PseudoElementSelector = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-element/after.js
  var After = class _After extends PseudoElementSelector {
    static of() {
      return new _After();
    }
    constructor() {
      super("after");
    }
    *[Symbol.iterator]() {
      yield this;
    }
  };
  (function(After2) {
    After2.parse = PseudoElementSelector.parseLegacy("after", After2.of);
  })(After || (After = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-element/backdrop.js
  var Backdrop = class _Backdrop extends PseudoElementSelector {
    static of() {
      return new _Backdrop();
    }
    constructor() {
      super("backdrop");
    }
    *[Symbol.iterator]() {
      yield this;
    }
  };
  (function(Backdrop2) {
    Backdrop2.parse = PseudoElementSelector.parseNonLegacy("backdrop", Backdrop2.of);
  })(Backdrop || (Backdrop = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-element/before.js
  var Before = class _Before extends PseudoElementSelector {
    static of() {
      return new _Before();
    }
    constructor() {
      super("before");
    }
    *[Symbol.iterator]() {
      yield this;
    }
  };
  (function(Before2) {
    Before2.parse = PseudoElementSelector.parseLegacy("before", Before2.of);
  })(Before || (Before = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-element/cue.js
  var { either: either95, map: map114, right: right33, take: take6 } = Parser;
  var Cue = class _Cue extends PseudoElementSelector {
    static of(selector) {
      return new _Cue(Option.from(selector));
    }
    _selector;
    constructor(selector) {
      super("cue");
      this._selector = selector;
    }
    get selector() {
      return this._selector;
    }
    *[Symbol.iterator]() {
      yield this;
    }
    equals(value) {
      return value instanceof _Cue && value.selector.equals(this.selector);
    }
    toJSON() {
      return {
        ...super.toJSON(),
        selector: this._selector.toJSON()
      };
    }
    toString() {
      return `::${this.name}` + this._selector.isSome() ? `(${this._selector})` : "";
    }
  };
  (function(Cue2) {
    function parse57(parseSelector) {
      return right33(
        take6(Token.parseColon, 2),
        // We need to try and fail the functional notation first to avoid accepting
        // the `::cue` prefix of a `::cue(selector)`.
        either95(
          map114(Function.parse("cue", parseSelector), ([_, selector]) => Cue2.of(selector)),
          // We need to eta-expand in order to discard the result of parseIdent.
          map114(Token.parseIdent("cue"), () => Cue2.of())
        )
      );
    }
    Cue2.parse = parse57;
  })(Cue || (Cue = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-element/cue-region.js
  var { either: either96, map: map115, right: right34, take: take7 } = Parser;
  var CueRegion = class _CueRegion extends PseudoElementSelector {
    static of(selector) {
      return new _CueRegion(Option.from(selector));
    }
    _selector;
    constructor(selector) {
      super("cue-region");
      this._selector = selector;
    }
    get selector() {
      return this._selector;
    }
    *[Symbol.iterator]() {
      yield this;
    }
    equals(value) {
      return value instanceof _CueRegion && value.selector.equals(this.selector);
    }
    toJSON() {
      return {
        ...super.toJSON(),
        selector: this._selector.toJSON()
      };
    }
    toString() {
      return `::${this.name}` + this._selector.isSome() ? `(${this._selector})` : "";
    }
  };
  (function(CueRegion2) {
    function parse57(parseSelector) {
      return right34(
        take7(Token.parseColon, 2),
        // We need to try and fail the functional notation first to avoid accepting
        // the `::cue-region` prefix of a `::cue-region(selector)`.
        either96(
          map115(Function.parse("cue-region", parseSelector), ([_, selector]) => CueRegion2.of(selector)),
          // We need to eta-expand in order to discard the result of parseIdent.
          map115(Token.parseIdent("cue-region"), () => CueRegion2.of())
        )
      );
    }
    CueRegion2.parse = parse57;
  })(CueRegion || (CueRegion = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-element/file-selector-button.js
  var FileSelectorButton = class _FileSelectorButton extends PseudoElementSelector {
    static of() {
      return new _FileSelectorButton();
    }
    constructor() {
      super("file-selector-button");
    }
    *[Symbol.iterator]() {
      yield this;
    }
  };
  (function(FileSelectorButton2) {
    FileSelectorButton2.parse = PseudoElementSelector.parseNonLegacy("file-selector-button", FileSelectorButton2.of);
  })(FileSelectorButton || (FileSelectorButton = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-element/first-letter.js
  var FirstLetter = class _FirstLetter extends PseudoElementSelector {
    static of() {
      return new _FirstLetter();
    }
    constructor() {
      super("first-letter");
    }
    *[Symbol.iterator]() {
      yield this;
    }
  };
  (function(FirstLetter2) {
    FirstLetter2.parse = PseudoElementSelector.parseLegacy("first-letter", FirstLetter2.of);
  })(FirstLetter || (FirstLetter = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-element/first-line.js
  var FirstLine = class _FirstLine extends PseudoElementSelector {
    static of() {
      return new _FirstLine();
    }
    constructor() {
      super("first-line");
    }
    *[Symbol.iterator]() {
      yield this;
    }
  };
  (function(FirstLine2) {
    FirstLine2.parse = PseudoElementSelector.parseLegacy("first-line", FirstLine2.of);
  })(FirstLine || (FirstLine = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-element/grammar-error.js
  var GrammarError = class _GrammarError extends PseudoElementSelector {
    static of() {
      return new _GrammarError();
    }
    constructor() {
      super("grammar-error");
    }
    *[Symbol.iterator]() {
      yield this;
    }
  };
  (function(GrammarError2) {
    GrammarError2.parse = PseudoElementSelector.parseNonLegacy("grammar-error", GrammarError2.of);
  })(GrammarError || (GrammarError = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-element/marker.js
  var Marker = class _Marker extends PseudoElementSelector {
    static of() {
      return new _Marker();
    }
    constructor() {
      super("marker");
    }
    *[Symbol.iterator]() {
      yield this;
    }
  };
  (function(Marker2) {
    Marker2.parse = PseudoElementSelector.parseNonLegacy("marker", Marker2.of);
  })(Marker || (Marker = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-element/part.js
  var { map: map116, separatedList: separatedList13 } = Parser;
  var Part = class _Part extends PseudoElementSelector {
    static of(idents) {
      return new _Part(Array2.from(idents));
    }
    _idents;
    constructor(idents) {
      super("part");
      this._idents = idents;
    }
    get idents() {
      return this._idents;
    }
    *[Symbol.iterator]() {
      yield this;
    }
    equals(value) {
      return value instanceof _Part && Array2.equals(value._idents, this._idents);
    }
    toJSON() {
      return {
        ...super.toJSON(),
        idents: Array2.toJSON(this._idents)
      };
    }
    toString() {
      return `::${this.name}(${this._idents})`;
    }
  };
  (function(Part2) {
    Part2.parse = map116(Function.parse("part", separatedList13(Token.parseIdent(), Token.parseWhitespace)), ([_, idents]) => Part2.of(idents));
  })(Part || (Part = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-element/placeholder.js
  var Placeholder = class _Placeholder extends PseudoElementSelector {
    static of() {
      return new _Placeholder();
    }
    constructor() {
      super("placeholder");
    }
    *[Symbol.iterator]() {
      yield this;
    }
  };
  (function(Placeholder2) {
    Placeholder2.parse = PseudoElementSelector.parseNonLegacy("placeholder", Placeholder2.of);
  })(Placeholder || (Placeholder = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-element/selection.js
  var Selection = class _Selection extends PseudoElementSelector {
    static of() {
      return new _Selection();
    }
    constructor() {
      super("selection");
    }
    *[Symbol.iterator]() {
      yield this;
    }
  };
  (function(Selection2) {
    Selection2.parse = PseudoElementSelector.parseNonLegacy("selection", Selection2.of);
  })(Selection || (Selection = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-element/slotted.js
  var { map: map117, right: right35, take: take8 } = Parser;
  var Slotted = class _Slotted extends PseudoElementSelector {
    static of(selector) {
      return new _Slotted(selector);
    }
    _selector;
    constructor(selector) {
      super("slotted", Specificity.sum(selector.specificity, Specificity.of(0, 0, 1)));
      this._selector = selector;
    }
    get selector() {
      return this._selector;
    }
    /**
     * @remarks
     * `::slotted` never aliases an element in its own tree.
     */
    matches() {
      return false;
    }
    *[Symbol.iterator]() {
      yield this;
    }
    equals(value) {
      return value instanceof _Slotted && value._selector.equals(this._selector);
    }
    toJSON() {
      return {
        ...super.toJSON(),
        selector: this._selector.toJSON()
      };
    }
    toString() {
      return `::${this.name}(${this._selector})`;
    }
  };
  (function(Slotted2) {
    function isSlotted(value) {
      return value instanceof Slotted2;
    }
    Slotted2.isSlotted = isSlotted;
    function matchSlotted(element, selector, context = Context.empty()) {
      const slotSelectors = [];
      const qualifier = [];
      const selectors = selector.type === "compound" ? selector.selectors : [selector];
      let actualSelector = None;
      let seen = false;
      for (const candidate of selectors) {
        if (Slotted2.isSlotted(candidate)) {
          if (actualSelector.isSome()) {
            return false;
          }
          actualSelector = Option.of(candidate);
          seen = true;
        } else if (seen) {
          qualifier.push(candidate);
        } else {
          slotSelectors.push(candidate);
        }
      }
      const slot = element.assignedSlot();
      return (
        // `element` must be slotted.
        slot.some((slot2) => (
          // The slot must match the slot selectors, if any.
          slotSelectors.every((selector2) => selector2.matches(slot2, context))
        )) && // There must be an actual ::slotted selector.
        actualSelector.some((slotted) => (
          // `element` must match the argument of the actual ::slotted selector.
          slotted.selector.matches(element, context)
        )) && // `element` must match the qualifier, if any.
        qualifier.every((selector2) => selector2.matches(element, context))
      );
    }
    Slotted2.matchSlotted = matchSlotted;
    function parse57(parseSelector) {
      return map117(right35(take8(Token.parseColon, 2), Function.parse("slotted", parseSelector)), ([_, selector]) => Slotted2.of(selector));
    }
    Slotted2.parse = parse57;
  })(Slotted || (Slotted = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-element/spelling-error.js
  var SpellingError = class _SpellingError extends PseudoElementSelector {
    static of() {
      return new _SpellingError();
    }
    constructor() {
      super("spelling-error");
    }
    *[Symbol.iterator]() {
      yield this;
    }
  };
  (function(SpellingError2) {
    SpellingError2.parse = PseudoElementSelector.parseNonLegacy("spelling-error", SpellingError2.of);
  })(SpellingError || (SpellingError = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-element/target-text.js
  var TargetText = class _TargetText extends PseudoElementSelector {
    static of() {
      return new _TargetText();
    }
    constructor() {
      super("target-text");
    }
    *[Symbol.iterator]() {
      yield this;
    }
  };
  (function(TargetText2) {
    TargetText2.parse = PseudoElementSelector.parseNonLegacy("target-text", TargetText2.of);
  })(TargetText || (TargetText = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/pseudo-element/index.js
  var { either: either97, filter: filter11 } = Parser;
  var { or: or8 } = Refinement;
  var PseudoElement;
  (function(PseudoElement2) {
    function isPseudoElement(value) {
      return value instanceof PseudoElementSelector;
    }
    PseudoElement2.isPseudoElement = isPseudoElement;
    function parse57(parseSelector) {
      return either97(After.parse, Before.parse, Cue.parse(parseSelector), CueRegion.parse(parseSelector), FirstLetter.parse, FirstLine.parse, Backdrop.parse, FileSelectorButton.parse, GrammarError.parse, Marker.parse, Part.parse, Placeholder.parse, Selection.parse, Slotted.parse(() => filter11(parseSelector(), or8(Compound.isCompound, Simple.isSimple), () => "::slotted() only accepts compound selectors")), SpellingError.parse, TargetText.parse);
    }
    PseudoElement2.parse = parse57;
  })(PseudoElement || (PseudoElement = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/type.js
  var { map: map118 } = Parser;
  var Type3 = class _Type extends WithName {
    static of(namespace, name) {
      return new _Type(namespace, name);
    }
    _namespace;
    _key;
    constructor(namespace, name) {
      super("type", name, Specificity.of(0, 0, 1));
      this._namespace = namespace;
      this._key = Option.of(this);
    }
    get namespace() {
      return this._namespace;
    }
    matches(element) {
      if (this._name !== element.name) {
        return false;
      }
      if (this._namespace.isNone() || this._namespace.includes("*")) {
        return true;
      }
      return element.namespace.equals(this._namespace);
    }
    equals(value) {
      return value instanceof _Type && value._namespace.equals(this._namespace) && value._name === this._name;
    }
    *[Symbol.iterator]() {
      yield this;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        namespace: this._namespace.getOr(null)
      };
    }
    toString() {
      const namespace = this._namespace.map((namespace2) => `${namespace2}|`).getOr("");
      return `${namespace}${this._name}`;
    }
  };
  (function(Type4) {
    function isType(value) {
      return value instanceof Type4;
    }
    Type4.isType = isType;
    Type4.parse = map118(parseName, ([namespace, name]) => Type4.of(namespace, name));
  })(Type3 || (Type3 = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/universal.js
  var { left: left19, map: map119, option: option61 } = Parser;
  var Universal = class _Universal extends Selector {
    static of(namespace) {
      return new _Universal(namespace);
    }
    static _empty = new _Universal(None);
    static empty() {
      return this._empty;
    }
    _namespace;
    constructor(namespace) {
      super("universal", Specificity.empty());
      this._namespace = namespace;
    }
    get namespace() {
      return this._namespace;
    }
    matches(element) {
      if (this._namespace.isNone() || this._namespace.includes("*")) {
        return true;
      }
      return element.namespace.equals(this._namespace);
    }
    equals(value) {
      return value instanceof _Universal && value._namespace.equals(this._namespace);
    }
    *[Symbol.iterator]() {
      yield this;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        namespace: this._namespace.getOr(null)
      };
    }
    toString() {
      const namespace = this._namespace.map((namespace2) => `${namespace2}|`).getOr("");
      return `${namespace}*`;
    }
  };
  (function(Universal2) {
    function isUniversal(value) {
      return value instanceof Universal2;
    }
    Universal2.isUniversal = isUniversal;
    Universal2.parse = map119(left19(option61(parseNamespace), Token.parseDelim("*")), (namespace) => Universal2.of(namespace));
  })(Universal || (Universal = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/simple/index.js
  var { either: either98 } = Parser;
  var Simple;
  (function(Simple2) {
    function isSimple(value) {
      return Type3.isType(value) || Universal.isUniversal(value) || Attribute2.isAttribute(value) || Class.isClass(value) || Id.isId(value) || PseudoClass.isPseudoClass(value) || PseudoElement.isPseudoElement(value);
    }
    Simple2.isSimple = isSimple;
    Simple2.parse = (parseSelector) => either98(Class.parse, Type3.parse, Attribute2.parse, Id.parse, Universal.parse, PseudoClass.parse(parseSelector), PseudoElement.parse(parseSelector));
  })(Simple || (Simple = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/compound.js
  var { map: map120, oneOrMore: oneOrMore3 } = Parser;
  var Compound = class _Compound extends Selector {
    static of(...selectors) {
      return new _Compound(selectors);
    }
    _selectors;
    _length;
    _key;
    constructor(selectors) {
      super("compound", Specificity.sum(...selectors.map((selector) => selector.specificity)));
      this._selectors = selectors;
      this._length = selectors.length;
      this._key = selectors[0]?.key ?? None;
    }
    get selectors() {
      return this._selectors;
    }
    get length() {
      return this._length;
    }
    matches(element, context) {
      return this._selectors.every((selector) => selector.matches(element, context));
    }
    equals(value) {
      return value instanceof _Compound && Array2.equals(value._selectors, this._selectors);
    }
    *[Symbol.iterator]() {
      yield this;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        selectors: this._selectors.map((selector) => selector.toJSON())
      };
    }
    toString() {
      return this._selectors.map((selector) => selector.toString()).join("");
    }
  };
  (function(Compound2) {
    function isCompound(value) {
      return value instanceof Compound2;
    }
    Compound2.isCompound = isCompound;
    Compound2.parseCompound = (parseSelector) => map120(oneOrMore3(Simple.parse(parseSelector)), (result) => result.length === 1 ? result[0] : Compound2.of(...result));
  })(Compound || (Compound = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/complex.js
  var { isElement: isElement12 } = Element;
  var { map: map121, pair: pair34, zeroOrMore: zeroOrMore6 } = Parser;
  var { and: and11 } = Refinement;
  var Complex = class _Complex extends Selector {
    static of(combinator, left22, right38) {
      return new _Complex(combinator, left22, right38);
    }
    _combinator;
    _left;
    _right;
    _key;
    constructor(combinator, left22, right38) {
      super("complex", Specificity.sum(left22.specificity, right38.specificity));
      this._combinator = combinator;
      this._left = left22;
      this._right = right38;
      this._key = right38.key;
    }
    get combinator() {
      return this._combinator;
    }
    get left() {
      return this._left;
    }
    get right() {
      return this._right;
    }
    /**
     * Does the element match?
     *
     * @remarks
     * This gets pretty hairy when shadow selectors (:host, :host-context,
     * ::slotted) are used in a complex selector.
     * * ::slotted may be used in the rightmost, e.g., `div ::slotted(p)`.
     *   In that case, the full selector matches something in the light,
     *   depending on the structure of the shadow tree. Thus, the full selector must
     *   be considered as a shadow selector (it matches out of its tree), and this
     *   can simply use tree traversal options to navigate the flat tree
     *   structure. However, the actual match toward the element must use the
     *   advanced #matchSlotted.
     * * :host and :host-context may be used as the leftmost, e.g., `:host(.foo) p`.
     *   This is useful to let users customise components through a simple
     *   class name on the custom element. In this case, the full selector
     *   matches something in the shadow tree and the full selector must **not**
     *   be considered as shadow selector (it matches in its own tree). But upon
     *   hitting the :host or :host-context, the matching must be delegated to
     *   the advance #matchHost (and jump over the shadow root to the actual
     *   host).
     *
     * @privateRemarks
     * Due to the recursive nature of the check, we oversimplify it a bit.
     * Namely, we do not really check that ::slotted appears in the rightmost
     * position only. This means that we incorrectly match thinks like
     * `div ::slotted(*) span` to a <span> descendant **in the light tree** of the
     * slotted element. This is incorrect, see CSS discussions about the
     * deprecated ::content. However, this shouldn't be a problem because
     * Selector.isShadow classify complex selectors by the presence of
     * ::slotted in the rightmost position only. Therefore, such a selector
     * will try to match in its own tree and fail to match the slotted element.
     *
     * In the rare case where (i) people use this incorrect structure and (ii)
     * it happens that there is a sub-shadow tree with structure similar enough
     * to cause the match, this will be incorrect, but we can probably live with
     * it until we see it.
     */
    matches(element, context) {
      let traversal = Node4.Traversal.empty;
      let rightMatches = false;
      if (Slotted.isSlotted(this._right) || Compound.isCompound(this._right) && Iterable.some(this._right.selectors, Slotted.isSlotted)) {
        traversal = Node4.flatTree;
        rightMatches = Slotted.matchSlotted(element, this._right, context);
      } else {
        rightMatches = this._right.matches(element, context);
      }
      if (rightMatches) {
        let leftMatches = this._left.matches.bind(this._left);
        let filter13 = isElement12;
        let inShadow = false;
        if (Host.isHost(this._left) || HostContext.isHostContext(this._left)) {
          leftMatches = this._left.matchHost.bind(this._left);
          traversal = Node4.flatTree;
          filter13 = and11(isElement12, (element2) => element2.shadow.isSome());
          inShadow = true;
        }
        switch (this._combinator) {
          case Combinator.Descendant:
            return inShadow ? element.ancestors(traversal).filter(filter13).some((element2) => leftMatches(element2, context)) : this.ancestorMatchesLeft(element, context);
          case Combinator.DirectDescendant:
            return element.parent(traversal).filter(filter13).some((element2) => leftMatches(element2, context));
          case Combinator.Sibling:
            return element.preceding(traversal).filter(filter13).some((element2) => leftMatches(element2, context));
          case Combinator.DirectSibling:
            return element.preceding(traversal).find(filter13).some((element2) => leftMatches(element2, context));
        }
      }
      return false;
    }
    _ancestorMatchCache = Cache2.empty();
    /**
     * Checks if a (strict) ancestor of element matches.
     *
     * @remarks
     * The result is cached, so that when matching `div.foo li`, we do not waste
     * time going all the way to the root for every `<li>`, instead we'll stop at
     * the first ancestor already encountered, e.g., the common parent `<ul>` of
     * a bunch of siblings `<li>`.
     */
    ancestorMatchesLeft(element, context = Context.empty()) {
      return this._ancestorMatchCache.get(element, Cache2.empty).get(context, () => element.parent().filter(isElement12).some((parent) => this._left.matches(parent, context) || this.ancestorMatchesLeft(parent, context)));
    }
    equals(value) {
      return value instanceof _Complex && value._combinator === this._combinator && value._left.equals(this._left) && value._right.equals(this._right);
    }
    *[Symbol.iterator]() {
      yield this;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        combinator: this._combinator,
        left: this._left.toJSON(),
        right: this._right.toJSON()
      };
    }
    toString() {
      const combinator = this._combinator === Combinator.Descendant ? " " : ` ${this._combinator} `;
      return `${this._left}${combinator}${this._right}`;
    }
  };
  (function(Complex2) {
    function isComplex2(value) {
      return value instanceof Complex2;
    }
    Complex2.isComplex = isComplex2;
    Complex2.parseComplex = (parseSelector) => map121(pair34(Compound.parseCompound(parseSelector), zeroOrMore6(pair34(Combinator.parseCombinator, Compound.parseCompound(parseSelector)))), (result) => {
      const [left22, selectors] = result;
      return Iterable.reduce(selectors, (left23, [combinator, right38]) => Complex2.of(combinator, left23, right38), left22);
    });
  })(Complex || (Complex = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/list.js
  var { map: map122, separatedList: separatedList14 } = Parser;
  var List4 = class _List extends Selector {
    static of(...selectors) {
      return new _List(selectors);
    }
    _selectors;
    _length;
    constructor(selectors) {
      super("list", Specificity.max(...selectors.map((selector) => selector.specificity)));
      this._selectors = selectors;
      this._length = selectors.length;
    }
    get selectors() {
      return this._selectors;
    }
    get length() {
      return this._length;
    }
    matches(element, context) {
      return this._selectors.some((selector) => selector.matches(element, context));
    }
    equals(value) {
      return value instanceof _List && Array2.equals(value._selectors, this._selectors);
    }
    *[Symbol.iterator]() {
      yield* this._selectors;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        selectors: Array2.toJSON(this._selectors)
      };
    }
    toString() {
      return this._selectors.map((selector) => selector.toString()).join(", ");
    }
  };
  (function(List5) {
    List5.parseList = (parseSelector) => map122(separatedList14(Complex.parseComplex(parseSelector), Comma.parse), (result) => List5.of(...result));
  })(List4 || (List4 = {}));

  // node_modules/@siteimprove/alfa-selector/dist/selector/index.js
  var { end: end8, left: left20, map: map123 } = Parser;
  var { and: and12, or: or9, test: test10 } = Refinement;
  var Selector2;
  (function(Selector3) {
    function hasSlotted(selector) {
      return test10(or9(
        Slotted.isSlotted,
        and12(Compound.isCompound, (compound) => Iterable.some(compound.selectors, Slotted.isSlotted)),
        // `::slotted` only works in the rightmost position of complex selectors.
        and12(Complex.isComplex, (complex) => hasSlotted(complex.right))
      ), selector);
    }
    Selector3.hasSlotted = hasSlotted;
    Selector3.isHostSelector = or9(Host.isHost, HostContext.isHostContext);
    Selector3.isShadow = or9(Selector3.isHostSelector, hasSlotted);
    function matchSlotted(selector, slotted, context = Context.empty()) {
      return hasSlotted(selector) && (Slotted.isSlotted(selector) || Compound.isCompound(selector) ? Slotted.matchSlotted(slotted, selector, context) : selector.matches(slotted, context));
    }
    Selector3.matchSlotted = matchSlotted;
    function parseSelector() {
      return left20(map123(List4.parseList(parseSelector), (list) => list.length === 1 ? Iterable.first(list.selectors).getUnsafe() : list), end8((token) => `Unexpected token ${token}`));
    }
    Selector3.parse = parseSelector();
  })(Selector2 || (Selector2 = {}));

  // node_modules/@siteimprove/alfa-cascade/dist/ancestor-filter.js
  var AncestorFilter = class _AncestorFilter {
    static empty() {
      return new _AncestorFilter();
    }
    _ids = Bucket.empty();
    _classes = Bucket.empty();
    _types = Bucket.empty();
    constructor() {
    }
    add(element) {
      for (const id of element.id) {
        this._ids.add(id);
      }
      this._types.add(element.name);
      for (const className of element.classes) {
        this._classes.add(className);
      }
    }
    remove(element) {
      for (const id of element.id) {
        this._ids.remove(id);
      }
      this._types.remove(element.name);
      for (const className of element.classes) {
        this._classes.remove(className);
      }
    }
    /**
     * @internal
     */
    matches(selector) {
      if (Id.isId(selector)) {
        return this._ids.has(selector.name);
      }
      if (Class.isClass(selector)) {
        return this._classes.has(selector.name);
      }
      if (Type3.isType(selector)) {
        return this._types.has(selector.name);
      }
      return false;
    }
    /**
     * Check if a selector can be rejected based on the ancestor filter.
     */
    canReject(selector) {
      if (Id.isId(selector) || Class.isClass(selector) || Type3.isType(selector)) {
        return !this.matches(selector);
      }
      if (Compound.isCompound(selector)) {
        return Iterable.some(selector.selectors, (selector2) => this.canReject(selector2));
      }
      if (Complex.isComplex(selector)) {
        const { combinator } = selector;
        if (combinator === Combinator.Descendant || combinator === Combinator.DirectDescendant) {
          return this.canReject(selector.right) || this.canReject(selector.left);
        }
      }
      return false;
    }
    toJSON() {
      return {
        ids: this._ids.toJSON(),
        classes: this._classes.toJSON(),
        types: this._types.toJSON()
      };
    }
  };
  var Bucket = class _Bucket {
    static empty() {
      return new _Bucket();
    }
    _entries = /* @__PURE__ */ new Map();
    constructor() {
    }
    has(entry) {
      return this._entries.has(entry);
    }
    add(entry) {
      const count = this._entries.get(entry);
      if (count === void 0) {
        this._entries.set(entry, 1);
      } else {
        this._entries.set(entry, count + 1);
      }
    }
    remove(entry) {
      const count = this._entries.get(entry);
      if (count === void 0) {
        return;
      }
      if (count === 1) {
        this._entries.delete(entry);
      } else {
        this._entries.set(entry, count - 1);
      }
    }
    toJSON() {
      return [...this._entries];
    }
  };

  // node_modules/@siteimprove/alfa-cascade/dist/precedence/encapsulation.js
  var Encapsulation;
  (function(Encapsulation2) {
    Encapsulation2.compare = Comparable.compareNumber;
  })(Encapsulation || (Encapsulation = {}));

  // node_modules/@siteimprove/alfa-cascade/dist/precedence/layer.js
  var Layer2 = class _Layer {
    static of(name, importance) {
      return new _Layer(false, name, importance, NaN);
    }
    static _empty = new _Layer(true, "", false, -Infinity);
    static empty() {
      return this._empty;
    }
    // Fully qualified name, including dot-separated path.
    _name;
    // Storing importance of blocks in this layer helps computing order.
    _importance;
    _ordered;
    _order;
    constructor(ordered, name, importance, order) {
      this._name = name;
      this._importance = importance;
      this._ordered = ordered;
      this._order = order;
    }
    get name() {
      return this._name;
    }
    get order() {
      return this._order;
    }
    get importance() {
      return this._importance;
    }
    get isOrdered() {
      return this._ordered;
    }
    /**
     * Mutate the layer by setting the order.
     *
     * @remarks
     * This actually mutates the layer, it does not create a new one.
     * This is on purpose to automatically update all blocks using this layer.
     */
    withOrder(order) {
      const that = this;
      that._ordered = true;
      that._order = order;
      return that;
    }
    compare(value) {
      return Comparable.compareNumber(this._order, value._order);
    }
    equals(value) {
      return value instanceof _Layer && value._name === this._name && value._order === this._order;
    }
    toJSON() {
      return {
        name: this._name,
        order: this._order
      };
    }
  };
  (function(Layer4) {
    Layer4.compare = (a, b) => a.compare(b);
    function sortUnordered(layers) {
      return Array2.copy(layers).sort(compareUnordered(layers)).map(({ name, normal, important }, idx) => ({
        name,
        // We skip 0 for the sake of having different order on each layer
        normal: normal.withOrder(-idx - 1),
        important: important.withOrder(idx + 1)
      }));
    }
    Layer4.sortUnordered = sortUnordered;
    function compareUnordered(layers) {
      return (a, b) => {
        if (a.name === b.name) {
          return Comparison.Equal;
        }
        const pathA = a.name.split(".");
        const pathB = b.name.split(".");
        const short = Math.min(pathA.length, pathB.length);
        let i = 0;
        while (i < short && pathA[i] === pathB[i]) {
          i++;
        }
        const common = pathA.slice(0, i).join(".");
        if (common === a.name) {
          return Comparison.Less;
        }
        if (common === b.name) {
          return Comparison.Greater;
        }
        const divergeA = pathA.slice(0, i + 1).join(".");
        const divergeB = pathB.slice(0, i + 1).join(".");
        return Comparable.compareNumber(-layers.findIndex((layer) => layer.name === divergeA), -layers.findIndex((layer) => layer.name === divergeB));
      };
    }
    Layer4.compareUnordered = compareUnordered;
  })(Layer2 || (Layer2 = {}));

  // node_modules/@siteimprove/alfa-cascade/dist/precedence/order.js
  var Order;
  (function(Order2) {
    Order2.compare = Comparable.compareNumber;
  })(Order || (Order = {}));

  // node_modules/@siteimprove/alfa-cascade/dist/precedence/origin.js
  var Origin;
  (function(Origin2) {
    Origin2[Origin2["NormalUserAgent"] = 1] = "NormalUserAgent";
    Origin2[Origin2["NormalUser"] = 2] = "NormalUser";
    Origin2[Origin2["NormalAuthor"] = 3] = "NormalAuthor";
    Origin2[Origin2["Animation"] = 4] = "Animation";
    Origin2[Origin2["ImportantAuthor"] = 5] = "ImportantAuthor";
    Origin2[Origin2["ImportantUser"] = 6] = "ImportantUser";
    Origin2[Origin2["ImportantUserAgent"] = 7] = "ImportantUserAgent";
    Origin2[Origin2["Transition"] = 8] = "Transition";
  })(Origin || (Origin = {}));
  (function(Origin2) {
    function isImportant3(origin) {
      return Origin2.ImportantAuthor <= origin && origin <= Origin2.ImportantUserAgent;
    }
    Origin2.isImportant = isImportant3;
    function isAuthor(origin) {
      return origin === Origin2.NormalAuthor || origin === Origin2.ImportantAuthor;
    }
    Origin2.isAuthor = isAuthor;
    Origin2.compare = Comparable.compareNumber;
  })(Origin || (Origin = {}));

  // node_modules/@siteimprove/alfa-cascade/dist/precedence/precedence.js
  var Precedence;
  (function(Precedence2) {
    Precedence2.empty = {
      origin: Origin.NormalUserAgent,
      encapsulation: -1,
      isElementAttached: false,
      layer: Layer2.empty(),
      specificity: Specificity.empty(),
      order: -Infinity
    };
    function toJSON(precedence) {
      return {
        origin: precedence.origin,
        encapsulation: precedence.encapsulation,
        isElementAttached: precedence.isElementAttached,
        layer: precedence.layer.toJSON(),
        specificity: precedence.specificity.toJSON(),
        order: precedence.order
      };
    }
    Precedence2.toJSON = toJSON;
    function isImportant3(precedence) {
      return Origin.isImportant(precedence.origin);
    }
    Precedence2.isImportant = isImportant3;
    function toTuple(precedence) {
      return [
        precedence.origin,
        precedence.encapsulation,
        precedence.isElementAttached,
        precedence.layer,
        precedence.specificity,
        precedence.order
      ];
    }
    Precedence2.toTuple = toTuple;
    function equals34(a, b) {
      return a.origin === b.origin && a.encapsulation === b.encapsulation && a.isElementAttached === b.isElementAttached && a.layer.equals(b.layer) && a.specificity.equals(b.specificity) && a.order === b.order;
    }
    Precedence2.equals = equals34;
    Precedence2.compare = (a, b) => Comparable.compareLexicographically(toTuple(a), toTuple(b), [
      Origin.compare,
      Encapsulation.compare,
      // In JS, true > false. This matches the behaviour of declarations from
      // a style attribute (isElementAttached = true) taking precedence over
      // declarations from a style rule.
      Comparable.compareBoolean,
      Layer2.compare,
      Specificity.compare,
      Order.compare
    ]);
  })(Precedence || (Precedence = {}));

  // node_modules/@siteimprove/alfa-cascade/dist/user-agent.js
  var UserAgent = h.sheet([
    h.rule.namespace("http://www.w3.org/1999/xhtml"),
    /**
     * {@link https://html.spec.whatwg.org/#hidden-elements}
     */
    h.rule.style("[hidden], base, basefont, datalist, head, link, meta, noembed, noframes, param, rp, script, source, style, template, track, title", {
      display: "none"
    }),
    // <area> elements are a little special in that while they are not rendered,
    // they are focusable for the purpose of users interacting with the image
    // reference of the <area> element. To accommodate this, we assign them a
    // default display property of inline rather than none.
    h.rule.style("area", {
      display: "inline"
    }),
    h.rule.style("embed[hidden]", {
      display: "inline",
      height: "0",
      width: "0"
    }),
    h.rule.style("input[type=hidden i]", {
      display: "none !important"
    }),
    h.rule.media("(scripting)", [
      h.rule.style("noscript", {
        display: "none !important"
      })
    ]),
    /**
     * {@link https://html.spec.whatwg.org/#the-page}
     */
    h.rule.style("html, body", {
      display: "block"
    }),
    /**
     * {@link https://html.spec.whatwg.org/#flow-content-3}
     */
    h.rule.style("address, blockquote, center, div, figure, figcaption, footer, form, header, hr, legend, listing, main, p, plaintext, pre, xmp", {
      display: "block"
    }),
    h.rule.style("dialog:not([open])", {
      display: "none"
    }),
    h.rule.style("dialog", {
      background: "white",
      color: "black"
    }),
    h.rule.style("dialog::backdrop", {
      background: "rgb(0 0 0 / 0.1)"
    }),
    h.rule.style("slot", {
      display: "contents"
    }),
    /**
     * {@link https://html.spec.whatwg.org/#phrasing-content-3}
     */
    h.rule.style("cite, dfn, em, i, var", { fontStyle: "italic" }),
    h.rule.style("b, strong", { fontWeight: "bolder" }),
    h.rule.style("code, kbd, samp, tt", { fontFamily: "monospace" }),
    h.rule.style("big", { fontSize: "larger" }),
    h.rule.style("small", { fontSize: "smaller" }),
    h.rule.style("sub", { verticalAlign: "sub" }),
    h.rule.style("sup", { verticalAlign: "super" }),
    h.rule.style("ruby", { display: "ruby" }),
    h.rule.style("rt", { display: "ruby-text" }),
    h.rule.style(":link", { color: "#0000ee" }),
    h.rule.style(":visited", { color: "#551a8b" }),
    h.rule.style(":link:active, :visited:active", { color: "#ff0000" }),
    h.rule.style(":link, :visited", {
      textDecoration: "underline",
      cursor: "pointer"
    }),
    h.rule.style(":focus", { outline: "auto" }),
    h.rule.style("mark", { background: "yellow", color: "black" }),
    h.rule.style("ins, u", { textDecoration: "underline" }),
    h.rule.style("del, s, strike", { textDecoration: "line-through" }),
    /**
     * {@link https://html.spec.whatwg.org/#sections-and-headings}
     */
    h.rule.style("article, aside, h1, h2, h3, h4, h5, h6, hgroup, nav, section", {
      display: "block"
    }),
    h.rule.style("h1", { fontSize: "2.00em", fontWeight: "bold" }),
    h.rule.style("h2", { fontSize: "1.50em", fontWeight: "bold" }),
    h.rule.style("h3", { fontSize: "1.17em", fontWeight: "bold" }),
    h.rule.style("h4", { fontSize: "1.00em", fontWeight: "bold" }),
    h.rule.style("h5", { fontSize: "0.83em", fontWeight: "bold" }),
    h.rule.style("h6", { fontSize: "0.67em", fontWeight: "bold" }),
    /**
     * {@link https://html.spec.whatwg.org/#section-lists}
     */
    h.rule.style("dir, dd, dl, dt, ol, ul", { display: "block" }),
    h.rule.style("li", { display: "list-item" }),
    /**
     * {@link https://html.spec.whatwg.org/#tables}
     */
    h.rule.style("table", { display: "table" }),
    h.rule.style("caption", { display: "table-caption" }),
    h.rule.style("colgroup, colgroup[hidden]", { display: "table-column-group" }),
    h.rule.style("col, col[hidden]", { display: "table-column" }),
    h.rule.style("thead, thead[hidden]", { display: "table-header-group" }),
    h.rule.style("tbody, tbody[hidden]", { display: "table-row-group" }),
    h.rule.style("tfoot, tfoot[hidden]", { display: "table-footer-group" }),
    h.rule.style("tr, tr[hidden]", { display: "table-row" }),
    h.rule.style("td, th, td[hidden], th[hidden]", { display: "table-cell" }),
    h.rule.style("colgroup[hidden], col[hidden], thead[hidden], tbody[hidden], tfoot[hidden], tr[hidden], td[hidden], th[hidden]", {
      visibility: "collapse"
    }),
    h.rule.style("th", { fontWeight: "bold" }),
    h.rule.style(":is(table, thead, tbody, tfoot, tr) > form", {
      display: "none !important"
    }),
    /**
     * {@link https://html.spec.whatwg.org/#form-controls}
     */
    h.rule.style("input, select, button, textarea", {
      letterSpacing: "initial",
      wordSpacing: "initial",
      lineHeight: "initial",
      textTransform: "initial",
      textIndent: "initial",
      textShadow: "initial"
    }),
    h.rule.style("input, select, textarea", {
      textAlign: "initial"
    }),
    /**
     * {@link https://html.spec.whatwg.org/multipage/rendering.html#the-select-element-2}
     */
    h.rule.style("select", { display: "inline-block" }),
    h.rule.style("input:is([type=reset i], [type=button i], [type=submit i]), button", {
      textAlign: "center"
    }),
    h.rule.style("input:is([type=reset i], [type=button i], [type=submit i], [type=color i]), button", {
      display: "inline-block"
    }),
    h.rule.style("input:is([type=radio i], [type=checkbox i], [type=reset i], [type=button i], [type=submit i], [type=color i], [type=search i]), select, button", {
      boxSizing: "border-box"
    }),
    h.rule.style("textarea", { whiteSpace: "pre-wrap" }),
    h.rule.style("button", {
      // <button> element defaults applied consistently by browsers.
      fontStyle: "normal",
      fontWeight: "400",
      // <button> colors differ between browsers, additionally they can be
      // overwritten by OS settings which we do not really have access to (although
      // forced-color media query could help), so we default to the system color.
      // as of 21.09.23, Chrome uses rgb(240, 240, 240) but Firefox uses
      // rgb(233, 233, 233).
      backgroundColor: "buttonface"
      // color seems to rather consistently defaults to black, which is the default.
      // color: "buttontext",
    }),
    /**
     * {@link https://html.spec.whatwg.org/#the-hr-element-rendering}
     */
    h.rule.style("hr", {
      color: "gray",
      overflow: "hidden"
    }),
    /**
     * {@link https://html.spec.whatwg.org/#the-fieldset-and-legend-elements}
     */
    h.rule.style("fieldset", {
      display: "block"
    })
  ]);

  // node_modules/@siteimprove/alfa-cascade/dist/block.js
  var Block3 = class _Block {
    /**
     * Create a block.
     *
     * @remarks
     * This does not validate coupling of the data. Prefer using Block.from()
     *
     * @privateRemarks
     * We need to accept unlayered blocks since this is how they are built.
     */
    static of(source, declarations, precedence) {
      return new _Block(source, Array2.from(declarations), precedence);
    }
    static _empty = new _Block({
      rule: h.rule.style("*", []),
      selector: Universal.of(None)
    }, [], Precedence.empty);
    /**
     * @internal
     */
    static empty() {
      return this._empty;
    }
    // These could be Options instead.
    // However, these (especially the selector) are used on hot path when
    // resolving cascade. Having them nullable, and encoding the nullability
    // in the type, allow for direct access without the small overhead of Options.
    _rule;
    _selector;
    _owner;
    _declarations;
    _precedence;
    constructor(source, declarations, precedence) {
      if (Element.isElement(source)) {
        this._rule = null;
        this._selector = null;
        this._owner = source;
      } else {
        this._rule = source.rule;
        this._selector = source.selector;
        this._owner = null;
      }
      this._declarations = declarations;
      this._precedence = precedence;
    }
    get source() {
      return this._owner !== null ? this._owner : (
        // By construction if owner is unset, then rule and selector are set.
        { rule: this._rule, selector: this._selector }
      );
    }
    get rule() {
      return this._rule;
    }
    get selector() {
      return this._selector;
    }
    get owner() {
      return this._owner;
    }
    get declarations() {
      return this._declarations;
    }
    get precedence() {
      return this._precedence;
    }
    equals(value) {
      return value instanceof _Block && Equatable.equals(value._rule, this._rule) && Equatable.equals(value._selector, this._selector) && Equatable.equals(value._owner, this._owner) && Array2.equals(value._declarations, this._declarations) && Precedence.equals(value._precedence, this._precedence);
    }
    toJSON() {
      return {
        source: Element.isElement(this._owner) ? this._owner.toJSON() : {
          rule: this._rule.toJSON(),
          selector: Serializable.toJSON(this._selector)
        },
        declarations: Array2.toJSON(this._declarations),
        precedence: Precedence.toJSON(this._precedence)
      };
    }
  };
  (function(Block4) {
    function from(rule, order, encapsulationDepth, layer) {
      const blocks = [];
      for (const [_, selectors] of Selector2.parse(Lexer.lex(rule.selector))) {
        order++;
        for (const [importance, declarations] of Iterable.groupBy(rule.style.declarations, (declaration) => declaration.important)) {
          const origin = rule.owner.includes(UserAgent) ? importance ? Origin.ImportantUserAgent : Origin.NormalUserAgent : importance ? Origin.ImportantAuthor : Origin.NormalAuthor;
          for (const selector of selectors) {
            const encapsulation = importance ? (
              // Important declarations have positive encapsulation depth, deeper wins.
              encapsulationDepth
            ) : (
              // Normal declarations have negative encapsulation depth, deeper loses.
              -encapsulationDepth
            );
            blocks.push(Block4.of({ rule, selector }, declarations, {
              origin,
              encapsulation,
              isElementAttached: false,
              layer: importance ? layer.important : layer.normal,
              order,
              specificity: selector.specificity
            }));
          }
        }
      }
      return [blocks, order];
    }
    Block4.from = from;
    function fromStyle(element, encapsulationDepth) {
      return element.style.map((style) => Iterable.map(Iterable.groupBy(style.declarations, (declaration) => declaration.important), ([importance, declarations]) => Block4.of(element, declarations, {
        origin: importance ? Origin.ImportantAuthor : Origin.NormalAuthor,
        encapsulation: importance ? (
          // Important declarations have positive encapsulation depth, deeper wins.
          encapsulationDepth
        ) : (
          // Normal declarations have negative encapsulation depth, deeper loses.
          -encapsulationDepth
        ),
        isElementAttached: true,
        // Since style attribute trumps layer, specificity and order in the cascade sort,
        // and there is at most one style attribute per element,
        // these never matters and we can use any placeholder.
        layer: Layer2.empty(),
        specificity: Specificity.empty(),
        order: -1
      }))).getOr([]);
    }
    Block4.fromStyle = fromStyle;
    Block4.compare = (a, b) => Precedence.compare(a.precedence, b.precedence);
  })(Block3 || (Block3 = {}));

  // node_modules/@siteimprove/alfa-cascade/dist/rule-tree.js
  var RuleTree = class _RuleTree {
    static empty() {
      return new _RuleTree();
    }
    // Rooting the forest at a fake node with no declaration.
    _root = _RuleTree.Node.of(Block3.empty(), [], None);
    constructor() {
    }
    /**
     * Add a bunch of items to the tree. Returns the last node created, which is
     * the highest precedence node for that list of items.
     *
     * @remarks
     * The rules are assumed to be:
     * 1. all matching the same element; and
     * 2. be all the rules matching that element.
     *
     * It is up to the caller to ensure this is true, as the tree itself cannot
     * check that (notably, it has no access to the DOM tree to ensure the rules
     * match the same element; nor to the origin or order of the rules to check
     * cascade order).
     *
     * @privateRemarks
     * This is stateful. Adding rules to a rule tree does mutate it!
     *
     * @internal
     */
    add(rules) {
      let parent = this._root;
      for (const block of Iterable.sortWith(rules, Block3.compare)) {
        parent = parent.add(block);
      }
      return parent;
    }
    toJSON() {
      return this._root.children.map((node) => node.toJSON());
    }
  };
  (function(RuleTree2) {
    class Node6 {
      static of(block, children, parent) {
        return new Node6(block, children, parent);
      }
      _block;
      _children;
      _parent;
      constructor(block, children, parent) {
        this._block = block;
        this._children = children;
        this._parent = parent;
      }
      get block() {
        return this._block;
      }
      get children() {
        return this._children;
      }
      get parent() {
        return this._parent;
      }
      *ancestors() {
        for (const parent of this._parent) {
          yield parent;
          yield* parent.ancestors();
        }
      }
      *inclusiveAncestors() {
        yield this;
        yield* this.ancestors();
      }
      /**
       * Adds style rule to a node in the tree. Returns the node where the rule
       * was added.
       *
       * @remarks
       * Blocks with no selector, aka coming from a style attribute, will always be
       * added as new nodes.
       *
       * @privateRemarks
       * This is stateful. Adding a rule to a node mutates the node!
       *
       * @internal
       */
      add(block) {
        if (
          // We cannot simply test === between the .selector because we do not
          // want to identify two null.
          (this._block.selector ?? 0) === (block.selector ?? 1) && Precedence.isImportant(this._block.precedence) === Precedence.isImportant(block.precedence)
        ) {
          return this;
        }
        for (const child of this._children) {
          if (
            // We cannot simply test .equals between the .selector because we do not
            // want to identify two None.
            child._block.selector !== null && child._block.selector.equals(block.selector)
          ) {
            return child.add(block);
          }
        }
        const node = Node6.of(block, [], Option.of(this));
        this._children.push(node);
        return node;
      }
      toJSON() {
        return {
          block: this._block.toJSON(),
          children: this._children.map((node) => node.toJSON())
        };
      }
    }
    RuleTree2.Node = Node6;
  })(RuleTree || (RuleTree = {}));

  // node_modules/@siteimprove/alfa-cascade/dist/selector-map.js
  var { equals: equals12, property: property4 } = Predicate;
  var { and: and13 } = Refinement;
  var { isComplex } = Complex;
  var isDescendantSelector = and13(isComplex, property4("combinator", equals12(Combinator.Descendant, Combinator.DirectDescendant)));
  var { isImportRule } = ImportRule;
  var { isLayerBlockRule } = Layer.BlockRule;
  var { isLayerStatementRule } = Layer.StatementRule;
  var { isMediaRule } = MediaRule;
  var { isStyleRule } = StyleRule;
  var { isSupportsRule } = SupportsRule;
  var SelectorMap = class _SelectorMap {
    static of(ids2, classes, types, other, shadow) {
      return new _SelectorMap(ids2, classes, types, other, shadow);
    }
    _ids;
    _classes;
    _types;
    _other;
    _shadow;
    constructor(ids2, classes, types, other, shadow) {
      this._ids = ids2;
      this._classes = classes;
      this._types = types;
      this._other = other;
      this._shadow = shadow;
    }
    /**
     * Get all blocks matching a given element and context, an optional
     * ancestor filter can be provided to optimize performances.
     *
     * @remarks
     * Blocks whose layers haven't been ordered are discarded at that point.
     * Under normal flow, this should only be called once layers have been ordered.
     */
    *get(element, context, filter13) {
      function* collect(candidates) {
        for (const block of candidates) {
          if (isDescendantSelector(block.selector) && filter13.canReject(block.selector.left)) {
            continue;
          }
          if (block.precedence.layer.isOrdered && block.selector.matches(element, context)) {
            yield block;
          }
        }
      }
      for (const id of element.id) {
        yield* collect(this._ids.get(id));
      }
      yield* collect(this._types.get(element.name));
      for (const className of element.classes) {
        yield* collect(this._classes.get(className));
      }
      yield* collect(this._other);
    }
    /**
     * Get all blocks from the "shadow" selectors that match a shadow host.
     *
     * @remarks
     * The host must be the shadow host of the tree whose style sheets define
     * this selector map.
     *
     * Blocks whose layers haven't been ordered are discarded at that point.
     * Under normal flow, this should only be called once layers have been ordered.
     *
     * @privateRemarks
     * Because `:host-context` is searching for shadow-including ancestors of the
     * host, we cannot use the ancestor filter that does not escape its tree.
     * This is therefore fairly costly, and hopefully not too frequent.
     */
    *getForHost(host, context) {
      yield* this._shadow.filter((block) => block.precedence.layer.isOrdered && Selector2.isHostSelector(block.selector) && block.selector.matchHost(host, context));
    }
    /**
     * Get all blocks from the "shadow" selectors that match a slotted element.
     *
     * @remarks
     * `slotted` should be a light node slotted in the tree whose style sheets
     * define this selector map. If this is not the case, all matches will fail.
     *
     * Blocks whose layers haven't been ordered are discarded at that point.
     * Under normal flow, this should only be called once layers have been ordered.
     *
     * @privateRemarks
     * Because this navigates (partly) in the flat tree rather than the normal DOM
     * tree, we cannot easily re-use the ancestor filter.
     */
    *getForSlotted(slotted, context) {
      yield* this._shadow.filter((block) => block.precedence.layer.isOrdered && Selector2.hasSlotted(block.selector) && Selector2.matchSlotted(block.selector, slotted, context));
    }
    toJSON() {
      return {
        ids: this._ids.toJSON(),
        classes: this._classes.toJSON(),
        types: this._types.toJSON(),
        other: this._other.map((node) => node.toJSON()),
        shadow: this._shadow.map((node) => node.toJSON())
      };
    }
  };
  (function(SelectorMap2) {
    function from(sheets, device, encapsulationDepth) {
      let order = 0;
      const ids2 = Bucket2.empty();
      const classes = Bucket2.empty();
      const types = Bucket2.empty();
      const buckets = { id: ids2, class: classes, type: types };
      const other = [];
      const shadow = [];
      const layers = [];
      let anonymousLayers = 0;
      function anonymous() {
        anonymousLayers++;
        return `(anonymous ${anonymousLayers})`;
      }
      function getSingleLayer(name) {
        let layer = layers.find((pair36) => pair36.name === name);
        if (layer === void 0) {
          layer = {
            name,
            normal: Layer2.of(name, false),
            important: Layer2.of(name, true)
          };
          layers.push(layer);
        }
        return layer;
      }
      function getLayer(name) {
        let current = "";
        let layer = getSingleLayer(current);
        for (const segment of name.split(".")) {
          current = (current === "" ? "" : `${current}.`) + segment;
          layer = getSingleLayer(current);
        }
        return layer;
      }
      function nextLayer(current, segment) {
        return getLayer(
          // If the current layer name is not empty, add a dot to it;
          (current.name === "" ? "" : `${current.name}.`) + // add the new segment, or create an anonymous layer.
          Maybe.toOption(segment).getOrElse(anonymous)
        );
      }
      function add(block) {
        const keySelector = block.selector.key;
        if (Selector2.isShadow(block.selector)) {
          shadow.push(block);
          return;
        }
        if (!keySelector.isSome()) {
          other.push(block);
          return;
        }
        const key = keySelector.get();
        buckets[key.type].add(key.name, block);
      }
      const skip3 = () => void 0;
      function visitChildren(visitor) {
        return (rule) => Iterable.forEach(rule.children(), visitor);
      }
      function visit3(layer) {
        return (rule) => Selective.of(rule).ifGuarded(isStyleRule, StyleRule.isEmpty, skip3, (rule2) => {
          let blocks = [];
          [blocks, order] = Block3.from(rule2, order, encapsulationDepth, layer);
          for (const block of blocks) {
            add(block);
          }
        }).ifGuarded(isImportRule, ImportRule.matches(device), (rule2) => Iterable.forEach(rule2.sheet.children(), visit3(
          // Here, we use None for anonymous layers. However, ImportRule
          // uses None for no layer, and Some("") for an anonymous layer.
          rule2.layer.map((name) => nextLayer(layer, name === "" ? None : name)).getOr(layer)
        )), skip3).if(isLayerBlockRule, (rule2) => visitChildren(visit3(nextLayer(layer, rule2.layer)))(rule2)).if(isLayerStatementRule, (rule2) => Iterable.forEach(rule2.layers, (name) => nextLayer(layer, name))).ifGuarded(isMediaRule, MediaRule.matches(device), visitChildren(visit3(layer)), skip3).ifGuarded(isSupportsRule, SupportsRule.matches(device), visitChildren(visit3(layer)), skip3).else(visitChildren(visit3(layer)));
      }
      for (const sheet of Iterable.reject(sheets, (sheet2) => sheet2.disabled)) {
        if (sheet.condition.isSome()) {
          const query = Feature.parseMediaQuery(Lexer.lex(sheet.condition.get()));
          if (query.every(([, query2]) => !query2.matches(device))) {
            continue;
          }
        }
        Iterable.forEach(sheet.children(), visit3(getLayer("")));
      }
      Layer2.sortUnordered(layers);
      return SelectorMap2.of(ids2, classes, types, other, shadow);
    }
    SelectorMap2.from = from;
    class Bucket2 {
      static empty() {
        return new Bucket2(/* @__PURE__ */ new Map());
      }
      _nodes;
      constructor(nodes) {
        this._nodes = nodes;
      }
      add(key, node) {
        const nodes = this._nodes.get(key);
        if (nodes === void 0) {
          this._nodes.set(key, [node]);
        } else {
          nodes.push(node);
        }
      }
      get(key) {
        const nodes = this._nodes.get(key);
        if (nodes === void 0) {
          return [];
        }
        return nodes;
      }
      toJSON() {
        return [...this._nodes].map(([key, nodes]) => [
          key,
          nodes.map((node) => node.toJSON())
        ]);
      }
    }
    SelectorMap2.Bucket = Bucket2;
  })(SelectorMap || (SelectorMap = {}));

  // node_modules/@siteimprove/alfa-cascade/dist/cascade.js
  var Cascade = class _Cascade {
    static _cascades = Cache2.empty();
    static from(node, device) {
      return this._cascades.get(node, Cache2.empty).get(device, () => new _Cascade(node, device));
    }
    _root;
    _depth;
    _device;
    _selectors;
    _rules = RuleTree.empty();
    _entries = Cache2.empty();
    constructor(root, device) {
      this._root = root;
      this._depth = getDepth(root);
      this._device = device;
      this._selectors = SelectorMap.from([UserAgent, ...root.style], device, this._depth);
      const context = Context.empty();
      const filter13 = AncestorFilter.empty();
      const visit3 = (node) => {
        if (Element.isElement(node)) {
          this._entries.get(node, Cache2.empty).get(context, () => this.add(node, context, filter13));
          filter13.add(node);
        }
        for (const child of node.children()) {
          visit3(child);
        }
        if (Element.isElement(node)) {
          filter13.remove(node);
        }
      };
      visit3(root);
    }
    /**
     * Adds an element to the rules tree, return the associated node.
     */
    add(element, context, filter13) {
      const forHost = element.shadow.map((shadow) => (
        // Since selectors can pierce shadow upwards but not downwards, we
        // only recurse downwards and this is safe.
        _Cascade.from(shadow, this._device)._selectors.getForHost(element, context)
      )).getOr([]);
      const forSlotted = element.parent().filter(Element.isElement).flatMap((parent) => parent.shadow).map((shadow) => (
        // Since selectors can pierce shadow upwards but not downwards, we
        // only recurse downwards and this is safe.
        _Cascade.from(shadow, this._device)._selectors.getForSlotted(element, context)
      )).getOr([]);
      return this._rules.add(Iterable.concat(
        // Blocks defined in style sheets of the current tree, that match `element`
        this._selectors.get(element, context, filter13),
        // Blocks defined in the `style` attribute of `element`.
        Block3.fromStyle(element, this._depth),
        forHost,
        forSlotted
      ));
    }
    /**
     * Get the rule tree node associated with an element.
     *
     * @remarks
     * This also adds the element to the rule tree if needed. That is, the rule
     * tree is build lazily upon need. For the empty context, we pre-build the
     * full tree, so we can benefit from an ancestor filter as we traverse the
     * full DOM tree.
     *
     * For other contexts, we assume that we will only need the style of a few elements
     * (e.g., when a link is focused we normally only need the style of the link
     * itself). Therefore, pre-building the full tree is not worth the cost.
     */
    get(element, context = Context.empty()) {
      return this._entries.get(element, Cache2.empty).get(
        context,
        // If the entry hasn't been cached already, we assume we are querying
        // for a single element and pay the price of building its custom ancestor
        // filter, hopefully saving on the matching cost.
        () => {
          const filter13 = AncestorFilter.empty();
          element.ancestors().filter(Element.isElement).forEach(filter13.add.bind(filter13));
          return this.add(element, context, filter13);
        }
      );
    }
    toJSON() {
      return {
        root: this._root.toJSON(),
        device: this._device.toJSON(),
        selectors: this._selectors.toJSON(),
        rules: this._rules.toJSON()
      };
    }
  };
  var shadowDepths = Cache2.empty();
  function getDepth(node) {
    return shadowDepths.get(node, () => {
      if (Shadow2.isShadow(node)) {
        return 1 + node.host.map(getDepth).getOr(0);
      }
      if (Slotable.isSlotable(node)) {
        return node.assignedSlot().map(getDepth).getOr(node.parent().map(getDepth).getOr(1));
      }
      return node.parent().map(getDepth).getOr(1);
    });
  }

  // node_modules/@siteimprove/alfa-style/dist/element/predicate/has-computed-style.js
  var { isElement: isElement13 } = Element;
  function hasComputedStyle(name, predicate, device, context) {
    return function hasComputedStyle12(node) {
      return isElement13(node) ? Style.from(node, device, context).computed(name).some(predicate) : node.parent(Node4.flatTree).filter(isElement13).some(hasComputedStyle12);
    };
  }

  // node_modules/@siteimprove/alfa-style/dist/element/predicate/is-positioned.js
  var { equals: equals13 } = Predicate;
  function isPositioned(device, ...positions) {
    return hasComputedStyle("position", (position) => positions.some(equals13(position.value)), device);
  }

  // node_modules/@siteimprove/alfa-style/dist/node/predicate/is-rendered.js
  var { isFallback: isFallback2 } = Element;
  var cache = Cache2.empty();
  function isRendered(device, context = Context.empty()) {
    return function isRendered6(node) {
      return cache.get(device, Cache2.empty).get(context, Cache2.empty).get(node, () => {
        if (isFallback2(node)) {
          return false;
        }
        if (Element.isElement(node) && Style.from(node, device, context).computed("display").some(({ values: [outside] }) => outside.value === "none")) {
          return false;
        }
        if (Comment.isComment(node)) {
          return false;
        }
        return node.parent(Node4.fullTree).every(isRendered6);
      });
    };
  }

  // node_modules/@siteimprove/alfa-style/dist/element/helpers/get-offset-parent.js
  var { hasName: hasName10, isElement: isElement14 } = Element;
  var { isRoot: isRoot2 } = Node4;
  var { and: and14, or: or10, not: not19, test: test11 } = Predicate;
  var isBody = hasName10("body");
  var isTabular = hasName10("td", "th", "table");
  function getOffsetParent(element, device) {
    const isFixed = isPositioned(device, "fixed");
    if (test11(or10(not19(isRendered(device)), isRoot2(Node4.flatTree), isBody, isFixed), element)) {
      return None;
    }
    const isStatic = isPositioned(device, "static");
    return element.ancestors(Node4.flatTree).filter(isElement14).find(or10(not19(isStatic), isBody, and14(isStatic, isTabular)));
  }

  // node_modules/@siteimprove/alfa-style/dist/element/helpers/get-positioning-parent.js
  var { isElement: isElement15 } = Element;
  function getPositioningParent(element, device) {
    if (isPositioned(device, "relative", "static", "sticky")(element)) {
      return element.parent(Node4.flatTree).filter(isElement15);
    } else {
      return getOffsetParent(element, device);
    }
  }

  // node_modules/@siteimprove/alfa-style/dist/element/predicate/has-border.js
  var sides = ["top", "right", "bottom", "left"];
  function hasBorder(device, context) {
    return (element) => {
      const style = Style.from(element, device, context);
      return sides.some((side) => style.computed(`border-${side}-width`).none(Numeric2.isZero) && style.computed(`border-${side}-color`).none((color) => color.type === "color" && Color.isTransparent(color)));
    };
  }

  // node_modules/@siteimprove/alfa-style/dist/element/predicate/is-visible-shadow.js
  function isVisibleShadow(shadow) {
    return !isInvisibleShadow(shadow);
  }
  function isInvisibleShadow(shadow) {
    return (
      // Transparent shadows are not visible
      Color.isTransparent(shadow.color) || // Shadows with no offset, blur and spread are not visible
      shadow.vertical.value === 0 && shadow.horizontal.value === 0 && shadow.blur.value === 0 && shadow.spread.value === 0
    );
  }

  // node_modules/@siteimprove/alfa-style/dist/element/predicate/has-box-shadow.js
  function hasBoxShadow(device, context) {
    return (element) => {
      const shadow = Style.from(element, device, context).computed("box-shadow").value;
      return !Keyword.isKeyword(shadow) && Iterable.some(shadow, isVisibleShadow);
    };
  }

  // node_modules/@siteimprove/alfa-style/dist/element/predicate/has-cascaded-style.js
  var { isElement: isElement16 } = Element;
  function hasCascadedStyle(name, predicate, device, context) {
    return function hasCascadedStyle6(node) {
      return isElement16(node) ? Style.from(node, device, context).cascaded(name).some((value) => value.some(predicate)) : node.parent(Node4.flatTree).filter(isElement16).some(hasCascadedStyle6);
    };
  }

  // node_modules/@siteimprove/alfa-style/dist/element/predicate/has-outline.js
  function hasOutline(device, context) {
    return (element) => {
      const style = Style.from(element, device, context);
      return style.computed("outline-width").none(Numeric2.isZero) && style.computed("outline-style").none((style2) => style2.value === "none") && style.computed("outline-color").none((color) => color.type === "color" && Color.isTransparent(color));
    };
  }

  // node_modules/@siteimprove/alfa-style/dist/element/predicate/has-positioning-parent.js
  function hasPositioningParent(device, predicate) {
    return (element) => getPositioningParent(element, device).some(predicate);
  }

  // node_modules/@siteimprove/alfa-style/dist/element/predicate/has-specified-style.js
  var { isElement: isElement17 } = Element;
  function hasSpecifiedStyle(name, predicate, device, context) {
    return function hasSpecifiedStyle4(node) {
      return isElement17(node) ? Style.from(node, device, context).specified(name).some(predicate) : node.parent(Node4.flatTree).filter(isElement17).some(hasSpecifiedStyle4);
    };
  }

  // node_modules/@siteimprove/alfa-style/dist/element/predicate/has-text-decoration.js
  function hasTextDecoration(device, context) {
    return (element) => {
      const style = Style.from(element, device, context);
      return style.computed("text-decoration-color").none(Color.isTransparent) && style.computed("text-decoration-line").none((line) => line.type === "keyword");
    };
  }

  // node_modules/@siteimprove/alfa-style/dist/element/predicate/has-transparent-background.js
  var { isReplaced: isReplaced2, isElement: isElement18 } = Element;
  var { or: or11, test: test12 } = Predicate;
  var cache2 = Cache2.empty();
  function hasTransparentBackground(device, context = Context.empty()) {
    return (element) => cache2.get(device, Cache2.empty).get(context, Cache2.empty).get(element, () => {
      if (test12(or11(
        // Replaced elements are assumed to be replaced by non-transparent content.
        isReplaced2,
        // Elements with non-transparent background are not transparent.
        Style.hasComputedStyle("background-color", (color) => !Color.isTransparent(color), device, context),
        // Elements with a background image are not transparent.
        Style.hasComputedStyle("background-image", (image) => !(Keyword.isKeyword(image.values[0]) && image.values[0].equals(Keyword.of("none"))), device, context)
      ), element)) {
        return false;
      }
      return element.children(Node4.fullTree).filter(isElement18).every(hasTransparentBackground(device, context));
    });
  }

  // node_modules/@siteimprove/alfa-style/dist/element/predicate/has-used-style.js
  var { isElement: isElement19 } = Element;
  function hasUsedStyle(name, predicate, device, context) {
    return function hasUsedStyle3(node) {
      return isElement19(node) ? Style.from(node, device, context).used(name).some((used) => used.some(predicate)) : node.parent(Node4.flatTree).filter(isElement19).some(hasUsedStyle3);
    };
  }

  // node_modules/@siteimprove/alfa-style/dist/element/predicate/is-focusable.js
  var { hasTabIndex: hasTabIndex2, isActuallyDisabled: isActuallyDisabled2 } = Element;
  var { and: and15, not: not20 } = Predicate;
  function isFocusable(device) {
    return and15(hasTabIndex2(), and15(not20(isActuallyDisabled2), isRendered(device)));
  }

  // node_modules/@siteimprove/alfa-style/dist/element/predicate/is-important.js
  function isImportant(device, property16) {
    return hasComputedStyle(property16, (_, source) => source.some((declaration) => declaration.important), device);
  }

  // node_modules/@siteimprove/alfa-style/dist/element/predicate/is-inert.js
  function isInert(device) {
    return Style.hasComputedStyle("visibility", (specified) => specified.value === "hidden" || specified.value === "collapse", device);
  }

  // node_modules/@siteimprove/alfa-style/dist/element/predicate/is-tabbable.js
  var { hasName: hasName11, hasNamespace: hasNamespace2, hasTabIndex: hasTabIndex3, isActuallyDisabled: isActuallyDisabled3 } = Element;
  var { and: and16, not: not21 } = Predicate;
  function isTabbable(device) {
    return and16(hasTabIndex3((tabIndex) => tabIndex >= 0), not21(redirectsFocus), not21(isActuallyDisabled3), not21(isInert(device)), isRendered(device));
  }
  var redirectsFocus = and16(hasNamespace2(Namespace.HTML), hasName11("iframe", "label"));

  // node_modules/@siteimprove/alfa-style/dist/node/helpers/inner-text.js
  var { hasName: hasName12, isElement: isElement20 } = Element;
  var { isText } = Text;
  var { and: and17 } = Predicate;
  var isWhitespace2 = (text) => String2.isWhitespace(text.data, false);
  function fromText(device, isAcceptable = () => () => true) {
    return (text) => Selective.of(text).if(isAcceptable(device), (text2) => text2.data).if(and17(isRendered(device), isWhitespace2), () => " ").else(() => "").get();
  }
  function fromNode(device, isAcceptable = () => () => true, wrapper = "") {
    return (node) => wrapper + node.children(Node4.flatTree).map((child) => Selective.of(child).if(isText, fromText(device, isAcceptable)).if(isElement20, fromElement(device, isAcceptable)).else(fromNode(device, isAcceptable)).get()).join("") + wrapper;
  }
  function fromElement(device, isAcceptable = () => () => true) {
    return (element) => {
      if (!isRendered(device)(element)) {
        return "";
      }
      if (hasName12("br")(element)) {
        return "\n";
      }
      if (hasName12("p")(element)) {
        return fromNode(device, isAcceptable, "\n\n")(element);
      }
      const {
        values: [outside]
        // this covers both outside and internal specified.
      } = Style.from(element, device).computed("display").value;
      if (outside.is("block", "table-caption")) {
        return fromNode(device, isAcceptable, "\n")(element);
      }
      if (outside.is("table-cell", "table-row")) {
        return fromNode(device, isAcceptable, " ")(element);
      }
      return fromNode(device, isAcceptable)(element);
    };
  }
  var innerText = fromElement;

  // node_modules/@siteimprove/alfa-style/dist/node/predicate/has-same-foreground-as-background.js
  var { or: or12, test: test13 } = Predicate;
  var cache3 = Cache2.empty();
  function hasSameForegroundAsBackground(device, context = Context.empty()) {
    return (text) => cache3.get(device, Cache2.empty).get(context, Cache2.empty).get(text, () => test13(
      // We should correctly resolve colors (including opacity, layers,
      // "currentcolor" keyword, system colors, …)
      // However, we assume that hiding content with color is mostly made
      // with solid `color` and `background-color`, so we stick on a simple
      // check for now.
      hasComputedStyle("color", (foreground) => text.ancestors().filter(Element.isElement).find(or12(hasNonColorBackgroundProperty(device, context), hasNonTransparentBackgroundColor(device, context))).reject(hasNonColorBackgroundProperty(device, context)).map((ancestor) => Style.from(ancestor, device, context).computed("background-color").value).some((background) => background.equals(foreground)), device, context),
      text
    ));
  }
  function hasNonColorBackgroundProperty(device, context = Context.empty()) {
    return (element) => {
      const style = Style.from(element, device, context);
      for (const property16 of [
        "attachment",
        "clip",
        "image",
        "origin",
        "position-x",
        "position-y",
        "repeat-x",
        "repeat-y",
        "size"
      ]) {
        if (Equatable.equals(style.computed(`background-${property16}`).value, Longhands.get(`background-${property16}`).initial)) {
          continue;
        }
        return true;
      }
      return false;
    };
  }
  function hasNonTransparentBackgroundColor(device, context = Context.empty()) {
    return (element) => !Color.isTransparent(Style.from(element, device, context).computed("background-color").value);
  }

  // node_modules/@siteimprove/alfa-style/dist/node/predicate/is-clipped.js
  var { abs: abs2 } = Math;
  var { isElement: isElement21, hasBox: hasBox2 } = Element;
  var { not: not22, or: or13, test: test14 } = Predicate;
  var { and: and18 } = Refinement;
  var cache4 = Cache2.empty();
  function isClipped(device, context = Context.empty()) {
    return (node) => cache4.get(device, Cache2.empty).get(context, Cache2.empty).get(node, () => test14(or13(
      // Either it is a clipped element
      and18(isElement21, or13(
        isClippedBySize(device, context),
        isClippedByIndent(device, context),
        isClippedByMasking(device, context),
        and18(
          // Boxes are gathered on an empty context and can only be used
          // with an empty context.
          () => context === Context.empty(),
          isClippedByMovingAway(device)
        ),
        // Or it is an element whose positioning parent is clipped
        hasPositioningParent(device, isClipped(device, context))
      )),
      // Or (it's not an element) and its parent is clipped
      and18(not22(isElement21), (node2) => node2.parent(Node4.fullTree).some(isClipped(device, context)))
    ), node));
  }
  function isClippedBySize(device, context = Context.empty()) {
    return function isClipped2(element) {
      const style = Style.from(element, device, context);
      const x = style.computed("overflow-x").value.value;
      const y = style.computed("overflow-y").value.value;
      const width = style.computed("width").value;
      const height = style.computed("height").value;
      const overflows = test14(canOverflow(device), element);
      const hasNoScrollBar = x !== "scroll" && y !== "scroll";
      for (const [axis, overflow2, dimension] of [
        ["width", x, width],
        ["height", y, height]
      ]) {
        if (overflow2 === "visible" && overflows) {
          continue;
        }
        if (context === Context.empty() && element.getBoundingBox(device).some((box) => box[axis] === 0)) {
          return true;
        }
        if (Numeric2.isNumeric(dimension) && !dimension.hasCalculation() && Numeric2.isZero(dimension)) {
          return true;
        }
        if (hasNoScrollBar && (overflow2 === "clip" || overflow2 === "hidden")) {
          if (context === Context.empty() && element.getBoundingBox(device).some((box) => box[axis] <= 1)) {
            return true;
          }
          if (Length2.isLength(dimension) && dimension.value <= 1) {
            return true;
          }
        }
      }
      return false;
    };
  }
  function isClippedByIndent(device, context) {
    return function isClipped2(element) {
      const style = Style.from(element, device, context);
      const x = style.computed("overflow-x").value.value;
      if (x === "hidden") {
        const { value: indent } = style.computed("text-indent");
        const { value: whitespace2 } = style.computed("white-space");
        if (LengthPercentage.isCalculated(indent)) {
          return false;
        }
        if (indent.value < 0 || whitespace2.value === "nowrap") {
          switch (indent.type) {
            case "percentage":
              if (abs2(indent.value) >= 1) {
                return true;
              } else {
                break;
              }
            case "length":
              if (abs2(indent.value) >= 999) {
                return true;
              } else {
                break;
              }
          }
        }
      }
      return false;
    };
  }
  function isClippedByMasking(device, context) {
    return function isClipped2(element) {
      const style = Style.from(element, device, context);
      const { value: clip } = style.computed("clip");
      return clip.type === "shape" && (clip.shape.top.type === "length" && clip.shape.top.equals(clip.shape.bottom) || clip.shape.left.type === "length" && clip.shape.left.equals(clip.shape.right));
    };
  }
  function isClippedByMovingAway(device) {
    return (element) => {
      return hasBox2((elementBox) => hasPositioningParent(device, isClipping(elementBox, device))(element), device)(element);
    };
  }
  var isNotVisible = (overflow2) => overflow2.value !== "visible";
  var isNoScroll = (overflow2) => overflow2.value === "clip" || overflow2.value === "hidden";
  function isClipping(elementBox, device) {
    return function isClipping2(ancestor) {
      return and18(
        // If the boxes intersect, we see the intersection at least and can
        // escape immediately. This should be by far the most frequent case. The
        // case where the ancestor itself is clipped away is handled by the global
        // recurrence in isClipped.
        // This doesn't handle corner cases of 1×1px intersections.
        not22(hasBox2(elementBox.intersects.bind(elementBox), device)),
        or13(
          // The element is to the left, and clipped away.
          and18(hasBox2((ancestorBox) => elementBox.right < ancestorBox.left, device), hasComputedStyle("overflow-x", isNotVisible, device)),
          // The element is to the right and cannot be scrolled to.
          and18(hasBox2((ancestorBox) => elementBox.left > ancestorBox.right, device), hasComputedStyle("overflow-x", isNoScroll, device)),
          // The element is above, and clipped away.
          and18(hasBox2((ancestorBox) => elementBox.bottom < ancestorBox.top, device), hasComputedStyle("overflow-y", isNotVisible, device)),
          // The element is below and cannot be scrolled to.
          and18(hasBox2((ancestorBox) => elementBox.top > ancestorBox.bottom, device), hasComputedStyle("overflow-y", isNoScroll, device)),
          // The ancestor doesn't clip, let's search for the next one.
          hasPositioningParent(device, isClipping2)
        )
      )(ancestor);
    };
  }
  function canOverflow(device) {
    return not22(Element.hasName("img"));
  }

  // node_modules/@siteimprove/alfa-style/dist/node/predicate/is-offscreen.js
  var { hasBox: hasBox3, isElement: isElement22 } = Element;
  var { abs: abs3 } = Math;
  var { and: and19, or: or14 } = Predicate;
  var cache5 = Cache2.empty();
  function isOffscreen(device, context = Context.empty()) {
    return function isOffscreen2(node) {
      return cache5.get(device, Cache2.empty).get(context, Cache2.empty).get(node, () => {
        if (isElement22(node)) {
          if (node.getBoundingBox(device).isSome() && context === Context.empty()) {
            return !isOnscreenLayout(node, device);
          } else {
            const style = Style.from(node, device, context);
            const fallback = isOffscreenFallback(style);
            return fallback ?? node.parent(Node4.flatTree).some(isOffscreen2);
          }
        }
        return node.parent(Node4.flatTree).some(isOffscreen2);
      });
    };
  }
  var scrollableQuadrant = Rectangle2.of(0, 0, Infinity, Infinity);
  function isOnscreenLayout(element, device) {
    const extendedViewport = Rectangle2.of(0, 0, device.viewport.width, Infinity);
    return or14(
      // At first, we check whether the element's box intersects an infinitely high
      // rectangle extending the viewport to the bottom.
      // If yes, then the element can be brought into viewport by vertical scrolling
      // which, we assume, is not restricted.
      hasBox3((box) => box.intersects(extendedViewport), device),
      // Next, we search whether the element is in the scrollable quadrant (extends
      // to the bottom and right), and has a positioning ancestor that creates
      // the needed horizontal scrolling.
      and19(hasBox3((box) => box.intersects(scrollableQuadrant), device), hasPositioningParent(device, isOnscreenAndScrolling(device)))
    )(element);
  }
  var onscreenAndScrollingCache = Cache2.empty();
  function isOnscreenAndScrolling(device) {
    const extendedViewport = Rectangle2.of(0, 0, device.viewport.width, Infinity);
    return function predicate(element) {
      return onscreenAndScrollingCache.get(device, Cache2.empty).get(element, () => or14(
        and19(
          // Does the element intersect the extended viewport?
          hasBox3((box) => box.intersects(extendedViewport), device),
          // And does it create a scrollbar which can show the content to the right?
          hasComputedStyle("overflow-x", (overflow2) => ["auto", "scroll", "visible"].includes(overflow2.value), device)
        ),
        // Otherwise, jump to the positioning parent and try again.
        hasPositioningParent(device, predicate)
      )(element));
    };
  }
  function isOffscreenFallback(style) {
    const { value: position } = style.computed("position");
    const { value: left22 } = style.computed("left");
    const { value: right38 } = style.computed("right");
    const { value: top } = style.computed("top");
    const { value: marginLeft } = style.computed("margin-left");
    if (marginLeft.type === "length" && marginLeft.value <= -9999) {
      return true;
    }
    if (position.value !== "static") {
      for (const inset of [left22, right38]) {
        if (inset.type === "length" && abs3(inset.value) >= 9999) {
          return true;
        }
      }
      if (top.type === "length" && top.value <= -9999) {
        return true;
      }
      return false;
    }
    return void 0;
  }

  // node_modules/@siteimprove/alfa-style/dist/node/predicate/is-option-hidden.js
  var { hasName: hasName13, isElement: isElement23 } = Element;
  var { and: and20 } = Refinement;
  function isOptionHidden(device) {
    return (node) => optionAncestor(node).some(isHidden);
    function isHidden(option64) {
      const parent = namedParent(option64, "select").orElse(() => namedParent(option64, "optgroup").flatMap(namedParent("select")));
      for (const select of parent) {
        if (option64.getBoundingBox(device).isSome() && select.getBoundingBox(device).isSome()) {
          return false;
        }
        const displaySize = select.displaySize();
        const multiple = select.attribute("multiple").isSome();
        if (!multiple && displaySize === 1) {
          return true;
        }
        const options = select.optionsList();
        let firstSelectedIndex = -1;
        let optionIndex = -1;
        let idx = 0;
        for (const candidate of options) {
          if (candidate === option64) {
            optionIndex = idx;
          }
          if (firstSelectedIndex === -1 && candidate.attribute("selected").isSome()) {
            firstSelectedIndex = idx;
          }
          if (firstSelectedIndex !== -1 && optionIndex !== -1) {
            break;
          }
          idx++;
        }
        if (firstSelectedIndex === -1 || firstSelectedIndex < displaySize) {
          return optionIndex >= displaySize;
        } else {
          return firstSelectedIndex - displaySize >= optionIndex || optionIndex > firstSelectedIndex;
        }
      }
      return false;
    }
  }
  var _optionAncestorCache = Cache2.empty();
  function optionAncestor(node) {
    return _optionAncestorCache.get(node, () => node.inclusiveAncestors(Node4.fullTree).find(and20(isElement23, hasName13("option"))));
  }
  function namedParent(elementOrName, name) {
    return isElement23(elementOrName) ? elementOrName.parent().filter(and20(isElement23, hasName13(name))) : (element) => element.parent().filter(and20(isElement23, hasName13(elementOrName)));
  }

  // node_modules/@siteimprove/alfa-style/dist/node/predicate/is-transparent.js
  var { isElement: isElement24 } = Element;
  var { isText: isText2 } = Text;
  var { or: or15, and: and21, test: test15 } = Refinement;
  var cache6 = Cache2.empty();
  function isNotOpaque(device, context) {
    return hasComputedStyle("opacity", (opacity) => opacity.value === 0, device, context);
  }
  function hasTransparentTextColor(device, context) {
    return hasComputedStyle("color", Color.isTransparent, device, context);
  }
  function isTransparent(device, context = Context.empty()) {
    return function isTransparent2(node) {
      return cache6.get(device, Cache2.empty).get(context, Cache2.empty).get(node, () => test15(or15(and21(isElement24, isNotOpaque(device, context)), and21(isText2, hasTransparentTextColor(device, context)), (node2) => node2.parent(Node4.flatTree).some(isTransparent2)), node));
    };
  }

  // node_modules/@siteimprove/alfa-style/dist/node/predicate/is-visible.js
  var { hasName: hasName14, isElement: isElement25, isReplaced: isReplaced3 } = Element;
  var { nor: nor2, not: not23, test: test16 } = Predicate;
  var { and: and22, or: or16 } = Refinement;
  var { isText: isText3 } = Text;
  function isVisible(device, context) {
    return not23(isInvisible(device, context));
  }
  var cache7 = Cache2.empty();
  function isInvisible(device, context = Context.empty()) {
    return (node) => cache7.get(device, Cache2.empty).get(context, Cache2.empty).get(node, () => test16(or16(
      not23(isRendered(device, context)),
      isTransparent(device, context),
      isClipped(device, context),
      isOffscreen(device, context),
      and22(isText3, or16(
        hasSameForegroundAsBackground(device, context),
        // Empty text
        (text) => text.data.trim() === "",
        // Text of size 0
        hasComputedStyle("font-size", (size) => size.value === 0, device, context)
      )),
      // Element or Text with visibility != "visible"
      and22(or16(isElement25, isText3), hasComputedStyle("visibility", (visibility) => visibility.value !== "visible", device, context)),
      // Most non-replaced elements with no visible children are not visible while
      // replaced elements are assumed to be replaced by something visible. Some
      // non-replaced elements are, however, visible even when empty.
      and22(isElement25, and22(
        // If the element is replaced, visible when empty, or has set dimensions,
        // it is assumed to be visible
        nor2(isReplaced3, isVisibleWhenEmpty, hasDimensions(device)),
        // otherwise, the element is invisible iff all its children are.
        (element) => element.children(Node4.fullTree).every(isInvisible(device, context))
      )),
      // `<option>` elements (and their content) have weird visibility
      // rules depending on their `<select>` parent.
      // (only text is allowed as children of `<option>`, this also works
      // on ill-formed DOM trees where the text is buried deeper)
      isOptionHidden(device)
    ), node));
  }
  var isVisibleWhenEmpty = hasName14("textarea", "select");
  function hasDimensions(device) {
    const hasDimension = (dimension) => hasComputedStyle(dimension, and22(Numeric2.isFixed, (number) => number.value > 0), device);
    const isStretched = (...sides2) => and22(isPositioned(device, "absolute"), hasComputedStyle(sides2[0], Numeric2.isNumeric, device), hasComputedStyle(sides2[1], Numeric2.isNumeric, device));
    return and22(or16(hasDimension("height"), isStretched("top", "bottom")), or16(hasDimension("width"), isStretched("left", "right")));
  }

  // node_modules/@siteimprove/alfa-style/dist/node/predicate/is-scrolled-behind.js
  var { isElement: isElement26, hasBox: hasBox4 } = Element;
  var { and: and23, or: or17, not: not24 } = Predicate;
  var cache8 = Cache2.empty();
  function isScrolledBehind(device) {
    return function isScrolledBehind3(node) {
      return cache8.get(device, Cache2.empty).get(node, () => {
        if (isElement26(node)) {
          return hasBox4((elementBox) => hasPositioningParent(device, or17(
            // The parent, or one of it's ancestors, is scroll container for the element,
            isScrollContainerFor(elementBox, device),
            // or the parent itself is scrolled behind
            isScrolledBehind3
          ))(node), device)(node);
        } else {
          return node.parent(Node4.fullTree).some(isScrolledBehind3);
        }
      });
    };
  }
  var isScrollOrAuto = (overflow2) => overflow2.value === "scroll" || overflow2.value === "auto";
  function isScrollContainerFor(elementBox, device) {
    return function isScrollContainerFor2(ancestor) {
      return or17(
        and23(
          // Element is in the scroll port, so it's not completely scrolled behind
          not24(hasBox4((ancestorBox) => ancestorBox.intersects(elementBox), device)),
          or17(
            // Element intersects the rectangle to the right stretching to infinity
            //
            //    +-------+-------- - -
            //    |       |  *
            //    |       |
            //    +-------+-------- - -
            //
            and23(hasBox4((ancestorBox) => Rectangle2.of(ancestorBox.right, ancestorBox.top, Infinity, ancestorBox.height).intersects(elementBox), device), hasComputedStyle("overflow-x", isScrollOrAuto, device)),
            // Element intersects the rectangle below stretching to infinity
            //
            //    +-------+
            //    |       |
            //    |       |
            //    +-------+
            //    |   *   |
            //    |       |
            //    .       .
            //    .       .
            and23(hasBox4((ancestorBox) => Rectangle2.of(ancestorBox.left, ancestorBox.bottom, ancestorBox.width, Infinity).intersects(elementBox), device), hasComputedStyle("overflow-y", isScrollOrAuto, device)),
            // Element intersects the rectangle to the right and below stretching to infinity
            //
            //    +-------+
            //    |       |
            //    |       |
            //    +-------+-------- - -
            //            |
            //            |   *
            //            .
            //            .
            and23(hasBox4((ancestorBox) => Rectangle2.of(ancestorBox.right, ancestorBox.bottom, Infinity, Infinity).intersects(elementBox), device), hasComputedStyle("overflow-x", isScrollOrAuto, device), hasComputedStyle("overflow-y", isScrollOrAuto, device))
          )
        ),
        // Element is not scrolled behind this container,
        // but it might be scrolled behind one of the containers ancestors.
        hasPositioningParent(device, isScrollContainerFor2)
      )(ancestor);
    };
  }

  // node_modules/@siteimprove/alfa-style/dist/variable.js
  var { delimited: delimited48, left: left21, map: map124, option: option62, pair: pair35, right: right36, takeUntil: takeUntil4 } = Parser;
  var Variable;
  (function(Variable2) {
    function gather(declarations) {
      let currentVariables = Map2.empty();
      for (const declaration of declarations.filter((declaration2) => declaration2.name.startsWith("--"))) {
        const { name, value } = declaration;
        if (currentVariables.get(name).isNone()) {
          currentVariables = currentVariables.set(name, Value4.of(Lexer.lex(value), Option.of(declaration)));
        }
      }
      return currentVariables;
    }
    Variable2.gather = gather;
    function flatten2(variables) {
      for (const [name, variable] of variables) {
        const substitution = substitute(variable.value, variables);
        if (substitution.isSome()) {
          const [tokens] = substitution.get();
          variables = variables.set(name, Value4.of(tokens, variable.source));
        } else {
          variables = variables.delete(name);
        }
      }
      return variables;
    }
    Variable2.flatten = flatten2;
    const parseInitial = Keyword.parse("initial");
    function resolve3(name, variables, fallback = None, visited = Set2.empty()) {
      return (
        // If the variable is defined on the current definition map, get its value
        variables.get(name).map((value) => value.value).reject((tokens) => parseInitial(tokens).isOk()).or(fallback).flatMap((tokens) => substitute(tokens, variables, visited.add(name))).map(([tokens]) => tokens)
      );
    }
    const substitutionLimit = 1024;
    function substitute(tokens, variables, visited = Set2.empty()) {
      const replaced = [];
      let substituted = false;
      while (tokens.length > 0) {
        const next = tokens.first().getUnsafe();
        if (next.type === "function" && next.value === "var") {
          const result = parseVar(tokens);
          if (!result.isOk()) {
            return None;
          }
          const [remaining, [name, fallback]] = result.get();
          tokens = remaining;
          if (visited.has(name)) {
            return None;
          }
          const value = resolve3(name, variables, fallback, visited);
          if (!value.isSome()) {
            return None;
          }
          replaced.push(...value.get());
          substituted = true;
        } else {
          replaced.push(next);
          tokens = tokens.rest();
        }
      }
      if (substituted && replaced.length > substitutionLimit) {
        return None;
      }
      return Option.of([
        Slice.of(replaced),
        substituted
      ]);
    }
    Variable2.substitute = substitute;
    const parseVar = right36(Token.parseFunction("var"), pair35(map124(delimited48(option62(Token.parseWhitespace), Token.parseIdent((ident) => ident.value.startsWith("--"))), (ident) => ident.value), left21(option62(right36(pair35(Token.parseComma, option62(Token.parseWhitespace)), map124(takeUntil4(Component.consume, Token.parseCloseParenthesis), (components) => Slice.of([...Iterable.flatten(components)])))), Token.parseCloseParenthesis)));
  })(Variable || (Variable = {}));

  // node_modules/@siteimprove/alfa-style/dist/style.js
  var Style = class _Style {
    /**
     * Build a style from a list of declarations.
     *
     * @remarks
     * Declarations must be pre-sorted in decreasing Cascade order.
     * Prefer using Style.from(), which has fewer assumptions.
     */
    static of(styleDeclarations, device, parent = None, owner = None) {
      const declarations = Array2.from(styleDeclarations);
      const declaredVariables = Variable.gather(declarations.map(([declaration]) => declaration));
      const cascadedVariables = parent.map((parent2) => parent2.variables).getOr(Map2.empty()).concat(declaredVariables);
      const variables = Variable.flatten(cascadedVariables);
      let properties = Map2.empty();
      let reverted = Set2.empty();
      function registerParsed(name, value, declaration) {
        if (value.equals(Keyword.of("revert"))) {
          reverted = reverted.add(name);
        } else {
          properties = properties.set(name, Value4.of(value, Option.of(declaration)));
        }
      }
      function register(name, value, declaration, origin, parsed) {
        if (reverted.has(name) && Origin.isAuthor(origin)) {
          return;
        }
        if (properties.get(name).isNone()) {
          if (parsed) {
            return registerParsed(name, value, declaration);
          } else {
            for (const result of parseLonghand(
              Longhands.get(name),
              // Type is ensured by the overload.
              value,
              variables
            )) {
              registerParsed(name, result, declaration);
            }
          }
        }
      }
      for (const [declaration, origin] of declarations) {
        const { name, value } = declaration;
        if (Longhands.isName(name)) {
          register(name, value, declaration, origin, false);
        } else if (Shorthands.isName(name)) {
          for (const result of parseShorthand(Shorthands.get(name), value, variables)) {
            for (const [name2, value2] of result) {
              register(name2, value2, declaration, origin, true);
            }
          }
        }
      }
      return new _Style(owner, device, parent, variables, properties);
    }
    static _empty = new _Style(None, Device.standard(), None, Map2.empty(), Map2.empty());
    static empty() {
      return this._empty;
    }
    _owner;
    _device;
    _parent;
    _variables;
    _properties;
    // We cache computed values but not specified values, as these are
    // inexpensive to resolve from cascaded and computed values;
    // nor used values, as in our case they are inexpensive to resolve
    // from computed values.
    _computed = Map2.empty();
    constructor(owner, device, parent, variables, properties) {
      this._owner = owner;
      this._device = device;
      this._parent = parent;
      this._variables = variables;
      this._properties = properties;
    }
    get owner() {
      return this._owner;
    }
    get device() {
      return this._device;
    }
    get parent() {
      return this._parent.getOrElse(() => _Style._empty);
    }
    get variables() {
      return this._variables;
    }
    get properties() {
      return this._properties;
    }
    root() {
      return this._parent.map((parent) => parent.root()).getOr(this);
    }
    /**
     * {@link https://www.w3.org/TR/css-cascade/#cascaded}
     */
    cascaded(name) {
      return this._properties.get(name);
    }
    /**
     * {@link https://www.w3.org/TR/css-cascade/#specified}
     */
    specified(name) {
      const { inherits } = Longhands.get(name);
      return this.cascaded(name).map((cascaded) => {
        const { value, source } = cascaded;
        if (Keyword.isKeyword(value)) {
          switch (value.value) {
            // https://drafts.csswg.org/css-cascade/#initial
            case "initial":
              return this.initial(name, source);
            // https://drafts.csswg.org/css-cascade/#inherit
            case "inherit":
              return this.inherited(name);
            // https://drafts.csswg.org/css-cascade/#inherit-initial
            case "unset":
              return inherits ? this.inherited(name) : this.initial(name, source);
          }
        }
        return cascaded;
      }).getOrElse(() => inherits ? this._parent.map((parent) => parent.computed(name)).getOrElse(() => this.initial(name)) : this.initial(name));
    }
    /**
     * {@link https://www.w3.org/TR/css-cascade/#computed}
     */
    computed(name) {
      if (this === _Style._empty) {
        return this.initial(name);
      }
      if (!this._computed.has(name)) {
        const compute2 = Longhands.get(name).compute;
        const specified = this.specified(name);
        const computed = compute2(specified, this);
        this._computed = this._computed.set(name, computed);
      }
      return this._computed.get(name).getUnsafe(`Computed style for ${name} does not exists`);
    }
    /**
     * {@link https://www.w3.org/TR/css-cascade/#used}
     *
     * @remarks
     * In our case, we do not resolve further (e.g., `width: auto`).
     * However, we filter out properties that do not apply to certain elements.
     */
    used(name) {
      const use = Longhands.get(name).use;
      return use(this.computed(name), this);
    }
    initial(name, source = None) {
      return Value4.of(Longhands.get(name).initial, source);
    }
    inherited(name) {
      return this.parent.computed(name);
    }
    toJSON() {
      return {
        device: this._device.toJSON(),
        variables: [...this._variables].map(([name, value]) => [
          name,
          value.toJSON()
        ]),
        properties: [...this._properties].map(([name, value]) => [
          name,
          value.toJSON()
        ])
      };
    }
  };
  (function(Style2) {
    const cache16 = Cache2.empty();
    function from(element, device, context = Context.empty()) {
      return cache16.get(device, Cache2.empty).get(element.freeze(), Cache2.empty).get(context, () => {
        const declarations = [];
        const root = element.root();
        if (Document.isDocument(root) || Shadow2.isShadow(root)) {
          const cascade = Cascade.from(root, device);
          for (const node of cascade.get(element, context).inclusiveAncestors()) {
            declarations.push(...Iterable.reverse(Iterable.map(node.block.declarations, (declaration) => [declaration, node.block.precedence.origin])));
          }
        } else {
          declarations.push(...element.style.map((block) => Iterable.reverse(Iterable.map(block.declarations, (declaration) => [
            declaration,
            declaration.important ? Origin.ImportantAuthor : Origin.NormalAuthor
          ]))).getOr([]));
        }
        return Style2.of(declarations, device, element.parent(Node4.flatTree).filter(Element.isElement).map((parent) => from(parent, device, context)), Option.of(element));
      });
    }
    Style2.from = from;
    Style2.getOffsetParent = getOffsetParent, Style2.getPositioningParent = getPositioningParent, Style2.hasBorder = hasBorder, Style2.hasBoxShadow = hasBoxShadow, Style2.hasCascadedStyle = hasCascadedStyle, Style2.hasComputedStyle = hasComputedStyle, Style2.hasPositioningParent = hasPositioningParent, Style2.hasOutline = hasOutline, Style2.hasSpecifiedStyle = hasSpecifiedStyle, Style2.hasTextDecoration = hasTextDecoration, Style2.hasTransparentBackground = hasTransparentBackground, Style2.hasUsedStyle = hasUsedStyle, Style2.isFocusable = isFocusable, Style2.isImportant = isImportant, Style2.isInert = isInert, Style2.isPositioned = isPositioned, Style2.isTabbable = isTabbable, Style2.isVisibleShadow = isVisibleShadow;
    Style2.innerText = innerText, Style2.isRendered = isRendered, Style2.isVisible = isVisible, Style2.isScrolledBehind = isScrolledBehind;
    Style2.isBlockContainer = isBlockContainer, Style2.isFlexContainer = isFlexContainer, Style2.isGridContainer = isGridContainer;
  })(Style || (Style = {}));
  function parseLonghand(property16, value, variables) {
    const substitution = Variable.substitute(Lexer.lex(value), variables);
    if (!substitution.isSome()) {
      return Result.of(Keyword.of("unset"));
    }
    const [tokens, substituted] = substitution.get();
    const parse57 = property16.parse;
    const result = parse57(trim(tokens)).map(([, value2]) => value2);
    if (result.isErr() && substituted) {
      return Result.of(Keyword.of("unset"));
    }
    return result;
  }
  function parseShorthand(shorthand, value, variables) {
    const substitution = Variable.substitute(Lexer.lex(value), variables);
    const longhands = shorthand.properties;
    const parse57 = shorthand.parse;
    if (!substitution.isSome()) {
      return Result.of(Iterable.map(longhands, (property16) => [property16, Keyword.of("unset")]));
    }
    const [tokens, substituted] = substitution.get();
    const result = parse57(trim(tokens)).map(([, value2]) => {
      if (Keyword.isKeyword(value2)) {
        return Iterable.map(longhands, (property16) => [property16, value2]);
      }
      return value2;
    });
    if (result.isErr() && substituted) {
      return Result.of(Iterable.map(longhands, (property16) => [property16, Keyword.of("unset")]));
    }
    return result;
  }
  function trim(tokens) {
    return tokens.trim(Token.isWhitespace);
  }

  // node_modules/@siteimprove/alfa-table/dist/anchored.js
  var Anchored;
  (function(Anchored2) {
    function compare(a, b) {
      return a.anchor.compare(b.anchor);
    }
    Anchored2.compare = compare;
    function equals34(a, b) {
      return a.anchor.equals(b.anchor);
    }
    Anchored2.equals = equals34;
  })(Anchored || (Anchored = {}));

  // node_modules/@siteimprove/alfa-table/dist/cell/predicate/has-element.js
  var { equals: equals14 } = Predicate;
  function hasElement(elementOrPredicate) {
    let predicate;
    if (typeof elementOrPredicate === "function") {
      predicate = elementOrPredicate;
    } else {
      predicate = equals14(elementOrPredicate);
    }
    return (cell) => predicate(cell.element);
  }

  // node_modules/@siteimprove/alfa-table/dist/cell.js
  var { and: and24, or: or18 } = Refinement;
  var { isElement: isElement27 } = Element;
  var { isText: isText4 } = Text;
  var Cell = class _Cell {
    _element;
    _anchor;
    _width;
    _height;
    _headers;
    constructor(element, anchor, width, height, headers) {
      this._element = element;
      this._anchor = anchor;
      this._width = width;
      this._height = height;
      this._headers = headers;
    }
    get element() {
      return this._element;
    }
    get anchor() {
      return this._anchor;
    }
    get x() {
      return this._anchor.x;
    }
    get y() {
      return this._anchor.y;
    }
    get width() {
      return this._width;
    }
    get height() {
      return this._height;
    }
    get headers() {
      return Sequence.from(this._headers);
    }
    /**
     * {@link https://html.spec.whatwg.org/#empty-cell}
     */
    isEmpty() {
      return this._element.children().none(or18(isElement27, and24(isText4, (text) => text.data.trim().length > 0)));
    }
    compare(anchored) {
      return Anchored.compare(this, anchored);
    }
    equals(value) {
      return value instanceof _Cell && value._element.equals(this._element) && value._anchor.equals(this._anchor) && value._width === this._width && value._height === this._height && Array2.equals(value._headers, this._headers);
    }
  };
  (function(Cell2) {
    function isCell(value) {
      return value instanceof Cell2;
    }
    Cell2.isCell = isCell;
    Cell2.hasElement = hasElement;
    class Data extends Cell2 {
      static of(element, anchor, width, height, headers = []) {
        return new Data(element, anchor, width, height, Array2.sort(Array2.copy(Array2.from(headers))));
      }
      constructor(element, anchor, width, height, headers) {
        super(element, anchor, width, height, headers);
      }
      isData() {
        return true;
      }
      isHeader() {
        return false;
      }
      equals(value) {
        return value instanceof Data && super.equals(value);
      }
      toJSON() {
        return {
          type: "data",
          element: this._element.path(),
          anchor: this._anchor.toJSON(),
          width: this._width,
          height: this._height,
          headers: Array2.toJSON(this._headers)
        };
      }
    }
    Cell2.Data = Data;
    (function(Data2) {
      function isData(value) {
        return value instanceof Data2;
      }
      Data2.isData = isData;
    })(Data = Cell2.Data || (Cell2.Data = {}));
    Cell2.data = Data.of, Cell2.isData = Data.isData;
    class Header2 extends Cell2 {
      static of(element, anchor, width, height, headers = [], scope = "auto") {
        return new Header2(element, anchor, width, height, Array2.sort(Array2.copy(Array2.from(headers))), scope);
      }
      _scope;
      constructor(element, anchor, width, height, headers, scope) {
        super(element, anchor, width, height, headers);
        this._scope = scope;
      }
      get scope() {
        return this._scope;
      }
      isData() {
        return false;
      }
      isHeader() {
        return true;
      }
      equals(value) {
        return value instanceof Header2 && super.equals(value) && value._scope === this._scope;
      }
      toJSON() {
        return {
          type: "header",
          scope: this._scope,
          element: this._element.path(),
          anchor: this._anchor.toJSON(),
          width: this._width,
          height: this._height,
          headers: Array2.toJSON(this._headers)
        };
      }
    }
    Cell2.Header = Header2;
    (function(Header3) {
      function isHeader(value) {
        return value instanceof Header3;
      }
      Header3.isHeader = isHeader;
    })(Header2 = Cell2.Header || (Cell2.Header = {}));
    Cell2.header = Header2.of, Cell2.isHeader = Header2.isHeader;
  })(Cell || (Cell = {}));

  // node_modules/@siteimprove/alfa-table/dist/slot.js
  var Slot2 = class _Slot {
    static of(x, y) {
      return new _Slot(x, y);
    }
    _x;
    _y;
    constructor(x, y) {
      this._x = x;
      this._y = y;
    }
    get x() {
      return this._x;
    }
    get y() {
      return this._y;
    }
    compare(slot) {
      if (this._y > slot._y) {
        return Comparison.Greater;
      }
      if (this._y < slot._y) {
        return Comparison.Less;
      }
      if (this._x > slot._x) {
        return Comparison.Greater;
      }
      if (this._x < slot._x) {
        return Comparison.Less;
      }
      return Comparison.Equal;
    }
    equals(value) {
      return value instanceof _Slot && value._x === this._x && value._y === this._y;
    }
    toJSON() {
      return {
        x: this._x,
        y: this._y
      };
    }
  };
  (function(Slot3) {
    function isSlot(value) {
      return value instanceof Slot3;
    }
    Slot3.isSlot = isSlot;
  })(Slot2 || (Slot2 = {}));

  // node_modules/@siteimprove/alfa-table/dist/column.js
  var Column = class _Column {
    static of(x) {
      return new _Column(x);
    }
    _x;
    constructor(x) {
      this._x = x;
    }
    get x() {
      return this._x;
    }
    get anchor() {
      return Slot2.of(this._x, 0);
    }
    compare(anchored) {
      return Anchored.compare(this, anchored);
    }
    equals(value) {
      return value instanceof _Column && value._x === this._x;
    }
    toJSON() {
      return {
        x: this._x
      };
    }
  };
  (function(Column2) {
    function isColumn(value) {
      return value instanceof Column2;
    }
    Column2.isColumn = isColumn;
    class Group3 {
      static of(element, x, width) {
        return new Group3(element, x, width);
      }
      _element;
      _x;
      _width;
      constructor(element, x, width) {
        this._element = element;
        this._x = x;
        this._width = width;
      }
      get element() {
        return this._element;
      }
      get x() {
        return this._x;
      }
      get anchor() {
        return Slot2.of(this._x, 0);
      }
      get width() {
        return this._width;
      }
      compare(anchored) {
        return Anchored.compare(this, anchored);
      }
      equals(value) {
        return value instanceof Group3 && value._element.equals(this._element) && value._x === this._x && value._width === this._width;
      }
      toJSON() {
        return {
          element: this._element.path(),
          x: this._x,
          width: this._width
        };
      }
    }
    Column2.Group = Group3;
    (function(Group4) {
      function isGroup(value) {
        return value instanceof Group4;
      }
      Group4.isGroup = isGroup;
    })(Group3 = Column2.Group || (Column2.Group = {}));
    Column2.group = Group3.of, Column2.isGroup = Group3.isGroup;
  })(Column || (Column = {}));

  // node_modules/@siteimprove/alfa-table/dist/row.js
  var Row = class _Row {
    static of(y) {
      return new _Row(y);
    }
    _y;
    constructor(y) {
      this._y = y;
    }
    get y() {
      return this._y;
    }
    get anchor() {
      return Slot2.of(0, this._y);
    }
    compare(anchored) {
      return Anchored.compare(this, anchored);
    }
    equals(value) {
      return value instanceof _Row && value._y === this._y;
    }
    toJSON() {
      return {
        y: this._y
      };
    }
  };
  (function(Row2) {
    function isRow(value) {
      return value instanceof Row2;
    }
    Row2.isRow = isRow;
    class Group3 {
      static of(element, y, height) {
        return new Group3(element, y, height);
      }
      _element;
      _y;
      _height;
      constructor(element, y, height) {
        this._element = element;
        this._y = y;
        this._height = height;
      }
      get element() {
        return this._element;
      }
      get y() {
        return this._y;
      }
      get anchor() {
        return Slot2.of(0, this._y);
      }
      get height() {
        return this._height;
      }
      compare(anchored) {
        return Anchored.compare(this, anchored);
      }
      equals(value) {
        return value instanceof Group3 && value._element.equals(this._element) && value._y === this._y && value._height === this._height;
      }
      toJSON() {
        return {
          element: this._element.path(),
          y: this._y,
          height: this._height
        };
      }
    }
    Row2.Group = Group3;
    (function(Group4) {
      function isGroup(value) {
        return value instanceof Group4;
      }
      Group4.isGroup = isGroup;
    })(Group3 = Row2.Group || (Row2.Group = {}));
    Row2.group = Group3.of, Row2.isGroup = Group3.isGroup;
  })(Row || (Row = {}));

  // node_modules/@siteimprove/alfa-table/dist/group.js
  var { or: or19 } = Refinement;
  var Group;
  (function(Group3) {
    Group3.isColumn = Column.isGroup;
    Group3.isRow = Row.isGroup;
    Group3.isGroup = or19(Group3.isColumn, Group3.isRow);
  })(Group || (Group = {}));

  // node_modules/@siteimprove/alfa-table/dist/scope.js
  var Scope2;
  (function(Scope3) {
    function from(element) {
      return element.attribute("scope").flatMap((attribute) => attribute.enumerate("row", "rowgroup", "col", "colgroup")).map((scope) => {
        switch (scope) {
          case "row":
            return "row";
          case "rowgroup":
            return "row-group";
          case "col":
            return "column";
          case "colgroup":
            return "column-group";
        }
      }).getOr("auto");
    }
    Scope3.from = from;
  })(Scope2 || (Scope2 = {}));

  // node_modules/@siteimprove/alfa-table/dist/table.js
  var { isNaN: isNaN2 } = Number;
  var { clamp: clamp2 } = Real;
  var { not: not25, equals: equals15 } = Predicate;
  var { hasName: hasName15, isElement: isElement28 } = Element;
  var Table = class _Table {
    static of(element, cells, groups) {
      return new _Table(element, Array2.sort(Array2.copy(Array2.from(cells))), Array2.sort(Array2.copy(Array2.from(groups))));
    }
    static empty(element) {
      return new _Table(element, [], []);
    }
    _element;
    _cells;
    _groups;
    constructor(element, cells, groups) {
      this._element = element;
      this._cells = cells;
      this._groups = groups;
    }
    get element() {
      return this._element;
    }
    get cells() {
      return Sequence.from(this._cells);
    }
    get groups() {
      return Sequence.from(this._groups);
    }
    isEmpty() {
      return this._cells.length === 0;
    }
    equals(value) {
      return value instanceof _Table && value._element.equals(this._element) && Array2.equals(value._cells, this._cells);
    }
    toJSON() {
      return {
        element: this._element.path(),
        cells: Array2.toJSON(this._cells),
        groups: Array2.toJSON(this._groups)
      };
    }
  };
  (function(Table2) {
    const cache16 = Cache2.empty();
    function from(element) {
      return cache16.get(element, () => formTable(element));
    }
    Table2.from = from;
    function formTable(element) {
      let xWidth = 0;
      let yHeight = 0;
      const footers = [];
      const cells = [];
      const groups = [];
      const table = [];
      const data = { x: /* @__PURE__ */ new Set(), y: /* @__PURE__ */ new Set() };
      const jumps = {
        x: /* @__PURE__ */ new Map(),
        y: /* @__PURE__ */ new Map()
      };
      const index = /* @__PURE__ */ new Map();
      const groupings = {
        x: /* @__PURE__ */ new Map(),
        y: /* @__PURE__ */ new Map()
      };
      if (element.children().isEmpty()) {
        return Table2.of(element, cells, groups);
      }
      let children = element.children().filter(isElement28);
      let current = children.first();
      function advance() {
        children = children.rest();
        current = children.first();
        return current;
      }
      function skip3(predicate) {
        while (current.some(predicate)) {
          advance();
        }
      }
      skip3(not25(hasName15("colgroup", "thead", "tbody", "tfoot", "tr")));
      while (current.some(hasName15("colgroup"))) {
        processColumnGroup(current.get());
        advance();
        skip3(not25(hasName15("colgroup", "thead", "tbody", "tfoot", "tr")));
      }
      let yCurrent = 0;
      let downwardGrowing = [];
      while (current.isSome()) {
        skip3(not25(hasName15("thead", "tbody", "tfoot", "tr")));
        if (current.isNone()) {
          break;
        }
        if (current.some(hasName15("tr"))) {
          processRow(current.get());
          advance();
          continue;
        }
        endRowGroup();
        if (current.some(hasName15("tfoot"))) {
          footers.push(current.get());
          advance();
          continue;
        }
        processRowGroup(current.get());
        advance();
      }
      footers.forEach(processRowGroup);
      cells.forEach(assignScope);
      cells.forEach(assignHeaders);
      return Table2.of(element, cells, groups);
      function ensure(x, y) {
        for (let i = table.length - 1; i < y; i++) {
          table.push([]);
        }
        const row = table[y];
        for (let i = row.length - 1; i < x; i++) {
          row.push([]);
        }
      }
      function get(x, y) {
        ensure(x, y);
        return table[y][x];
      }
      function has(x, y) {
        return get(x, y).length > 0;
      }
      function add(x, y, i) {
        const cell = cells[i];
        if (cell.isHeader()) {
          if (jumps.x.has(x)) {
            jumps.x.get(x).push(y);
          } else {
            jumps.x.set(x, [y]);
          }
          if (jumps.y.has(y)) {
            jumps.y.get(y).push(x);
          } else {
            jumps.y.set(y, [x]);
          }
        } else if (!cell.isEmpty()) {
          data.x.add(x);
          data.y.add(y);
        }
        ensure(x, y);
        return table[y][x].push(i);
      }
      function jump(i, candidates = []) {
        for (let j = candidates.length - 1; j >= 0; j--) {
          const candidate = candidates[j];
          if (candidate <= i) {
            return candidate;
          }
        }
        return -1;
      }
      function processRowGroup(element2) {
        const yStart = yHeight;
        element2.children().filter(isElement28).filter(hasName15("tr")).forEach(processRow);
        if (yHeight > yStart) {
          const group = Row.group(element2, yStart, yHeight - yStart);
          const i = groups.length;
          groups.push(group);
          for (let y = group.y, n = y + group.height; y < n; y++) {
            groupings.y.set(y, i);
          }
        }
        endRowGroup();
      }
      function endRowGroup() {
        while (yCurrent < yHeight) {
          growCells();
          yCurrent++;
        }
        downwardGrowing = [];
      }
      function processRow(element2) {
        if (yHeight === yCurrent) {
          yHeight++;
        }
        let xCurrent = 0;
        growCells();
        let children2 = element2.children().filter(isElement28).filter(hasName15("td", "th"));
        if (children2.isEmpty()) {
          yCurrent++;
          return;
        }
        let current2 = children2.first();
        function advance2() {
          children2 = children2.rest();
          current2 = children2.first();
          return current2;
        }
        while (current2.isSome()) {
          while (xCurrent < xWidth && has(xCurrent, yCurrent)) {
            xCurrent++;
          }
          if (xCurrent === xWidth) {
            xWidth++;
          }
          const colspan = integerValue(
            current2.get(),
            "colspan",
            1,
            1e3
            /* upper */
          );
          let rowspan = integerValue(
            current2.get(),
            "rowspan",
            0,
            65534,
            1
            /* missing */
          );
          let growsDownward;
          if (rowspan === 0) {
            growsDownward = true;
            rowspan = 1;
          } else {
            growsDownward = false;
          }
          if (xWidth < xCurrent + colspan) {
            xWidth = xCurrent + colspan;
          }
          if (yHeight < yCurrent + rowspan) {
            yHeight = yCurrent + rowspan;
          }
          let cell;
          if (current2.some(hasName15("th"))) {
            cell = Cell.header(current2.get(), Slot2.of(xCurrent, yCurrent), colspan, rowspan);
          } else {
            cell = Cell.data(current2.get(), Slot2.of(xCurrent, yCurrent), colspan, rowspan);
          }
          const i = cells.length;
          cells.push(cell);
          for (const id of cell.element.id) {
            index.set(id, i);
          }
          for (let x = xCurrent, n = x + colspan; x < n; x++) {
            for (let y = yCurrent, n2 = y + rowspan; y < n2; y++) {
              add(x, y, i);
            }
          }
          if (growsDownward) {
            downwardGrowing.push([cell, i]);
          }
          xCurrent += colspan;
          if (advance2().isNone()) {
            yCurrent++;
            return;
          }
        }
      }
      function processColumnGroup(element2) {
        let children2 = element2.children().filter(isElement28).filter(hasName15("col"));
        let current2 = children2.first();
        function advance2() {
          children2 = children2.rest();
          current2 = children2.first();
          return current2;
        }
        let group;
        let i;
        if (!children2.isEmpty()) {
          const xStart = xWidth;
          while (current2.isSome()) {
            const span = integerValue(
              current2.get(),
              "span",
              1,
              1e3
              /* upper */
            );
            xWidth += span;
            advance2();
          }
          group = Column.group(element2, xStart, xWidth - xStart);
          i = groups.length;
        } else {
          const span = integerValue(
            element2,
            "span",
            1,
            1e3
            /* upper */
          );
          xWidth += span;
          group = Column.group(element2, xWidth - span, span);
          i = groups.length;
        }
        groups.push(group);
        for (let x = group.x, n = x + group.width; x < n; x++) {
          groupings.x.set(x, i);
        }
      }
      function growCells() {
        for (const [cell, i] of downwardGrowing) {
          const height = yCurrent - cell.y + 1;
          for (let x = cell.x, n = x + cell.width; x < n; x++) {
            for (let y = cell.y + cell.height, n2 = cell.y + height; y < n2; y++) {
              add(x, y, i);
            }
          }
          if (cell.isHeader()) {
            cells[i] = Cell.header(cell.element, cell.anchor, cell.width, height);
          } else {
            cells[i] = Cell.data(cell.element, cell.anchor, cell.width, height);
          }
        }
      }
      function assignHeaders(cell, i) {
        const headers = [];
        const ids2 = cell.element.attribute("headers").map((attribute) => attribute.tokens());
        if (ids2.isSome()) {
          headers.push(...ids2.get().collect((id) => Option.from(index.get(id)).map((i2) => cells[i2])));
        } else {
          for (let y = cell.y, n = y + cell.height; y < n; y++) {
            scanHeaderCells(cell, headers, cell.x, y, -1, 0);
          }
          for (let x = cell.x, n = x + cell.width; x < n; x++) {
            scanHeaderCells(cell, headers, x, cell.y, 0, -1);
          }
          const i2 = groupings.y.get(cell.y);
          if (i2 !== void 0) {
            const group = groups[i2];
            for (let x = cell.x + cell.width - 1; x >= 0; x--) {
              for (let y = group.y, n = cell.y + cell.height; y < n; y++) {
                x = jump(x, jumps.y.get(y));
                if (x < 0) {
                  break;
                }
                headers.push(...get(x, y).map((i3) => cells[i3]).filter((cell2) => cell2.isHeader() && isRowGroupHeader(cell2)));
              }
            }
          }
          const j = groupings.x.get(cell.x);
          if (j !== void 0) {
            const group = groups[j];
            for (let y = cell.y + cell.height - 1; y >= 0; y--) {
              for (let x = group.x, n = cell.x + cell.width; x < n; x++) {
                y = jump(y, jumps.x.get(x));
                if (y < 0) {
                  break;
                }
                headers.push(...get(x, y).map((i3) => cells[i3]).filter((cell2) => cell2.isHeader() && isColumnGroupHeader(cell2)));
              }
            }
          }
        }
        const filtered = Sequence.from(headers).reject((cell2) => cell2.isEmpty()).distinct().reject(equals15(cell));
        const anchors = filtered.map((cell2) => cell2.anchor);
        if (cell.isHeader()) {
          cells[i] = Cell.header(cell.element, cell.anchor, cell.width, cell.height, anchors, cell.scope);
        } else {
          cells[i] = Cell.data(cell.element, cell.anchor, cell.width, cell.height, anchors);
        }
      }
      function scanHeaderCells(principal, headers, initialX, initialY, deltaX, deltaY) {
        let x = initialX;
        let y = initialY;
        const opaque = [];
        let inHeader = principal.isHeader();
        let currentHeaders = inHeader ? [principal] : [];
        while (true) {
          x += deltaX;
          y += deltaY;
          if (deltaX === 0) {
            y = jump(y, jumps.x.get(x));
          } else {
            x = jump(x, jumps.y.get(y));
          }
          if (x < 0 || y < 0) {
            return;
          }
          const neighbour = get(x, y);
          if (neighbour.length !== 1) {
            continue;
          }
          const cell = cells[neighbour[0]];
          if (cell.isHeader()) {
            inHeader = true;
            currentHeaders.push(cell);
            let blocked = false;
            if (deltaX === 0) {
              if (opaque.some((header) => header.x === cell.x && header.width === cell.width) || !isColumHeader(cell)) {
                blocked = true;
              }
            } else {
              if (opaque.some((header) => header.y === cell.y && header.height === cell.height) || !isRowHeader(cell)) {
                blocked = true;
              }
            }
            if (!blocked) {
              headers.push(cell);
            }
          } else if (inHeader) {
            inHeader = false;
            opaque.push(...currentHeaders);
            currentHeaders = [];
          }
        }
      }
      function assignScope(cell, i) {
        if (!cell.isHeader()) {
          return;
        }
        let scope;
        if (isColumHeader(cell)) {
          scope = "column";
        } else if (isColumnGroupHeader(cell)) {
          scope = "column-group";
        } else if (isRowHeader(cell)) {
          scope = "row";
        } else if (isRowGroupHeader(cell)) {
          scope = "row-group";
        } else {
          return;
        }
        cells[i] = Cell.header(cell.element, cell.anchor, cell.width, cell.height, cell.headers, scope);
      }
      function isColumHeader(cell) {
        if (cell.scope === "column") {
          return true;
        }
        switch (Scope2.from(cell.element)) {
          case "column":
            return true;
          case "auto":
            for (let y = cell.y, n = y + cell.height; y < n; y++) {
              if (data.y.has(y)) {
                return false;
              }
            }
            return true;
        }
        return false;
      }
      function isColumnGroupHeader(cell) {
        return cell.scope === "column-group" || Scope2.from(cell.element) === "column-group";
      }
      function isRowHeader(cell) {
        if (cell.scope === "row") {
          return true;
        }
        switch (Scope2.from(cell.element)) {
          case "row":
            return true;
          case "auto":
            for (let x = cell.x, n = x + cell.width; x < n; x++) {
              if (data.x.has(x)) {
                return false;
              }
            }
            return true;
        }
        return false;
      }
      function isRowGroupHeader(cell) {
        return cell.scope === "row-group" || Scope2.from(cell.element) === "row-group";
      }
    }
    function integerValue(element, attribute, lower, upper, missing = lower) {
      return clamp2(element.attribute(attribute).map((attribute2) => parseInt(attribute2.value)).reject(isNaN2).getOr(missing), lower, upper);
    }
  })(Table || (Table = {}));

  // node_modules/@siteimprove/alfa-aria/dist/attribute/data.js
  var Attributes = {
    "aria-activedescendant": {
      kind: "property",
      type: "id-reference",
      options: null,
      default: null
    },
    "aria-atomic": {
      kind: "property",
      type: "true-false",
      options: null,
      default: "false"
    },
    "aria-autocomplete": {
      kind: "property",
      type: "token",
      options: ["inline", "list", "both", "none"],
      default: "none"
    },
    "aria-busy": {
      kind: "state",
      type: "true-false",
      options: null,
      default: "false"
    },
    "aria-checked": {
      kind: "state",
      type: "tristate",
      options: null,
      default: "undefined"
    },
    "aria-colcount": {
      kind: "property",
      type: "integer",
      options: null,
      default: null
    },
    "aria-colindex": {
      kind: "property",
      type: "integer",
      options: null,
      default: null
    },
    "aria-colspan": {
      kind: "property",
      type: "integer",
      options: null,
      default: null
    },
    "aria-controls": {
      kind: "property",
      type: "id-reference-list",
      options: null,
      default: null
    },
    "aria-current": {
      kind: "state",
      type: "token",
      options: ["page", "step", "location", "date", "time", "true", "false"],
      default: "false"
    },
    "aria-describedby": {
      kind: "property",
      type: "id-reference-list",
      options: null,
      default: null
    },
    "aria-details": {
      kind: "property",
      type: "id-reference",
      options: null,
      default: null
    },
    "aria-disabled": {
      kind: "state",
      type: "true-false",
      options: null,
      default: "false"
    },
    "aria-dropeffect": {
      kind: "property",
      type: "token-list",
      options: ["copy", "execute", "link", "move", "none", "popup"],
      default: "none"
    },
    "aria-errormessage": {
      kind: "property",
      type: "id-reference",
      options: null,
      default: null
    },
    "aria-expanded": {
      kind: "state",
      type: "true-false-undefined",
      options: null,
      default: "undefined"
    },
    "aria-flowto": {
      kind: "property",
      type: "id-reference-list",
      options: null,
      default: null
    },
    "aria-grabbed": {
      kind: "state",
      type: "true-false-undefined",
      options: null,
      default: "undefined"
    },
    "aria-haspopup": {
      kind: "property",
      type: "token",
      options: ["false", "true", "menu", "listbox", "tree", "grid", "dialog"],
      default: "false"
    },
    "aria-hidden": {
      kind: "state",
      type: "true-false-undefined",
      options: null,
      default: "undefined"
    },
    "aria-invalid": {
      kind: "state",
      type: "token",
      options: ["grammar", "false", "spelling", "true"],
      default: "false"
    },
    "aria-keyshortcuts": {
      kind: "property",
      type: "string",
      options: null,
      default: null
    },
    "aria-label": {
      kind: "property",
      type: "string",
      options: null,
      default: null
    },
    "aria-labelledby": {
      kind: "property",
      type: "id-reference-list",
      options: null,
      default: null
    },
    "aria-level": {
      kind: "property",
      type: "integer",
      options: null,
      default: null
    },
    "aria-live": {
      kind: "property",
      type: "token",
      options: ["assertive", "off", "polite"],
      default: "off"
    },
    "aria-modal": {
      kind: "property",
      type: "true-false",
      options: null,
      default: "false"
    },
    "aria-multiline": {
      kind: "property",
      type: "true-false",
      options: null,
      default: "false"
    },
    "aria-multiselectable": {
      kind: "property",
      type: "true-false",
      options: null,
      default: "false"
    },
    "aria-orientation": {
      kind: "property",
      type: "token",
      options: ["horizontal", "undefined", "vertical"],
      default: "undefined"
    },
    "aria-owns": {
      kind: "property",
      type: "id-reference-list",
      options: null,
      default: null
    },
    "aria-placeholder": {
      kind: "property",
      type: "string",
      options: null,
      default: null
    },
    "aria-posinset": {
      kind: "property",
      type: "integer",
      options: null,
      default: null
    },
    "aria-pressed": {
      kind: "state",
      type: "tristate",
      options: null,
      default: "undefined"
    },
    "aria-readonly": {
      kind: "property",
      type: "true-false",
      options: null,
      default: "false"
    },
    "aria-relevant": {
      kind: "property",
      type: "token-list",
      options: ["additions", "additions text", "all", "removals", "text"],
      default: "additions text"
    },
    "aria-required": {
      kind: "property",
      type: "true-false",
      options: null,
      default: "false"
    },
    "aria-roledescription": {
      kind: "property",
      type: "string",
      options: null,
      default: null
    },
    "aria-rowcount": {
      kind: "property",
      type: "integer",
      options: null,
      default: null
    },
    "aria-rowindex": {
      kind: "property",
      type: "integer",
      options: null,
      default: null
    },
    "aria-rowspan": {
      kind: "property",
      type: "integer",
      options: null,
      default: null
    },
    "aria-selected": {
      kind: "state",
      type: "true-false-undefined",
      options: null,
      default: "undefined"
    },
    "aria-setsize": {
      kind: "property",
      type: "integer",
      options: null,
      default: null
    },
    "aria-sort": {
      kind: "property",
      type: "token",
      options: ["ascending", "descending", "none", "other"],
      default: "none"
    },
    "aria-valuemax": {
      kind: "property",
      type: "number",
      options: null,
      default: null
    },
    "aria-valuemin": {
      kind: "property",
      type: "number",
      options: null,
      default: null
    },
    "aria-valuenow": {
      kind: "property",
      type: "number",
      options: null,
      default: null
    },
    "aria-valuetext": {
      kind: "property",
      type: "string",
      options: null,
      default: null
    }
  };

  // node_modules/@siteimprove/alfa-aria/dist/role/data.js
  var Roles = {
    alert: {
      abstract: false,
      inherited: ["section"],
      attributes: [
        [
          "aria-atomic",
          {
            required: false,
            prohibited: false,
            value: "true"
          }
        ],
        [
          "aria-live",
          {
            required: false,
            prohibited: false,
            value: "assertive"
          }
        ]
      ],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    alertdialog: {
      abstract: false,
      inherited: ["alert", "dialog"],
      attributes: [],
      name: {
        required: true,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    application: {
      abstract: false,
      inherited: ["structure"],
      attributes: [
        [
          "aria-activedescendant",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-disabled",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-errormessage",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-expanded",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-haspopup",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-invalid",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ]
      ],
      name: {
        required: true,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    article: {
      abstract: false,
      inherited: ["document"],
      attributes: [
        [
          "aria-posinset",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-setsize",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ]
      ],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    banner: {
      abstract: false,
      inherited: ["landmark"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    blockquote: {
      abstract: false,
      inherited: ["section"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    button: {
      abstract: false,
      inherited: ["command"],
      attributes: [
        [
          "aria-disabled",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-expanded",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-haspopup",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-pressed",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ]
      ],
      name: {
        required: true,
        prohibited: false,
        from: ["author", "contents"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: true,
        required: []
      }
    },
    caption: {
      abstract: false,
      inherited: ["section"],
      attributes: [
        [
          "aria-label",
          {
            required: false,
            prohibited: true,
            value: null
          }
        ],
        [
          "aria-labelledby",
          {
            required: false,
            prohibited: true,
            value: null
          }
        ]
      ],
      name: {
        required: false,
        prohibited: true,
        from: []
      },
      parent: {
        required: [["figure"], ["grid"], ["table"], ["treegrid"]]
      },
      children: {
        presentational: false,
        required: []
      }
    },
    cell: {
      abstract: false,
      inherited: ["section"],
      attributes: [
        [
          "aria-colindex",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-colspan",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-rowindex",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-rowspan",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ]
      ],
      name: {
        required: false,
        prohibited: false,
        from: ["author", "contents"]
      },
      parent: {
        required: [["row"]]
      },
      children: {
        presentational: false,
        required: []
      }
    },
    checkbox: {
      abstract: false,
      inherited: ["input"],
      attributes: [
        [
          "aria-checked",
          {
            required: true,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-errormessage",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-expanded",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-invalid",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-readonly",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-required",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ]
      ],
      name: {
        required: true,
        prohibited: false,
        from: ["author", "contents"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: true,
        required: []
      }
    },
    code: {
      abstract: false,
      inherited: ["section"],
      attributes: [
        [
          "aria-label",
          {
            required: false,
            prohibited: true,
            value: null
          }
        ],
        [
          "aria-labelledby",
          {
            required: false,
            prohibited: true,
            value: null
          }
        ]
      ],
      name: {
        required: false,
        prohibited: true,
        from: []
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    columnheader: {
      abstract: false,
      inherited: ["cell", "gridcell", "sectionhead"],
      attributes: [
        [
          "aria-sort",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ]
      ],
      name: {
        required: true,
        prohibited: false,
        from: ["author", "contents"]
      },
      parent: {
        required: [["row"]]
      },
      children: {
        presentational: false,
        required: []
      }
    },
    combobox: {
      abstract: false,
      inherited: ["input"],
      attributes: [
        [
          "aria-activedescendant",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-autocomplete",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-controls",
          {
            required: true,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-errormessage",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-expanded",
          {
            required: true,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-haspopup",
          {
            required: false,
            prohibited: false,
            value: "listbox"
          }
        ],
        [
          "aria-invalid",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-readonly",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-required",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ]
      ],
      name: {
        required: true,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    command: {
      abstract: true,
      inherited: ["widget"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    complementary: {
      abstract: false,
      inherited: ["landmark"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    composite: {
      abstract: true,
      inherited: ["widget"],
      attributes: [
        [
          "aria-activedescendant",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-disabled",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ]
      ],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    contentinfo: {
      abstract: false,
      inherited: ["landmark"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    definition: {
      abstract: false,
      inherited: ["section"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    deletion: {
      abstract: false,
      inherited: ["section"],
      attributes: [
        [
          "aria-label",
          {
            required: false,
            prohibited: true,
            value: null
          }
        ],
        [
          "aria-labelledby",
          {
            required: false,
            prohibited: true,
            value: null
          }
        ]
      ],
      name: {
        required: false,
        prohibited: true,
        from: []
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    dialog: {
      abstract: false,
      inherited: ["window"],
      attributes: [],
      name: {
        required: true,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    directory: {
      abstract: false,
      inherited: ["list"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    document: {
      abstract: false,
      inherited: ["structure"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    emphasis: {
      abstract: false,
      inherited: ["section"],
      attributes: [
        [
          "aria-label",
          {
            required: false,
            prohibited: true,
            value: null
          }
        ],
        [
          "aria-labelledby",
          {
            required: false,
            prohibited: true,
            value: null
          }
        ]
      ],
      name: {
        required: false,
        prohibited: true,
        from: []
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    feed: {
      abstract: false,
      inherited: ["list"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: [["article"]]
      }
    },
    figure: {
      abstract: false,
      inherited: ["section"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    form: {
      abstract: false,
      inherited: ["landmark"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    generic: {
      abstract: false,
      inherited: ["structure"],
      attributes: [
        [
          "aria-label",
          {
            required: false,
            prohibited: true,
            value: null
          }
        ],
        [
          "aria-labelledby",
          {
            required: false,
            prohibited: true,
            value: null
          }
        ],
        [
          "aria-roledescription",
          {
            required: false,
            prohibited: true,
            value: null
          }
        ]
      ],
      name: {
        required: false,
        prohibited: true,
        from: []
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    grid: {
      abstract: false,
      inherited: ["composite", "table"],
      attributes: [
        [
          "aria-multiselectable",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-readonly",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ]
      ],
      name: {
        required: true,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: [["row"], ["rowgroup", "row"]]
      }
    },
    gridcell: {
      abstract: false,
      inherited: ["cell", "widget"],
      attributes: [
        [
          "aria-disabled",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-errormessage",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-expanded",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-haspopup",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-invalid",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-readonly",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-required",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-selected",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ]
      ],
      name: {
        required: false,
        prohibited: false,
        from: ["author", "contents"]
      },
      parent: {
        required: [["row"]]
      },
      children: {
        presentational: false,
        required: []
      }
    },
    group: {
      abstract: false,
      inherited: ["section"],
      attributes: [
        [
          "aria-activedescendant",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-disabled",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ]
      ],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    heading: {
      abstract: false,
      inherited: ["sectionhead"],
      attributes: [
        [
          "aria-level",
          {
            required: true,
            prohibited: false,
            value: null
          }
        ]
      ],
      name: {
        required: true,
        prohibited: false,
        from: ["author", "contents"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    img: {
      abstract: false,
      inherited: ["section"],
      attributes: [],
      name: {
        required: true,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: true,
        required: []
      }
    },
    input: {
      abstract: true,
      inherited: ["widget"],
      attributes: [
        [
          "aria-disabled",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ]
      ],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    insertion: {
      abstract: false,
      inherited: ["section"],
      attributes: [
        [
          "aria-label",
          {
            required: false,
            prohibited: true,
            value: null
          }
        ],
        [
          "aria-labelledby",
          {
            required: false,
            prohibited: true,
            value: null
          }
        ]
      ],
      name: {
        required: false,
        prohibited: true,
        from: []
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    landmark: {
      abstract: true,
      inherited: ["section"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    link: {
      abstract: false,
      inherited: ["command"],
      attributes: [
        [
          "aria-disabled",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-expanded",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-haspopup",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ]
      ],
      name: {
        required: true,
        prohibited: false,
        from: ["author", "contents"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    list: {
      abstract: false,
      inherited: ["section"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: [["listitem"]]
      }
    },
    listbox: {
      abstract: false,
      inherited: ["select"],
      attributes: [
        [
          "aria-errormessage",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-expanded",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-invalid",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-multiselectable",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-orientation",
          {
            required: false,
            prohibited: false,
            value: "vertical"
          }
        ],
        [
          "aria-readonly",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-required",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ]
      ],
      name: {
        required: true,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: [["group", "option"], ["option"]]
      }
    },
    listitem: {
      abstract: false,
      inherited: ["section"],
      attributes: [
        [
          "aria-level",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-posinset",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-setsize",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ]
      ],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: [["directory"], ["list"]]
      },
      children: {
        presentational: false,
        required: []
      }
    },
    log: {
      abstract: false,
      inherited: ["section"],
      attributes: [
        [
          "aria-live",
          {
            required: false,
            prohibited: false,
            value: "polite"
          }
        ]
      ],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    main: {
      abstract: false,
      inherited: ["landmark"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    marquee: {
      abstract: false,
      inherited: ["section"],
      attributes: [],
      name: {
        required: true,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    math: {
      abstract: false,
      inherited: ["section"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    menu: {
      abstract: false,
      inherited: ["select"],
      attributes: [
        [
          "aria-orientation",
          {
            required: false,
            prohibited: false,
            value: "vertical"
          }
        ]
      ],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: [
          ["group", "menuitem"],
          ["group", "menuitemradio"],
          ["group", "menuitemcheckbox"],
          ["menuitem"],
          ["menuitemcheckbox"],
          ["menuitemradio"]
        ]
      }
    },
    menubar: {
      abstract: false,
      inherited: ["menu"],
      attributes: [
        [
          "aria-orientation",
          {
            required: false,
            prohibited: false,
            value: "horizontal"
          }
        ]
      ],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: [
          ["group", "menuitem"],
          ["group", "menuitemradio"],
          ["group", "menuitemcheckbox"],
          ["menuitem"],
          ["menuitemcheckbox"],
          ["menuitemradio"]
        ]
      }
    },
    menuitem: {
      abstract: false,
      inherited: ["command"],
      attributes: [
        [
          "aria-disabled",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-expanded",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-haspopup",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-posinset",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-setsize",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ]
      ],
      name: {
        required: true,
        prohibited: false,
        from: ["author", "contents"]
      },
      parent: {
        required: [["group"], ["menu"], ["menubar"]]
      },
      children: {
        presentational: false,
        required: []
      }
    },
    menuitemcheckbox: {
      abstract: false,
      inherited: ["menuitem"],
      attributes: [
        [
          "aria-checked",
          {
            required: true,
            prohibited: false,
            value: null
          }
        ]
      ],
      name: {
        required: true,
        prohibited: false,
        from: ["author", "contents"]
      },
      parent: {
        required: [["group"], ["menu"], ["menubar"]]
      },
      children: {
        presentational: true,
        required: []
      }
    },
    menuitemradio: {
      abstract: false,
      inherited: ["menuitemcheckbox"],
      attributes: [],
      name: {
        required: true,
        prohibited: false,
        from: ["author", "contents"]
      },
      parent: {
        required: [["group"], ["menu"], ["menubar"]]
      },
      children: {
        presentational: true,
        required: []
      }
    },
    meter: {
      abstract: false,
      inherited: ["range"],
      attributes: [
        [
          "aria-valuemax",
          {
            required: false,
            prohibited: false,
            value: "100"
          }
        ],
        [
          "aria-valuemin",
          {
            required: false,
            prohibited: false,
            value: "0"
          }
        ],
        [
          "aria-valuenow",
          {
            required: true,
            prohibited: false,
            value: null
          }
        ]
      ],
      name: {
        required: true,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: true,
        required: []
      }
    },
    navigation: {
      abstract: false,
      inherited: ["landmark"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    none: {
      abstract: false,
      inherited: [],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: []
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    note: {
      abstract: false,
      inherited: ["section"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    option: {
      abstract: false,
      inherited: ["input"],
      attributes: [
        [
          "aria-checked",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-posinset",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-selected",
          {
            required: true,
            prohibited: false,
            value: "false"
          }
        ],
        [
          "aria-setsize",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ]
      ],
      name: {
        required: true,
        prohibited: false,
        from: ["author", "contents"]
      },
      parent: {
        required: [["group"], ["listbox"]]
      },
      children: {
        presentational: true,
        required: []
      }
    },
    paragraph: {
      abstract: false,
      inherited: ["section"],
      attributes: [
        [
          "aria-label",
          {
            required: false,
            prohibited: true,
            value: null
          }
        ],
        [
          "aria-labelledby",
          {
            required: false,
            prohibited: true,
            value: null
          }
        ]
      ],
      name: {
        required: false,
        prohibited: true,
        from: []
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    presentation: {
      abstract: false,
      inherited: ["structure"],
      attributes: [
        [
          "aria-label",
          {
            required: false,
            prohibited: true,
            value: null
          }
        ],
        [
          "aria-labelledby",
          {
            required: false,
            prohibited: true,
            value: null
          }
        ]
      ],
      name: {
        required: false,
        prohibited: true,
        from: []
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    progressbar: {
      abstract: false,
      inherited: ["range", "widget"],
      attributes: [
        [
          "aria-valuemax",
          {
            required: false,
            prohibited: false,
            value: "100"
          }
        ],
        [
          "aria-valuemin",
          {
            required: false,
            prohibited: false,
            value: "0"
          }
        ]
      ],
      name: {
        required: true,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: true,
        required: []
      }
    },
    radio: {
      abstract: false,
      inherited: ["input"],
      attributes: [
        [
          "aria-checked",
          {
            required: true,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-posinset",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-setsize",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ]
      ],
      name: {
        required: true,
        prohibited: false,
        from: ["author", "contents"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: true,
        required: []
      }
    },
    radiogroup: {
      abstract: false,
      inherited: ["select"],
      attributes: [
        [
          "aria-errormessage",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-invalid",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-readonly",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-required",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ]
      ],
      name: {
        required: true,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: [["radio"]]
      }
    },
    range: {
      abstract: true,
      inherited: ["structure"],
      attributes: [
        [
          "aria-valuemax",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-valuemin",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-valuenow",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-valuetext",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ]
      ],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    region: {
      abstract: false,
      inherited: ["landmark"],
      attributes: [],
      name: {
        required: true,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    roletype: {
      abstract: true,
      inherited: [],
      attributes: [
        [
          "aria-atomic",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-busy",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-controls",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-current",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-describedby",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-details",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-dropeffect",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-flowto",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-grabbed",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-hidden",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-keyshortcuts",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-label",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-labelledby",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-live",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-owns",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-relevant",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-roledescription",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ]
      ],
      name: {
        required: false,
        prohibited: false,
        from: []
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    row: {
      abstract: false,
      inherited: ["group", "widget"],
      attributes: [
        [
          "aria-colindex",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-expanded",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-level",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-posinset",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-rowindex",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-selected",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-setsize",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ]
      ],
      name: {
        required: false,
        prohibited: false,
        from: ["author", "contents"]
      },
      parent: {
        required: [["grid"], ["rowgroup"], ["table"], ["treegrid"]]
      },
      children: {
        presentational: false,
        required: [["cell"], ["columnheader"], ["gridcell"], ["rowheader"]]
      }
    },
    rowgroup: {
      abstract: false,
      inherited: ["structure"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: [["grid"], ["table"], ["treegrid"]]
      },
      children: {
        presentational: false,
        required: [["row"]]
      }
    },
    rowheader: {
      abstract: false,
      inherited: ["cell", "gridcell", "sectionhead"],
      attributes: [
        [
          "aria-expanded",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-sort",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ]
      ],
      name: {
        required: true,
        prohibited: false,
        from: ["author", "contents"]
      },
      parent: {
        required: [["row"]]
      },
      children: {
        presentational: false,
        required: []
      }
    },
    scrollbar: {
      abstract: false,
      inherited: ["range", "widget"],
      attributes: [
        [
          "aria-controls",
          {
            required: true,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-disabled",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-orientation",
          {
            required: false,
            prohibited: false,
            value: "vertical"
          }
        ],
        [
          "aria-valuemax",
          {
            required: false,
            prohibited: false,
            value: "100"
          }
        ],
        [
          "aria-valuemin",
          {
            required: false,
            prohibited: false,
            value: "0"
          }
        ],
        [
          "aria-valuenow",
          {
            required: true,
            prohibited: false,
            value: null
          }
        ]
      ],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: true,
        required: []
      }
    },
    search: {
      abstract: false,
      inherited: ["landmark"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    searchbox: {
      abstract: false,
      inherited: ["textbox"],
      attributes: [],
      name: {
        required: true,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    section: {
      abstract: true,
      inherited: ["structure"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: []
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    sectionhead: {
      abstract: true,
      inherited: ["structure"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author", "contents"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    select: {
      abstract: true,
      inherited: ["composite", "group"],
      attributes: [
        [
          "aria-orientation",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ]
      ],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    separator: {
      abstract: false,
      inherited: ["structure", "widget"],
      attributes: [
        [
          "aria-disabled",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-orientation",
          {
            required: false,
            prohibited: false,
            value: "horizontal"
          }
        ],
        [
          "aria-valuemax",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-valuemin",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-valuenow",
          {
            required: true,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-valuetext",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ]
      ],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: true,
        required: []
      }
    },
    slider: {
      abstract: false,
      inherited: ["input", "range"],
      attributes: [
        [
          "aria-errormessage",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-haspopup",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-invalid",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-orientation",
          {
            required: false,
            prohibited: false,
            value: "horizontal"
          }
        ],
        [
          "aria-readonly",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-valuemax",
          {
            required: false,
            prohibited: false,
            value: "100"
          }
        ],
        [
          "aria-valuemin",
          {
            required: false,
            prohibited: false,
            value: "0"
          }
        ],
        [
          "aria-valuenow",
          {
            required: true,
            prohibited: false,
            value: null
          }
        ]
      ],
      name: {
        required: true,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: true,
        required: []
      }
    },
    spinbutton: {
      abstract: false,
      inherited: ["composite", "input", "range"],
      attributes: [
        [
          "aria-errormessage",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-invalid",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-readonly",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-required",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-valuemax",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-valuemin",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-valuenow",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-valuetext",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ]
      ],
      name: {
        required: true,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    status: {
      abstract: false,
      inherited: ["section"],
      attributes: [
        [
          "aria-atomic",
          {
            required: false,
            prohibited: false,
            value: "true"
          }
        ],
        [
          "aria-live",
          {
            required: false,
            prohibited: false,
            value: "polite"
          }
        ]
      ],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    strong: {
      abstract: false,
      inherited: ["section"],
      attributes: [
        [
          "aria-label",
          {
            required: false,
            prohibited: true,
            value: null
          }
        ],
        [
          "aria-labelledby",
          {
            required: false,
            prohibited: true,
            value: null
          }
        ]
      ],
      name: {
        required: false,
        prohibited: true,
        from: []
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    structure: {
      abstract: true,
      inherited: ["roletype"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: []
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    subscript: {
      abstract: false,
      inherited: ["section"],
      attributes: [
        [
          "aria-label",
          {
            required: false,
            prohibited: true,
            value: null
          }
        ],
        [
          "aria-labelledby",
          {
            required: false,
            prohibited: true,
            value: null
          }
        ]
      ],
      name: {
        required: false,
        prohibited: true,
        from: []
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    superscript: {
      abstract: false,
      inherited: ["section"],
      attributes: [
        [
          "aria-label",
          {
            required: false,
            prohibited: true,
            value: null
          }
        ],
        [
          "aria-labelledby",
          {
            required: false,
            prohibited: true,
            value: null
          }
        ]
      ],
      name: {
        required: false,
        prohibited: true,
        from: []
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    switch: {
      abstract: false,
      inherited: ["checkbox"],
      attributes: [
        [
          "aria-checked",
          {
            required: true,
            prohibited: false,
            value: null
          }
        ]
      ],
      name: {
        required: true,
        prohibited: false,
        from: ["author", "contents"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: true,
        required: []
      }
    },
    tab: {
      abstract: false,
      inherited: ["sectionhead", "widget"],
      attributes: [
        [
          "aria-disabled",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-expanded",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-haspopup",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-posinset",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-selected",
          {
            required: false,
            prohibited: false,
            value: "false"
          }
        ],
        [
          "aria-setsize",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ]
      ],
      name: {
        required: false,
        prohibited: false,
        from: ["author", "contents"]
      },
      parent: {
        required: [["tablist"]]
      },
      children: {
        presentational: true,
        required: []
      }
    },
    table: {
      abstract: false,
      inherited: ["section"],
      attributes: [
        [
          "aria-colcount",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-rowcount",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ]
      ],
      name: {
        required: true,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: [["row"], ["rowgroup", "row"]]
      }
    },
    tablist: {
      abstract: false,
      inherited: ["composite"],
      attributes: [
        [
          "aria-multiselectable",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-orientation",
          {
            required: false,
            prohibited: false,
            value: "horizontal"
          }
        ]
      ],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: [["tab"]]
      }
    },
    tabpanel: {
      abstract: false,
      inherited: ["section"],
      attributes: [],
      name: {
        required: true,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    term: {
      abstract: false,
      inherited: ["section"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    textbox: {
      abstract: false,
      inherited: ["input"],
      attributes: [
        [
          "aria-activedescendant",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-autocomplete",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-errormessage",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-haspopup",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-invalid",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-multiline",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-placeholder",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-readonly",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-required",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ]
      ],
      name: {
        required: true,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    time: {
      abstract: false,
      inherited: ["section"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    timer: {
      abstract: false,
      inherited: ["status"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    toolbar: {
      abstract: false,
      inherited: ["group"],
      attributes: [
        [
          "aria-orientation",
          {
            required: false,
            prohibited: false,
            value: "horizontal"
          }
        ]
      ],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    tooltip: {
      abstract: false,
      inherited: ["section"],
      attributes: [],
      name: {
        required: true,
        prohibited: false,
        from: ["author", "contents"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    tree: {
      abstract: false,
      inherited: ["select"],
      attributes: [
        [
          "aria-errormessage",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-invalid",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-multiselectable",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-orientation",
          {
            required: false,
            prohibited: false,
            value: "vertical"
          }
        ],
        [
          "aria-required",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ]
      ],
      name: {
        required: true,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: [["group", "treeitem"], ["treeitem"]]
      }
    },
    treegrid: {
      abstract: false,
      inherited: ["grid", "tree"],
      attributes: [],
      name: {
        required: true,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: [["row"], ["rowgroup", "row"]]
      }
    },
    treeitem: {
      abstract: false,
      inherited: ["listitem", "option"],
      attributes: [
        [
          "aria-expanded",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ],
        [
          "aria-haspopup",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ]
      ],
      name: {
        required: true,
        prohibited: false,
        from: ["author", "contents"]
      },
      parent: {
        required: [["group"], ["tree"]]
      },
      children: {
        presentational: false,
        required: []
      }
    },
    widget: {
      abstract: true,
      inherited: ["roletype"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: []
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    window: {
      abstract: true,
      inherited: ["roletype"],
      attributes: [
        [
          "aria-modal",
          {
            required: false,
            prohibited: false,
            value: null
          }
        ]
      ],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    "graphics-document": {
      abstract: false,
      inherited: ["document"],
      attributes: [],
      name: {
        required: true,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    "graphics-object": {
      abstract: false,
      inherited: ["group"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author", "contents"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    "graphics-symbol": {
      abstract: false,
      inherited: ["img"],
      attributes: [],
      name: {
        required: true,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: true,
        required: []
      }
    },
    "doc-abstract": {
      abstract: false,
      inherited: ["section"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    "doc-acknowledgments": {
      abstract: false,
      inherited: ["landmark"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    "doc-afterword": {
      abstract: false,
      inherited: ["landmark"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    "doc-appendix": {
      abstract: false,
      inherited: ["landmark"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    "doc-backlink": {
      abstract: false,
      inherited: ["link"],
      attributes: [],
      name: {
        required: true,
        prohibited: false,
        from: ["author", "contents"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    "doc-biblioentry": {
      abstract: false,
      inherited: ["listitem"],
      attributes: [],
      name: {
        required: true,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: [["doc-bibliography"]]
      },
      children: {
        presentational: false,
        required: []
      }
    },
    "doc-bibliography": {
      abstract: false,
      inherited: ["landmark"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: [["doc-biblioentry"]]
      }
    },
    "doc-biblioref": {
      abstract: false,
      inherited: ["link"],
      attributes: [],
      name: {
        required: true,
        prohibited: false,
        from: ["author", "contents"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    "doc-chapter": {
      abstract: false,
      inherited: ["landmark"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    "doc-colophon": {
      abstract: false,
      inherited: ["section"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    "doc-conclusion": {
      abstract: false,
      inherited: ["landmark"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    "doc-cover": {
      abstract: false,
      inherited: ["img"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    "doc-credit": {
      abstract: false,
      inherited: ["section"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    "doc-credits": {
      abstract: false,
      inherited: ["landmark"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    "doc-dedication": {
      abstract: false,
      inherited: ["section"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    "doc-endnote": {
      abstract: false,
      inherited: ["listitem"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: [["doc-endnotes"]]
      },
      children: {
        presentational: false,
        required: []
      }
    },
    "doc-endnotes": {
      abstract: false,
      inherited: ["landmark"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: [["doc-endnote"]]
      }
    },
    "doc-epigraph": {
      abstract: false,
      inherited: ["section"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    "doc-epilogue": {
      abstract: false,
      inherited: ["landmark"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    "doc-errata": {
      abstract: false,
      inherited: ["landmark"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    "doc-example": {
      abstract: false,
      inherited: ["section"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    "doc-footnote": {
      abstract: false,
      inherited: ["section"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    "doc-foreword": {
      abstract: false,
      inherited: ["landmark"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    "doc-glossary": {
      abstract: false,
      inherited: ["landmark"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: [["term", "definition"]]
      }
    },
    "doc-glossref": {
      abstract: false,
      inherited: ["link"],
      attributes: [],
      name: {
        required: true,
        prohibited: false,
        from: ["author", "contents"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    "doc-index": {
      abstract: false,
      inherited: ["navigation"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    "doc-introduction": {
      abstract: false,
      inherited: ["landmark"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    "doc-noteref": {
      abstract: false,
      inherited: ["link"],
      attributes: [],
      name: {
        required: true,
        prohibited: false,
        from: ["author", "contents"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    "doc-notice": {
      abstract: false,
      inherited: ["note"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    "doc-pagebreak": {
      abstract: false,
      inherited: ["separator"],
      attributes: [],
      name: {
        required: true,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: true,
        required: []
      }
    },
    "doc-pagelist": {
      abstract: false,
      inherited: ["navigation"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    "doc-part": {
      abstract: false,
      inherited: ["landmark"],
      attributes: [],
      name: {
        required: true,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    "doc-preface": {
      abstract: false,
      inherited: ["landmark"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    "doc-prologue": {
      abstract: false,
      inherited: ["landmark"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    "doc-pullquote": {
      abstract: false,
      inherited: ["none"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    "doc-qna": {
      abstract: false,
      inherited: ["section"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    "doc-subtitle": {
      abstract: false,
      inherited: ["sectionhead"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    "doc-tip": {
      abstract: false,
      inherited: ["note"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    },
    "doc-toc": {
      abstract: false,
      inherited: ["navigation"],
      attributes: [],
      name: {
        required: false,
        prohibited: false,
        from: ["author"]
      },
      parent: {
        required: []
      },
      children: {
        presentational: false,
        required: []
      }
    }
  };

  // node_modules/@siteimprove/alfa-aria/dist/role/predicate/has-name.js
  var { equals: equals16 } = Predicate;
  function hasName16(nameOrPredicate, ...names) {
    let predicate;
    if (typeof nameOrPredicate === "function") {
      predicate = nameOrPredicate;
    } else {
      predicate = equals16(nameOrPredicate, ...names);
    }
    return (role) => predicate(role.name);
  }

  // node_modules/@siteimprove/alfa-aria/dist/role.js
  var { and: and25, not: not26, nor: nor3 } = Predicate;
  var roles = Map2.empty();
  var Role = class _Role {
    static of(name) {
      return roles.get(name).getOrElse(() => {
        const attributes = Roles[name].attributes;
        const inherited = Roles[name].inherited;
        const supportedAttributes = Set2.from(attributes.map(([attribute]) => attribute)).concat(inherited.flatMap((parent) => _Role.of(parent).supportedAttributes));
        const requiredAttributes = Set2.from(Array2.collect(attributes, ([attribute, { required }]) => required ? Option.of(attribute) : None)).concat(inherited.flatMap((parent) => _Role.of(parent).requiredAttributes));
        const prohibitedAttributes = Set2.from(Array2.collect(attributes, ([attribute, { prohibited }]) => prohibited ? Option.of(attribute) : None)).concat(inherited.flatMap((parent) => _Role.of(parent).prohibitedAttributes));
        const role = new _Role(name, [...supportedAttributes], [...requiredAttributes], [...prohibitedAttributes]);
        roles = roles.set(name, role);
        return role;
      });
    }
    _name;
    _supportedAttributes;
    _requiredAttributes;
    _prohibitedAttributes;
    constructor(name, supportedAttributes, requiredAttributes, prohibitedAttributes) {
      this._name = name;
      this._supportedAttributes = supportedAttributes;
      this._requiredAttributes = requiredAttributes;
      this._prohibitedAttributes = prohibitedAttributes;
    }
    get name() {
      return this._name;
    }
    /**
     * Get all attributes supported by this role and its inherited (ancestors) roles.
     */
    get supportedAttributes() {
      return this._supportedAttributes;
    }
    /**
     * Get all attributes required by this role and its inherited (ancestors) roles.
     */
    get requiredAttributes() {
      return this._requiredAttributes;
    }
    /**
     * Get all attributes prohibited on this role and its inherited (ancestors) roles.
     */
    get prohibitedAttributes() {
      return this._prohibitedAttributes;
    }
    /**
     * Get the required parent of this role.
     */
    get requiredParent() {
      return Roles[this._name].parent.required;
    }
    /**
     * Get the required children of this role.
     */
    get requiredChildren() {
      return Roles[this._name].children.required;
    }
    /**
     * Check if this role has the specified name.
     */
    hasName(name) {
      return this._name === name;
    }
    /**
     * Check if this role is a superclass of the role with the specified name.
     */
    isSuperclassOf(name) {
      const { inherited } = Roles[name];
      for (const parent of inherited) {
        if (parent === this._name || this.isSuperclassOf(parent)) {
          return true;
        }
      }
      return false;
    }
    /**
     * Check if this role is a subclass of the role with the specified name.
     */
    isSubclassOf(name) {
      return _Role.of(name).isSuperclassOf(this._name);
    }
    /**
     * Check if this role either is, or is a subclass of, the role with the
     * specified name.
     */
    is(name) {
      return this.hasName(name) || this.isSubclassOf(name);
    }
    /**
     * Check if this role is abstract.
     */
    isAbstract() {
      return Roles[this._name].abstract;
    }
    /**
     * Check if this role is non-abstract.
     */
    isConcrete() {
      return !this.isAbstract();
    }
    /**
     * Check if this role is presentational.
     */
    isPresentational() {
      return this.hasName("presentation") || this.hasName("none");
    }
    /**
     * Check if this role is a widget.
     */
    isWidget() {
      return this.is("widget");
    }
    /**
     * Check if this role is a landmark.
     */
    isLandmark() {
      return this.is("landmark");
    }
    /**
     * Check if this role supports naming by the specified method.
     */
    isNamedBy(method) {
      for (const found of Roles[this._name].name.from) {
        if (found === method) {
          return true;
        }
      }
      return false;
    }
    /**
     * Check if this role prohibits naming.
     */
    isNameProhibited() {
      return Roles[this._name].name.prohibited;
    }
    /**
     * Check if this role has a required parent.
     */
    hasRequiredParent() {
      return Roles[this._name].parent.required.length > 0;
    }
    /**
     * Check if this role has presentational children.
     */
    hasPresentationalChildren() {
      return Roles[this._name].children.presentational;
    }
    /**
     * Check if this role has required children.
     */
    hasRequiredChildren() {
      return Roles[this._name].children.required.length > 0;
    }
    /**
     * Check if this role supports the specified attribute.
     */
    isAttributeSupported(name) {
      return this._supportedAttributes.includes(name);
    }
    /**
     * Check if this role requires the specified attribute.
     */
    isAttributeRequired(name) {
      return this._requiredAttributes.includes(name);
    }
    /**
     * Check if this role prohibits the specified attribute.
     */
    isAttributeProhibited(name) {
      return this._prohibitedAttributes.includes(name);
    }
    /**
     * Get the implicit value of the specified attribute, if any.
     */
    implicitAttributeValue(name) {
      const { inherited, attributes } = Roles[this._name];
      for (const [found, { value }] of attributes) {
        if (name === found && value !== null) {
          return Option.from(value);
        }
      }
      for (const parent of inherited) {
        for (const value of _Role.of(parent).implicitAttributeValue(name)) {
          return Option.of(value);
        }
      }
      return None;
    }
    equals(value) {
      return value instanceof _Role && value._name === this._name;
    }
    hash(hash2) {
      hash2.writeString(this._name);
    }
    toJSON() {
      return {
        name: this._name
      };
    }
  };
  (function(Role2) {
    function isName2(value) {
      return value in Roles;
    }
    Role2.isName = isName2;
    function isRole(value, name) {
      return value instanceof Role2 && (name === void 0 || value.name === name);
    }
    Role2.isRole = isRole;
    function from(element) {
      return fromExplicit(element).orElse(() => fromImplicit(element));
    }
    Role2.from = from;
    function fromExplicit(element) {
      const roles2 = element.attribute("role").map((attribute) => attribute.tokens()).getOrElse(() => Sequence.empty());
      return roles2.map((role) => role.toLowerCase()).filter(isName2).map(Role2.of).reject((role) => role.isAbstract()).reject((role) => isAllowedPresentational(element) ? false : role.isPresentational()).first();
    }
    Role2.fromExplicit = fromExplicit;
    function fromImplicit(element) {
      return element.namespace.flatMap((namespace) => Feature2.from(namespace, element.name).flatMap((feature) => Sequence.from(feature.role(element)).reject((role) => isAllowedPresentational(element) ? false : role.isPresentational()).first()));
    }
    Role2.fromImplicit = fromImplicit;
    Role2.hasName = hasName16;
  })(Role || (Role = {}));
  var hasGlobalAttributes = (element) => Iterable.some(Role.of("roletype").supportedAttributes, (attribute) => element.attribute(attribute).isSome());
  var isPotentiallyFocusable = and25(Element.hasTabIndex(), not26(Element.isActuallyDisabled));
  var isAllowedPresentational = nor3(hasGlobalAttributes, isPotentiallyFocusable);

  // node_modules/@siteimprove/alfa-aria/dist/attribute.js
  var Attribute3 = class _Attribute {
    static of(name, value) {
      return new _Attribute(name, value);
    }
    _name;
    _value;
    constructor(name, value) {
      this._name = name;
      this._value = value;
    }
    get name() {
      return this._name;
    }
    get value() {
      return this._value;
    }
    get kind() {
      return Attributes[this._name].kind;
    }
    get type() {
      return Attributes[this._name].type;
    }
    get default() {
      const value = Attributes[this._name].default;
      if (value === null) {
        return None;
      }
      return Option.of(value);
    }
    get options() {
      const options = Attributes[this._name].options;
      if (options === null) {
        return Sequence.empty();
      }
      return Sequence.from(options);
    }
    /**
     * {@link https://www.w3.org/TR/wai-aria/#global_states}
     */
    isGlobal() {
      return Role.of("roletype").isAttributeSupported(this._name);
    }
    equals(value) {
      return value instanceof _Attribute && value._name === this._name && value._value === this._value;
    }
    toJSON() {
      return {
        name: this._name,
        value: this._value
      };
    }
  };
  (function(Attribute4) {
    function isName2(value) {
      return value in Attributes;
    }
    Attribute4.isName = isName2;
  })(Attribute3 || (Attribute3 = {}));

  // node_modules/@siteimprove/alfa-aria/dist/feature.js
  var { hasAttribute: hasAttribute3, hasInputType: hasInputType3, hasName: hasName17, isElement: isElement29, isScopedTo: isScopedTo2 } = Element;
  var { or: or20, test: test17 } = Predicate;
  var { and: and26 } = Refinement;
  var { getElementDescendants: getElementDescendants2 } = Query3;
  var Feature2 = class _Feature {
    static of(role = () => None, attributes = () => None, name = () => None) {
      const roleAspect = typeof role === "function" ? role : () => Option.of(Role.of(role));
      return new _Feature(roleAspect, attributes, name);
    }
    _role;
    _attributes;
    _name;
    constructor(roleAspect, attributes, name) {
      this._role = (element) => {
        const role = roleAspect(element);
        return typeof role === "string" ? Option.of(Role.of(role)) : role;
      };
      this._attributes = attributes;
      this._name = name;
    }
    get role() {
      return this._role;
    }
    get attributes() {
      return this._attributes;
    }
    get name() {
      return this._name;
    }
  };
  (function(Feature3) {
    function from(namespace, name) {
      return Option.from(Features[namespace]?.[name]).orElse(() => {
        switch (namespace) {
          case Namespace.HTML:
            return Option.of(html());
          case Namespace.SVG:
            return Option.of(svg());
        }
        return None;
      });
    }
    Feature3.from = from;
    Feature3.generic = html("generic");
  })(Feature2 || (Feature2 = {}));
  function html(role = () => None, attributes = () => None, name = () => None) {
    return Feature2.of(role, attributes, (element, device, state) => Name.fromSteps(() => name(element, device, state), () => nameFromAttribute(element, "title")));
  }
  function svg(role = () => None, attributes = () => None, name = () => None) {
    return Feature2.of(role, attributes, (element, device, state) => Name.fromSteps(() => name(element, device, state), () => nameFromChild(hasName17("title"))(element, device, state), () => nameFromAttribute(element, "title")));
  }
  var nameFromAttribute = (element, ...attributes) => {
    for (const name of attributes) {
      for (const attribute of element.attribute(name)) {
        if (attribute.value.length > 0) {
          return Name.fromLabel(attribute);
        }
      }
    }
    return None;
  };
  var nameFromChild = (predicate) => (element, device, state) => element.children().filter(isElement29).find(predicate).flatMap((child) => Name.fromDescendants(child, device, state.visit(child)).map((name) => Name.of(name.value, [Source.descendant(element, name)])));
  var ids = Cache2.empty();
  var labels = Cache2.empty();
  var nameFromLabel = (element, device, state) => {
    const root = element.root();
    const elements = getElementDescendants2(root);
    const isFirstReference = element.id.some((id) => ids.get(root, () => Map2.from(elements.collect((element2) => element2.id.map((id2) => [id2, element2])).reverse())).get(id).includes(element));
    const references = labels.get(root, () => elements.filter(hasName17("label"))).filter(or20((label) => label.attribute("for").isNone() && label.descendants().includes(element), (label) => isFirstReference && label.attribute("for").some((attribute) => element.id.includes(attribute.value))));
    const names = references.collect((element2) => Name.fromNode(element2, device, state.reference(element2, element2).recurse(true).descend(false)).map((name2) => [name2, element2]));
    const name = names.map(([name2]) => name2.value).join(" ").trim();
    if (name === "") {
      return None;
    }
    return Option.of(Name.of(name, names.map(([name2, element2]) => {
      for (const attribute of element2.attribute("for")) {
        return Source.reference(attribute, name2);
      }
      return Source.ancestor(element2, name2);
    })));
  };
  function ifScopedTo(names, ifScoped, ifNotScoped) {
    return (element) => test17(isScopedTo2(...names), element) ? ifScoped : ifNotScoped;
  }
  function ifHasAttribute(attribute, ifHas, ifDoesNotHave) {
    return (element) => test17(hasAttribute3(attribute), element) ? ifHas : ifDoesNotHave;
  }
  var Features = {
    [Namespace.HTML]: {
      a: html(
        ifHasAttribute("href", "link", "generic"),
        () => [],
        // Content takes precedence over title for `<a>` elements, so we need to
        // call Name.fromDescendants() before `html` looks into `title`.
        (element, device, state) => Name.fromDescendants(element, device, state.visit(element))
      ),
      area: html(ifHasAttribute("href", "link", "generic"), () => [], (element) => nameFromAttribute(element, "alt")),
      article: html("article"),
      // We currently cannot detect at this point if the element has an accessible
      // name, and always map to complementary.
      // see https://github.com/Siteimprove/alfa/issues/298
      aside: html("complementary"),
      button: html("button", function* (element) {
        for (const _ of element.attribute("disabled")) {
          yield Attribute3.of("aria-disabled", "true");
        }
      }),
      // https://w3c.github.io/html-aam/#el-datalist
      // <datalist> only has a role if it is correctly mapped to an <input>
      // via the list attribute. We should probably check that.
      // Additionally, it seems to never be rendered, hence always ignored.
      datalist: html("listbox"),
      dd: html("definition"),
      dfn: html("term"),
      dialog: html("dialog", function* (element) {
        yield Attribute3.of("aria-expanded", element.attribute("open").isSome() ? "true" : "false");
      }),
      details: html(() => None, function* (element) {
        yield Attribute3.of("aria-expanded", element.attribute("open").isSome() ? "true" : "false");
      }),
      dt: html("term"),
      fieldset: html("group", function* (element) {
        for (const _ of element.attribute("disabled")) {
          yield Attribute3.of("aria-disabled", "true");
        }
      }, nameFromChild(hasName17("legend"))),
      figure: html("figure", () => [], nameFromChild(hasName17("figcaption"))),
      footer: html(ifScopedTo(["article", "aside", "main", "nav", "section"], "generic", "contentinfo")),
      // We currently cannot detect at this point if the element has an accessible
      // name, and always map to form.
      // see https://github.com/Siteimprove/alfa/issues/298
      form: html("form"),
      h1: html("heading", () => [Attribute3.of("aria-level", "1")]),
      h2: html("heading", () => [Attribute3.of("aria-level", "2")]),
      h3: html("heading", () => [Attribute3.of("aria-level", "3")]),
      h4: html("heading", () => [Attribute3.of("aria-level", "4")]),
      h5: html("heading", () => [Attribute3.of("aria-level", "5")]),
      h6: html("heading", () => [Attribute3.of("aria-level", "6")]),
      header: html(ifScopedTo(["article", "aside", "main", "nav", "section"], "generic", "banner")),
      hgroup: html("group"),
      hr: html("separator"),
      img: html(
        // We need to yield all roles, not just return one, in order for the
        // presentational role conflict resolution to discard `presentation`
        // and correctly default to `img`.
        function* (element) {
          if (element.attribute("alt").some((alt) => alt.value === "")) {
            yield Role.of("presentation");
          }
          if (element.attribute("src").every((src) => src.value.trim() === "")) {
            yield Role.of("presentation");
          }
          yield Role.of("img");
        },
        () => [],
        (element) => nameFromAttribute(element, "alt")
      ),
      input: html((element) => {
        switch (element.inputType()) {
          case "button":
          case "image":
          case "reset":
          case "submit":
            return "button";
          case "checkbox":
            return "checkbox";
          case "number":
            return "spinbutton";
          case "radio":
            return "radio";
          case "range":
            return "slider";
          case "search":
            return element.attribute("list").isSome() ? "combobox" : "searchbox";
          // Note: The specification for email has changed, it now has role textbox. We should look into this if it becomes an issue.
          case "email":
          case "tel":
          case "text":
          case "url":
            return element.attribute("list").isSome() ? "combobox" : "textbox";
        }
        return None;
      }, function* (element) {
        yield Attribute3.of("aria-checked", element.attribute("checked").isSome() ? "true" : "false");
        for (const { value } of element.attribute("list")) {
          yield Attribute3.of("aria-controls", value);
        }
        for (const _ of element.attribute("disabled")) {
          yield Attribute3.of("aria-disabled", "true");
        }
        for (const { value } of element.attribute("placeholder")) {
          yield Attribute3.of("aria-placeholder", value);
        }
        for (const _ of element.attribute("readonly")) {
          yield Attribute3.of("aria-readonly", "true");
        }
        for (const _ of element.attribute("required")) {
          yield Attribute3.of("aria-required", "true");
        }
        for (const { value } of element.attribute("max")) {
          yield Attribute3.of("aria-valuemax", value);
        }
        for (const { value } of element.attribute("min")) {
          yield Attribute3.of("aria-valuemin", value);
        }
        for (const { value } of element.attribute("value")) {
          yield Attribute3.of("aria-valuenow", value);
        }
      }, (element, device, state) => {
        if (test17(hasInputType3("text", "password", "search", "tel", "email", "url"), element)) {
          return Name.fromSteps(
            () => nameFromLabel(element, device, state),
            // The title attribute has poor and varying support, but
            // the specs give it precedence over placeholder.
            // This could be a browser-branched value.
            () => nameFromAttribute(element, "title", "placeholder")
          );
        }
        if (test17(hasInputType3("button"), element)) {
          return Name.fromSteps(
            // {@link https://github.com/w3c/html-aam/pull/423}
            () => nameFromLabel(element, device, state),
            () => nameFromAttribute(element, "value")
          );
        }
        if (test17(hasInputType3("submit"), element)) {
          return Name.fromSteps(
            // {@link https://github.com/w3c/html-aam/pull/423}
            () => nameFromLabel(element, device, state),
            () => nameFromAttribute(element, "value"),
            () => Option.of(Name.of("Submit"))
          );
        }
        if (test17(hasInputType3("reset"), element)) {
          return Name.fromSteps(
            // {@link https://github.com/w3c/html-aam/pull/423}
            () => nameFromLabel(element, device, state),
            () => nameFromAttribute(element, "value"),
            () => Option.of(Name.of("Reset"))
          );
        }
        if (test17(hasInputType3("image"), element)) {
          return Name.fromSteps(
            // {@link https://github.com/w3c/html-aam/pull/423}
            () => nameFromLabel(element, device, state),
            // The title attribute has poor and varying support, but the specs
            // use it.
            // This could be a browser-branched value.
            () => nameFromAttribute(element, "alt", "title"),
            () => Option.of(Name.of("Submit Query"))
          );
        }
        return nameFromLabel(element, device, state);
      }),
      li: html((element) => element.parent(Node4.fullTree).some(and26(Element.isElement, hasName17("ol", "ul", "menu"))) ? "listitem" : "generic", (element) => {
        const siblings = element.inclusiveSiblings().filter(and26(Element.isElement, Element.hasName("li")));
        return [
          Attribute3.of("aria-setsize", `${siblings.size}`),
          Attribute3.of("aria-posinset", `${siblings.takeUntil((sibling) => sibling.equals(element)).size + 1}`)
        ];
      }),
      main: html("main"),
      math: html("math"),
      menu: html("list"),
      meter: html(() => None, function* (element) {
        for (const { value } of element.attribute("max")) {
          yield Attribute3.of("aria-valuemax", value);
        }
        for (const { value } of element.attribute("min")) {
          yield Attribute3.of("aria-valuemin", value);
        }
        for (const { value } of element.attribute("value")) {
          yield Attribute3.of("aria-valuenow", value);
        }
      }),
      nav: html("navigation"),
      ol: html("list"),
      optgroup: html("group", function* (element) {
        for (const _ of element.attribute("disabled")) {
          yield Attribute3.of("aria-disabled", "true");
        }
      }),
      option: html(ifScopedTo(["select", "optgroup", "datalist"], "option", None), function* (element) {
        for (const _ of element.attribute("disabled")) {
          yield Attribute3.of("aria-disabled", "true");
        }
        yield Attribute3.of("aria-selected", element.attribute("selected").isSome() ? "true" : "false");
      }),
      output: html("status"),
      p: html("paragraph"),
      progress: html("progressbar", function* (element) {
        for (const { value } of element.attribute("max")) {
          yield Attribute3.of("aria-valuemax", value);
        }
        for (const { value } of element.attribute("value")) {
          yield Attribute3.of("aria-valuenow", value);
        }
      }),
      // We currently cannot detect at this point if the element has an accessible
      // name, and always map to region.
      // see https://github.com/Siteimprove/alfa/issues/298
      section: html("region"),
      select: html(
        // mono-line <select> are mapped to combobox by HTML AAM, but their child
        // <option> are still mapped to option, which are out of their context role.
        // See https://www.w3.org/TR/html-aam-1.0/#el-select-combobox
        // UAs seem to interpose a listbox, sometimes through UA shadow DOM.
        // This is actually a good behaviour as the combobox is supposed to control
        // a listbox containing the options.
        // We cheat and always map <select> to listbox
        "listbox",
        // (element) =>
        //   test(Element.hasDisplaySize((size) => size > 1), element)
        //   ? "listbox" : combobox
        function* (element) {
          for (const _ of element.attribute("disabled")) {
            yield Attribute3.of("aria-disabled", "true");
          }
          for (const _ of element.attribute("required")) {
            yield Attribute3.of("aria-required", "true");
          }
          for (const _ of element.attribute("multiple")) {
            yield Attribute3.of("aria-multiselectable", "true");
          }
        },
        nameFromLabel
      ),
      table: html("table", () => [], nameFromChild(hasName17("caption"))),
      tbody: html("rowgroup"),
      td: html((element) => element.ancestors().filter(isElement29).find(hasName17("table")).flatMap((table) => {
        for (const role of Role.from(table)) {
          if (role.is("table")) {
            return Option.of(Role.of("cell"));
          }
          if (role.is("grid")) {
            return Option.of(Role.of("gridcell"));
          }
        }
        return None;
      }), function* (element) {
        for (const { value } of element.attribute("colspan")) {
          yield Attribute3.of("aria-colspan", value);
        }
        for (const { value } of element.attribute("rowspan")) {
          yield Attribute3.of("aria-rowspan", value);
        }
      }),
      textarea: html("textbox", function* (element) {
        yield Attribute3.of("aria-multiline", "true");
        for (const _ of element.attribute("disabled")) {
          yield Attribute3.of("aria-disabled", "true");
        }
        for (const _ of element.attribute("readonly")) {
          yield Attribute3.of("aria-readonly", "true");
        }
        for (const _ of element.attribute("required")) {
          yield Attribute3.of("aria-required", "true");
        }
        for (const { value } of element.attribute("placeholder")) {
          yield Attribute3.of("aria-placeholder", value);
        }
      }, (element, device, state) => {
        return Name.fromSteps(() => nameFromLabel(element, device, state), () => nameFromAttribute(element, "title", "placeholder"));
      }),
      tfoot: html("rowgroup"),
      th: html((element) => element.ancestors().filter(isElement29).find(hasName17("table")).map(Table.from).flatMap((table) => table.cells.filter(Cell.isHeader).find(Cell.hasElement(element)).map((cell) => {
        return { table, cell };
      })).flatMap(({ table, cell }) => {
        switch (cell.scope) {
          case "column":
          case "column-group":
            return Option.of(Role.of("columnheader"));
          case "row":
          case "row-group":
            return Option.of(Role.of("rowheader"));
          default:
            for (const role of Role.from(table.element)) {
              if (role.is("table")) {
                return Option.of(Role.of("cell"));
              }
              if (role.is("grid")) {
                return Option.of(Role.of("gridcell"));
              }
            }
            return None;
        }
      }), function* (element) {
        for (const { value } of element.attribute("colspan")) {
          yield Attribute3.of("aria-colspan", value);
        }
        for (const { value } of element.attribute("rowspan")) {
          yield Attribute3.of("aria-rowspan", value);
        }
      }),
      thead: html("rowgroup"),
      tr: html("row"),
      ul: html("list"),
      // Generic containers with no real semantics
      b: Feature2.generic,
      bdi: Feature2.generic,
      bdo: Feature2.generic,
      body: Feature2.generic,
      data: Feature2.generic,
      div: Feature2.generic,
      i: Feature2.generic,
      pre: Feature2.generic,
      q: Feature2.generic,
      samp: Feature2.generic,
      small: Feature2.generic,
      span: Feature2.generic,
      u: Feature2.generic
    },
    [Namespace.SVG]: {
      a: svg(ifHasAttribute("href", "link", "group")),
      circle: svg("graphics-symbol"),
      ellipse: svg("graphics-symbol"),
      foreignObject: svg("group"),
      g: svg("group"),
      image: svg("img"),
      line: svg("graphics-symbol"),
      mesh: svg("img"),
      path: svg("graphics-symbol"),
      polygon: svg("graphics-symbol"),
      polyline: svg("graphics-symbol"),
      rect: svg("graphics-symbol"),
      svg: svg("graphics-document"),
      symbol: svg("graphics-object"),
      text: svg("group"),
      textPath: svg("group"),
      use: svg("graphics-object")
    }
  };

  // node_modules/@siteimprove/alfa-aria/dist/name/predicate/has-value.js
  var { equals: equals17 } = Predicate;
  function hasValue(valueOrPredicate, ...values) {
    let predicate;
    if (typeof valueOrPredicate === "function") {
      predicate = valueOrPredicate;
    } else {
      predicate = equals17(valueOrPredicate, ...values);
    }
    return (name) => predicate(name.value);
  }

  // node_modules/@siteimprove/alfa-aria/dist/name/source.js
  var Source;
  (function(Source2) {
    class Data {
      static of(text) {
        return new Data(text);
      }
      _text;
      constructor(text) {
        this._text = text;
      }
      get type() {
        return "data";
      }
      get text() {
        return this._text;
      }
      equals(value) {
        return value instanceof Data && value._text.equals(this._text);
      }
      *[Symbol.iterator]() {
        yield this._text;
      }
      toJSON() {
        return {
          type: "data",
          text: this._text.path()
        };
      }
    }
    Source2.Data = Data;
    function data(text) {
      return Data.of(text);
    }
    Source2.data = data;
    class Descendant {
      static of(element, name) {
        return new Descendant(element, name);
      }
      _element;
      _name;
      constructor(element, name) {
        this._element = element;
        this._name = name;
      }
      get type() {
        return "descendants";
      }
      get element() {
        return this._element;
      }
      get name() {
        return this._name;
      }
      equals(value) {
        return value instanceof Descendant && value._element.equals(this._element) && value._name.equals(this._name);
      }
      *[Symbol.iterator]() {
        yield this._element;
        yield* this._name.sourceNodes();
      }
      toJSON() {
        return {
          type: "descendant",
          element: this._element.path(Node4.flatTree),
          name: this._name.toJSON()
        };
      }
    }
    Source2.Descendant = Descendant;
    function descendant(element, name) {
      return Descendant.of(element, name);
    }
    Source2.descendant = descendant;
    class Ancestor {
      static of(element, name) {
        return new Ancestor(element, name);
      }
      _element;
      _name;
      constructor(element, name) {
        this._element = element;
        this._name = name;
      }
      get type() {
        return "ancestor";
      }
      get element() {
        return this._element;
      }
      get name() {
        return this._name;
      }
      equals(value) {
        return value instanceof Ancestor && value._element.equals(this._element) && value._name.equals(this._name);
      }
      *[Symbol.iterator]() {
        yield this._element;
        yield* this._name.sourceNodes();
      }
      toJSON() {
        return {
          type: "ancestor",
          element: this._element.path(),
          name: this._name.toJSON()
        };
      }
    }
    Source2.Ancestor = Ancestor;
    function ancestor(element, name) {
      return Ancestor.of(element, name);
    }
    Source2.ancestor = ancestor;
    class Label {
      static of(attribute) {
        return new Label(attribute);
      }
      _attribute;
      constructor(attribute) {
        this._attribute = attribute;
      }
      get type() {
        return "label";
      }
      get attribute() {
        return this._attribute;
      }
      equals(value) {
        return value instanceof Label && value._attribute.equals(this._attribute);
      }
      *[Symbol.iterator]() {
        yield this._attribute;
      }
      toJSON() {
        return {
          type: "label",
          attribute: this._attribute.path()
        };
      }
    }
    Source2.Label = Label;
    function label(attribute) {
      return Label.of(attribute);
    }
    Source2.label = label;
    class Reference {
      static of(attribute, name) {
        return new Reference(attribute, name);
      }
      _attribute;
      _name;
      constructor(attribute, name) {
        this._attribute = attribute;
        this._name = name;
      }
      get type() {
        return "reference";
      }
      get attribute() {
        return this._attribute;
      }
      get name() {
        return this._name;
      }
      equals(value) {
        return value instanceof Reference && value._attribute.equals(this._attribute);
      }
      *[Symbol.iterator]() {
        yield this._attribute;
        yield* this._name.sourceNodes();
      }
      toJSON() {
        return {
          type: "reference",
          attribute: this._attribute.path(),
          name: this._name.toJSON()
        };
      }
    }
    Source2.Reference = Reference;
    function reference(attribute, name) {
      return Reference.of(attribute, name);
    }
    Source2.reference = reference;
  })(Source || (Source = {}));

  // node_modules/@siteimprove/alfa-aria/dist/name/state.js
  var State3 = class _State {
    static _empty = new _State([], None, None, false, false);
    static empty() {
      return this._empty;
    }
    _visited;
    // which element has an aria-labelledby causing the current traversal?
    _referrer;
    // which element was the target of aria-labelledby?
    _referred;
    _isRecursing;
    _isDescending;
    constructor(visited, referrer, referred, isRecursing, isDescending) {
      this._visited = visited;
      this._referrer = referrer;
      this._referred = referred;
      this._isRecursing = isRecursing;
      this._isDescending = isDescending;
    }
    /**
     * The elements that have been seen by the name computation so far. This is
     * used for detecting circular references resulting from things such as the
     * `aria-labelledby` attribute and form controls that get their name from
     * a containing `<label>` element.
     */
    get visited() {
      return this._visited;
    }
    /**
     * The element that referenced the name computation.
     * (this is the element on which aria-labelledby is set)
     */
    get referrer() {
      return this._referrer;
    }
    /**
     * The element that is referenced during the name computation.
     * (this is the target of the aria-labelledby attribute)
     */
    get referred() {
      return this._referred;
    }
    /**
     * Whether the name computation is the result of recursion.
     */
    get isRecursing() {
      return this._isRecursing;
    }
    /**
     * Whether the name computation is the result of a reference.
     */
    get isReferencing() {
      return this._referrer.isSome();
    }
    /**
     * Whether the name computation is descending into a subtree.
     */
    get isDescending() {
      return this._isDescending;
    }
    hasVisited(element) {
      return this._visited.includes(element);
    }
    visit(element) {
      if (this._visited.includes(element)) {
        return this;
      }
      return new _State([...this._visited, element], this._referrer, this._referred, this._isRecursing, this._isDescending);
    }
    recurse(isRecursing) {
      if (this._isRecursing === isRecursing) {
        return this;
      }
      return new _State(this._visited, this._referrer, this._referred, isRecursing, this._isDescending);
    }
    /**
     * @remarks
     * This set both _referrer and _referred, so that they will always be
     * either both Some or both None.
     *
     * @remarks
     * We currently have no way to clear references since we currently have no
     * use for it.
     */
    reference(referrer, referred) {
      if (this._referrer.includes(referrer) && this._referred.includes(referred)) {
        return this;
      }
      return new _State(this._visited, Option.of(referrer), Option.of(referred), this._isRecursing, this._isDescending);
    }
    descend(isDescending) {
      if (this._isDescending === isDescending) {
        return this;
      }
      return new _State(this._visited, this._referrer, this._referred, this._isRecursing, isDescending);
    }
    equals(value) {
      return value instanceof _State && Array2.equals(value._visited, this._visited) && value._referrer.equals(this._referrer) && value._referred.equals(this._referred) && value._isRecursing === this._isRecursing && value._isDescending === this._isDescending;
    }
    toJSON() {
      return {
        visited: this._visited.map((element) => element.path()),
        referrer: this._referrer.map((element) => element.path()).getOr(null),
        referred: this._referred.map((element) => element.path()).getOr(null),
        isRecursing: this._isRecursing,
        isDescending: this._isDescending
      };
    }
  };

  // node_modules/@siteimprove/alfa-aria/dist/dom/predicate/is-programmatically-hidden.js
  var { hasAttribute: hasAttribute4, isElement: isElement30 } = Element;
  var { or: or21, test: test18, equals: equals18 } = Predicate;
  var { and: and27 } = Refinement;
  var { hasComputedStyle: hasComputedStyle2 } = Style;
  function isProgrammaticallyHidden(device, context = Context.empty()) {
    return or21(hasComputedStyle2("visibility", (visibility) => visibility.value !== "visible", device, context), hasHiddenAncestors(device, context));
  }
  var cache9 = Cache2.empty();
  function hasHiddenAncestors(device, context = Context.empty()) {
    return (node) => cache9.get(device, Cache2.empty).get(context, Cache2.empty).get(node, () => test18(or21(
      // Either it is a programmatically hidden element
      and27(isElement30, or21(hasComputedStyle2("display", ({ values: [outside] }) => outside.value === "none", device, context), hasAttribute4("aria-hidden", equals18("true")))),
      // Or its parent is programmatically hidden
      (node2) => node2.parent(Node4.fullTree).some(hasHiddenAncestors(device, context))
    ), node));
  }

  // node_modules/@siteimprove/alfa-aria/dist/name/name.js
  var { isElement: isElement31 } = Element;
  var { isText: isText5 } = Text;
  var { test: test19 } = Predicate;
  var { or: or22 } = Refinement;
  var { hasComputedStyle: hasComputedStyle3 } = Style;
  var { getElementIdMap: getElementIdMap2 } = Query3;
  var Name = class _Name {
    static of(value, sources = [], spaces) {
      return new _Name(value, Array2.from(sources), spaces?.before ?? false, spaces?.after ?? false);
    }
    _value;
    _sources;
    // Accessible names are computed piece-wise (e.g., aria-labelledby, or from
    // content), and then joined. The handling of spaces when joining is tricky
    // and while it is often clear what the "good" result should be, defining it
    // is much more tricky.
    // see https://github.com/w3c/accname/issues/225 for the latest iteration.
    //
    // Consider notably:
    // 1 <button><span>foo</span> <span>bar</span></button> => "foo bar" (inter-element space)
    // 2 <button><span>foo</span><span>bar</span></button> => "foobar" (no inter-element space)
    // 3 <button><span>foo</span><span> bar</span></button> => "foo bar" (leading space)
    // 4 <button><span> foo</span><span> bar</span></button> => "foo bar" (trimming final leading space)
    // 5 <button><span>foo</span><span> </span><span>bar</span></button> => "foo bar" (keeping isolated space)
    // 6 <button><span> </span></button> => "" (aka no name) (killing final isolated space)
    // 7 <button><span>foo</span><div>bar</div></button> => "foo bar" (block element)
    //
    // Anyway, the older version was aggressively trimming, resulting in too many
    // dropped spaces. Upon recursing into content, names were joined looking at
    // `display` and spaces added if needed. But cases 3 or 5 were trimmed before
    // join and the space was incorrectly dropped.
    //
    // Another possibility is to keep the spaces and trim them at the final end.
    // This is a bit annoying given the multiple layers of back and forth (also with
    // Feature). Moreover, it would be a bit inconsistent for compositionality (and
    // sources). For example, in case 5, the name "foo bar" would come from elements
    // <span>foo</span>, <span> </span> and <span>bar</span>, with respective "names"
    // ["foo", " ", "bar"]. But the actual name of the second <span> is actually empty…
    // This solution is also a bit trickier when concatenating names from different
    // elements since it requires looking at the elements to figure out whether extra
    // spaces are needed.
    //
    // The solution we attempt now it to trim the spaces asap, but record within the
    // name that it needs spaces before or after upon concatenation. This way,
    // each name is fully self-contained and concatenating names doesn't require to
    // look at their sources.
    _spaceBefore;
    _spaceAfter;
    constructor(value, sources, spaceBefore, spaceAfter) {
      this._value = value;
      this._sources = sources;
      this._spaceBefore = spaceBefore;
      this._spaceAfter = spaceAfter;
    }
    get value() {
      return this._value;
    }
    get spaces() {
      return { before: this._spaceBefore, after: this._spaceAfter };
    }
    get hasSpaces() {
      return this._spaceBefore || this._spaceAfter;
    }
    get source() {
      return this._sources;
    }
    *sourceNodes() {
      for (const source of this._sources) {
        yield* source;
      }
    }
    /**
     * Normalize the name by trimming and collapsing spaces.
     *
     * @remarks
     * If the name starts or end with spaces that are removed upon trimming,
     * also records that they are needing upon concatenation.
     */
    normalize() {
      const flatName = this._value.replace(/\s+/g, " ");
      return new _Name(flatName.trim(), this._sources, this._spaceBefore || flatName.startsWith(" "), this._spaceAfter || flatName.endsWith(" "));
    }
    /**
     * Add spaces before or after. Do not remove spaces if they are already there.
     */
    spaced(spaceBefore, spaceAfter = spaceBefore) {
      return new _Name(this._value, this._sources, spaceBefore || this._spaceBefore, spaceAfter || this._spaceAfter);
    }
    add(that) {
      return new _Name(this._value + (this._spaceAfter || that._spaceBefore ? " " : "") + that._value, this._sources.concat(that._sources), this._spaceBefore, that._spaceAfter);
    }
    static join(...names) {
      return names.reduce((acc, name) => acc.add(name), _Name.of("")).normalize();
    }
    isEmpty() {
      return this._value.length === 0 && !this.hasSpaces;
    }
    equals(value) {
      return value instanceof _Name && value._value === this._value && value._sources.length === this._sources.length && value._sources.every((source, i) => source.equals(this._sources[i]));
    }
    toJSON() {
      return {
        value: this._value,
        spaces: { before: this._spaceBefore, after: this._spaceAfter },
        sources: this._sources.map((source) => source.toJSON())
      };
    }
    toString() {
      return this._value;
    }
  };
  (function(Name2) {
    function from(node, device) {
      return fromNode2(node, device, State3.empty()).andThen((name) => (
        // Once the computation is finished, we can safely discard empty names that
        // would need spacing if combined. These won't be combined further.
        name.value === "" ? None : Option.of(name)
      ));
    }
    Name2.from = from;
    const names = Cache2.empty();
    function fromNode2(node, device, state) {
      const name = () => isElement31(node) ? fromElement2(node, device, state) : fromText2(node);
      if (isElement31(node)) {
        if (state.isReferencing) {
          return name();
        }
        if (state.isDescending) {
          return name();
        }
      }
      return names.get(device, Cache2.empty).get(node, name);
    }
    Name2.fromNode = fromNode2;
    function fromElement2(element, device, state) {
      if (element.name === "br") {
        return Option.of(Name2.of("", [], { before: true, after: true }));
      }
      if (state.hasVisited(element)) {
        if (!state.referrer.includes(element)) {
          return None;
        }
      } else {
        state = state.visit(element);
      }
      const role = Role.from(element);
      if (!state.isReferencing && !state.isDescending && role.some((role2) => role2.isNameProhibited())) {
        return None;
      }
      if (
        // The element is hidden
        // https://www.w3.org/TR/wai-aria-1.2/#dfn-hidden
        // https://w3c.github.io/accname/#step2A (first comment)
        test19(isProgrammaticallyHidden(device), element)
      ) {
        if (!state.isReferencing) {
          return None;
        }
        if (state.referrer.equals(state.referred)) {
          return None;
        }
        if (state.referred.none(isProgrammaticallyHidden(device))) {
          return None;
        }
      }
      const spaced = test19(hasComputedStyle3("display", ({ values: [outside] }) => outside.value === "block" || outside.value === "table-cell", device), element);
      return fromSteps(
        // Step 2B: Use the `aria-labelledby` attribute, if present and allowed.
        // https://w3c.github.io/accname/#step2B
        () => {
          if (state.isReferencing) {
            return None;
          }
          return element.attribute("aria-labelledby").flatMap((attribute) => fromReferences(attribute, element, device, state)).map((name) => name.spaced(spaced));
        },
        // Step 2C: control embedded in a label, not currently handled
        // https://github.com/Siteimprove/alfa/issues/305
        // Step 2D: Use the `aria-label` attribute, if present.
        // https://w3c.github.io/accname/#step2D
        () => {
          return element.attribute("aria-label").flatMap((attribute) => fromLabel(attribute)).map((name) => name.spaced(true));
        },
        // Step 2E: Use native features, if present and allowed.
        // https://w3c.github.io/accname/#step2E
        () => {
          if (role.some((role2) => role2.isPresentational()) || !element.namespace.isSome()) {
            return None;
          }
          return Feature2.from(element.namespace.get(), element.name).flatMap((feature) => feature.name(element, device, state)).map((name) => name.spaced(spaced));
        },
        // Step 2F: Use the subtree content, if referencing or allowed.
        // https://w3c.github.io/accname/#step2F
        () => {
          if (!state.isReferencing && !role.some((role2) => role2.isNamedBy("contents"))) {
            return None;
          }
          return fromDescendants(element, device, state).map((name) => name.spaced(spaced));
        },
        // Step 2H: Use the subtree content, if descending.
        // https://w3c.github.io/accname/#step2H
        () => {
          if (!state.isDescending) {
            return None;
          }
          return fromDescendants(element, device, state).map((name) => name.spaced(spaced));
        }
      );
    }
    Name2.fromElement = fromElement2;
    function fromText2(text) {
      const data = text.data;
      if (data === "") {
        return None;
      }
      return Option.of(Name2.of(data, [Source.data(text)], {
        before: false,
        after: false
      }).normalize());
    }
    Name2.fromText = fromText2;
    const fromDescendantsCache = Cache2.empty();
    function fromDescendants(element, device, state) {
      return fromDescendantsCache.get(device, Cache2.empty).get(state, Cache2.empty).get(element, () => {
        const names2 = element.children(Node4.flatTree).filter(or22(isText5, isElement31)).collect((element2) => fromNode2(element2, device, state.recurse(true).descend(true)));
        const name = Name2.join(...names2);
        if (name.isEmpty()) {
          return None;
        }
        return Option.of(Name2.of(name.value, names2.map((name2) => Source.descendant(element, name2)), name.spaces));
      });
    }
    Name2.fromDescendants = fromDescendants;
    function fromLabel(attribute) {
      if (attribute.value === "") {
        return None;
      }
      return Option.of(Name2.of(attribute.value, [Source.label(attribute)], {
        before: false,
        after: false
      }).normalize());
    }
    Name2.fromLabel = fromLabel;
    function fromReferences(attribute, referrer, device, state) {
      if (!attribute.owner.isSome()) {
        return None;
      }
      const root = attribute.owner.get().root();
      const names2 = attribute.tokens().collect((id) => getElementIdMap2(root).get(id)).collect((element) => fromNode2(element, device, state.reference(referrer, element).recurse(true).descend(false))).map((name2) => name2.spaced(true, false));
      const name = Name2.join(...names2);
      if (name.isEmpty()) {
        return None;
      }
      return Option.of(Name2.of(name.value, [
        Source.reference(attribute, Name2.of(name.value, names2.flatMap((name2) => Sequence.from(name2.source)), name.spaces))
      ], name.spaces));
    }
    Name2.fromReferences = fromReferences;
    function fromSteps(...steps) {
      const results = [];
      return Array2.collectFirst(steps, (step, index) => {
        const result = step();
        results[index] = result;
        return result.reject((name) => name.value === "");
      }).orElse(() => Array2.collectFirst(steps, (step, index) => (results[index] ?? step()).reject((name) => name.isEmpty())));
    }
    Name2.fromSteps = fromSteps;
    Name2.hasValue = hasValue;
  })(Name || (Name = {}));

  // node_modules/@siteimprove/alfa-graph/dist/graph.js
  var Graph = class _Graph {
    static of(nodes) {
      return new _Graph(nodes);
    }
    static _empty = new _Graph(Map2.empty());
    static empty() {
      return this._empty;
    }
    _nodes;
    constructor(nodes) {
      this._nodes = nodes;
    }
    get size() {
      return this._nodes.size;
    }
    isEmpty() {
      return this._nodes.isEmpty();
    }
    nodes() {
      return this._nodes.keys();
    }
    neighbors(node) {
      return this._nodes.get(node).getOr([]);
    }
    has(node) {
      return this._nodes.has(node);
    }
    add(node) {
      if (this.has(node)) {
        return this;
      }
      return new _Graph(this._nodes.set(node, Set2.empty()));
    }
    delete(node) {
      const nodes = this._nodes;
      if (!nodes.has(node)) {
        return this;
      }
      return new _Graph(nodes.delete(node).map((neighbors) => neighbors.delete(node)));
    }
    connect(from, to) {
      let nodes = this._nodes;
      if (!nodes.has(from)) {
        nodes = nodes.set(from, Set2.empty());
      }
      if (!nodes.has(to)) {
        nodes = nodes.set(to, Set2.empty());
      }
      return new _Graph(nodes.set(from, nodes.get(from).map((from2) => from2.add(to)).getUnsafe()));
    }
    disconnect(from, to) {
      if (!this.has(from) || !this.has(to)) {
        return this;
      }
      const nodes = this._nodes;
      return new _Graph(nodes.set(from, nodes.get(from).map((from2) => from2.delete(to)).getUnsafe()));
    }
    traverse(root, traversal = _Graph.DepthFirst) {
      return Sequence.from(traversal(this, root));
    }
    path(from, to, traversal = _Graph.BreadthFirst) {
      const parents = Map2.from(traversal(this, from));
      const path = [];
      while (parents.has(to)) {
        const parent = parents.get(to).getUnsafe();
        path.unshift(to);
        to = parent;
      }
      return Sequence.from(path);
    }
    hasPath(from, to) {
      if (!this.has(from) || !this.has(to)) {
        return false;
      }
      return this.traverse(from).map(([node]) => node).includes(to);
    }
    reverse() {
      let reversed = _Graph.empty();
      for (const [node, neighbors] of this._nodes) {
        reversed = reversed.add(node);
        for (const neighbor of neighbors) {
          reversed = reversed.connect(neighbor, node);
        }
      }
      return reversed;
    }
    *sort() {
      let incoming = this.reverse();
      const queue = incoming.toArray().filter(([, edges]) => edges.length === 0).map(([node]) => node);
      while (queue.length > 0) {
        const next = queue.shift();
        yield next;
        for (const neighbor of this.neighbors(next)) {
          incoming = incoming.disconnect(neighbor, next);
          if (Iterable.isEmpty(incoming.neighbors(neighbor))) {
            queue.push(neighbor);
          }
        }
      }
    }
    equals(value) {
      return value instanceof _Graph && value._nodes.equals(this._nodes);
    }
    hash(hash2) {
      hash2.writeHashable(this._nodes);
    }
    *iterator() {
      yield* this._nodes;
    }
    [Symbol.iterator]() {
      return this.iterator();
    }
    toArray() {
      return [...this].map(([node, neighbors]) => [node, [...neighbors]]);
    }
    toJSON(options) {
      return this.toArray().map(([node, neighbors]) => [
        Serializable.toJSON(node, options),
        neighbors.map((node2) => Serializable.toJSON(node2, options))
      ]);
    }
    toString() {
      const entries3 = this.toArray().map(([node, edges]) => {
        const entries4 = edges.join(", ");
        return `${node}${entries4 === "" ? "" : ` => [ ${entries4} ]`}`;
      }).join(", ");
      return `Graph {${entries3 === "" ? "" : ` ${entries3} `}}`;
    }
  };
  (function(Graph2) {
    function isGraph(value) {
      return value instanceof Graph2;
    }
    Graph2.isGraph = isGraph;
    function from(iterable) {
      if (isGraph(iterable)) {
        return iterable;
      }
      return Graph2.of(Map2.from(Iterable.map(iterable, ([node, neighbours]) => [
        node,
        Set2.from(neighbours)
      ])));
    }
    Graph2.from = from;
    Graph2.DepthFirst = function* (graph, root) {
      const stack = [...graph.neighbors(root)].map((node) => [node, root]);
      let seen = Set2.of(root);
      while (stack.length > 0) {
        const next = stack.pop();
        if (seen.has(next[0])) {
          continue;
        }
        yield next;
        seen = seen.add(next[0]);
        for (const neighbor of graph.neighbors(next[0])) {
          stack.push([neighbor, next[0]]);
        }
      }
    };
    Graph2.BreadthFirst = function* (graph, root) {
      const queue = [...graph.neighbors(root)].map((node) => [node, root]);
      let seen = Set2.of(root, ...graph.neighbors(root));
      while (queue.length > 0) {
        const next = queue.shift();
        yield next;
        for (const neighbor of graph.neighbors(next[0])) {
          if (seen.has(neighbor)) {
            continue;
          }
          seen = seen.add(neighbor);
          queue.push([neighbor, next[0]]);
        }
      }
    };
  })(Graph || (Graph = {}));

  // node_modules/@siteimprove/alfa-aria/dist/node/predicate/has-attribute.js
  var { property: property5 } = Predicate;
  function hasAttribute5(nameOrPredicate, value = () => true) {
    if (typeof nameOrPredicate === "function") {
      return (node) => node.attribute(nameOrPredicate).isSome();
    }
    const name = nameOrPredicate;
    const predicate = property5("value", value);
    return (node) => node.attribute(name).some(predicate);
  }

  // node_modules/@siteimprove/alfa-aria/dist/node/predicate/has-name.js
  function hasName18(nameOrPredicate = () => true, ...names) {
    const predicate = typeof nameOrPredicate === "function" ? nameOrPredicate : Name.hasValue(nameOrPredicate, ...names);
    return (node) => node.name.some(predicate);
  }

  // node_modules/@siteimprove/alfa-aria/dist/node/predicate/has-role.js
  function hasRole(nameOrPredicate = () => true, ...names) {
    let predicate;
    if (typeof nameOrPredicate === "function") {
      predicate = nameOrPredicate;
    } else {
      predicate = hasName16(nameOrPredicate, ...names);
    }
    return (node) => node.role.some(predicate);
  }

  // node_modules/@siteimprove/alfa-aria/dist/node.js
  var { and: and28, equals: equals19, not: not27, test: test20 } = Predicate;
  var { isRendered: isRendered2 } = Style;
  var { getElementIdMap: getElementIdMap3, getElementDescendants: getElementDescendants3 } = Query3;
  var Node5 = class _Node extends Node3 {
    _node;
    constructor(owner, children, type) {
      super(children, type);
      this._node = owner;
    }
    get node() {
      return this._node;
    }
    get name() {
      return None;
    }
    get role() {
      return None;
    }
    attribute(predicate) {
      return None;
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-parent}
     */
    parent(options = _Node.Traversal.empty) {
      const parent = this._parent;
      if (options.has(_Node.Traversal.ignored)) {
        return parent;
      }
      return parent.flatMap((parent2) => parent2.isIgnored() ? parent2.parent(options) : Option.of(parent2));
    }
    /**
     * {@link https://dom.spec.whatwg.org/#concept-tree-child}
     */
    children(options = _Node.Traversal.empty) {
      const children = Sequence.from(this._children);
      if (options.has(_Node.Traversal.ignored)) {
        return children;
      }
      return children.flatMap((child) => child.isIgnored() ? child.children(options) : Sequence.of(child));
    }
    toJSON() {
      return {
        ...super.toJSON(),
        node: this._node.path(Node4.fullTree)
      };
    }
  };
  (function(Node6) {
    class Traversal extends Flags {
      static of(...flags) {
        return new Traversal(Flags._reduce(...flags));
      }
    }
    Node6.Traversal = Traversal;
    (function(Traversal2) {
      Traversal2.none = 0;
      Traversal2.ignored = 1 << 0;
      Traversal2.empty = Traversal2.of(Traversal2.none);
    })(Traversal = Node6.Traversal || (Node6.Traversal = {}));
    Node6.includeIgnored = Traversal.of(Traversal.ignored);
    const cache16 = Cache2.empty();
    function from(node, device) {
      const _cache = cache16.get(device, Cache2.empty);
      if (_cache.has(node)) {
        return _cache.get(node).getUnsafe();
      }
      const root = node.root(Node4.flatTree);
      if (_cache.has(root)) {
        return _cache.get(node, () => Inert.of(node));
      }
      const exclusiveDescendants = getElementDescendants3(root);
      const elements = Element.isElement(root) ? exclusiveDescendants.prepend(root) : exclusiveDescendants;
      const ids2 = getElementIdMap3(root);
      const references = elements.collect((element) => element.attribute("aria-owns").map((attribute) => [
        element,
        attribute.tokens().collect((id) => ids2.get(id)).reject((reference) => element === reference || element.ancestors().includes(reference))
      ]));
      const [claimed, owned] = references.reduce(([claimed2, owned2, graph], [element, references2]) => {
        references2 = references2.reject((reference) => claimed2.has(reference) || graph.hasPath(reference, element));
        if (references2.isEmpty()) {
          return [claimed2, owned2, graph];
        }
        claimed2 = references2.reduce((claimed3, reference) => claimed3.add(reference), claimed2);
        graph = references2.reduce((graph2, reference) => graph2.connect(element, reference), graph);
        return [claimed2, owned2.set(element, references2), graph];
      }, [
        Set2.empty(),
        Map2.empty(),
        Graph.empty()
      ]);
      fromNode2(root, device, claimed, owned, State4.empty());
      return _cache.get(node, () => (
        // If the cache still doesn't hold an entry for the specified node, then
        // the node doesn't even participate in the tree. Store it as an inert
        // node.
        Inert.of(node)
      ));
    }
    Node6.from = from;
    class State4 {
      static _empty = new State4(false, true);
      static empty() {
        return this._empty;
      }
      _isPresentational;
      _isVisible;
      constructor(isPresentational, isVisible25) {
        this._isPresentational = isPresentational;
        this._isVisible = isVisible25;
      }
      get isPresentational() {
        return this._isPresentational;
      }
      get isVisible() {
        return this._isVisible;
      }
      presentational(isPresentational) {
        if (this._isPresentational === isPresentational) {
          return this;
        }
        return new State4(isPresentational, this._isVisible);
      }
      visible(isVisible25) {
        if (this._isVisible === isVisible25) {
          return this;
        }
        return new State4(this._isPresentational, isVisible25);
      }
    }
    function fromNode2(node, device, claimed, owned, state) {
      return cache16.get(device, Cache2.empty).get(node, () => {
        if (Element.isElement(node)) {
          if (node.attribute("aria-hidden").some((attribute) => attribute.enumerate("true", "false").some(equals19("true")))) {
            return Inert.of(node);
          }
          const style = Style.from(node, device);
          if (test20(not27(isRendered2(device)), node)) {
            return Inert.of(node);
          }
          let children;
          const explicit = owned.get(node).getOrElse(() => Sequence.empty());
          const implicit = node.children(Node4.flatTree).reject((child) => claimed.has(child) || explicit.includes(child));
          children = (state2) => implicit.concat(explicit).map((child) => fromNode2(child, device, claimed, owned, state2));
          if (style.computed("visibility").value.value !== "visible") {
            return Container.of(node, children(state.visible(false)));
          }
          state = state.visible(true);
          const role = Role.fromExplicit(node).orElse(() => (
            // If the element has no explicit role and instead inherits a
            // presentational role then use that, otherwise fall back to the
            // implicit role.
            state.isPresentational ? Option.of(Role.of("presentation")) : Role.fromImplicit(node)
          ));
          if (role.some((role2) => role2.isPresentational())) {
            return Container.of(node, children(state.presentational(
              // If the implicit role of the presentational element has
              // required children then any owned children must also be
              // presentational.
              Role.fromImplicit(node).some((role2) => role2.hasRequiredChildren())
            )));
          }
          let attributes = Map2.empty();
          if (role.isSome()) {
            for (const attribute of role.get().supportedAttributes) {
              for (const value of role.get().implicitAttributeValue(attribute)) {
                attributes = attributes.set(attribute, Attribute3.of(attribute, value));
              }
            }
          }
          for (const namespace of node.namespace) {
            for (const feature of Feature2.from(namespace, node.name)) {
              for (const attribute of feature.attributes(node)) {
                attributes = attributes.set(attribute.name, attribute);
              }
            }
          }
          for (const { name, value } of node.attributes) {
            if (Attribute3.isName(name)) {
              const attribute = Attribute3.of(name, value);
              if (attribute.isGlobal() || role.some((role2) => role2.isAttributeSupported(attribute.name))) {
                attributes = attributes.set(name, attribute);
              }
            }
          }
          if (attributes.isEmpty() && role.every(Role.hasName("generic")) && node.tabIndex().isNone() && !test20(alwaysExpose, node)) {
            return Container.of(node, children(state), role);
          }
          if (role.some((role2) => role2.hasPresentationalChildren())) {
            state = state.presentational(true);
          }
          return Element2.of(node, role, Name.from(node, device), attributes.values(), children(state));
        }
        if (Text.isText(node)) {
          if (!state.isVisible) {
            return Inert.of(node);
          }
          return Text2.of(node, Name.from(node, device));
        }
        return Container.of(node, node.children(Node4.flatTree).reject((child) => claimed.has(child)).map((child) => fromNode2(child, device, claimed, owned, state)));
      });
    }
    Node6.hasAttribute = hasAttribute5, Node6.hasName = hasName18, Node6.hasRole = hasRole;
  })(Node5 || (Node5 = {}));
  var alwaysExpose = and28(Element.hasName("object"), Element.hasAttribute("data", (data) => data.trim() !== ""));

  // node_modules/@siteimprove/alfa-aria/dist/dom/predicate/has-accessible-name.js
  var { test: test21 } = Predicate;
  function hasAccessibleName(device, nameOrPredicate = () => true, ...names) {
    const predicate = typeof nameOrPredicate === "string" ? hasValue(nameOrPredicate, ...names) : nameOrPredicate;
    return (node) => test21(hasName18(predicate), Node5.from(node, device));
  }

  // node_modules/@siteimprove/alfa-aria/dist/dom/predicate/has-explicit-role.js
  var { equals: equals20, property: property6 } = Predicate;
  function hasExplicitRole(nameOrPredicate = () => true, ...names) {
    let predicate;
    if (typeof nameOrPredicate === "function") {
      predicate = nameOrPredicate;
    } else {
      predicate = property6("name", equals20(nameOrPredicate, ...names));
    }
    return (element) => Role.fromExplicit(element).some(predicate);
  }

  // node_modules/@siteimprove/alfa-aria/dist/dom/predicate/has-heading-level.js
  function hasHeadingLevel(device, predicate = (n) => !isNaN(n)) {
    return (element) => Node5.from(element, device).attribute("aria-level").map((level) => Number(level.value)).some(predicate);
  }

  // node_modules/@siteimprove/alfa-aria/dist/dom/predicate/has-implicit-role.js
  var { equals: equals21, property: property7 } = Predicate;
  function hasImplicitRole(nameOrPredicate, ...names) {
    let predicate;
    if (typeof nameOrPredicate === "function") {
      predicate = nameOrPredicate;
    } else {
      predicate = property7("name", equals21(nameOrPredicate, ...names));
    }
    return (element) => Role.fromImplicit(element).some(predicate);
  }

  // node_modules/@siteimprove/alfa-aria/dist/dom/predicate/has-incorrect-role-without-name.js
  var { hasName: hasName19, isScopedTo: isScopedTo3 } = Element;
  var { and: and29, not: not28, or: or23 } = Predicate;
  function hasIncorrectRoleWithoutName(device) {
    return and29(hasSuspiciousRole, not28(hasExplicitRole()), not28(hasAccessibleName(device)));
  }
  var hasSuspiciousRole = or23(hasName19("form", "section"), and29(hasName19("aside"), isScopedTo3("article", "aside", "nav", "section")));

  // node_modules/@siteimprove/alfa-aria/dist/dom/predicate/has-non-default-role.js
  var { not: not29, test: test22 } = Predicate;
  function hasNonDefaultRole(element) {
    return test22(hasExplicitRole((explicit) => test22(not29(hasImplicitRole((implicit) => implicit.equals(explicit))), element)), element);
  }

  // node_modules/@siteimprove/alfa-aria/dist/dom/predicate/has-non-empty-accessible-name.js
  function hasNonEmptyAccessibleName(device) {
    return hasAccessibleName(device, hasValue((value) => value.trim().length > 0));
  }

  // node_modules/@siteimprove/alfa-aria/dist/dom/predicate/has-role.js
  function hasRole2(device, nameOrPredicate = () => true, ...names) {
    let predicate;
    if (typeof nameOrPredicate === "function") {
      predicate = nameOrPredicate;
    } else {
      predicate = hasName16(nameOrPredicate, ...names);
    }
    return (element) => Node5.from(element, device).role.some(predicate);
  }

  // node_modules/@siteimprove/alfa-aria/dist/dom/predicate/is-included-accessibility-tree.js
  function isIncludedInTheAccessibilityTree(device) {
    return (node) => !Node5.from(node, device).isIgnored();
  }
  function isIgnored(device) {
    return (node) => Node5.from(node, device).isIgnored();
  }

  // node_modules/@siteimprove/alfa-aria/dist/dom/predicate/is-marked-decorative.js
  var isMarkedDecorative = (element) => {
    const role = element.attribute("role").flatMap((attribute) => attribute.tokens().filter(Role.isName).map(Role.of).reject((role2) => role2.isAbstract()).first());
    if (role.some((role2) => role2.isPresentational())) {
      return true;
    }
    switch (element.name) {
      case "img":
        return role.isNone() && element.attribute("alt").some((attribute) => attribute.value === "");
      default:
        return false;
    }
  };

  // node_modules/@siteimprove/alfa-aria/dist/dom/predicate/is-perceivable.js
  var { and: and30 } = Predicate;
  var { isVisible: isVisible2 } = Style;
  function isPerceivableForAll(device) {
    return and30(isVisible2(device), (node) => node.inclusiveDescendants().some(isIncludedInTheAccessibilityTree(device)));
  }

  // node_modules/@siteimprove/alfa-aria/dist/dom/predicate/is-semantically-disabled.js
  var { equals: equals22, or: or24 } = Predicate;
  var isSemanticallyDisabled = or24(
    // Alfa hub's definition uses the `:disabled` pseudo-class, which is
    // equivalent to "actually disabled" for HTML; we shortcut it here.
    Element.isActuallyDisabled,
    Element.hasAttribute("aria-disabled", equals22("true"))
  );

  // node_modules/@siteimprove/alfa-aria/dist/node/container.js
  var Container = class _Container extends Node5 {
    static of(owner, children = [], role = None) {
      return new _Container(owner, Array.from(children), role);
    }
    _role;
    constructor(owner, children, role) {
      super(owner, children, "container");
      this._role = role;
    }
    clone(parent = None) {
      return new _Container(this._node, this._children.map((child) => child.clone()), this._role);
    }
    get role() {
      return this._role;
    }
    isIgnored() {
      return true;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        role: this._role.map((role) => role.name).getOr(null)
      };
    }
    toString() {
      return [
        "container",
        ...this._children.map((child) => String2.indent(child.toString()))
      ].join("\n");
    }
  };

  // node_modules/@siteimprove/alfa-aria/dist/node/element.js
  var Element2 = class _Element extends Node5 {
    static of(owner, role = None, name = None, attributes = [], children = []) {
      return new _Element(owner, role, name, Array.from(attributes), Array.from(children));
    }
    _role;
    _name;
    _attributes;
    constructor(owner, role, name, attributes, children) {
      super(owner, children, "element");
      this._role = role;
      this._name = name;
      this._attributes = attributes;
    }
    get role() {
      return this._role;
    }
    get name() {
      return this._name;
    }
    get attributes() {
      return this._attributes;
    }
    attribute(predicate) {
      return Iterable.find(this._attributes, typeof predicate === "string" ? (attribute) => attribute.name === predicate : predicate);
    }
    clone() {
      return new _Element(this._node, this._role, this._name, this._attributes, this._children.map((child) => child.clone()));
    }
    isIgnored() {
      return false;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        role: this._role.map((role) => role.name).getOr(null),
        name: this._name.map((name) => name.value).getOr(null),
        attributes: this._attributes.map((attribute) => attribute.toJSON())
      };
    }
    toString() {
      return [
        [
          this._role.map((role) => role.name).getOr("element"),
          ...this._name.map((name) => `"${name}"`)
        ].join(" "),
        ...this._children.map((child) => String2.indent(child.toString()))
      ].join("\n");
    }
  };

  // node_modules/@siteimprove/alfa-aria/dist/node/inert.js
  var Inert = class _Inert extends Node5 {
    static of(owner) {
      return new _Inert(owner);
    }
    constructor(owner) {
      super(owner, [], "inert");
    }
    clone() {
      return new _Inert(this._node);
    }
    isIgnored() {
      return true;
    }
    toString() {
      return "ignored";
    }
    toJSON() {
      const result = super.toJSON();
      delete result.children;
      return result;
    }
  };

  // node_modules/@siteimprove/alfa-aria/dist/node/text.js
  var Text2 = class _Text extends Node5 {
    static of(owner, name) {
      return new _Text(owner, name);
    }
    _name;
    constructor(owner, name) {
      super(owner, [], "text");
      this._name = name;
    }
    get name() {
      return this._name;
    }
    clone() {
      return new _Text(this._node, this._name);
    }
    isIgnored() {
      return false;
    }
    toJSON() {
      const result = {
        ...super.toJSON(),
        name: this._name.map((name) => name.value).getOr(null)
      };
      delete result.children;
      return result;
    }
    toString() {
      return `text "${this._name.map((name) => `${name}`).getOr("")}"`;
    }
  };

  // node_modules/@siteimprove/alfa-aria/dist/index.js
  var DOM;
  (function(DOM2) {
    DOM2.hasAccessibleName = hasAccessibleName, DOM2.hasExplicitRole = hasExplicitRole, DOM2.hasHeadingLevel = hasHeadingLevel, DOM2.hasImplicitRole = hasImplicitRole, DOM2.hasIncorrectRoleWithoutName = hasIncorrectRoleWithoutName, DOM2.hasNonDefaultRole = hasNonDefaultRole, DOM2.hasNonEmptyAccessibleName = hasNonEmptyAccessibleName, DOM2.hasRole = hasRole2, DOM2.isIgnored = isIgnored, DOM2.isIncludedInTheAccessibilityTree = isIncludedInTheAccessibilityTree, DOM2.isMarkedDecorative = isMarkedDecorative, DOM2.isPerceivableForAll = isPerceivableForAll, DOM2.isProgrammaticallyHidden = isProgrammaticallyHidden, DOM2.isSemanticallyDisabled = isSemanticallyDisabled;
  })(DOM || (DOM = {}));

  // node_modules/@siteimprove/alfa-branched/dist/branched.js
  var { not: not30 } = Predicate;
  var Branched = class _Branched {
    static of(value, ...branches) {
      return new _Branched(List.of(Value5.of(value, branches.length === 0 ? None : Some.of(List.from(branches)))));
    }
    _values;
    constructor(values) {
      this._values = values;
    }
    get size() {
      return this._values.size;
    }
    isEmpty() {
      return false;
    }
    forEach(callback) {
      this._values.forEach(({ value, branches }) => callback(value, branches.getOrElse(() => List.empty())));
    }
    map(mapper) {
      return new _Branched(this._values.reduce((values, { value, branches }) => merge(values, mapper(value, branches.getOrElse(() => List.empty())), branches), List.empty()));
    }
    apply(mapper) {
      return mapper.flatMap((mapper2) => this.map(mapper2));
    }
    flatMap(mapper) {
      return new _Branched(this._values.reduce((values, { value, branches: scope }) => mapper(value, scope.getOrElse(() => List.empty()))._values.reduce((values2, { value: value2, branches }) => {
        if (scope.isNone() && branches.isSome()) {
          branches = unused(branches, this._values);
        } else {
          branches = narrow(branches, scope);
        }
        return merge(values2, value2, branches);
      }, values), List.empty()));
    }
    flatten() {
      return this.flatMap((branched) => branched);
    }
    reduce(reducer, accumulator) {
      return this._values.reduce((accumulator2, value) => reducer(accumulator2, value.value, value.branches.getOrElse(() => List.empty())), accumulator);
    }
    filter(predicate) {
      return new _Branched(this._values.filter(({ value, branches }) => predicate(value, branches.getOrElse(() => List.empty()))));
    }
    reject(predicate) {
      return this.filter(not30(predicate));
    }
    find(predicate) {
      return this._values.find(({ value, branches }) => predicate(value, branches.getOrElse(() => List.empty()))).map(({ value }) => value);
    }
    includes(value) {
      return this._values.some(({ value: found }) => Equatable.equals(value, found));
    }
    collect(mapper) {
      return new _Branched(this._values.reduce((values, { value, branches }) => mapper(value, branches.getOrElse(() => List.empty())).map((value2) => merge(values, value2, branches)).getOr(values), List.empty()));
    }
    collectFirst(mapper) {
      return this._values.collectFirst(({ value, branches }) => mapper(value, branches.getOrElse(() => List.empty())));
    }
    some(predicate) {
      for (const value of this._values) {
        if (predicate(value.value, value.branches.getOrElse(() => List.empty()))) {
          return true;
        }
      }
      return false;
    }
    none(predicate) {
      return this.every(not30(predicate));
    }
    every(predicate) {
      for (const value of this._values) {
        if (!predicate(value.value, value.branches.getOrElse(() => List.empty()))) {
          return false;
        }
      }
      return true;
    }
    count(predicate) {
      return this.reduce((count, value, branches) => predicate(value, branches) ? count + 1 : count, 0);
    }
    /**
     * @remarks
     * As branched values merges branches with duplicate values, they will only
     * ever contain distinct values.
     */
    distinct() {
      return this;
    }
    tee(callback, ...args) {
      callback(this, ...args);
      return this;
    }
    branch(value, ...branches) {
      return new _Branched(merge(this._values, value, branches.length === 0 ? None : Some.of(List.from(branches))));
    }
    equals(value) {
      return value instanceof _Branched && value._values.equals(this._values);
    }
    hash(hash2) {
      hash2.writeHashable(this._values);
    }
    *[Symbol.iterator]() {
      for (const value of this._values) {
        yield [value.value, value.branches.getOrElse(() => List.empty())];
      }
    }
    toArray() {
      return this._values.toArray().map(({ value, branches }) => [
        value,
        branches.getOrElse(() => List.empty()).toArray()
      ]);
    }
    toJSON() {
      return this._values.toArray().map(({ value, branches }) => [
        Serializable.toJSON(value),
        branches.getOrElse(() => List.empty()).toJSON()
      ]);
    }
  };
  (function(Branched2) {
    function isBranched(value) {
      return value instanceof Branched2;
    }
    Branched2.isBranched = isBranched;
    function from(values) {
      if (isBranched(values)) {
        return values;
      }
      const [[value, branches], ...rest] = values;
      return rest.reduce((result, [value2, branches2]) => result.branch(value2, ...branches2), Branched2.of(value, ...branches));
    }
    Branched2.from = from;
    function traverse(values, mapper) {
      return Iterable.reduce(values, (values2, value, i) => values2.flatMap((values3) => mapper(value, i).map((value2) => values3.append(value2))), Branched2.of(List.empty()));
    }
    Branched2.traverse = traverse;
    function sequence(values) {
      return traverse(values, (value) => value);
    }
    Branched2.sequence = sequence;
  })(Branched || (Branched = {}));
  var Value5 = class _Value {
    static of(value, branches = None) {
      return new _Value(value, branches);
    }
    _value;
    _branches;
    constructor(value, branches) {
      this._value = value;
      this._branches = branches;
    }
    get value() {
      return this._value;
    }
    get branches() {
      return this._branches;
    }
    equals(value) {
      return value instanceof _Value && Equatable.equals(value._value, this._value) && Equatable.equals(value._branches, this._branches);
    }
    hash(hash2) {
      hash2.writeUnknown(this._value).writeHashable(this._branches);
    }
  };
  function merge(values, value, branches) {
    if (values.size === 0) {
      return List.of(Value5.of(value, branches));
    }
    branches = values.find((existing) => Equatable.equals(existing.value, value)).map((existing) => existing.branches.flatMap((left22) => branches.map((right38) => left22.concat(right38)))).getOr(branches);
    return deduplicate(values, value, branches).append(Value5.of(value, branches));
  }
  function deduplicate(values, value, branches) {
    return values.reduce((values2, existing) => {
      if (Equatable.equals(existing.value, value)) {
        return values2;
      }
      if (existing.branches.isNone()) {
        return branches.isNone() ? values2 : values2.append(existing);
      }
      return existing.branches.reduce((values3, existingBranches) => {
        const deduplicated = branches.reduce((existing2, branches2) => existing2.subtract(branches2), existingBranches);
        if (deduplicated.size === 0) {
          return values3;
        }
        return values3.append(Value5.of(existing.value, Some.of(deduplicated)));
      }, values2);
    }, List.empty());
  }
  function narrow(branches, scope) {
    return scope.map((scope2) => branches.reduce((scope3, branches2) => scope3.intersect(branches2), scope2));
  }
  function unused(branches, values) {
    return values.reduce((branches2, value) => value.branches.flatMap((existing) => branches2.map((branches3) => branches3.subtract(existing))).or(branches2), branches);
  }

  // node_modules/@siteimprove/alfa-wcag/dist/criterion/data.js
  var Criteria = {
    "1.1.1": {
      title: "Non-text Content",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#non-text-content",
            level: "A"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#non-text-content",
            level: "A"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#text-equiv-all",
            level: "A"
          }
        ]
      ]
    },
    "1.2.1": {
      title: "Audio-only and Video-only (Prerecorded)",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#audio-only-and-video-only-prerecorded",
            level: "A"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#audio-only-and-video-only-prerecorded",
            level: "A"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#media-equiv-av-only-alt",
            level: "A"
          }
        ]
      ]
    },
    "1.2.2": {
      title: "Captions (Prerecorded)",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#captions-prerecorded",
            level: "A"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#captions-prerecorded",
            level: "A"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#media-equiv-captions",
            level: "A"
          }
        ]
      ]
    },
    "1.2.3": {
      title: "Audio Description or Media Alternative (Prerecorded)",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#audio-description-or-media-alternative-prerecorded",
            level: "A"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#audio-description-or-media-alternative-prerecorded",
            level: "A"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#media-equiv-audio-desc",
            level: "A"
          }
        ]
      ]
    },
    "1.2.4": {
      title: "Captions (Live)",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#captions-live",
            level: "AA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#captions-live",
            level: "AA"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#media-equiv-real-time-captions",
            level: "AA"
          }
        ]
      ]
    },
    "1.2.5": {
      title: "Audio Description (Prerecorded)",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#audio-description-prerecorded",
            level: "AA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#audio-description-prerecorded",
            level: "AA"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#media-equiv-audio-desc-only",
            level: "AA"
          }
        ]
      ]
    },
    "1.2.6": {
      title: "Sign Language (Prerecorded)",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#sign-language-prerecorded",
            level: "AAA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#sign-language-prerecorded",
            level: "AAA"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#media-equiv-sign",
            level: "AAA"
          }
        ]
      ]
    },
    "1.2.7": {
      title: "Extended Audio Description (Prerecorded)",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#extended-audio-description-prerecorded",
            level: "AAA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#extended-audio-description-prerecorded",
            level: "AAA"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#media-equiv-extended-ad",
            level: "AAA"
          }
        ]
      ]
    },
    "1.2.8": {
      title: "Media Alternative (Prerecorded)",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#media-alternative-prerecorded",
            level: "AAA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#media-alternative-prerecorded",
            level: "AAA"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#media-equiv-text-doc",
            level: "AAA"
          }
        ]
      ]
    },
    "1.2.9": {
      title: "Audio-only (Live)",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#audio-only-live",
            level: "AAA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#audio-only-live",
            level: "AAA"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#media-equiv-live-audio-only",
            level: "AAA"
          }
        ]
      ]
    },
    "1.3.1": {
      title: "Info and Relationships",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#info-and-relationships",
            level: "A"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#info-and-relationships",
            level: "A"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#content-structure-separation-programmatic",
            level: "A"
          }
        ]
      ]
    },
    "1.3.2": {
      title: "Meaningful Sequence",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#meaningful-sequence",
            level: "A"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#meaningful-sequence",
            level: "A"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#content-structure-separation-sequence",
            level: "A"
          }
        ]
      ]
    },
    "1.3.3": {
      title: "Sensory Characteristics",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#sensory-characteristics",
            level: "A"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#sensory-characteristics",
            level: "A"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#content-structure-separation-understanding",
            level: "A"
          }
        ]
      ]
    },
    "1.3.4": {
      title: "Orientation",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#orientation",
            level: "AA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#orientation",
            level: "AA"
          }
        ]
      ]
    },
    "1.3.5": {
      title: "Identify Input Purpose",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#identify-input-purpose",
            level: "AA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#identify-input-purpose",
            level: "AA"
          }
        ]
      ]
    },
    "1.3.6": {
      title: "Identify Purpose",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#identify-purpose",
            level: "AAA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#identify-purpose",
            level: "AAA"
          }
        ]
      ]
    },
    "1.4.1": {
      title: "Use of Color",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#use-of-color",
            level: "A"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#use-of-color",
            level: "A"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#visual-audio-contrast-without-color",
            level: "A"
          }
        ]
      ]
    },
    "1.4.2": {
      title: "Audio Control",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#audio-control",
            level: "A"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#audio-control",
            level: "A"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#visual-audio-contrast-dis-audio",
            level: "A"
          }
        ]
      ]
    },
    "1.4.3": {
      title: "Contrast (Minimum)",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#contrast-minimum",
            level: "AA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#contrast-minimum",
            level: "AA"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#visual-audio-contrast-contrast",
            level: "AA"
          }
        ]
      ]
    },
    "1.4.4": {
      title: "Resize Text",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#resize-text",
            level: "AA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#resize-text",
            level: "AA"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#visual-audio-contrast-scale",
            level: "AA"
          }
        ]
      ]
    },
    "1.4.5": {
      title: "Images of Text",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#images-of-text",
            level: "AA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#images-of-text",
            level: "AA"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#visual-audio-contrast-text-presentation",
            level: "AA"
          }
        ]
      ]
    },
    "1.4.6": {
      title: "Contrast (Enhanced)",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#contrast-enhanced",
            level: "AAA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#contrast-enhanced",
            level: "AAA"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#visual-audio-contrast7",
            level: "AAA"
          }
        ]
      ]
    },
    "1.4.7": {
      title: "Low or No Background Audio",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#low-or-no-background-audio",
            level: "AAA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#low-or-no-background-audio",
            level: "AAA"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#visual-audio-contrast-noaudio",
            level: "AAA"
          }
        ]
      ]
    },
    "1.4.8": {
      title: "Visual Presentation",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#visual-presentation",
            level: "AAA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#visual-presentation",
            level: "AAA"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#visual-audio-contrast-visual-presentation",
            level: "AAA"
          }
        ]
      ]
    },
    "1.4.9": {
      title: "Images of Text (No Exception)",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#images-of-text-no-exception",
            level: "AAA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#images-of-text-no-exception",
            level: "AAA"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#visual-audio-contrast-text-images",
            level: "AAA"
          }
        ]
      ]
    },
    "1.4.10": {
      title: "Reflow",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#reflow",
            level: "AA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#reflow",
            level: "AA"
          }
        ]
      ]
    },
    "1.4.11": {
      title: "Non-text Contrast",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#non-text-contrast",
            level: "AA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#non-text-contrast",
            level: "AA"
          }
        ]
      ]
    },
    "1.4.12": {
      title: "Text Spacing",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#text-spacing",
            level: "AA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#text-spacing",
            level: "AA"
          }
        ]
      ]
    },
    "1.4.13": {
      title: "Content on Hover or Focus",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#content-on-hover-or-focus",
            level: "AA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#content-on-hover-or-focus",
            level: "AA"
          }
        ]
      ]
    },
    "2.1.1": {
      title: "Keyboard",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#keyboard",
            level: "A"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#keyboard",
            level: "A"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#keyboard-operation-keyboard-operable",
            level: "A"
          }
        ]
      ]
    },
    "2.1.2": {
      title: "No Keyboard Trap",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#no-keyboard-trap",
            level: "A"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#no-keyboard-trap",
            level: "A"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#keyboard-operation-trapping",
            level: "A"
          }
        ]
      ]
    },
    "2.1.3": {
      title: "Keyboard (No Exception)",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#keyboard-no-exception",
            level: "AAA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#keyboard-no-exception",
            level: "AAA"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#keyboard-operation-all-funcs",
            level: "AAA"
          }
        ]
      ]
    },
    "2.1.4": {
      title: "Character Key Shortcuts",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#character-key-shortcuts",
            level: "A"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#character-key-shortcuts",
            level: "A"
          }
        ]
      ]
    },
    "2.2.1": {
      title: "Timing Adjustable",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#timing-adjustable",
            level: "A"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#timing-adjustable",
            level: "A"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#time-limits-required-behaviors",
            level: "A"
          }
        ]
      ]
    },
    "2.2.2": {
      title: "Pause, Stop, Hide",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#pause-stop-hide",
            level: "A"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#pause-stop-hide",
            level: "A"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#time-limits-pause",
            level: "A"
          }
        ]
      ]
    },
    "2.2.3": {
      title: "No Timing",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#no-timing",
            level: "AAA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#no-timing",
            level: "AAA"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#time-limits-no-exceptions",
            level: "AAA"
          }
        ]
      ]
    },
    "2.2.4": {
      title: "Interruptions",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#interruptions",
            level: "AAA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#interruptions",
            level: "AAA"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#time-limits-postponed",
            level: "AAA"
          }
        ]
      ]
    },
    "2.2.5": {
      title: "Re-authenticating",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#re-authenticating",
            level: "AAA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#re-authenticating",
            level: "AAA"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#time-limits-server-timeout",
            level: "AAA"
          }
        ]
      ]
    },
    "2.2.6": {
      title: "Timeouts",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#timeouts",
            level: "AAA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#timeouts",
            level: "AAA"
          }
        ]
      ]
    },
    "2.3.1": {
      title: "Three Flashes or Below Threshold",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#three-flashes-or-below-threshold",
            level: "A"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#three-flashes-or-below-threshold",
            level: "A"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#seizure-does-not-violate",
            level: "A"
          }
        ]
      ]
    },
    "2.3.2": {
      title: "Three Flashes",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#three-flashes",
            level: "AAA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#three-flashes",
            level: "AAA"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#seizure-three-times",
            level: "AAA"
          }
        ]
      ]
    },
    "2.3.3": {
      title: "Animation from Interactions",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#animation-from-interactions",
            level: "AAA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#animation-from-interactions",
            level: "AAA"
          }
        ]
      ]
    },
    "2.4.1": {
      title: "Bypass Blocks",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#bypass-blocks",
            level: "A"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#bypass-blocks",
            level: "A"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#navigation-mechanisms-skip",
            level: "A"
          }
        ]
      ]
    },
    "2.4.2": {
      title: "Page Titled",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#page-titled",
            level: "A"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#page-titled",
            level: "A"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#navigation-mechanisms-title",
            level: "A"
          }
        ]
      ]
    },
    "2.4.3": {
      title: "Focus Order",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#focus-order",
            level: "A"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#focus-order",
            level: "A"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#navigation-mechanisms-focus-order",
            level: "A"
          }
        ]
      ]
    },
    "2.4.4": {
      title: "Link Purpose (In Context)",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#link-purpose-in-context",
            level: "A"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#link-purpose-in-context",
            level: "A"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#navigation-mechanisms-refs",
            level: "A"
          }
        ]
      ]
    },
    "2.4.5": {
      title: "Multiple Ways",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#multiple-ways",
            level: "AA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#multiple-ways",
            level: "AA"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#navigation-mechanisms-mult-loc",
            level: "AA"
          }
        ]
      ]
    },
    "2.4.6": {
      title: "Headings and Labels",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#headings-and-labels",
            level: "AA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#headings-and-labels",
            level: "AA"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#navigation-mechanisms-descriptive",
            level: "AA"
          }
        ]
      ]
    },
    "2.4.7": {
      title: "Focus Visible",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#focus-visible",
            level: "AA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#focus-visible",
            level: "AA"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#navigation-mechanisms-focus-visible",
            level: "AA"
          }
        ]
      ]
    },
    "2.4.8": {
      title: "Location",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#location",
            level: "AAA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#location",
            level: "AAA"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#navigation-mechanisms-location",
            level: "AAA"
          }
        ]
      ]
    },
    "2.4.9": {
      title: "Link Purpose (Link Only)",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#link-purpose-link-only",
            level: "AAA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#link-purpose-link-only",
            level: "AAA"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#navigation-mechanisms-link",
            level: "AAA"
          }
        ]
      ]
    },
    "2.4.10": {
      title: "Section Headings",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#section-headings",
            level: "AAA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#section-headings",
            level: "AAA"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#navigation-mechanisms-headings",
            level: "AAA"
          }
        ]
      ]
    },
    "2.4.11": {
      title: "Focus Not Obscured (Minimum)",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#focus-not-obscured-minimum",
            level: "AA"
          }
        ]
      ]
    },
    "2.4.12": {
      title: "Focus Not Obscured (Enhanced)",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#focus-not-obscured-enhanced",
            level: "AAA"
          }
        ]
      ]
    },
    "2.4.13": {
      title: "Focus Appearance",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#focus-appearance",
            level: "AAA"
          }
        ]
      ]
    },
    "2.5.1": {
      title: "Pointer Gestures",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#pointer-gestures",
            level: "A"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#pointer-gestures",
            level: "A"
          }
        ]
      ]
    },
    "2.5.2": {
      title: "Pointer Cancellation",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#pointer-cancellation",
            level: "A"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#pointer-cancellation",
            level: "A"
          }
        ]
      ]
    },
    "2.5.3": {
      title: "Label in Name",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#label-in-name",
            level: "A"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#label-in-name",
            level: "A"
          }
        ]
      ]
    },
    "2.5.4": {
      title: "Motion Actuation",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#motion-actuation",
            level: "A"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#motion-actuation",
            level: "A"
          }
        ]
      ]
    },
    "2.5.5": {
      title: "Target Size (Enhanced)",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#target-size-enhanced",
            level: "AAA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#target-size",
            level: "AAA"
          }
        ]
      ]
    },
    "2.5.6": {
      title: "Concurrent Input Mechanisms",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#concurrent-input-mechanisms",
            level: "AAA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#concurrent-input-mechanisms",
            level: "AAA"
          }
        ]
      ]
    },
    "2.5.7": {
      title: "Dragging Movements",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#dragging-movements",
            level: "AA"
          }
        ]
      ]
    },
    "2.5.8": {
      title: "Target Size (Minimum)",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#target-size-minimum",
            level: "AA"
          }
        ]
      ]
    },
    "3.1.1": {
      title: "Language of Page",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#language-of-page",
            level: "A"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#language-of-page",
            level: "A"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#meaning-doc-lang-id",
            level: "A"
          }
        ]
      ]
    },
    "3.1.2": {
      title: "Language of Parts",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#language-of-parts",
            level: "AA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#language-of-parts",
            level: "AA"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#meaning-other-lang-id",
            level: "AA"
          }
        ]
      ]
    },
    "3.1.3": {
      title: "Unusual Words",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#unusual-words",
            level: "AAA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#unusual-words",
            level: "AAA"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#meaning-idioms",
            level: "AAA"
          }
        ]
      ]
    },
    "3.1.4": {
      title: "Abbreviations",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#abbreviations",
            level: "AAA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#abbreviations",
            level: "AAA"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#meaning-located",
            level: "AAA"
          }
        ]
      ]
    },
    "3.1.5": {
      title: "Reading Level",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#reading-level",
            level: "AAA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#reading-level",
            level: "AAA"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#meaning-supplements",
            level: "AAA"
          }
        ]
      ]
    },
    "3.1.6": {
      title: "Pronunciation",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#pronunciation",
            level: "AAA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#pronunciation",
            level: "AAA"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#meaning-pronunciation",
            level: "AAA"
          }
        ]
      ]
    },
    "3.2.1": {
      title: "On Focus",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#on-focus",
            level: "A"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#on-focus",
            level: "A"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#consistent-behavior-receive-focus",
            level: "A"
          }
        ]
      ]
    },
    "3.2.2": {
      title: "On Input",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#on-input",
            level: "A"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#on-input",
            level: "A"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#consistent-behavior-unpredictable-change",
            level: "A"
          }
        ]
      ]
    },
    "3.2.3": {
      title: "Consistent Navigation",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#consistent-navigation",
            level: "AA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#consistent-navigation",
            level: "AA"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#consistent-behavior-consistent-locations",
            level: "AA"
          }
        ]
      ]
    },
    "3.2.4": {
      title: "Consistent Identification",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#consistent-identification",
            level: "AA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#consistent-identification",
            level: "AA"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#consistent-behavior-consistent-functionality",
            level: "AA"
          }
        ]
      ]
    },
    "3.2.5": {
      title: "Change on Request",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#change-on-request",
            level: "AAA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#change-on-request",
            level: "AAA"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#consistent-behavior-no-extreme-changes-context",
            level: "AAA"
          }
        ]
      ]
    },
    "3.2.6": {
      title: "Consistent Help",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#consistent-help",
            level: "A"
          }
        ]
      ]
    },
    "3.3.1": {
      title: "Error Identification",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#error-identification",
            level: "A"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#error-identification",
            level: "A"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#minimize-error-identified",
            level: "A"
          }
        ]
      ]
    },
    "3.3.2": {
      title: "Labels or Instructions",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#labels-or-instructions",
            level: "A"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#labels-or-instructions",
            level: "A"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#minimize-error-cues",
            level: "A"
          }
        ]
      ]
    },
    "3.3.3": {
      title: "Error Suggestion",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#error-suggestion",
            level: "AA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#error-suggestion",
            level: "AA"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#minimize-error-suggestions",
            level: "AA"
          }
        ]
      ]
    },
    "3.3.4": {
      title: "Error Prevention (Legal, Financial, Data)",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#error-prevention-legal-financial-data",
            level: "AA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#error-prevention-legal-financial-data",
            level: "AA"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#minimize-error-reversible",
            level: "AA"
          }
        ]
      ]
    },
    "3.3.5": {
      title: "Help",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#help",
            level: "AAA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#help",
            level: "AAA"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#minimize-error-context-help",
            level: "AAA"
          }
        ]
      ]
    },
    "3.3.6": {
      title: "Error Prevention (All)",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#error-prevention-all",
            level: "AAA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#error-prevention-all",
            level: "AAA"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#minimize-error-reversible-all",
            level: "AAA"
          }
        ]
      ]
    },
    "3.3.7": {
      title: "Redundant Entry",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#redundant-entry",
            level: "A"
          }
        ]
      ]
    },
    "3.3.8": {
      title: "Accessible Authentication (Minimum)",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#accessible-authentication-minimum",
            level: "AA"
          }
        ]
      ]
    },
    "3.3.9": {
      title: "Accessible Authentication (Enhanced)",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#accessible-authentication-enhanced",
            level: "AAA"
          }
        ]
      ]
    },
    "4.1.2": {
      title: "Name, Role, Value",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#name-role-value",
            level: "A"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#name-role-value",
            level: "A"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#ensure-compat-rsv",
            level: "A"
          }
        ]
      ]
    },
    "4.1.3": {
      title: "Status Messages",
      versions: [
        [
          "2.2",
          {
            uri: "https://www.w3.org/TR/WCAG2/#status-messages",
            level: "AA"
          }
        ],
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#status-messages",
            level: "AA"
          }
        ]
      ]
    },
    "4.1.1": {
      title: "Parsing",
      versions: [
        [
          "2.1",
          {
            uri: "https://www.w3.org/TR/WCAG21/#parsing",
            level: "A"
          }
        ],
        [
          "2.0",
          {
            uri: "https://www.w3.org/TR/WCAG20/#ensure-compat-parses",
            level: "A"
          }
        ]
      ]
    }
  };

  // node_modules/@siteimprove/alfa-wcag/dist/criterion.js
  var Criterion = class _Criterion extends Requirement {
    static of(chapter) {
      const versions = [...Criteria[chapter].versions];
      const [, { uri }] = versions.find(([version]) => version === _Criterion.Version.Recommendation) ?? versions.find(([version]) => version === _Criterion.Version.Old);
      return new _Criterion(chapter, uri);
    }
    _chapter;
    constructor(chapter, uri) {
      super("criterion", uri);
      this._chapter = chapter;
    }
    /**
     * The chapter of this criterion.
     */
    get chapter() {
      return this._chapter;
    }
    /**
     * The title of this criterion.
     */
    get title() {
      return Criteria[this._chapter].title;
    }
    /**
     * The versions in which this criterion is defined.
     */
    get versions() {
      return [...Criteria[this._chapter].versions].map(([version]) => version);
    }
    /**
     * The level of this criterion.
     *
     * @remarks
     * The level may be different between versions.
     */
    get level() {
      return Branched.from([...Criteria[this._chapter].versions].map(([version, { level }]) => [
        level,
        [version]
      ]));
    }
    toJSON() {
      const { title } = Criteria[this._chapter];
      return {
        ...super.toJSON(),
        chapter: this._chapter,
        title
      };
    }
    toEARL() {
      const { title } = Criteria[this._chapter];
      return {
        ...super.toEARL(),
        "@context": {
          earl: "http://www.w3.org/ns/earl#",
          dct: "http://purl.org/dc/terms/"
        },
        "dct:title": title,
        "dct:isPartOf": "https://www.w3.org/TR/WCAG/"
      };
    }
  };
  (function(Criterion2) {
    function isChapter(value) {
      return value in Criteria;
    }
    Criterion2.isChapter = isChapter;
    let Version2;
    (function(Version3) {
      Version3.Recommendation = "2.2";
      Version3.Old = "2.1";
    })(Version2 = Criterion2.Version || (Criterion2.Version = {}));
    function isCriterion(value) {
      return value instanceof Criterion2;
    }
    Criterion2.isCriterion = isCriterion;
    function fromURI(uri) {
      const rewrittenUri = uri.replace("/WCAG22/", "/WCAG2/").replace("/WCAG/", "/WCAG2/");
      for (const [chapter, value] of Object.entries(Criteria)) {
        for (const version of value.versions) {
          if (version[1].uri === rewrittenUri) {
            return Option.of(Criterion2.of(chapter));
          }
        }
      }
      return None;
    }
    Criterion2.fromURI = fromURI;
  })(Criterion || (Criterion = {}));

  // node_modules/@siteimprove/alfa-wcag/dist/conformance.js
  var Conformance;
  (function(Conformance2) {
    function hasLevel(level, version = Criterion.Version.Recommendation) {
      return (criterion) => criterion.level.some((found, versions) => found <= level && [...versions].includes(version));
    }
    function isA(version) {
      return hasLevel("A", version);
    }
    Conformance2.isA = isA;
    function isAA(version) {
      return hasLevel("AA", version);
    }
    Conformance2.isAA = isAA;
    function isAAA(version) {
      return hasLevel("AAA", version);
    }
    Conformance2.isAAA = isAAA;
  })(Conformance || (Conformance = {}));

  // node_modules/@siteimprove/alfa-wcag/dist/technique/data.js
  var Techniques = {
    ARIA1: {
      title: "Using the aria-describedby property to provide a descriptive label for user interface",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/aria/ARIA1"
    },
    ARIA2: {
      title: "Identifying a required field with the aria-required property",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/aria/ARIA2"
    },
    ARIA4: {
      title: "Using a WAI-ARIA role to expose the role of a user interface component",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/aria/ARIA4"
    },
    ARIA5: {
      title: "Using WAI-ARIA state and property attributes to expose the state of a user interface",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/aria/ARIA5"
    },
    ARIA6: {
      title: "Using aria-label to provide labels for objects",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/aria/ARIA6"
    },
    ARIA7: {
      title: "Using aria-labelledby for link purpose",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/aria/ARIA7"
    },
    ARIA8: {
      title: "Using aria-label for link purpose",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/aria/ARIA8"
    },
    ARIA9: {
      title: "Using aria-labelledby to concatenate a label from several text nodes",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/aria/ARIA9"
    },
    ARIA10: {
      title: "Using aria-labelledby to provide a text alternative for non-text content",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/aria/ARIA10"
    },
    ARIA11: {
      title: "Using ARIA landmarks to identify regions of a page",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/aria/ARIA11"
    },
    ARIA12: {
      title: "Using role=heading to identify headings",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/aria/ARIA12"
    },
    ARIA13: {
      title: "Using aria-labelledby to name regions and landmarks",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/aria/ARIA13"
    },
    ARIA14: {
      title: "Using aria-label to provide an invisible label where a visible label cannot be used",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/aria/ARIA14"
    },
    ARIA15: {
      title: "Using aria-describedby to provide descriptions of images",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/aria/ARIA15"
    },
    ARIA16: {
      title: "Using aria-labelledby to provide a name for user interface controls",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/aria/ARIA16"
    },
    ARIA17: {
      title: "Using grouping roles to identify related form controls",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/aria/ARIA17"
    },
    ARIA18: {
      title: "Using aria-alertdialog to Identify Errors",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/aria/ARIA18"
    },
    ARIA19: {
      title: "Using ARIA role=alert or Live Regions to Identify Errors",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/aria/ARIA19"
    },
    ARIA20: {
      title: "Using the region role to identify a region of the page",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/aria/ARIA20"
    },
    ARIA21: {
      title: "Using aria-invalid to Indicate An Error Field",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/aria/ARIA21"
    },
    ARIA22: {
      title: "Using role=status to present status messages",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/aria/ARIA22"
    },
    ARIA23: {
      title: "Using role=log to identify sequential information updates",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/aria/ARIA23"
    },
    ARIA24: {
      title: 'Semantically identifying a font icon with role="img"',
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/aria/ARIA24"
    },
    SCR1: {
      title: "Allowing the user to extend the default time limit",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/client-side-script/SCR1"
    },
    SCR2: {
      title: "Using redundant keyboard and mouse event handlers",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/client-side-script/SCR2"
    },
    SCR14: {
      title: "Using scripts to make nonessential alerts optional",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/client-side-script/SCR14"
    },
    SCR16: {
      title: "Providing a script that warns the user a time limit is about to expire",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/client-side-script/SCR16"
    },
    SCR18: {
      title: "Providing client-side validation and alert",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/client-side-script/SCR18"
    },
    SCR19: {
      title: "Using an onchange event on a select element without causing a change of context",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/client-side-script/SCR19"
    },
    SCR20: {
      title: "Using both keyboard and other device-specific functions",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/client-side-script/SCR20"
    },
    SCR21: {
      title: "Using functions of the Document Object Model (DOM) to add content to a page",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/client-side-script/SCR21"
    },
    SCR22: {
      title: "Using scripts to control blinking and stop it in five seconds or less",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/client-side-script/SCR22"
    },
    SCR24: {
      title: "Using progressive enhancement to open new windows on user request",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/client-side-script/SCR24"
    },
    SCR26: {
      title: "Inserting dynamic content into the Document Object Model immediately following its",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/client-side-script/SCR26"
    },
    SCR27: {
      title: "Reordering page sections using the Document Object Model",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/client-side-script/SCR27"
    },
    SCR28: {
      title: "Using an expandable and collapsible menu to bypass block of content",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/client-side-script/SCR28"
    },
    SCR29: {
      title: "Adding keyboard-accessible actions to static HTML elements",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/client-side-script/SCR29"
    },
    SCR30: {
      title: "Using scripts to change the link text",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/client-side-script/SCR30"
    },
    SCR31: {
      title: "Using script to change the background color or border of the element with focus",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/client-side-script/SCR31"
    },
    SCR32: {
      title: "Providing client-side validation and adding error text via the DOM",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/client-side-script/SCR32"
    },
    SCR33: {
      title: "Using script to scroll content, and providing a mechanism to pause it",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/client-side-script/SCR33"
    },
    SCR34: {
      title: "Calculating size and position in a way that scales with text size",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/client-side-script/SCR34"
    },
    SCR35: {
      title: "Making actions keyboard accessible by using the onclick event of anchors and buttons",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/client-side-script/SCR35"
    },
    SCR36: {
      title: "Providing a mechanism to allow users to display moving, scrolling, or auto-updating",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/client-side-script/SCR36"
    },
    SCR37: {
      title: "Creating Custom Dialogs",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/client-side-script/SCR37"
    },
    SCR38: {
      title: "Creating a conforming alternate version for a web page designed with progressive enhancement",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/client-side-script/SCR38"
    },
    SCR39: {
      title: "Making content on focus or hover hoverable, dismissible, and persistent",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/client-side-script/SCR39"
    },
    C6: {
      title: "Positioning content based on structural markup",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/css/C6"
    },
    C7: {
      title: "Using CSS to hide a portion of the link text",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/css/C7"
    },
    C8: {
      title: "Using CSS letter-spacing to control spacing within a word",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/css/C8"
    },
    C9: {
      title: "Using CSS to include decorative images",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/css/C9"
    },
    C12: {
      title: "Using percent for font sizes",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/css/C12"
    },
    C13: {
      title: "Using named font sizes",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/css/C13"
    },
    C14: {
      title: "Using em units for font sizes",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/css/C14"
    },
    C15: {
      title: "Using CSS to change the presentation of a user interface component when it receives",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/css/C15"
    },
    C17: {
      title: "Scaling form elements which contain text",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/css/C17"
    },
    C18: {
      title: "Using CSS margin and padding rules instead of spacer images for layout design",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/css/C18"
    },
    C19: {
      title: "Specifying alignment either to the left or right in CSS",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/css/C19"
    },
    C20: {
      title: "Using relative measurements to set column widths so that lines can average 80 characters",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/css/C20"
    },
    C21: {
      title: "Specifying line spacing in CSS",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/css/C21"
    },
    C22: {
      title: "Using CSS to control visual presentation of text",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/css/C22"
    },
    C23: {
      title: "Specifying text and background colors of secondary content such as banners, features",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/css/C23"
    },
    C24: {
      title: "Using percentage values in CSS for container sizes",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/css/C24"
    },
    C25: {
      title: "Specifying borders and layout in CSS to delineate areas of a Web page while not specifying",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/css/C25"
    },
    C27: {
      title: "Making the DOM order match the visual order",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/css/C27"
    },
    C28: {
      title: "Specifying the size of text containers using em units",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/css/C28"
    },
    C29: {
      title: "Using a style switcher to provide a conforming alternate version",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/css/C29"
    },
    C30: {
      title: "Using CSS to replace text with images of text and providing user interface controls",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/css/C30"
    },
    C31: {
      title: "Using CSS Flexbox to reflow content",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/css/C31"
    },
    C32: {
      title: "Using media queries and grid CSS to reflow columns",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/css/C32"
    },
    C33: {
      title: "Allowing for Reflow with Long URLs and Strings of Text",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/css/C33"
    },
    C34: {
      title: "Using media queries to un-fixing sticky headers / footers",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/css/C34"
    },
    C35: {
      title: "Allowing for text spacing without wrapping",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/css/C35"
    },
    C36: {
      title: "Allowing for text spacing override",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/css/C36"
    },
    C37: {
      title: "Using CSS max-width and height to fit images",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/css/C37"
    },
    C38: {
      title: "Using CSS width, max-width and flexbox to fit labels and inputs",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/css/C38"
    },
    C39: {
      title: "Using the CSS reduce-motion query to prevent motion",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/css/C39"
    },
    C40: {
      title: "Creating a two-color focus indicator to ensure sufficient contrast with all components",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/css/C40"
    },
    C41: {
      title: "Creating a strong focus indicator within the component",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/css/C41"
    },
    C42: {
      title: "Using min-height and min-width to ensure sufficient target spacing",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/css/C42"
    },
    C43: {
      title: "Using CSS scroll-padding to un-obscure content",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/css/C43"
    },
    F1: {
      title: "Failure of Success Criterion 1.3.2 due to changing the meaning of content by positioning",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F1"
    },
    F2: {
      title: "Failure of Success Criterion 1.3.1 due to using changes in text presentation to convey",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F2"
    },
    F3: {
      title: "Failure of Success Criterion 1.1.1 due to using CSS to include images that convey",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F3"
    },
    F4: {
      title: "Failure of Success Criterion 2.2.2 due to using text-decoration:blink without a mechanism",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F4"
    },
    F7: {
      title: "Failure of Success Criterion 2.2.2 due to an object or applet for more than five seconds",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F7"
    },
    F8: {
      title: "Failure of Success Criterion 1.2.2 due to captions omitting some dialogue or important",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F8"
    },
    F9: {
      title: "Failure of Success Criterion 3.2.5 due to changing the context when the user removes",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F9"
    },
    F10: {
      title: "Failure of Success Criterion 2.1.2 and Conformance Requirement 5 due to combining",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F10"
    },
    F12: {
      title: "Failure of Success Criterion 2.2.5 due to having a session time limit without a mechanism",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F12"
    },
    F13: {
      title: "Failure of Success Criterion 1.1.1 and 1.4.1 due to having a text alternative that",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F13"
    },
    F14: {
      title: "Failure of Success Criterion 1.3.3 due to identifying content only by its shape or",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F14"
    },
    F15: {
      title: "Failure of Success Criterion 4.1.2 due to implementing custom controls that do not",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F15"
    },
    F16: {
      title: "Failure of Success Criterion 2.2.2 due to including scrolling content where movement",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F16"
    },
    F19: {
      title: "Failure of Conformance Requirement 1 due to not providing a method for the user to",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F19"
    },
    F20: {
      title: "Failure of Success Criterion 1.1.1 and 4.1.2 due to not updating text alternatives",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F20"
    },
    F22: {
      title: "Failure of Success Criterion 3.2.5 due to opening windows that are not requested by",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F22"
    },
    F23: {
      title: "Failure of 1.4.2 due to playing a sound longer than 3 seconds where              ",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F23"
    },
    F24: {
      title: "Failure of Success Criterion 1.4.3, 1.4.6 and 1.4.8 due to specifying foreground colors",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F24"
    },
    F25: {
      title: "Failure of Success Criterion 2.4.2 due to the title of a Web page not identifying",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F25"
    },
    F26: {
      title: "Failure of Success Criterion 1.3.3 due to using a graphical symbol alone to convey",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F26"
    },
    F30: {
      title: "Failure of Success Criterion 1.1.1 and 1.2.1 due to using text alternatives that are",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F30"
    },
    F31: {
      title: "Failure of Success Criterion 3.2.4 due to using two different labels for the same",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F31"
    },
    F32: {
      title: "Failure of Success Criterion 1.3.2 due to using white space characters to control",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F32"
    },
    F33: {
      title: "Failure of Success Criterion 1.3.1 and 1.3.2 due to using white space characters to",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F33"
    },
    F34: {
      title: "Failure of Success Criterion 1.3.1 and 1.3.2 due to using white space characters to",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F34"
    },
    F36: {
      title: "Failure of Success Criterion 3.2.2 due to automatically submitting a form and given",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F36"
    },
    F37: {
      title: "Failure of Success Criterion 3.2.2 due to launching a new window without prior warning",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F37"
    },
    F38: {
      title: "Failure of Success Criterion 1.1.1 due to not marking up decorative images in HTML",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F38"
    },
    F39: {
      title: "Failure of Success Criterion 1.1.1 due to providing a text alternative that is not",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F39"
    },
    F40: {
      title: "Failure due to using meta redirect with a time limit",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F40"
    },
    F41: {
      title: "Failure of Success Criterion 2.2.1, 2.2.4, and 3.2.5 due to using meta refresh to",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F41"
    },
    F42: {
      title: "Failure of Success Criteria 1.3.1, 2.1.1, 2.1.3, or 4.1.2 when emulating links",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F42"
    },
    F43: {
      title: "Failure of Success Criterion 1.3.1 due to using structural markup in a way that does",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F43"
    },
    F44: {
      title: "Failure of Success Criterion 2.4.3 due to using tabindex to create a tab order that",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F44"
    },
    F46: {
      title: "Failure of Success Criterion 1.3.1 due to using th elements, layout tables",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F46"
    },
    F47: {
      title: "Failure of Success Criterion 2.2.2 due to using the blink element",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F47"
    },
    F48: {
      title: "Failure of Success Criterion 1.3.1 due to using the pre element to markup tabular",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F48"
    },
    F49: {
      title: "Failure of Success Criterion 1.3.2 due to using an HTML layout table that does not",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F49"
    },
    F50: {
      title: "Failure of Success Criterion 2.2.2 due to a script that causes a blink effect without",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F50"
    },
    F52: {
      title: "Failure of Success Criterion 3.2.1 and 3.2.5 due to opening a new window as soon as",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F52"
    },
    F54: {
      title: "Failure of Success Criterion 2.1.1 due to using only pointing-device-specific event",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F54"
    },
    F55: {
      title: "Failure of Success Criteria 2.1.1, 2.4.7, and 3.2.1 due to using script to remove",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F55"
    },
    F58: {
      title: "Failure of Success Criterion 2.2.1 due to using server-side techniques to automatically",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F58"
    },
    F59: {
      title: "Failure of Success Criterion 4.1.2 due to using script to make div or span a user",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F59"
    },
    F60: {
      title: "Failure of Success Criterion 3.2.5 due to launching a new window when a user enters",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F60"
    },
    F61: {
      title: "Failure of Success Criterion 3.2.5 due to complete change of main content through",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F61"
    },
    F63: {
      title: "Failure of Success Criterion 2.4.4 due to providing link context only in content that",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F63"
    },
    F65: {
      title: "Failure of Success Criterion 1.1.1 due to omitting the alt attribute or text alternative",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F65"
    },
    F66: {
      title: "Failure of Success Criterion 3.2.3 due to presenting navigation links in a different",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F66"
    },
    F67: {
      title: "Failure of Success Criterion 1.1.1 and 1.2.1 due to providing long descriptions for",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F67"
    },
    F68: {
      title: "Failure of Success Criterion 4.1.2 due to a user interface control not having a programmatically",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F68"
    },
    F69: {
      title: "Failure of Success Criterion 1.4.4 when resizing visually rendered text up to 200",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F69"
    },
    F70: {
      title: "Failure of Success Criterion 4.1.1 due to incorrect use of start and end tags or attribute",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F70"
    },
    F71: {
      title: "Failure of Success Criterion 1.1.1 due to using text look-alikes to represent text",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F71"
    },
    F72: {
      title: "Failure of Success Criterion 1.1.1 due to using ASCII art without providing a text",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F72"
    },
    F73: {
      title: "Failure of Success Criterion 1.4.1 due to creating links that are not visually evident",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F73"
    },
    F74: {
      title: "Failure of Success Criterion 1.2.2 and 1.2.8 due to not labeling a synchronized media",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F74"
    },
    F75: {
      title: "Failure of Success Criterion 1.2.2 by providing synchronized media without captions",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F75"
    },
    F77: {
      title: "Failure of Success Criterion 4.1.1 due to duplicate values of type ID",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F77"
    },
    F78: {
      title: "Failure of Success Criterion 2.4.7 due to styling element outlines and borders in",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F78"
    },
    F79: {
      title: "Failure of Success Criterion 4.1.2 due to the focus state of a user interface component",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F79"
    },
    F80: {
      title: "Failure of Success Criterion 1.4.4 when text-based form controls do not resize when",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F80"
    },
    F81: {
      title: "Failure of Success Criterion 1.4.1 due to identifying required or error fields using",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F81"
    },
    F82: {
      title: "Failure of Success Criterion 3.3.2 by visually formatting a set of phone number fields",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F82"
    },
    F83: {
      title: "Failure of Success Criterion 1.4.3 and 1.4.6 due to using background images that do",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F83"
    },
    F84: {
      title: 'Failure of Success Criterion 2.4.9 due to using a non-specific link such as "click',
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F84"
    },
    F85: {
      title: "Failure of Success Criterion 2.4.3 due to using dialogs or menus that are not adjacent",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F85"
    },
    F86: {
      title: "Failure of Success Criterion 4.1.2 due to not providing names for each part of a multi-part",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F86"
    },
    F87: {
      title: "Failure of Success Criterion 1.3.1 due to inserting non-decorative content by using",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F87"
    },
    F88: {
      title: "Failure of Success Criterion 1.4.8 due to using text that is justified (aligned to",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F88"
    },
    F89: {
      title: "Failure of Success Criteria 2.4.4, 2.4.9 and 4.1.2 due to not providing an accessible",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F89"
    },
    F90: {
      title: "Failure of Success Criterion 1.3.1 for incorrectly associating table headers and content",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F90"
    },
    F91: {
      title: "Failure of Success Criterion 1.3.1 for not correctly marking up table headers",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F91"
    },
    F92: {
      title: "Failure of Success Criterion 1.3.1 due to the use of role presentation on content",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F92"
    },
    F93: {
      title: "Failure of Success Criterion 1.4.2 for absence of a way to pause or stop an HTML5",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F93"
    },
    F94: {
      title: "Failure of Success Criterion 1.4.4 due to incorrect use of viewport units to resize",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F94"
    },
    F95: {
      title: "Failure of Success Criterion 1.4.13 due to content shown on hover not being hoverable",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F95"
    },
    F96: {
      title: "Failure due to the accessible name not containing the visible label text",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F96"
    },
    F97: {
      title: "Failure due to locking the orientation to landscape or portrait view",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F97"
    },
    F98: {
      title: "Failure due to interactions being limited to touch-only on touchscreen devices",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F98"
    },
    F99: {
      title: "Failure of Success Criterion 2.1.4 due to implementing character key shortcuts that",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F99"
    },
    F100: {
      title: "Failure of Success Criterion 1.3.4 due to showing a message asking to reorient device",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F100"
    },
    F101: {
      title: "Failure of Success Criterion 2.5.2 due to activating a control on the down-event",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F101"
    },
    F102: {
      title: "Failure of Success Criterion 1.4.10 due to content disappearing and not being available",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F102"
    },
    F103: {
      title: "Failure of Success Criterion 4.1.3 due to providing status messages that cannot be",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F103"
    },
    F104: {
      title: "Failure of Success Criterion 1.4.12 due to clipped or overlapped content when text",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F104"
    },
    F105: {
      title: "Failure of Success Criterion 2.5.1 due to providing functionality via a path-based",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F105"
    },
    F106: {
      title: "Failure due to inability to deactivate motion actuation",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F106"
    },
    F107: {
      title: "Failure of Success Criterion 1.3.5 due to incorrect autocomplete attribute values",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F107"
    },
    F108: {
      title: "Failure of Success Criterion 2.5.7 Dragging Movements due to not providing a single",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F108"
    },
    F109: {
      title: "Failure of Success Criterion 3.3.8 and 3.3.9 due to preventing password or code re-entry",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F109"
    },
    F110: {
      title: "Failure of Success Criterion 2.4.12 Focus Not Obscured (Minimum) due to a sticky footer",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/failures/F110"
    },
    G1: {
      title: "Adding a link at the top of each page that goes directly to the main content area",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G1"
    },
    G4: {
      title: "Allowing the content to be paused and restarted from where it was paused",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G4"
    },
    G5: {
      title: "Allowing users to complete an activity without any time limit",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G5"
    },
    G8: {
      title: "Providing a movie with extended audio descriptions",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G8"
    },
    G9: {
      title: "Creating captions for live synchronized media",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G9"
    },
    G10: {
      title: "Creating components using a technology that supports the accessibility notification",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G10"
    },
    G11: {
      title: "Creating content that blinks for less than 5 seconds",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G11"
    },
    G13: {
      title: "Describing what will happen before a change to a form control that causes a change",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G13"
    },
    G14: {
      title: "Ensuring that information conveyed by color differences is also available in text",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G14"
    },
    G15: {
      title: "Using a tool to ensure that content does not violate the general flash threshold or",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G15"
    },
    G17: {
      title: "Ensuring that a contrast ratio of at least 7:1 exists between text (and images of",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G17"
    },
    G18: {
      title: "Ensuring that a contrast ratio of at least 4.5:1 exists between text (and images of",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G18"
    },
    G19: {
      title: "Ensuring that no component of the content flashes more than three times in any 1-second",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G19"
    },
    G21: {
      title: "Ensuring that users are not trapped in content",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G21"
    },
    G53: {
      title: "Identifying the purpose of a link using link text combined with the text of the enclosing",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G53"
    },
    G54: {
      title: "Including a sign language interpreter in the video stream",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G54"
    },
    G55: {
      title: "Linking to definitions",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G55"
    },
    G56: {
      title: "Mixing audio files so that non-speech sounds are at least 20 decibels lower than the",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G56"
    },
    G57: {
      title: "Ordering the content in a meaningful sequence",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G57"
    },
    G58: {
      title: "Placing a link to the alternative for time-based media immediately next to the non-text",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G58"
    },
    G59: {
      title: "Placing the interactive elements in an order that follows sequences and relationships",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G59"
    },
    G60: {
      title: "Playing a sound that turns off automatically within three seconds",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G60"
    },
    G61: {
      title: "Presenting repeated components in the same relative order each time they appear",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G61"
    },
    G62: {
      title: "Providing a glossary",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G62"
    },
    G63: {
      title: "Providing a site map",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G63"
    },
    G64: {
      title: "Providing a Table of Contents",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G64"
    },
    G65: {
      title: "Providing a breadcrumb trail",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G65"
    },
    G68: {
      title: "Providing a short text alternative that describes the purpose of live audio-only and",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G68"
    },
    G69: {
      title: "Providing an alternative for time based media",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G69"
    },
    G70: {
      title: "Providing a function to search an online dictionary",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G70"
    },
    G71: {
      title: "Providing a help link on every Web page",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G71"
    },
    G73: {
      title: "Providing a long description in another location with a link to it that is immediately",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G73"
    },
    G74: {
      title: "Providing a long description in text near the non-text content, with a reference to",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G74"
    },
    G75: {
      title: "Providing a mechanism to postpone any updating of content",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G75"
    },
    G76: {
      title: "Providing a mechanism to request an update of the content instead of updating automatically",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G76"
    },
    G78: {
      title: "Providing a second, user-selectable, audio track that includes audio descriptions",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G78"
    },
    G79: {
      title: "Providing a spoken version of the text",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G79"
    },
    G80: {
      title: "Providing a submit button to initiate a change of context",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G80"
    },
    G81: {
      title: "Providing a synchronized video of the sign language interpreter that can be displayed",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G81"
    },
    G82: {
      title: "Providing a text alternative that identifies the purpose of the non-text content",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G82"
    },
    G83: {
      title: "Providing text descriptions to identify required fields that were not completed",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G83"
    },
    G84: {
      title: "Providing a text description when the user provides information that is not in the",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G84"
    },
    G85: {
      title: "Providing a text description when user input falls outside the required format or",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G85"
    },
    G86: {
      title: "Providing a text summary that can be understood by people with lower secondary education",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G86"
    },
    G87: {
      title: "Providing closed captions",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G87"
    },
    G88: {
      title: "Providing descriptive titles for Web pages",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G88"
    },
    G89: {
      title: "Providing expected data format and example",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G89"
    },
    G90: {
      title: "Providing keyboard-triggered event handlers",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G90"
    },
    G91: {
      title: "Providing link text that describes the purpose of a link",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G91"
    },
    G92: {
      title: "Providing long description for non-text content that serves the same purpose and presents",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G92"
    },
    G93: {
      title: "Providing open (always visible) captions",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G93"
    },
    G94: {
      title: "Providing short text alternative for non-text content that serves the same purpose",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G94"
    },
    G95: {
      title: "Providing short text alternatives that provide a brief description of the non-text",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G95"
    },
    G96: {
      title: "Providing textual identification of items that otherwise rely only on sensory information",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G96"
    },
    G97: {
      title: "Providing the first use of an abbreviation immediately before or after the expanded",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G97"
    },
    G98: {
      title: "Providing the ability for the user to review and correct answers before submitting",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G98"
    },
    G99: {
      title: "Providing the ability to recover deleted information",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G99"
    },
    G100: {
      title: "Providing a short text alternative which is the accepted name or a descriptive name",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G100"
    },
    G101: {
      title: "Providing the definition of a word or phrase used in an unusual or restricted way",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G101"
    },
    G102: {
      title: "Providing the expansion or explanation of an abbreviation",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G102"
    },
    G103: {
      title: "Providing visual illustrations, pictures, and symbols to help explain ideas, events,",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G103"
    },
    G105: {
      title: "Saving data so that it can be used after a user re-authenticates",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G105"
    },
    G107: {
      title: 'Using "activate" rather than "focus" as a trigger for changes of context',
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G107"
    },
    G108: {
      title: "Using markup features to expose the name and role, allow user-settable properties",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G108"
    },
    G110: {
      title: "Using an instant client-side redirect",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G110"
    },
    G111: {
      title: "Using color and pattern",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G111"
    },
    G112: {
      title: "Using inline definitions",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G112"
    },
    G115: {
      title: "Using semantic elements to mark up structure",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G115"
    },
    G117: {
      title: "Using text to convey information that is conveyed by variations in presentation of",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G117"
    },
    G120: {
      title: "Providing the pronunciation immediately following the word",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G120"
    },
    G121: {
      title: "Linking to pronunciations",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G121"
    },
    G123: {
      title: "Adding a link at the beginning of a block of repeated content to go to the end of",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G123"
    },
    G124: {
      title: "Adding links at the top of the page to each area of the content",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G124"
    },
    G125: {
      title: "Providing links to navigate to related Web pages",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G125"
    },
    G126: {
      title: "Providing a list of links to all other Web pages",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G126"
    },
    G127: {
      title: "Identifying a Web page's relationship to a larger collection of Web pages",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G127"
    },
    G128: {
      title: "Indicating current location within navigation bars",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G128"
    },
    G130: {
      title: "Providing descriptive headings",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G130"
    },
    G131: {
      title: "Providing descriptive labels",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G131"
    },
    G133: {
      title: "Providing a checkbox on the first page of a multipart form that allows users to ask",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G133"
    },
    G134: {
      title: "Validating Web pages",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G134"
    },
    G135: {
      title: "Using the accessibility API features of a technology to expose names and notification",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G135"
    },
    G136: {
      title: "Providing a link at the beginning of a nonconforming Web page that points to a conforming",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G136"
    },
    G138: {
      title: "Using semantic markup whenever color cues are used",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G138"
    },
    G139: {
      title: "Creating a mechanism that allows users to jump to errors",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G139"
    },
    G140: {
      title: "Separating information and structure from presentation to enable different presentations",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G140"
    },
    G141: {
      title: "Organizing a page using headings",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G141"
    },
    G142: {
      title: "Using a technology that has commonly-available user agents that support zoom",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G142"
    },
    G143: {
      title: "Providing a text alternative that describes the purpose of the CAPTCHA",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G143"
    },
    G144: {
      title: "Ensuring that the Web Page contains another CAPTCHA serving the same purpose using",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G144"
    },
    G145: {
      title: "Ensuring that a contrast ratio of at least 3:1 exists between text (and images of",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G145"
    },
    G146: {
      title: "Using liquid layout",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G146"
    },
    G148: {
      title: "Not specifying background color, not specifying text color, and not using technology",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G148"
    },
    G149: {
      title: "Using user interface components that are highlighted by the user agent when they receive",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G149"
    },
    G150: {
      title: "Providing text based alternatives for live audio-only content",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G150"
    },
    G151: {
      title: "Providing a link to a text transcript of a prepared statement or script if the script",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G151"
    },
    G152: {
      title: "Setting animated gif images to stop blinking after n cycles (within 5 seconds)",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G152"
    },
    G153: {
      title: "Making the text easier to read",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G153"
    },
    G155: {
      title: "Providing a checkbox in addition to a submit button",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G155"
    },
    G156: {
      title: "Using a technology that has commonly-available user agents that can change the foreground",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G156"
    },
    G157: {
      title: "Incorporating a live audio captioning service into a Web page",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G157"
    },
    G158: {
      title: "Providing an alternative for time-based media for audio-only content",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G158"
    },
    G159: {
      title: "Providing an alternative for time-based media for video-only content",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G159"
    },
    G160: {
      title: "Providing sign language versions of information, ideas, and processes that must be",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G160"
    },
    G161: {
      title: "Providing a search function to help users find content",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G161"
    },
    G162: {
      title: "Positioning labels to maximize predictability of relationships",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G162"
    },
    G163: {
      title: "Using standard diacritical marks that can be turned off",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G163"
    },
    G164: {
      title: "Providing a stated time within which an online request (or transaction) may be amended",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G164"
    },
    G165: {
      title: "Using the default focus indicator for the platform so that high visibility default",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G165"
    },
    G166: {
      title: "Providing audio that describes the important video content and describing it as such",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G166"
    },
    G167: {
      title: "Using an adjacent button to label the purpose of a field",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G167"
    },
    G168: {
      title: "Requesting confirmation to continue with selected action",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G168"
    },
    G169: {
      title: "Aligning text on only one side",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G169"
    },
    G170: {
      title: "Providing a control near the beginning of the Web page that turns off sounds that",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G170"
    },
    G171: {
      title: "Playing sounds only on user request",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G171"
    },
    G172: {
      title: "Providing a mechanism to remove full justification of text",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G172"
    },
    G173: {
      title: "Providing a version of a movie with audio descriptions",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G173"
    },
    G174: {
      title: "Providing a control with a sufficient contrast ratio that allows users to switch to",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G174"
    },
    G175: {
      title: "Providing a multi color selection tool on the page for foreground and background colors",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G175"
    },
    G176: {
      title: "Keeping the flashing area small enough",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G176"
    },
    G177: {
      title: "Providing suggested correction text",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G177"
    },
    G178: {
      title: "Providing controls on the Web page that allow users to incrementally change the size",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G178"
    },
    G179: {
      title: "Ensuring that there is no loss of content or functionality when the text resizes and",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G179"
    },
    G180: {
      title: "Providing the user with a means to set the time limit to 10 times the default time",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G180"
    },
    G181: {
      title: "Encoding user data as hidden or encrypted data in a re-authorization page",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G181"
    },
    G182: {
      title: "Ensuring that additional visual cues are available when text color differences are",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G182"
    },
    G183: {
      title: "Using a contrast ratio of 3:1 with surrounding text and providing additional visual",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G183"
    },
    G184: {
      title: "Providing text instructions at the beginning of a form or set of fields that describes",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G184"
    },
    G185: {
      title: "Linking to all of the pages on the site from the home page",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G185"
    },
    G186: {
      title: "Using a control in the Web page that stops moving, blinking, or auto-updating content",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G186"
    },
    G187: {
      title: "Using a technology to include blinking content that can be turned off via the user",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G187"
    },
    G188: {
      title: "Providing a button on the page to increase line spaces and paragraph spaces",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G188"
    },
    G189: {
      title: "Providing a control near the beginning of the Web page that changes the link text",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G189"
    },
    G190: {
      title: "Providing a link adjacent to or associated with a non-conforming object that links",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G190"
    },
    G191: {
      title: "Providing a link, button, or other mechanism that reloads the page without any blinking",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G191"
    },
    G192: {
      title: "Fully conforming to specifications",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G192"
    },
    G193: {
      title: "Providing help by an assistant in the Web page",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G193"
    },
    G194: {
      title: "Providing spell checking and suggestions for text input",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G194"
    },
    G195: {
      title: "Using an author-supplied, visible focus indicator",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G195"
    },
    G196: {
      title: "Using a text alternative on one item within a group of images that describes all items",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G196"
    },
    G197: {
      title: "Using labels, names, and text alternatives consistently for content that has the same",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G197"
    },
    G198: {
      title: "Providing a way for the user to turn the time limit off",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G198"
    },
    G199: {
      title: "Providing success feedback when data is submitted successfully",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G199"
    },
    G200: {
      title: "Opening new windows and tabs from a link only when necessary",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G200"
    },
    G201: {
      title: "Giving users advanced warning when opening a new window",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G201"
    },
    G202: {
      title: "Ensuring keyboard control for all functionality",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G202"
    },
    G203: {
      title: "Using a static text alternative to describe a talking head video",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G203"
    },
    G204: {
      title: "Not interfering with the user agent's reflow of text as the viewing window is narrowed",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G204"
    },
    G205: {
      title: "Including a text cue for colored form control labels",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G205"
    },
    G206: {
      title: "Providing options within the content to switch to a layout that does not require the",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G206"
    },
    G207: {
      title: "Ensuring that a contrast ratio of 3:1 is provided for icons",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G207"
    },
    G208: {
      title: "Including the text of the visible label as part of the accessible name",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G208"
    },
    G209: {
      title: "Provide sufficient contrast at the boundaries between adjoining colors",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G209"
    },
    G210: {
      title: "Ensuring that drag-and-drop actions can be cancelled",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G210"
    },
    G211: {
      title: "Matching the accessible name to the visible label",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G211"
    },
    G212: {
      title: "Using native controls to ensure functionality is triggered on the up-event.",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G212"
    },
    G213: {
      title: "Provide conventional controls and an application setting for motion activated input",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G213"
    },
    G214: {
      title: "Using a control to allow access to content in different orientations which is otherwise",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G214"
    },
    G215: {
      title: "Providing controls to achieve the same result as path based or multipoint gestures",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G215"
    },
    G216: {
      title: "Providing single point activation for a control slider",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G216"
    },
    G217: {
      title: "Providing a mechanism to allow users to remap or turn off character key shortcuts",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G217"
    },
    G218: {
      title: "Email link authentication",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G218"
    },
    G219: {
      title: "Ensuring that an alternative is available for dragging movements that operate on content",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G219"
    },
    G220: {
      title: "Provide a contact-us link in a consistent location",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G220"
    },
    G221: {
      title: "Provide data from a previous step in a process",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G221"
    },
    G223: {
      title: "Using an author-supplied, highly visible focus indicator",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/general/G223"
    },
    H2: {
      title: "Combining adjacent image and text links for the same resource",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H2"
    },
    H24: {
      title: "Providing text alternatives for the area elements of image maps",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H24"
    },
    H25: {
      title: "Providing a title using the title element",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H25"
    },
    H28: {
      title: "Providing definitions for abbreviations by using the abbr element",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H28"
    },
    H30: {
      title: "Providing link text that describes the purpose of a link for anchor elements",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H30"
    },
    H32: {
      title: "Providing submit buttons",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H32"
    },
    H33: {
      title: "Supplementing link text with the title attribute",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H33"
    },
    H34: {
      title: "Using a Unicode right-to-left mark (RLM) or left-to-right mark (LRM) to mix text direction",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H34"
    },
    H36: {
      title: "Using alt attributes on images used as submit buttons",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H36"
    },
    H37: {
      title: "Using alt attributes on img elements",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H37"
    },
    H39: {
      title: "Using caption elements to associate data table captions with data tables",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H39"
    },
    H40: {
      title: "Using description lists",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H40"
    },
    H42: {
      title: "Using h1-h6 to identify headings",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H42"
    },
    H43: {
      title: "Using id and headers attributes to associate data cells with header cells in data",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H43"
    },
    H44: {
      title: "Using label elements to associate text labels with form controls",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H44"
    },
    H48: {
      title: "Using ol, ul and dl for lists or groups of links",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H48"
    },
    H49: {
      title: "Using semantic markup to mark emphasized or special text",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H49"
    },
    H51: {
      title: "Using table markup to present tabular information",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H51"
    },
    H53: {
      title: "Using the body of the object element",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H53"
    },
    H54: {
      title: "Using the dfn element to identify the defining instance of a word",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H54"
    },
    H56: {
      title: "Using the dir attribute on an inline element to resolve problems with nested directional",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H56"
    },
    H57: {
      title: "Using the language attribute on the HTML element",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H57"
    },
    H58: {
      title: "Using language attributes to identify changes in the human language",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H58"
    },
    H59: {
      title: "Using the link element and navigation tools",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H59"
    },
    H62: {
      title: "Using the ruby element",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H62"
    },
    H63: {
      title: "Using the scope attribute to associate header cells and data cells in data tables",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H63"
    },
    H64: {
      title: "Using the title attribute of the iframe element",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H64"
    },
    H65: {
      title: "Using the title attribute to identify form controls when the label element cannot",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H65"
    },
    H67: {
      title: "Using null alt text and no title attribute on img elements for images that assistive",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H67"
    },
    H69: {
      title: "Providing heading elements at the beginning of each section of content",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H69"
    },
    H70: {
      title: "Using frame elements to group blocks of repeated material",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H70"
    },
    H71: {
      title: "Providing a description for groups of form controls using fieldset and legend elements",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H71"
    },
    H74: {
      title: "Ensuring that opening and closing tags are used according to specification",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H74"
    },
    H75: {
      title: "Ensuring that Web pages are well-formed",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H75"
    },
    H76: {
      title: "Using meta refresh to create an instant client-side redirect",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H76"
    },
    H77: {
      title: "Identifying the purpose of a link using link text combined with its enclosing list",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H77"
    },
    H78: {
      title: "Identifying the purpose of a link using link text combined with its enclosing paragraph",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H78"
    },
    H79: {
      title: "Identifying the purpose of a link in a data table using the link text combined with",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H79"
    },
    H80: {
      title: "Identifying the purpose of a link using link text combined with the preceding heading",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H80"
    },
    H81: {
      title: "Identifying the purpose of a link in a nested list using link text combined with the",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H81"
    },
    H83: {
      title: "Using the target attribute to open a new window on user request and indicating this",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H83"
    },
    H84: {
      title: "Using a button with a select element to perform an action",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H84"
    },
    H85: {
      title: "Using optgroup to group option elements inside a select",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H85"
    },
    H86: {
      title: "Providing text alternatives for emojis, emoticons, ASCII art, and leetspeak",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H86"
    },
    H88: {
      title: "Using HTML according to spec",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H88"
    },
    H89: {
      title: "Using the title attribute to provide context-sensitive help",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H89"
    },
    H90: {
      title: "Indicating required form controls using label or legend",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H90"
    },
    H91: {
      title: "Using HTML form controls and links",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H91"
    },
    H93: {
      title: "Ensuring that id attributes are unique on a Web page",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H93"
    },
    H94: {
      title: "Ensuring that elements do not contain duplicate attributes",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H94"
    },
    H95: {
      title: "Using the track element to provide captions",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H95"
    },
    H96: {
      title: "Using the track element to provide audio descriptions",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H96"
    },
    H97: {
      title: "Grouping related links using the nav element",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H97"
    },
    H98: {
      title: "Using HTML 5.2 autocomplete attributes",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H98"
    },
    H99: {
      title: "Provide a page-selection mechanism",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H99"
    },
    H100: {
      title: "Providing properly marked up email and password inputs",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H100"
    },
    H101: {
      title: "Using semantic HTML elements to identify regions of a page",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/html/H101"
    },
    PDF1: {
      title: "Applying text alternatives to images with the Alt entry in PDF documents",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/pdf/PDF1"
    },
    PDF2: {
      title: "Creating bookmarks in PDF documents",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/pdf/PDF2"
    },
    PDF3: {
      title: "Ensuring correct tab and reading order in PDF documents",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/pdf/PDF3"
    },
    PDF4: {
      title: "Hiding decorative images with the Artifact tag in PDF documents",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/pdf/PDF4"
    },
    PDF5: {
      title: "Indicating required form controls in PDF forms",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/pdf/PDF5"
    },
    PDF6: {
      title: "Using table elements for table markup in PDF Documents",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/pdf/PDF6"
    },
    PDF7: {
      title: "Performing OCR on a scanned PDF document to provide actual text",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/pdf/PDF7"
    },
    PDF8: {
      title: "Providing definitions for abbreviations via an E entry for a structure element",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/pdf/PDF8"
    },
    PDF9: {
      title: "Providing headings by marking content with heading tags in PDF documents",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/pdf/PDF9"
    },
    PDF10: {
      title: "Providing labels for interactive form controls in PDF documents",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/pdf/PDF10"
    },
    PDF11: {
      title: "Providing links and link text using the Link annotation and the /Link structure element",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/pdf/PDF11"
    },
    PDF12: {
      title: "Providing name, role, value information for form fields in PDF documents",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/pdf/PDF12"
    },
    PDF13: {
      title: "Providing replacement text using the /Alt entry for links in PDF documents",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/pdf/PDF13"
    },
    PDF14: {
      title: "Providing running headers and footers in PDF documents",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/pdf/PDF14"
    },
    PDF15: {
      title: "Providing submit buttons with the submit-form action in PDF forms",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/pdf/PDF15"
    },
    PDF16: {
      title: "Setting the default language using the /Lang entry in the document catalog of a PDF",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/pdf/PDF16"
    },
    PDF17: {
      title: "Specifying consistent page numbering for PDF documents",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/pdf/PDF17"
    },
    PDF18: {
      title: "Specifying the document title using the Title entry in the document information dictionary",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/pdf/PDF18"
    },
    PDF19: {
      title: "Specifying the language for a passage or phrase with the Lang entry in PDF documents",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/pdf/PDF19"
    },
    PDF20: {
      title: "Using Adobe Acrobat Pro's Table Editor to repair mistagged tables",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/pdf/PDF20"
    },
    PDF21: {
      title: "Using List tags for lists in PDF documents",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/pdf/PDF21"
    },
    PDF22: {
      title: "Indicating when user input falls outside the required format or values in PDF forms",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/pdf/PDF22"
    },
    PDF23: {
      title: "Providing interactive form controls in PDF documents",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/pdf/PDF23"
    },
    SVR1: {
      title: "Implementing automatic redirects on the server side instead of on the	client side",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/server-side-script/SVR1"
    },
    SVR2: {
      title: "Using .htaccess to ensure that the only way to access non-conforming content is from",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/server-side-script/SVR2"
    },
    SVR3: {
      title: "Using HTTP referer to ensure that the only way to access non-conforming content is",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/server-side-script/SVR3"
    },
    SVR4: {
      title: "Allowing users to provide preferences for the display of conforming alternate versions",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/server-side-script/SVR4"
    },
    SVR5: {
      title: "Specifying the default language in the HTTP header",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/server-side-script/SVR5"
    },
    SM1: {
      title: "Adding extended audio description in SMIL 1.0",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/smil/SM1"
    },
    SM2: {
      title: "Adding extended audio description in SMIL 2.0",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/smil/SM2"
    },
    SM6: {
      title: "Providing audio description in SMIL 1.0",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/smil/SM6"
    },
    SM7: {
      title: "Providing audio description in SMIL 2.0",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/smil/SM7"
    },
    SM11: {
      title: "Providing captions through synchronized text streams in SMIL 1.0",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/smil/SM11"
    },
    SM12: {
      title: "Providing captions through synchronized text streams in SMIL 2.0",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/smil/SM12"
    },
    SM13: {
      title: "Providing sign language interpretation through synchronized video streams in SMIL",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/smil/SM13"
    },
    SM14: {
      title: "Providing sign language interpretation through synchronized video streams in SMIL",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/smil/SM14"
    },
    T1: {
      title: "Using standard text formatting conventions for paragraphs",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/text/T1"
    },
    T2: {
      title: "Using standard text formatting conventions for lists",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/text/T2"
    },
    T3: {
      title: "Using standard text formatting conventions for headings",
      uri: "https://www.w3.org/WAI/WCAG22/Techniques/text/T3"
    }
  };

  // node_modules/@siteimprove/alfa-wcag/dist/technique.js
  var Technique = class _Technique extends Requirement {
    static of(name) {
      return new _Technique(name, Techniques[name].uri);
    }
    _name;
    _title;
    constructor(name, uri) {
      super("technique", uri);
      this._name = name;
      this._title = Techniques[name].title;
    }
    /**
     * The name of this technique.
     */
    get name() {
      return this._name;
    }
    /**
     * The title of this technique.
     */
    get title() {
      return this._title;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        name: this._name,
        title: this._title
      };
    }
    toEARL() {
      return {
        ...super.toEARL(),
        "@context": {
          earl: "http://www.w3.org/ns/earl#",
          dct: "http://purl.org/dc/terms/"
        },
        "dct:title": this._title,
        "dct:isPartOf": "https://www.w3.org/WAI/WCAG21/Techniques/"
      };
    }
  };
  (function(Technique2) {
    function isName2(value) {
      return value in Techniques;
    }
    Technique2.isName = isName2;
    function isTechnique(value) {
      return value instanceof Technique2;
    }
    Technique2.isTechnique = isTechnique;
  })(Technique || (Technique = {}));

  // node_modules/@siteimprove/alfa-thunk/dist/thunk.js
  var Thunk;
  (function(Thunk2) {
    function of(value) {
      return () => value;
    }
    Thunk2.of = of;
    function map126(thunk, mapper) {
      return () => mapper(thunk());
    }
    Thunk2.map = map126;
    function flatMap5(thunk, mapper) {
      return () => mapper(thunk())();
    }
    Thunk2.flatMap = flatMap5;
    function reduce2(thunk, reducer, accumulator) {
      return reducer(accumulator, thunk());
    }
    Thunk2.reduce = reduce2;
  })(Thunk || (Thunk = {}));

  // node_modules/@siteimprove/alfa-rules/dist/common/act/expectation.js
  function expectation(test43, ifTrue, ifFalse, ifUnknown = Thunk.of(None)) {
    switch (test43) {
      case true:
        return ifTrue();
      case false:
        return ifFalse();
      default:
        return ifUnknown();
    }
  }

  // node_modules/@siteimprove/alfa-rules/dist/common/diagnostic/contrast.js
  var Contrast = class _Contrast extends Diagnostic {
    static of(message, threshold4 = 4.5, pairings = []) {
      return new _Contrast(message, threshold4, Array.from(pairings));
    }
    _threshold;
    _pairings;
    constructor(message, threshold4, pairings) {
      super(message);
      this._threshold = threshold4;
      this._pairings = pairings;
    }
    get threshold() {
      return this._threshold;
    }
    get pairings() {
      return this._pairings;
    }
    equals(value) {
      return super.equals(value) && value instanceof _Contrast && value._threshold === this._threshold && value._pairings.length === this._pairings.length && value._pairings.every((pairing, i) => pairing.equals(this._pairings[i]));
    }
    hash(hash2) {
      super.hash(hash2);
      hash2.writeNumber(this._threshold);
    }
    toJSON(options) {
      return {
        ...super.toJSON(options),
        threshold: this._threshold,
        pairings: this._pairings.map((pairing) => pairing.toJSON())
      };
    }
  };
  (function(Contrast3) {
    function isContrast(value) {
      return value instanceof Contrast3;
    }
    Contrast3.isContrast = isContrast;
    class Pairing {
      static of(color1, color2, contrast2) {
        return new Pairing(Color3.of(...color1), Color3.of(...color2), contrast2);
      }
      _color1;
      _color2;
      _contrast;
      constructor(color1, color2, contrast2) {
        this._color1 = color1;
        this._color2 = color2;
        this._contrast = contrast2;
      }
      hash(hash2) {
        hash2.writeHashable(this._color1).writeHashable(this._color2).writeNumber(this._contrast);
      }
      get color1() {
        return this._color1;
      }
      get color2() {
        return this._color2;
      }
      get contrast() {
        return this._contrast;
      }
      equals(value) {
        return value instanceof Pairing && value._color1.equals(this._color1) && value._color2.equals(this._color2) && value._contrast === this._contrast;
      }
      compare(value) {
        if (this._contrast < value.contrast) {
          return Comparison.Greater;
        }
        if (this._contrast > value.contrast) {
          return Comparison.Less;
        }
        return Comparison.Equal;
      }
      toJSON() {
        return {
          color1: this._color1.toJSON(),
          color2: this._color2.toJSON(),
          contrast: this._contrast
        };
      }
    }
    Contrast3.Pairing = Pairing;
    class Color3 {
      static of(name, value) {
        return new Color3(name, value);
      }
      _name;
      _value;
      constructor(name, value) {
        this._name = name;
        this._value = value;
      }
      hash(hash2) {
        hash2.writeString(this._name).writeHashable(this._value);
      }
      get name() {
        return this._name;
      }
      get value() {
        return this._value;
      }
      equals(value) {
        return value instanceof Color3 && value._name === this._name && value._value.equals(this._value);
      }
      toJSON() {
        return {
          name: this._name,
          value: this._value.toJSON()
        };
      }
    }
  })(Contrast || (Contrast = {}));

  // node_modules/@siteimprove/alfa-rules/dist/common/diagnostic/text-spacing.js
  var TextSpacing = class _TextSpacing extends Diagnostic {
    static of(message, property16, value, fontSize, ratio, threshold4, declaration, owner) {
      return property16 === void 0 ? Diagnostic.of(message) : new _TextSpacing(message, property16, value, fontSize, ratio, threshold4, declaration, owner);
    }
    _property;
    _value;
    _fontSize;
    _ratio;
    _threshold;
    // The bad declaration in the style attribute
    _declaration;
    // The element with the bad style attribute
    _owner;
    constructor(message, property16, value, fontSize, ratio, threshold4, declaration, owner) {
      super(message);
      this._property = property16;
      this._value = value;
      this._fontSize = fontSize;
      this._ratio = ratio;
      this._threshold = threshold4;
      this._declaration = declaration;
      this._owner = owner;
    }
    get property() {
      return this._property;
    }
    get value() {
      return this._value;
    }
    get fontSize() {
      return this._fontSize;
    }
    get ratio() {
      return this._ratio;
    }
    get threshold() {
      return this._threshold;
    }
    get declaration() {
      return this._declaration;
    }
    get owner() {
      return this._owner;
    }
    equals(value) {
      return value instanceof _TextSpacing && value._message === this._message && value._property === this._property && value._value.equals(this._value) && value._fontSize.equals(this._fontSize) && value._ratio === this._ratio && value._declaration.equals(this._declaration) && value._owner.equals(this._owner);
    }
    hash(hash2) {
      super.hash(hash2);
      this._owner.hash(hash2);
      hash2.writeString(this._property);
      hash2.writeNumber(this._ratio);
      hash2.writeNumber(this._threshold);
      hash2.writeNumber(this._value.value);
    }
    toJSON(options) {
      return {
        ...super.toJSON(options),
        property: this._property,
        value: this._value.toJSON(),
        "font-size": this._fontSize.toJSON(),
        ratio: this._ratio,
        threshold: this._threshold,
        declaration: this._declaration.toJSON(),
        owner: this._owner.toJSON(options)
      };
    }
  };
  (function(TextSpacing2) {
    function isTextSpacing(value) {
      return value instanceof TextSpacing2;
    }
    TextSpacing2.isTextSpacing = isTextSpacing;
  })(TextSpacing || (TextSpacing = {}));

  // node_modules/@siteimprove/alfa-rules/dist/common/diagnostic/with-bad-elements.js
  var WithBadElements = class _WithBadElements extends Diagnostic {
    static of(message, errors = []) {
      return new _WithBadElements(message, Array2.from(errors));
    }
    _errors;
    constructor(message, errors) {
      super(message);
      this._errors = errors;
    }
    get errors() {
      return this._errors;
    }
    equals(value) {
      return value instanceof _WithBadElements && value._message === this._message && Array2.equals(value._errors, this._errors);
    }
    hash(hash2) {
      super.hash(hash2);
      this._errors.forEach((element) => element.hash(hash2));
    }
    *[Symbol.iterator]() {
      yield* this._errors;
    }
    toJSON(options) {
      return {
        ...super.toJSON(options),
        errors: Array2.toJSON(this._errors, options)
      };
    }
  };
  (function(WithBadElements2) {
    function isWithBadElements(value) {
      return value instanceof WithBadElements2;
    }
    WithBadElements2.isWithBadElements = isWithBadElements;
  })(WithBadElements || (WithBadElements = {}));

  // node_modules/@siteimprove/alfa-rules/dist/common/diagnostic/with-role.js
  var WithRole = class _WithRole extends Diagnostic {
    static of(message, role) {
      return role === void 0 ? new Diagnostic(message) : new _WithRole(message, role);
    }
    _role;
    constructor(message, role) {
      super(message);
      this._role = role;
    }
    get role() {
      return this._role;
    }
    equals(value) {
      return value instanceof _WithRole && value._message === this._message && value._role === this._role;
    }
    hash(hash2) {
      super.hash(hash2);
      hash2.writeString(this._role);
    }
    toJSON(options) {
      return {
        ...super.toJSON(options),
        role: this._role
      };
    }
  };
  (function(WithRole2) {
    function isWithRole(value) {
      return value instanceof WithRole2;
    }
    WithRole2.isWithRole = isWithRole;
    function getRoleName(element, device) {
      return Node5.from(element, device).role.map((role) => role.name).getOr("generic");
    }
    WithRole2.getRoleName = getRoleName;
  })(WithRole || (WithRole = {}));

  // node_modules/@siteimprove/alfa-rules/dist/common/diagnostic/with-name.js
  var WithName2 = class _WithName extends Diagnostic {
    static of(message, name) {
      return name === void 0 ? new Diagnostic(message) : new _WithName(message, name);
    }
    _name;
    constructor(message, name) {
      super(message);
      this._name = name;
    }
    get name() {
      return this._name;
    }
    toJSON(options) {
      return {
        ...super.toJSON(options),
        name: this._name
      };
    }
  };
  (function(WithName3) {
    function isWithName(value) {
      return value instanceof WithName3;
    }
    WithName3.isWithName = isWithName;
    function getName(element, device) {
      return Node5.from(element, device).name.map((x) => x.value);
    }
    WithName3.getName = getName;
  })(WithName2 || (WithName2 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/common/diagnostic/with-other-heading.js
  var WithOtherHeading = class _WithOtherHeading extends Diagnostic {
    static of(message, otherHeading, currentLevel, otherLevel, otherPosition) {
      return otherHeading === void 0 || currentLevel === void 0 || otherLevel === void 0 || otherPosition === void 0 ? Diagnostic.of(message) : new _WithOtherHeading(message, otherHeading, currentLevel, otherLevel, otherPosition);
    }
    _otherHeading;
    _currentLevel;
    _otherLevel;
    _otherPosition;
    constructor(message, otherHeading, currentLevel, otherLevel, otherPosition) {
      super(message);
      this._otherHeading = otherHeading;
      this._currentLevel = currentLevel;
      this._otherLevel = otherLevel;
      this._otherPosition = otherPosition;
    }
    get otherHeading() {
      return this._otherHeading;
    }
    get currentHeadingLevel() {
      return this._currentLevel;
    }
    get otherHeadingLevel() {
      return this._otherLevel;
    }
    get otherPosition() {
      return this._otherPosition;
    }
    equals(value) {
      return value instanceof _WithOtherHeading && value._message === this._message && value._otherHeading.equals(this._otherHeading) && value._currentLevel === this._currentLevel && value._otherLevel === this._otherLevel && value._otherPosition === this._otherPosition;
    }
    hash(hash2) {
      super.hash(hash2);
      hash2.writeNumber(this._currentLevel);
      hash2.writeNumber(this._otherLevel);
      hash2.writeString(this._otherPosition);
      this._otherHeading.hash(hash2);
    }
    toJSON(options) {
      return {
        ...super.toJSON(options),
        otherHeading: this._otherHeading.toJSON(options),
        currentHeadingLevel: this._currentLevel,
        otherHeadingLevel: this._otherLevel,
        otherPosition: this._otherPosition
      };
    }
  };
  (function(WithOtherHeading2) {
    function isWithOtherHeading(value) {
      return value instanceof WithOtherHeading2;
    }
    WithOtherHeading2.isWithOtherHeading = isWithOtherHeading;
  })(WithOtherHeading || (WithOtherHeading = {}));

  // node_modules/@siteimprove/alfa-rules/dist/common/diagnostic/with-bounding-box.js
  var WithBoundingBox = class _WithBoundingBox extends WithName2 {
    static of(message, name, box, condition, tooCloseNeighbors) {
      if (name === void 0) {
        return new Diagnostic(message);
      }
      if (box === void 0 || condition === void 0 || tooCloseNeighbors === void 0) {
        return new WithName2(message, name);
      }
      return new _WithBoundingBox(message, name, box, condition, tooCloseNeighbors);
    }
    _box;
    _condition;
    _tooCloseNeighbors;
    constructor(message, name, box, condition, tooCloseNeighbors) {
      super(message, name);
      this._box = box;
      this._condition = condition.either((uaCond) => Either.left({ ua: uaCond.ua }), (sizeAndSpacingCond) => Either.right({
        size: sizeAndSpacingCond.size,
        spacing: sizeAndSpacingCond.spacing
      }));
      this._tooCloseNeighbors = Sequence.from(tooCloseNeighbors);
    }
    get box() {
      return this._box;
    }
    get condition() {
      return this._condition;
    }
    get tooCloseNeighbors() {
      return this._tooCloseNeighbors;
    }
    equals(value) {
      return value instanceof _WithBoundingBox && value._message === this._message && value._name === this._name && value._box.equals(this._box) && value._condition.equals(this._condition) && value._tooCloseNeighbors.equals(this._tooCloseNeighbors);
    }
    hash(hash2) {
      super.hash(hash2);
      this._box.hash(hash2);
      this._condition.hash(hash2);
      this._tooCloseNeighbors.hash(hash2);
    }
    toJSON(options) {
      return {
        ...super.toJSON(options),
        box: this._box.toJSON(),
        condition: this._condition.toJSON(),
        tooCloseNeighbors: this._tooCloseNeighbors.toJSON(options)
      };
    }
  };
  (function(WithBoundingBox2) {
    function isWithBoundingBox(value) {
      return value instanceof WithBoundingBox2;
    }
    WithBoundingBox2.isWithBoundingBox = isWithBoundingBox;
  })(WithBoundingBox || (WithBoundingBox = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-er8/rule.js
  var { hasNonEmptyAccessibleName: hasNonEmptyAccessibleName2, hasRole: hasRole3, isIncludedInTheAccessibilityTree: isIncludedInTheAccessibilityTree2 } = DOM;
  var { hasInputType: hasInputType4, hasNamespace: hasNamespace3 } = Element;
  var { and: and31, or: or25 } = Predicate;
  var { getElementDescendants: getElementDescendants4 } = Query3;
  var rule_default = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r8",
    requirements: [Criterion.of("4.1.2")],
    tags: [Scope.Component, Stability.Experimental, Version.of(2)],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return getElementDescendants4(document2, Node4.fullTree).filter(and31(hasNamespace3(Namespace.HTML), or25(hasRole3(device, "checkbox", "combobox", "listbox", "menuitemcheckbox", "menuitemradio", "radio", "searchbox", "slider", "spinbutton", "switch", "textbox"), hasInputType4("password", "color", "date", "datetime-local", "file", "month", "time", "week")), isIncludedInTheAccessibilityTree2(device)));
        },
        expectations(target) {
          const role = Node5.from(target, device).role;
          if (role.isSome()) {
            const roleName = role.get().name;
            return {
              1: expectation(hasNonEmptyAccessibleName2(device)(target), () => Outcomes.FormFieldWithAriaRoleHasName(roleName), () => Outcomes.FormFieldWithAriaRoleHasNoName(roleName))
            };
          } else {
            const inputType = target.attribute("type").map((attr) => attr.value).getUnsafe(`R8v2 found an element with no role nor 'type' attribute: ${target.path()}`);
            return {
              1: expectation(hasNonEmptyAccessibleName2(device)(target), () => Outcomes.InputElementWithNoAriaRoleHasName(inputType), () => Outcomes.InputElementWithNoAriaRoleHasNoName(inputType))
            };
          }
        }
      };
    }
  });
  var Outcomes;
  (function(Outcomes87) {
    Outcomes87.FormFieldWithAriaRoleHasName = (role) => Ok.of(WithRole.of(`The form field has an accessible name`, role));
    Outcomes87.FormFieldWithAriaRoleHasNoName = (role) => Err.of(WithRole.of(`The form field does not have an accessible name`, role));
    Outcomes87.InputElementWithNoAriaRoleHasName = (typeAttribValue) => Ok.of(Diagnostic.of(`The type="${typeAttribValue}" form field has an accessible name`));
    Outcomes87.InputElementWithNoAriaRoleHasNoName = (typeAttribValue) => Err.of(Diagnostic.of(`The type="${typeAttribValue}" form field does not have an accessible name`));
  })(Outcomes || (Outcomes = {}));

  // node_modules/@siteimprove/alfa-rules/dist/common/act/question.js
  var Question2;
  (function(Question3) {
    function of(uri, subject, contextOrMessage, messageOrOptions, options = {}) {
      let context = subject;
      let message;
      if (
        // We assume that no context will be a string.
        // Since contexts are guaranteed to be test targets, this is OK. They are
        // more likely to be text nodes that the actual text in it.
        typeof contextOrMessage === "string"
      ) {
        message = contextOrMessage ?? Data[uri].message;
        options = messageOrOptions;
      } else {
        context = contextOrMessage ?? subject;
        message = messageOrOptions ?? Data[uri].message;
      }
      return Question.of(Data[uri].type, uri, message, subject, context, options);
    }
    Question3.of = of;
    const Data = {
      // R15, R41, R81
      "reference-equivalent-resources": {
        type: "boolean",
        message: `Do the [links/iframe] [resolve to/reference] equivalent resources?`
      },
      // media rules (R27 [R22, R31], R30 [R23, R29], R35 [R26, R32, R33, R34],
      //              R37 [R25, R31, R36], R38 [R24, R25, R31, R36], R50 [R48, R49])
      "has-audio": {
        // Also used in R50 [R48, R49]
        type: "boolean",
        message: `Does the \`<video>\` element have audio?`
      },
      "has-audio-track": {
        type: "boolean",
        message: `Does the \`<video>\` element have an audio track that describes its visual information?`
      },
      "has-captions": {
        type: "boolean",
        message: `Does the \`<video>\` element have captions that describe the content of the video?`
      },
      "has-description": {
        type: "boolean",
        message: `Is the visual information of the [audio/video] available through its audio or a separate audio description track?`
      },
      "is-audio-streaming": {
        type: "boolean",
        message: `Is the \`<audio>\` element streaming?`
      },
      "is-playing": {
        type: "boolean",
        message: `Is the \`<audio>\` element currently playing?`
      },
      "is-video-streaming": {
        type: "boolean",
        message: `Is the \`<video>\` element streaming?`
      },
      label: {
        type: "node",
        message: `Where is the text that labels the [audio/video] element as a video alternative?`
      },
      "play-button": {
        type: "node",
        message: `Where is the button that controls playback of the \`<audio>\` element?`
      },
      "text-alternative": {
        type: "node",
        message: `Where is the text alternative of the [audio/video] element?`
      },
      "track-describes-video": {
        type: "boolean",
        message: `Does at least 1 track describe the visual information of the \`<video>\` element, either in the language of the \`<video>\` element or the language of the page?`
      },
      transcript: {
        type: "node",
        message: `Where is the transcript that describes the content of the [audio/video] element?`
      },
      "transcript-link": {
        type: "node",
        message: `Where is the link pointing to the transcript that describes the content of the [audio/video] element?`
      },
      // R39
      "name-describes-purpose": {
        type: "boolean",
        message: `Does the accessible name of the \`<(target.name]>\` element describe its purpose?`
      },
      // R50 [R48, R49]
      "audio-control-mechanism": {
        type: "node",
        message: `Where is the mechanism that can pause or stop the audio of the \`<[target.name]>\` element?`
      },
      "is-above-duration-threshold": {
        type: "boolean",
        message: `Does the \`<[element.name]>\` element have a duration of more than 3 seconds?`
      },
      "is-below-audio-duration-threshold": {
        type: "boolean",
        message: `Does the \`<[target.name]>\` element have a total audio duration of less than 3 seconds?`
      },
      // R55
      "is-content-equivalent": {
        type: "boolean",
        message: `Do these [role] landmarks have the same or equivalent content?`
      },
      // R65
      "has-focus-indicator": {
        type: "boolean",
        message: `Does the element have a visible focus indicator?`
      },
      // R66, R69
      "background-colors": {
        type: "color[]",
        message: "What are the background colors of the text node?"
      },
      "foreground-colors": {
        type: "color[]",
        message: "What are the foreground colors of the text node?"
      },
      "ignored-interposed-elements": {
        type: "node[]",
        message: "Which of these interposed descendants should be ignored?"
      },
      // R87
      "first-tabbable-is-internal-link": {
        type: "boolean",
        message: `Is the first tabbable element of the document an internal link?`
      },
      "first-tabbable-is-visible": {
        type: "boolean",
        message: `Is the first tabbable element of the document visible if it's focused?`
      },
      "first-tabbable-reference": {
        type: "node",
        message: `Where in the document does the first tabbable element point?`
      },
      "first-tabbable-reference-is-main": {
        type: "boolean",
        message: `Does the first tabbable element of the document point to the main content?`
      },
      // R82 (experimental)
      "error-indicators": {
        type: "node[]",
        message: `Where are (all) the error indicators, if any, for the form field?`
      },
      "error-indicator-describing-resolution": {
        type: "node",
        message: `Which of these error indicators describes, in text, the cause of the error or how to resolve it?`
      },
      "error-indicator-identifying-form-field": {
        type: "node",
        message: "Which of these error indicators identifies, in text, the form field it relates to?"
      },
      // ER87 (experimental)
      "internal-reference": {
        type: "node",
        message: `Where in the document does this element point?`
      },
      "is-start-of-main": {
        type: "boolean",
        message: `Is this element at the start of the main content of the document?`
      },
      "is-visible-when-focused": {
        type: "boolean",
        message: `Is this element visible when it's focused?`
      },
      // R109 (experimental)
      "document-language": {
        type: "string",
        message: "What is the main language of the document?"
      },
      // R114 (experimental)
      "is-title-descriptive": {
        type: "boolean",
        message: "Does this title describe the content of the document?"
      }
    };
  })(Question2 || (Question2 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/common/predicate/is-large-text.js
  var { isElement: isElement32 } = Element;
  function isLargeText(device) {
    return (text) => {
      const parent = text.parent(Node4.flatTree).filter(isElement32);
      if (!parent.isSome()) {
        return false;
      }
      const style = Style.from(parent.get(), device);
      const size = style.computed("font-size").value.withUnit("pt");
      if (size.value > 17.999) {
        return true;
      }
      const weight = style.computed("font-weight").value;
      return size.value > 13.999 && weight.value >= 700;
    };
  }

  // node_modules/@siteimprove/alfa-rules/dist/common/predicate/is-at-the-start.js
  var { isPerceivableForAll: isPerceivableForAll2 } = DOM;
  var { isContent: isContent2 } = Element;
  var { and: and32 } = Predicate;
  function isAtTheStart(node2, device = Device.standard()) {
    return (node1) => !Node4.getNodesBetween(node1, node2, {
      includeFirst: true,
      includeSecond: false
    }).some(and32(isPerceivableForAll2(device), isContent2(Node4.fullTree)));
  }

  // node_modules/@siteimprove/alfa-rules/dist/common/predicate/reference-same-resource.js
  function referenceSameResource(base3) {
    return (a, b) => {
      if (a.name === b.name) {
        switch (a.name) {
          case "a":
          case "area":
            return a.attribute("href").some((a2) => URL3.parse(a2.value, base3).some((a3) => b.attribute("href").some((b2) => URL3.parse(b2.value, base3).some((b3) => a3.equals(b3)))));
          case "iframe":
            return a.attribute("srcdoc").some((a2) => b.attribute("srcdoc").some((b2) => a2.value === b2.value)) || a.attribute("src").some((a2) => URL3.parse(a2.value, base3).some((a3) => b.attribute("src").some((b2) => URL3.parse(b2.value, base3).some((b3) => a3.equals(b3)))));
        }
      }
      return false;
    };
  }

  // node_modules/@siteimprove/alfa-rules/dist/common/applicability/with-document-element.js
  var { fold } = Predicate;
  var { and: and33 } = Refinement;
  var withDocumentElement = (document2, predicate = () => true) => fold(Node4.hasChild(and33(Element.isDocumentElement, predicate)), () => Option.of(document2), () => None, document2);

  // node_modules/@siteimprove/alfa-rules/dist/sia-er87/rule.js
  var { hasRole: hasRole4, isIgnored: isIgnored2 } = DOM;
  var { hasName: hasName20, isElement: isElement33 } = Element;
  var { and: and34 } = Refinement;
  var { isTabbable: isTabbable2, isVisible: isVisible3 } = Style;
  var { getElementDescendants: getElementDescendants5 } = Query3;
  var rule_default2 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r87",
    requirements: [Technique.of("G1")],
    tags: [Scope.Page, Stability.Experimental, Version.of(2)],
    evaluate({ device, document: document2, response }) {
      return {
        applicability() {
          return withDocumentElement(document2);
        },
        expectations(target) {
          const firstTabbable = target.tabOrder().find(isTabbable2(device));
          if (!firstTabbable.isSome()) {
            return { 1: Outcomes2.HasNoTabbable };
          }
          const element = firstTabbable.get();
          const isAtTheStartOfMain = (reference2) => {
            const destination = reference2.inclusiveAncestors(Node4.fullTree).find(isElement33);
            if (!destination.isSome()) {
              return Outcomes2.FirstTabbableIsNotLinkToContent;
            }
            const askIsMain = Question2.of("is-start-of-main", destination.get(), target);
            const isAtStart = document2.inclusiveDescendants(Node4.flatTree).filter(and34(isElement33, hasRole4(device, "main"))).some((main) => isAtTheStart(main, device)(reference2));
            return askIsMain.answerIf(isAtStart, true).map((isMain) => expectation(isMain, () => Outcomes2.FirstTabbableIsLinkToContent, () => Outcomes2.FirstTabbableIsNotLinkToContent));
          };
          const askReference = Question2.of("internal-reference", element, target);
          const url = hasName20("a", "area")(element) ? element.attribute("href").flatMap((attribute) => URL3.parse(attribute.value, response.url).ok()) : None;
          const reference = url.filter(isInternalURL(response.url)).flatMap((url2) => url2.fragment.flatMap((fragment) => getElementDescendants5(element.root()).find((element2) => element2.id.includes(fragment))));
          const isSkipLink = () => askReference.answerIf(reference.isSome(), reference).map((ref) => expectation(
            // Oracle may still answer None to the question.
            ref.isSome(),
            // We are in the ifTrue branch of the expectation, but TS
            // can't narrow the type.
            () => isAtTheStartOfMain(ref.getUnsafe()),
            () => Outcomes2.FirstTabbableIsNotInternalLink
          ));
          const askIsVisible = Question2.of("is-visible-when-focused", element, target);
          return {
            1: expectation(isIgnored2(device)(element), () => Outcomes2.FirstTabbableIsIgnored, () => expectation(hasRole4(device, (role) => role.is("link"))(element), () => (
              // No need to check if element is tabbable because this was
              // already checked at the very start of expectation.
              askIsVisible.answerIf(isVisible3(device, Context.focus(element))(element), true).map((isVisible25) => expectation(isVisible25, isSkipLink, () => Outcomes2.FirstTabbableIsNotVisible))
            ), () => Outcomes2.FirstTabbableIsNotLink))
          };
        }
      };
    }
  });
  var Outcomes2;
  (function(Outcomes87) {
    Outcomes87.HasNoTabbable = Err.of(Diagnostic.of(`The document has no tabbable descendants`));
    Outcomes87.FirstTabbableIsNotLink = Err.of(Diagnostic.of(`The first tabbable element in the document is not a semantic link`));
    Outcomes87.FirstTabbableIsNotInternalLink = Err.of(Diagnostic.of(`The first tabbable element in the document is not an internal link`));
    Outcomes87.FirstTabbableIsIgnored = Err.of(Diagnostic.of(`The first tabbable element in the document is not included in the
      accessibility tree`));
    Outcomes87.FirstTabbableIsNotVisible = Err.of(Diagnostic.of(`The first tabbable element in the document is not visible when on focus`));
    Outcomes87.FirstTabbableIsLinkToContent = Ok.of(Diagnostic.of(`The first tabbable element in the document is a keyboard actionable link
      that is included in the accessibility tree and links to the main block of
      content of the document`));
    Outcomes87.FirstTabbableIsNotLinkToContent = Err.of(Diagnostic.of(`The first tabbable element in the document is a keyboard actionable link
      that is included in the accessibility tree, but does not link to the main
      block of content of the document`));
  })(Outcomes2 || (Outcomes2 = {}));
  function isInternalURL(base3) {
    return (url) => url.fragment.isSome() && url.withoutFragment().equals(base3.withoutFragment());
  }

  // node_modules/@siteimprove/alfa-rules/dist/sia-r82/rule.js
  var { hasRole: hasRole5, isPerceivableForAll: isPerceivableForAll3 } = DOM;
  var { hasNamespace: hasNamespace4 } = Element;
  var { and: and35, test: test23 } = Predicate;
  var { getElementDescendants: getElementDescendants6 } = Query3;
  var rule_default3 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r82",
    requirements: [Criterion.of("3.3.1")],
    tags: [Scope.Component, Stability.Experimental],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return getElementDescendants6(document2, Node4.fullTree).filter(and35(hasNamespace4(Namespace.HTML), hasRole5(device, "checkbox", "combobox", "listbox", "menuitemcheckbox", "menuitemradio", "radio", "searchbox", "slider", "spinbutton", "switch", "textbox")));
        },
        expectations(target) {
          const indicators = Question2.of("error-indicators", target).map(Array2.from);
          return {
            1: indicators.map((indicators2) => expectation(indicators2.length === 0, () => Outcomes3.HasNoErrorIndicator, () => identifiesTarget(target, indicators2, device))),
            2: indicators.map((indicators2) => expectation(indicators2.length === 0, () => Outcomes3.HasNoErrorIndicator, () => describesResolution(target, indicators2, device)))
          };
        }
      };
    }
  });
  var Outcomes3;
  (function(Outcomes87) {
    Outcomes87.HasNoErrorIndicator = Ok.of(Diagnostic.of(`The form field has no error indicator`));
    Outcomes87.ErrorIndicatorIdentifiesTarget = Ok.of(Diagnostic.of(`At least one error indicator that is perceivable identifies the form field`));
    Outcomes87.ErrorIndicatorIdentifiesTargetButIsNotPerceivable = Err.of(Diagnostic.of(`At least one error indicator identifies the form field, but the error
    indicator is not perceivable`));
    Outcomes87.NoErrorIndicatorIdentifiesTarget = Err.of(Diagnostic.of(`None of the error indicators identify the form field`));
    Outcomes87.ErrorIndicatorDescribesResolution = Ok.of(Diagnostic.of(`At least one error indicator that is perceivable describes the cause of the
    error or how to resolve it`));
    Outcomes87.ErrorIndicatorDescribesResolutionButIsNotPerceivable = Err.of(Diagnostic.of(`At least one error indicator describes the cause of the error or how to
    resolve it, but the error indicator is not perceivable`));
    Outcomes87.NoErrorIndicatorDescribesResolution = Err.of(Diagnostic.of(`None of the error indicators describe the cause of the error or how to
    resolve it`));
  })(Outcomes3 || (Outcomes3 = {}));
  var identifiesTarget = (target, indicators, device) => Question2.of("error-indicator-identifying-form-field", indicators, target).map((indicator) => expectation(indicator.isNone(), () => Outcomes3.NoErrorIndicatorIdentifiesTarget, () => expectation(
    // indicator is not None due to the first expectation
    test23(isPerceivableForAll3(device), indicator.getUnsafe()),
    () => Outcomes3.ErrorIndicatorIdentifiesTarget,
    () => Outcomes3.ErrorIndicatorIdentifiesTargetButIsNotPerceivable
  )));
  var describesResolution = (target, indicators, device) => Question2.of("error-indicator-describing-resolution", indicators, target).map((indicator) => expectation(indicator.isNone(), () => Outcomes3.NoErrorIndicatorDescribesResolution, () => expectation(
    // indicator is not None due to the first expectation
    test23(isPerceivableForAll3(device), indicator.getUnsafe()),
    () => Outcomes3.ErrorIndicatorDescribesResolution,
    () => Outcomes3.ErrorIndicatorDescribesResolutionButIsNotPerceivable
  )));

  // node_modules/@siteimprove/alfa-iana/dist/language/data.js
  var Languages = {
    primary: {
      aa: { scope: null },
      ab: { scope: null },
      ae: { scope: null },
      af: { scope: null },
      ak: { scope: "macrolanguage" },
      am: { scope: null },
      an: { scope: null },
      ar: { scope: "macrolanguage" },
      as: { scope: null },
      av: { scope: null },
      ay: { scope: "macrolanguage" },
      az: { scope: "macrolanguage" },
      ba: { scope: null },
      be: { scope: null },
      bg: { scope: null },
      bh: { scope: "collection" },
      bi: { scope: null },
      bm: { scope: null },
      bn: { scope: null },
      bo: { scope: null },
      br: { scope: null },
      bs: { scope: null },
      ca: { scope: null },
      ce: { scope: null },
      ch: { scope: null },
      co: { scope: null },
      cr: { scope: "macrolanguage" },
      cs: { scope: null },
      cu: { scope: null },
      cv: { scope: null },
      cy: { scope: null },
      da: { scope: null },
      de: { scope: null },
      dv: { scope: null },
      dz: { scope: null },
      ee: { scope: null },
      el: { scope: null },
      en: { scope: null },
      eo: { scope: null },
      es: { scope: null },
      et: { scope: "macrolanguage" },
      eu: { scope: null },
      fa: { scope: "macrolanguage" },
      ff: { scope: "macrolanguage" },
      fi: { scope: null },
      fj: { scope: null },
      fo: { scope: null },
      fr: { scope: null },
      fy: { scope: null },
      ga: { scope: null },
      gd: { scope: null },
      gl: { scope: null },
      gn: { scope: "macrolanguage" },
      gu: { scope: null },
      gv: { scope: null },
      ha: { scope: null },
      he: { scope: null },
      hi: { scope: null },
      ho: { scope: null },
      hr: { scope: null },
      ht: { scope: null },
      hu: { scope: null },
      hy: { scope: null },
      hz: { scope: null },
      ia: { scope: null },
      id: { scope: null },
      ie: { scope: null },
      ig: { scope: null },
      ii: { scope: null },
      ik: { scope: "macrolanguage" },
      in: { scope: null },
      io: { scope: null },
      is: { scope: null },
      it: { scope: null },
      iu: { scope: "macrolanguage" },
      iw: { scope: null },
      ja: { scope: null },
      ji: { scope: null },
      jv: { scope: null },
      jw: { scope: null },
      ka: { scope: null },
      kg: { scope: "macrolanguage" },
      ki: { scope: null },
      kj: { scope: null },
      kk: { scope: null },
      kl: { scope: null },
      km: { scope: null },
      kn: { scope: null },
      ko: { scope: null },
      kr: { scope: "macrolanguage" },
      ks: { scope: null },
      ku: { scope: "macrolanguage" },
      kv: { scope: "macrolanguage" },
      kw: { scope: null },
      ky: { scope: null },
      la: { scope: null },
      lb: { scope: null },
      lg: { scope: null },
      li: { scope: null },
      ln: { scope: null },
      lo: { scope: null },
      lt: { scope: null },
      lu: { scope: null },
      lv: { scope: "macrolanguage" },
      mg: { scope: "macrolanguage" },
      mh: { scope: null },
      mi: { scope: null },
      mk: { scope: null },
      ml: { scope: null },
      mn: { scope: "macrolanguage" },
      mo: { scope: null },
      mr: { scope: null },
      ms: { scope: "macrolanguage" },
      mt: { scope: null },
      my: { scope: null },
      na: { scope: null },
      nb: { scope: null },
      nd: { scope: null },
      ne: { scope: "macrolanguage" },
      ng: { scope: null },
      nl: { scope: null },
      nn: { scope: null },
      no: { scope: "macrolanguage" },
      nr: { scope: null },
      nv: { scope: null },
      ny: { scope: null },
      oc: { scope: null },
      oj: { scope: "macrolanguage" },
      om: { scope: "macrolanguage" },
      or: { scope: "macrolanguage" },
      os: { scope: null },
      pa: { scope: null },
      pi: { scope: null },
      pl: { scope: null },
      ps: { scope: "macrolanguage" },
      pt: { scope: null },
      qu: { scope: "macrolanguage" },
      rm: { scope: null },
      rn: { scope: null },
      ro: { scope: null },
      ru: { scope: null },
      rw: { scope: null },
      sa: { scope: null },
      sc: { scope: "macrolanguage" },
      sd: { scope: null },
      se: { scope: null },
      sg: { scope: null },
      sh: { scope: "macrolanguage" },
      si: { scope: null },
      sk: { scope: null },
      sl: { scope: null },
      sm: { scope: null },
      sn: { scope: null },
      so: { scope: null },
      sq: { scope: "macrolanguage" },
      sr: { scope: null },
      ss: { scope: null },
      st: { scope: null },
      su: { scope: null },
      sv: { scope: null },
      sw: { scope: "macrolanguage" },
      ta: { scope: null },
      te: { scope: null },
      tg: { scope: null },
      th: { scope: null },
      ti: { scope: null },
      tk: { scope: null },
      tl: { scope: null },
      tn: { scope: null },
      to: { scope: null },
      tr: { scope: null },
      ts: { scope: null },
      tt: { scope: null },
      tw: { scope: null },
      ty: { scope: null },
      ug: { scope: null },
      uk: { scope: null },
      ur: { scope: null },
      uz: { scope: "macrolanguage" },
      ve: { scope: null },
      vi: { scope: null },
      vo: { scope: null },
      wa: { scope: null },
      wo: { scope: null },
      xh: { scope: null },
      yi: { scope: "macrolanguage" },
      yo: { scope: null },
      za: { scope: "macrolanguage" },
      zh: { scope: "macrolanguage" },
      zu: { scope: null },
      aaa: { scope: null },
      aab: { scope: null },
      aac: { scope: null },
      aad: { scope: null },
      aae: { scope: null },
      aaf: { scope: null },
      aag: { scope: null },
      aah: { scope: null },
      aai: { scope: null },
      aak: { scope: null },
      aal: { scope: null },
      aam: { scope: null },
      aan: { scope: null },
      aao: { scope: null },
      aap: { scope: null },
      aaq: { scope: null },
      aas: { scope: null },
      aat: { scope: null },
      aau: { scope: null },
      aav: { scope: "collection" },
      aaw: { scope: null },
      aax: { scope: null },
      aaz: { scope: null },
      aba: { scope: null },
      abb: { scope: null },
      abc: { scope: null },
      abd: { scope: null },
      abe: { scope: null },
      abf: { scope: null },
      abg: { scope: null },
      abh: { scope: null },
      abi: { scope: null },
      abj: { scope: null },
      abl: { scope: null },
      abm: { scope: null },
      abn: { scope: null },
      abo: { scope: null },
      abp: { scope: null },
      abq: { scope: null },
      abr: { scope: null },
      abs: { scope: null },
      abt: { scope: null },
      abu: { scope: null },
      abv: { scope: null },
      abw: { scope: null },
      abx: { scope: null },
      aby: { scope: null },
      abz: { scope: null },
      aca: { scope: null },
      acb: { scope: null },
      acd: { scope: null },
      ace: { scope: null },
      acf: { scope: null },
      ach: { scope: null },
      aci: { scope: null },
      ack: { scope: null },
      acl: { scope: null },
      acm: { scope: null },
      acn: { scope: null },
      acp: { scope: null },
      acq: { scope: null },
      acr: { scope: null },
      acs: { scope: null },
      act: { scope: null },
      acu: { scope: null },
      acv: { scope: null },
      acw: { scope: null },
      acx: { scope: null },
      acy: { scope: null },
      acz: { scope: null },
      ada: { scope: null },
      adb: { scope: null },
      add: { scope: null },
      ade: { scope: null },
      adf: { scope: null },
      adg: { scope: null },
      adh: { scope: null },
      adi: { scope: null },
      adj: { scope: null },
      adl: { scope: null },
      adn: { scope: null },
      ado: { scope: null },
      adp: { scope: null },
      adq: { scope: null },
      adr: { scope: null },
      ads: { scope: null },
      adt: { scope: null },
      adu: { scope: null },
      adw: { scope: null },
      adx: { scope: null },
      ady: { scope: null },
      adz: { scope: null },
      aea: { scope: null },
      aeb: { scope: null },
      aec: { scope: null },
      aed: { scope: null },
      aee: { scope: null },
      aek: { scope: null },
      ael: { scope: null },
      aem: { scope: null },
      aen: { scope: null },
      aeq: { scope: null },
      aer: { scope: null },
      aes: { scope: null },
      aeu: { scope: null },
      aew: { scope: null },
      aey: { scope: null },
      aez: { scope: null },
      afa: { scope: "collection" },
      afb: { scope: null },
      afd: { scope: null },
      afe: { scope: null },
      afg: { scope: null },
      afh: { scope: null },
      afi: { scope: null },
      afk: { scope: null },
      afn: { scope: null },
      afo: { scope: null },
      afp: { scope: null },
      afs: { scope: null },
      aft: { scope: null },
      afu: { scope: null },
      afz: { scope: null },
      aga: { scope: null },
      agb: { scope: null },
      agc: { scope: null },
      agd: { scope: null },
      age: { scope: null },
      agf: { scope: null },
      agg: { scope: null },
      agh: { scope: null },
      agi: { scope: null },
      agj: { scope: null },
      agk: { scope: null },
      agl: { scope: null },
      agm: { scope: null },
      agn: { scope: null },
      ago: { scope: null },
      agp: { scope: null },
      agq: { scope: null },
      agr: { scope: null },
      ags: { scope: null },
      agt: { scope: null },
      agu: { scope: null },
      agv: { scope: null },
      agw: { scope: null },
      agx: { scope: null },
      agy: { scope: null },
      agz: { scope: null },
      aha: { scope: null },
      ahb: { scope: null },
      ahg: { scope: null },
      ahh: { scope: null },
      ahi: { scope: null },
      ahk: { scope: null },
      ahl: { scope: null },
      ahm: { scope: null },
      ahn: { scope: null },
      aho: { scope: null },
      ahp: { scope: null },
      ahr: { scope: null },
      ahs: { scope: null },
      aht: { scope: null },
      aia: { scope: null },
      aib: { scope: null },
      aic: { scope: null },
      aid: { scope: null },
      aie: { scope: null },
      aif: { scope: null },
      aig: { scope: null },
      aih: { scope: null },
      aii: { scope: null },
      aij: { scope: null },
      aik: { scope: null },
      ail: { scope: null },
      aim: { scope: null },
      ain: { scope: null },
      aio: { scope: null },
      aip: { scope: null },
      aiq: { scope: null },
      air: { scope: null },
      ais: { scope: null },
      ait: { scope: null },
      aiw: { scope: null },
      aix: { scope: null },
      aiy: { scope: null },
      aja: { scope: null },
      ajg: { scope: null },
      aji: { scope: null },
      ajn: { scope: null },
      ajp: { scope: null },
      ajt: { scope: null },
      aju: { scope: null },
      ajw: { scope: null },
      ajz: { scope: null },
      akb: { scope: null },
      akc: { scope: null },
      akd: { scope: null },
      ake: { scope: null },
      akf: { scope: null },
      akg: { scope: null },
      akh: { scope: null },
      aki: { scope: null },
      akj: { scope: null },
      akk: { scope: null },
      akl: { scope: null },
      akm: { scope: null },
      ako: { scope: null },
      akp: { scope: null },
      akq: { scope: null },
      akr: { scope: null },
      aks: { scope: null },
      akt: { scope: null },
      aku: { scope: null },
      akv: { scope: null },
      akw: { scope: null },
      akx: { scope: null },
      aky: { scope: null },
      akz: { scope: null },
      ala: { scope: null },
      alc: { scope: null },
      ald: { scope: null },
      ale: { scope: null },
      alf: { scope: null },
      alg: { scope: "collection" },
      alh: { scope: null },
      ali: { scope: null },
      alj: { scope: null },
      alk: { scope: null },
      all: { scope: null },
      alm: { scope: null },
      aln: { scope: null },
      alo: { scope: null },
      alp: { scope: null },
      alq: { scope: null },
      alr: { scope: null },
      als: { scope: null },
      alt: { scope: null },
      alu: { scope: null },
      alv: { scope: "collection" },
      alw: { scope: null },
      alx: { scope: null },
      aly: { scope: null },
      alz: { scope: null },
      ama: { scope: null },
      amb: { scope: null },
      amc: { scope: null },
      ame: { scope: null },
      amf: { scope: null },
      amg: { scope: null },
      ami: { scope: null },
      amj: { scope: null },
      amk: { scope: null },
      aml: { scope: null },
      amm: { scope: null },
      amn: { scope: null },
      amo: { scope: null },
      amp: { scope: null },
      amq: { scope: null },
      amr: { scope: null },
      ams: { scope: null },
      amt: { scope: null },
      amu: { scope: null },
      amv: { scope: null },
      amw: { scope: null },
      amx: { scope: null },
      amy: { scope: null },
      amz: { scope: null },
      ana: { scope: null },
      anb: { scope: null },
      anc: { scope: null },
      and: { scope: null },
      ane: { scope: null },
      anf: { scope: null },
      ang: { scope: null },
      anh: { scope: null },
      ani: { scope: null },
      anj: { scope: null },
      ank: { scope: null },
      anl: { scope: null },
      anm: { scope: null },
      ann: { scope: null },
      ano: { scope: null },
      anp: { scope: null },
      anq: { scope: null },
      anr: { scope: null },
      ans: { scope: null },
      ant: { scope: null },
      anu: { scope: null },
      anv: { scope: null },
      anw: { scope: null },
      anx: { scope: null },
      any: { scope: null },
      anz: { scope: null },
      aoa: { scope: null },
      aob: { scope: null },
      aoc: { scope: null },
      aod: { scope: null },
      aoe: { scope: null },
      aof: { scope: null },
      aog: { scope: null },
      aoh: { scope: null },
      aoi: { scope: null },
      aoj: { scope: null },
      aok: { scope: null },
      aol: { scope: null },
      aom: { scope: null },
      aon: { scope: null },
      aor: { scope: null },
      aos: { scope: null },
      aot: { scope: null },
      aou: { scope: null },
      aox: { scope: null },
      aoz: { scope: null },
      apa: { scope: "collection" },
      apb: { scope: null },
      apc: { scope: null },
      apd: { scope: null },
      ape: { scope: null },
      apf: { scope: null },
      apg: { scope: null },
      aph: { scope: null },
      api: { scope: null },
      apj: { scope: null },
      apk: { scope: null },
      apl: { scope: null },
      apm: { scope: null },
      apn: { scope: null },
      apo: { scope: null },
      app: { scope: null },
      apq: { scope: null },
      apr: { scope: null },
      aps: { scope: null },
      apt: { scope: null },
      apu: { scope: null },
      apv: { scope: null },
      apw: { scope: null },
      apx: { scope: null },
      apy: { scope: null },
      apz: { scope: null },
      aqa: { scope: "collection" },
      aqc: { scope: null },
      aqd: { scope: null },
      aqg: { scope: null },
      aqk: { scope: null },
      aql: { scope: "collection" },
      aqm: { scope: null },
      aqn: { scope: null },
      aqp: { scope: null },
      aqr: { scope: null },
      aqt: { scope: null },
      aqz: { scope: null },
      arb: { scope: null },
      arc: { scope: null },
      ard: { scope: null },
      are: { scope: null },
      arh: { scope: null },
      ari: { scope: null },
      arj: { scope: null },
      ark: { scope: null },
      arl: { scope: null },
      arn: { scope: null },
      aro: { scope: null },
      arp: { scope: null },
      arq: { scope: null },
      arr: { scope: null },
      ars: { scope: null },
      art: { scope: "collection" },
      aru: { scope: null },
      arv: { scope: null },
      arw: { scope: null },
      arx: { scope: null },
      ary: { scope: null },
      arz: { scope: null },
      asa: { scope: null },
      asb: { scope: null },
      asc: { scope: null },
      asd: { scope: null },
      ase: { scope: null },
      asf: { scope: null },
      asg: { scope: null },
      ash: { scope: null },
      asi: { scope: null },
      asj: { scope: null },
      ask: { scope: null },
      asl: { scope: null },
      asn: { scope: null },
      aso: { scope: null },
      asp: { scope: null },
      asq: { scope: null },
      asr: { scope: null },
      ass: { scope: null },
      ast: { scope: null },
      asu: { scope: null },
      asv: { scope: null },
      asw: { scope: null },
      asx: { scope: null },
      asy: { scope: null },
      asz: { scope: null },
      ata: { scope: null },
      atb: { scope: null },
      atc: { scope: null },
      atd: { scope: null },
      ate: { scope: null },
      atg: { scope: null },
      ath: { scope: "collection" },
      ati: { scope: null },
      atj: { scope: null },
      atk: { scope: null },
      atl: { scope: null },
      atm: { scope: null },
      atn: { scope: null },
      ato: { scope: null },
      atp: { scope: null },
      atq: { scope: null },
      atr: { scope: null },
      ats: { scope: null },
      att: { scope: null },
      atu: { scope: null },
      atv: { scope: null },
      atw: { scope: null },
      atx: { scope: null },
      aty: { scope: null },
      atz: { scope: null },
      aua: { scope: null },
      aub: { scope: null },
      auc: { scope: null },
      aud: { scope: null },
      aue: { scope: null },
      auf: { scope: "collection" },
      aug: { scope: null },
      auh: { scope: null },
      aui: { scope: null },
      auj: { scope: null },
      auk: { scope: null },
      aul: { scope: null },
      aum: { scope: null },
      aun: { scope: null },
      auo: { scope: null },
      aup: { scope: null },
      auq: { scope: null },
      aur: { scope: null },
      aus: { scope: "collection" },
      aut: { scope: null },
      auu: { scope: null },
      auw: { scope: null },
      aux: { scope: null },
      auy: { scope: null },
      auz: { scope: null },
      avb: { scope: null },
      avd: { scope: null },
      avi: { scope: null },
      avk: { scope: null },
      avl: { scope: null },
      avm: { scope: null },
      avn: { scope: null },
      avo: { scope: null },
      avs: { scope: null },
      avt: { scope: null },
      avu: { scope: null },
      avv: { scope: null },
      awa: { scope: null },
      awb: { scope: null },
      awc: { scope: null },
      awd: { scope: "collection" },
      awe: { scope: null },
      awg: { scope: null },
      awh: { scope: null },
      awi: { scope: null },
      awk: { scope: null },
      awm: { scope: null },
      awn: { scope: null },
      awo: { scope: null },
      awr: { scope: null },
      aws: { scope: null },
      awt: { scope: null },
      awu: { scope: null },
      awv: { scope: null },
      aww: { scope: null },
      awx: { scope: null },
      awy: { scope: null },
      axb: { scope: null },
      axe: { scope: null },
      axg: { scope: null },
      axk: { scope: null },
      axl: { scope: null },
      axm: { scope: null },
      axx: { scope: null },
      aya: { scope: null },
      ayb: { scope: null },
      ayc: { scope: null },
      ayd: { scope: null },
      aye: { scope: null },
      ayg: { scope: null },
      ayh: { scope: null },
      ayi: { scope: null },
      ayk: { scope: null },
      ayl: { scope: null },
      ayn: { scope: null },
      ayo: { scope: null },
      ayp: { scope: null },
      ayq: { scope: null },
      ayr: { scope: null },
      ays: { scope: null },
      ayt: { scope: null },
      ayu: { scope: null },
      ayx: { scope: null },
      ayy: { scope: null },
      ayz: { scope: null },
      aza: { scope: null },
      azb: { scope: null },
      azc: { scope: "collection" },
      azd: { scope: null },
      azg: { scope: null },
      azj: { scope: null },
      azm: { scope: null },
      azn: { scope: null },
      azo: { scope: null },
      azt: { scope: null },
      azz: { scope: null },
      baa: { scope: null },
      bab: { scope: null },
      bac: { scope: null },
      bad: { scope: "collection" },
      bae: { scope: null },
      baf: { scope: null },
      bag: { scope: null },
      bah: { scope: null },
      bai: { scope: "collection" },
      baj: { scope: null },
      bal: { scope: "macrolanguage" },
      ban: { scope: null },
      bao: { scope: null },
      bap: { scope: null },
      bar: { scope: null },
      bas: { scope: null },
      bat: { scope: "collection" },
      bau: { scope: null },
      bav: { scope: null },
      baw: { scope: null },
      bax: { scope: null },
      bay: { scope: null },
      baz: { scope: null },
      bba: { scope: null },
      bbb: { scope: null },
      bbc: { scope: null },
      bbd: { scope: null },
      bbe: { scope: null },
      bbf: { scope: null },
      bbg: { scope: null },
      bbh: { scope: null },
      bbi: { scope: null },
      bbj: { scope: null },
      bbk: { scope: null },
      bbl: { scope: null },
      bbm: { scope: null },
      bbn: { scope: null },
      bbo: { scope: null },
      bbp: { scope: null },
      bbq: { scope: null },
      bbr: { scope: null },
      bbs: { scope: null },
      bbt: { scope: null },
      bbu: { scope: null },
      bbv: { scope: null },
      bbw: { scope: null },
      bbx: { scope: null },
      bby: { scope: null },
      bbz: { scope: null },
      bca: { scope: null },
      bcb: { scope: null },
      bcc: { scope: null },
      bcd: { scope: null },
      bce: { scope: null },
      bcf: { scope: null },
      bcg: { scope: null },
      bch: { scope: null },
      bci: { scope: null },
      bcj: { scope: null },
      bck: { scope: null },
      bcl: { scope: null },
      bcm: { scope: null },
      bcn: { scope: null },
      bco: { scope: null },
      bcp: { scope: null },
      bcq: { scope: null },
      bcr: { scope: null },
      bcs: { scope: null },
      bct: { scope: null },
      bcu: { scope: null },
      bcv: { scope: null },
      bcw: { scope: null },
      bcy: { scope: null },
      bcz: { scope: null },
      bda: { scope: null },
      bdb: { scope: null },
      bdc: { scope: null },
      bdd: { scope: null },
      bde: { scope: null },
      bdf: { scope: null },
      bdg: { scope: null },
      bdh: { scope: null },
      bdi: { scope: null },
      bdj: { scope: null },
      bdk: { scope: null },
      bdl: { scope: null },
      bdm: { scope: null },
      bdn: { scope: null },
      bdo: { scope: null },
      bdp: { scope: null },
      bdq: { scope: null },
      bdr: { scope: null },
      bds: { scope: null },
      bdt: { scope: null },
      bdu: { scope: null },
      bdv: { scope: null },
      bdw: { scope: null },
      bdx: { scope: null },
      bdy: { scope: null },
      bdz: { scope: null },
      bea: { scope: null },
      beb: { scope: null },
      bec: { scope: null },
      bed: { scope: null },
      bee: { scope: null },
      bef: { scope: null },
      beg: { scope: null },
      beh: { scope: null },
      bei: { scope: null },
      bej: { scope: null },
      bek: { scope: null },
      bem: { scope: null },
      beo: { scope: null },
      bep: { scope: null },
      beq: { scope: null },
      ber: { scope: "collection" },
      bes: { scope: null },
      bet: { scope: null },
      beu: { scope: null },
      bev: { scope: null },
      bew: { scope: null },
      bex: { scope: null },
      bey: { scope: null },
      bez: { scope: null },
      bfa: { scope: null },
      bfb: { scope: null },
      bfc: { scope: null },
      bfd: { scope: null },
      bfe: { scope: null },
      bff: { scope: null },
      bfg: { scope: null },
      bfh: { scope: null },
      bfi: { scope: null },
      bfj: { scope: null },
      bfk: { scope: null },
      bfl: { scope: null },
      bfm: { scope: null },
      bfn: { scope: null },
      bfo: { scope: null },
      bfp: { scope: null },
      bfq: { scope: null },
      bfr: { scope: null },
      bfs: { scope: null },
      bft: { scope: null },
      bfu: { scope: null },
      bfw: { scope: null },
      bfx: { scope: null },
      bfy: { scope: null },
      bfz: { scope: null },
      bga: { scope: null },
      bgb: { scope: null },
      bgc: { scope: null },
      bgd: { scope: null },
      bge: { scope: null },
      bgf: { scope: null },
      bgg: { scope: null },
      bgi: { scope: null },
      bgj: { scope: null },
      bgk: { scope: null },
      bgl: { scope: null },
      bgm: { scope: null },
      bgn: { scope: null },
      bgo: { scope: null },
      bgp: { scope: null },
      bgq: { scope: null },
      bgr: { scope: null },
      bgs: { scope: null },
      bgt: { scope: null },
      bgu: { scope: null },
      bgv: { scope: null },
      bgw: { scope: null },
      bgx: { scope: null },
      bgy: { scope: null },
      bgz: { scope: null },
      bha: { scope: null },
      bhb: { scope: null },
      bhc: { scope: null },
      bhd: { scope: null },
      bhe: { scope: null },
      bhf: { scope: null },
      bhg: { scope: null },
      bhh: { scope: null },
      bhi: { scope: null },
      bhj: { scope: null },
      bhk: { scope: null },
      bhl: { scope: null },
      bhm: { scope: null },
      bhn: { scope: null },
      bho: { scope: null },
      bhp: { scope: null },
      bhq: { scope: null },
      bhr: { scope: null },
      bhs: { scope: null },
      bht: { scope: null },
      bhu: { scope: null },
      bhv: { scope: null },
      bhw: { scope: null },
      bhx: { scope: null },
      bhy: { scope: null },
      bhz: { scope: null },
      bia: { scope: null },
      bib: { scope: null },
      bic: { scope: null },
      bid: { scope: null },
      bie: { scope: null },
      bif: { scope: null },
      big: { scope: null },
      bij: { scope: null },
      bik: { scope: "macrolanguage" },
      bil: { scope: null },
      bim: { scope: null },
      bin: { scope: null },
      bio: { scope: null },
      bip: { scope: null },
      biq: { scope: null },
      bir: { scope: null },
      bit: { scope: null },
      biu: { scope: null },
      biv: { scope: null },
      biw: { scope: null },
      bix: { scope: null },
      biy: { scope: null },
      biz: { scope: null },
      bja: { scope: null },
      bjb: { scope: null },
      bjc: { scope: null },
      bjd: { scope: null },
      bje: { scope: null },
      bjf: { scope: null },
      bjg: { scope: null },
      bjh: { scope: null },
      bji: { scope: null },
      bjj: { scope: null },
      bjk: { scope: null },
      bjl: { scope: null },
      bjm: { scope: null },
      bjn: { scope: null },
      bjo: { scope: null },
      bjp: { scope: null },
      bjq: { scope: null },
      bjr: { scope: null },
      bjs: { scope: null },
      bjt: { scope: null },
      bju: { scope: null },
      bjv: { scope: null },
      bjw: { scope: null },
      bjx: { scope: null },
      bjy: { scope: null },
      bjz: { scope: null },
      bka: { scope: null },
      bkb: { scope: null },
      bkc: { scope: null },
      bkd: { scope: null },
      bkf: { scope: null },
      bkg: { scope: null },
      bkh: { scope: null },
      bki: { scope: null },
      bkj: { scope: null },
      bkk: { scope: null },
      bkl: { scope: null },
      bkm: { scope: null },
      bkn: { scope: null },
      bko: { scope: null },
      bkp: { scope: null },
      bkq: { scope: null },
      bkr: { scope: null },
      bks: { scope: null },
      bkt: { scope: null },
      bku: { scope: null },
      bkv: { scope: null },
      bkw: { scope: null },
      bkx: { scope: null },
      bky: { scope: null },
      bkz: { scope: null },
      bla: { scope: null },
      blb: { scope: null },
      blc: { scope: null },
      bld: { scope: null },
      ble: { scope: null },
      blf: { scope: null },
      blg: { scope: null },
      blh: { scope: null },
      bli: { scope: null },
      blj: { scope: null },
      blk: { scope: null },
      bll: { scope: null },
      blm: { scope: null },
      bln: { scope: null },
      blo: { scope: null },
      blp: { scope: null },
      blq: { scope: null },
      blr: { scope: null },
      bls: { scope: null },
      blt: { scope: null },
      blv: { scope: null },
      blw: { scope: null },
      blx: { scope: null },
      bly: { scope: null },
      blz: { scope: null },
      bma: { scope: null },
      bmb: { scope: null },
      bmc: { scope: null },
      bmd: { scope: null },
      bme: { scope: null },
      bmf: { scope: null },
      bmg: { scope: null },
      bmh: { scope: null },
      bmi: { scope: null },
      bmj: { scope: null },
      bmk: { scope: null },
      bml: { scope: null },
      bmm: { scope: null },
      bmn: { scope: null },
      bmo: { scope: null },
      bmp: { scope: null },
      bmq: { scope: null },
      bmr: { scope: null },
      bms: { scope: null },
      bmt: { scope: null },
      bmu: { scope: null },
      bmv: { scope: null },
      bmw: { scope: null },
      bmx: { scope: null },
      bmy: { scope: null },
      bmz: { scope: null },
      bna: { scope: null },
      bnb: { scope: null },
      bnc: { scope: "macrolanguage" },
      bnd: { scope: null },
      bne: { scope: null },
      bnf: { scope: null },
      bng: { scope: null },
      bni: { scope: null },
      bnj: { scope: null },
      bnk: { scope: null },
      bnl: { scope: null },
      bnm: { scope: null },
      bnn: { scope: null },
      bno: { scope: null },
      bnp: { scope: null },
      bnq: { scope: null },
      bnr: { scope: null },
      bns: { scope: null },
      bnt: { scope: "collection" },
      bnu: { scope: null },
      bnv: { scope: null },
      bnw: { scope: null },
      bnx: { scope: null },
      bny: { scope: null },
      bnz: { scope: null },
      boa: { scope: null },
      bob: { scope: null },
      boe: { scope: null },
      bof: { scope: null },
      bog: { scope: null },
      boh: { scope: null },
      boi: { scope: null },
      boj: { scope: null },
      bok: { scope: null },
      bol: { scope: null },
      bom: { scope: null },
      bon: { scope: null },
      boo: { scope: null },
      bop: { scope: null },
      boq: { scope: null },
      bor: { scope: null },
      bot: { scope: null },
      bou: { scope: null },
      bov: { scope: null },
      bow: { scope: null },
      box: { scope: null },
      boy: { scope: null },
      boz: { scope: null },
      bpa: { scope: null },
      bpb: { scope: null },
      bpd: { scope: null },
      bpe: { scope: null },
      bpg: { scope: null },
      bph: { scope: null },
      bpi: { scope: null },
      bpj: { scope: null },
      bpk: { scope: null },
      bpl: { scope: null },
      bpm: { scope: null },
      bpn: { scope: null },
      bpo: { scope: null },
      bpp: { scope: null },
      bpq: { scope: null },
      bpr: { scope: null },
      bps: { scope: null },
      bpt: { scope: null },
      bpu: { scope: null },
      bpv: { scope: null },
      bpw: { scope: null },
      bpx: { scope: null },
      bpy: { scope: null },
      bpz: { scope: null },
      bqa: { scope: null },
      bqb: { scope: null },
      bqc: { scope: null },
      bqd: { scope: null },
      bqf: { scope: null },
      bqg: { scope: null },
      bqh: { scope: null },
      bqi: { scope: null },
      bqj: { scope: null },
      bqk: { scope: null },
      bql: { scope: null },
      bqm: { scope: null },
      bqn: { scope: null },
      bqo: { scope: null },
      bqp: { scope: null },
      bqq: { scope: null },
      bqr: { scope: null },
      bqs: { scope: null },
      bqt: { scope: null },
      bqu: { scope: null },
      bqv: { scope: null },
      bqw: { scope: null },
      bqx: { scope: null },
      bqy: { scope: null },
      bqz: { scope: null },
      bra: { scope: null },
      brb: { scope: null },
      brc: { scope: null },
      brd: { scope: null },
      brf: { scope: null },
      brg: { scope: null },
      brh: { scope: null },
      bri: { scope: null },
      brj: { scope: null },
      brk: { scope: null },
      brl: { scope: null },
      brm: { scope: null },
      brn: { scope: null },
      bro: { scope: null },
      brp: { scope: null },
      brq: { scope: null },
      brr: { scope: null },
      brs: { scope: null },
      brt: { scope: null },
      bru: { scope: null },
      brv: { scope: null },
      brw: { scope: null },
      brx: { scope: null },
      bry: { scope: null },
      brz: { scope: null },
      bsa: { scope: null },
      bsb: { scope: null },
      bsc: { scope: null },
      bse: { scope: null },
      bsf: { scope: null },
      bsg: { scope: null },
      bsh: { scope: null },
      bsi: { scope: null },
      bsj: { scope: null },
      bsk: { scope: null },
      bsl: { scope: null },
      bsm: { scope: null },
      bsn: { scope: null },
      bso: { scope: null },
      bsp: { scope: null },
      bsq: { scope: null },
      bsr: { scope: null },
      bss: { scope: null },
      bst: { scope: null },
      bsu: { scope: null },
      bsv: { scope: null },
      bsw: { scope: null },
      bsx: { scope: null },
      bsy: { scope: null },
      bta: { scope: null },
      btb: { scope: null },
      btc: { scope: null },
      btd: { scope: null },
      bte: { scope: null },
      btf: { scope: null },
      btg: { scope: null },
      bth: { scope: null },
      bti: { scope: null },
      btj: { scope: null },
      btk: { scope: "collection" },
      btl: { scope: null },
      btm: { scope: null },
      btn: { scope: null },
      bto: { scope: null },
      btp: { scope: null },
      btq: { scope: null },
      btr: { scope: null },
      bts: { scope: null },
      btt: { scope: null },
      btu: { scope: null },
      btv: { scope: null },
      btw: { scope: null },
      btx: { scope: null },
      bty: { scope: null },
      btz: { scope: null },
      bua: { scope: "macrolanguage" },
      bub: { scope: null },
      buc: { scope: null },
      bud: { scope: null },
      bue: { scope: null },
      buf: { scope: null },
      bug: { scope: null },
      buh: { scope: null },
      bui: { scope: null },
      buj: { scope: null },
      buk: { scope: null },
      bum: { scope: null },
      bun: { scope: null },
      buo: { scope: null },
      bup: { scope: null },
      buq: { scope: null },
      bus: { scope: null },
      but: { scope: null },
      buu: { scope: null },
      buv: { scope: null },
      buw: { scope: null },
      bux: { scope: null },
      buy: { scope: null },
      buz: { scope: null },
      bva: { scope: null },
      bvb: { scope: null },
      bvc: { scope: null },
      bvd: { scope: null },
      bve: { scope: null },
      bvf: { scope: null },
      bvg: { scope: null },
      bvh: { scope: null },
      bvi: { scope: null },
      bvj: { scope: null },
      bvk: { scope: null },
      bvl: { scope: null },
      bvm: { scope: null },
      bvn: { scope: null },
      bvo: { scope: null },
      bvp: { scope: null },
      bvq: { scope: null },
      bvr: { scope: null },
      bvt: { scope: null },
      bvu: { scope: null },
      bvv: { scope: null },
      bvw: { scope: null },
      bvx: { scope: null },
      bvy: { scope: null },
      bvz: { scope: null },
      bwa: { scope: null },
      bwb: { scope: null },
      bwc: { scope: null },
      bwd: { scope: null },
      bwe: { scope: null },
      bwf: { scope: null },
      bwg: { scope: null },
      bwh: { scope: null },
      bwi: { scope: null },
      bwj: { scope: null },
      bwk: { scope: null },
      bwl: { scope: null },
      bwm: { scope: null },
      bwn: { scope: null },
      bwo: { scope: null },
      bwp: { scope: null },
      bwq: { scope: null },
      bwr: { scope: null },
      bws: { scope: null },
      bwt: { scope: null },
      bwu: { scope: null },
      bww: { scope: null },
      bwx: { scope: null },
      bwy: { scope: null },
      bwz: { scope: null },
      bxa: { scope: null },
      bxb: { scope: null },
      bxc: { scope: null },
      bxd: { scope: null },
      bxe: { scope: null },
      bxf: { scope: null },
      bxg: { scope: null },
      bxh: { scope: null },
      bxi: { scope: null },
      bxj: { scope: null },
      bxk: { scope: null },
      bxl: { scope: null },
      bxm: { scope: null },
      bxn: { scope: null },
      bxo: { scope: null },
      bxp: { scope: null },
      bxq: { scope: null },
      bxr: { scope: null },
      bxs: { scope: null },
      bxu: { scope: null },
      bxv: { scope: null },
      bxw: { scope: null },
      bxx: { scope: null },
      bxz: { scope: null },
      bya: { scope: null },
      byb: { scope: null },
      byc: { scope: null },
      byd: { scope: null },
      bye: { scope: null },
      byf: { scope: null },
      byg: { scope: null },
      byh: { scope: null },
      byi: { scope: null },
      byj: { scope: null },
      byk: { scope: null },
      byl: { scope: null },
      bym: { scope: null },
      byn: { scope: null },
      byo: { scope: null },
      byp: { scope: null },
      byq: { scope: null },
      byr: { scope: null },
      bys: { scope: null },
      byt: { scope: null },
      byv: { scope: null },
      byw: { scope: null },
      byx: { scope: null },
      byy: { scope: null },
      byz: { scope: null },
      bza: { scope: null },
      bzb: { scope: null },
      bzc: { scope: null },
      bzd: { scope: null },
      bze: { scope: null },
      bzf: { scope: null },
      bzg: { scope: null },
      bzh: { scope: null },
      bzi: { scope: null },
      bzj: { scope: null },
      bzk: { scope: null },
      bzl: { scope: null },
      bzm: { scope: null },
      bzn: { scope: null },
      bzo: { scope: null },
      bzp: { scope: null },
      bzq: { scope: null },
      bzr: { scope: null },
      bzs: { scope: null },
      bzt: { scope: null },
      bzu: { scope: null },
      bzv: { scope: null },
      bzw: { scope: null },
      bzx: { scope: null },
      bzy: { scope: null },
      bzz: { scope: null },
      caa: { scope: null },
      cab: { scope: null },
      cac: { scope: null },
      cad: { scope: null },
      cae: { scope: null },
      caf: { scope: null },
      cag: { scope: null },
      cah: { scope: null },
      cai: { scope: "collection" },
      caj: { scope: null },
      cak: { scope: null },
      cal: { scope: null },
      cam: { scope: null },
      can: { scope: null },
      cao: { scope: null },
      cap: { scope: null },
      caq: { scope: null },
      car: { scope: null },
      cas: { scope: null },
      cau: { scope: "collection" },
      cav: { scope: null },
      caw: { scope: null },
      cax: { scope: null },
      cay: { scope: null },
      caz: { scope: null },
      cba: { scope: "collection" },
      cbb: { scope: null },
      cbc: { scope: null },
      cbd: { scope: null },
      cbe: { scope: null },
      cbg: { scope: null },
      cbh: { scope: null },
      cbi: { scope: null },
      cbj: { scope: null },
      cbk: { scope: null },
      cbl: { scope: null },
      cbn: { scope: null },
      cbo: { scope: null },
      cbq: { scope: null },
      cbr: { scope: null },
      cbs: { scope: null },
      cbt: { scope: null },
      cbu: { scope: null },
      cbv: { scope: null },
      cbw: { scope: null },
      cby: { scope: null },
      cca: { scope: null },
      ccc: { scope: null },
      ccd: { scope: null },
      cce: { scope: null },
      ccg: { scope: null },
      cch: { scope: null },
      ccj: { scope: null },
      ccl: { scope: null },
      ccm: { scope: null },
      ccn: { scope: "collection" },
      cco: { scope: null },
      ccp: { scope: null },
      ccq: { scope: null },
      ccr: { scope: null },
      ccs: { scope: "collection" },
      cda: { scope: null },
      cdc: { scope: "collection" },
      cdd: { scope: "collection" },
      cde: { scope: null },
      cdf: { scope: null },
      cdg: { scope: null },
      cdh: { scope: null },
      cdi: { scope: null },
      cdj: { scope: null },
      cdm: { scope: null },
      cdn: { scope: null },
      cdo: { scope: null },
      cdr: { scope: null },
      cds: { scope: null },
      cdy: { scope: null },
      cdz: { scope: null },
      cea: { scope: null },
      ceb: { scope: null },
      ceg: { scope: null },
      cek: { scope: null },
      cel: { scope: "collection" },
      cen: { scope: null },
      cet: { scope: null },
      cey: { scope: null },
      cfa: { scope: null },
      cfd: { scope: null },
      cfg: { scope: null },
      cfm: { scope: null },
      cga: { scope: null },
      cgc: { scope: null },
      cgg: { scope: null },
      cgk: { scope: null },
      chb: { scope: null },
      chc: { scope: null },
      chd: { scope: null },
      chf: { scope: null },
      chg: { scope: null },
      chh: { scope: null },
      chj: { scope: null },
      chk: { scope: null },
      chl: { scope: null },
      chm: { scope: "macrolanguage" },
      chn: { scope: null },
      cho: { scope: null },
      chp: { scope: null },
      chq: { scope: null },
      chr: { scope: null },
      cht: { scope: null },
      chw: { scope: null },
      chx: { scope: null },
      chy: { scope: null },
      chz: { scope: null },
      cia: { scope: null },
      cib: { scope: null },
      cic: { scope: null },
      cid: { scope: null },
      cie: { scope: null },
      cih: { scope: null },
      cik: { scope: null },
      cim: { scope: null },
      cin: { scope: null },
      cip: { scope: null },
      cir: { scope: null },
      ciw: { scope: null },
      ciy: { scope: null },
      cja: { scope: null },
      cje: { scope: null },
      cjh: { scope: null },
      cji: { scope: null },
      cjk: { scope: null },
      cjm: { scope: null },
      cjn: { scope: null },
      cjo: { scope: null },
      cjp: { scope: null },
      cjr: { scope: null },
      cjs: { scope: null },
      cjv: { scope: null },
      cjy: { scope: null },
      cka: { scope: null },
      ckb: { scope: null },
      ckh: { scope: null },
      ckl: { scope: null },
      ckm: { scope: null },
      ckn: { scope: null },
      cko: { scope: null },
      ckq: { scope: null },
      ckr: { scope: null },
      cks: { scope: null },
      ckt: { scope: null },
      cku: { scope: null },
      ckv: { scope: null },
      ckx: { scope: null },
      cky: { scope: null },
      ckz: { scope: null },
      cla: { scope: null },
      clc: { scope: null },
      cld: { scope: null },
      cle: { scope: null },
      clh: { scope: null },
      cli: { scope: null },
      clj: { scope: null },
      clk: { scope: null },
      cll: { scope: null },
      clm: { scope: null },
      clo: { scope: null },
      clt: { scope: null },
      clu: { scope: null },
      clw: { scope: null },
      cly: { scope: null },
      cma: { scope: null },
      cmc: { scope: "collection" },
      cme: { scope: null },
      cmg: { scope: null },
      cmi: { scope: null },
      cmk: { scope: null },
      cml: { scope: null },
      cmm: { scope: null },
      cmn: { scope: null },
      cmo: { scope: null },
      cmr: { scope: null },
      cms: { scope: null },
      cmt: { scope: null },
      cna: { scope: null },
      cnb: { scope: null },
      cnc: { scope: null },
      cng: { scope: null },
      cnh: { scope: null },
      cni: { scope: null },
      cnk: { scope: null },
      cnl: { scope: null },
      cno: { scope: null },
      cnp: { scope: null },
      cnr: { scope: null },
      cns: { scope: null },
      cnt: { scope: null },
      cnu: { scope: null },
      cnw: { scope: null },
      cnx: { scope: null },
      coa: { scope: null },
      cob: { scope: null },
      coc: { scope: null },
      cod: { scope: null },
      coe: { scope: null },
      cof: { scope: null },
      cog: { scope: null },
      coh: { scope: null },
      coj: { scope: null },
      cok: { scope: null },
      col: { scope: null },
      com: { scope: null },
      con: { scope: null },
      coo: { scope: null },
      cop: { scope: null },
      coq: { scope: null },
      cot: { scope: null },
      cou: { scope: null },
      cov: { scope: null },
      cow: { scope: null },
      cox: { scope: null },
      coy: { scope: null },
      coz: { scope: null },
      cpa: { scope: null },
      cpb: { scope: null },
      cpc: { scope: null },
      cpe: { scope: "collection" },
      cpf: { scope: "collection" },
      cpg: { scope: null },
      cpi: { scope: null },
      cpn: { scope: null },
      cpo: { scope: null },
      cpp: { scope: "collection" },
      cps: { scope: null },
      cpu: { scope: null },
      cpx: { scope: null },
      cpy: { scope: null },
      cqd: { scope: null },
      cqu: { scope: null },
      cra: { scope: null },
      crb: { scope: null },
      crc: { scope: null },
      crd: { scope: null },
      crf: { scope: null },
      crg: { scope: null },
      crh: { scope: null },
      cri: { scope: null },
      crj: { scope: null },
      crk: { scope: null },
      crl: { scope: null },
      crm: { scope: null },
      crn: { scope: null },
      cro: { scope: null },
      crp: { scope: "collection" },
      crq: { scope: null },
      crr: { scope: null },
      crs: { scope: null },
      crt: { scope: null },
      crv: { scope: null },
      crw: { scope: null },
      crx: { scope: null },
      cry: { scope: null },
      crz: { scope: null },
      csa: { scope: null },
      csb: { scope: null },
      csc: { scope: null },
      csd: { scope: null },
      cse: { scope: null },
      csf: { scope: null },
      csg: { scope: null },
      csh: { scope: null },
      csi: { scope: null },
      csj: { scope: null },
      csk: { scope: null },
      csl: { scope: null },
      csm: { scope: null },
      csn: { scope: null },
      cso: { scope: null },
      csp: { scope: null },
      csq: { scope: null },
      csr: { scope: null },
      css: { scope: null },
      cst: { scope: null },
      csu: { scope: "collection" },
      csv: { scope: null },
      csw: { scope: null },
      csx: { scope: null },
      csy: { scope: null },
      csz: { scope: null },
      cta: { scope: null },
      ctc: { scope: null },
      ctd: { scope: null },
      cte: { scope: null },
      ctg: { scope: null },
      cth: { scope: null },
      ctl: { scope: null },
      ctm: { scope: null },
      ctn: { scope: null },
      cto: { scope: null },
      ctp: { scope: null },
      cts: { scope: null },
      ctt: { scope: null },
      ctu: { scope: null },
      cty: { scope: null },
      ctz: { scope: null },
      cua: { scope: null },
      cub: { scope: null },
      cuc: { scope: null },
      cug: { scope: null },
      cuh: { scope: null },
      cui: { scope: null },
      cuj: { scope: null },
      cuk: { scope: null },
      cul: { scope: null },
      cum: { scope: null },
      cuo: { scope: null },
      cup: { scope: null },
      cuq: { scope: null },
      cur: { scope: null },
      cus: { scope: "collection" },
      cut: { scope: null },
      cuu: { scope: null },
      cuv: { scope: null },
      cuw: { scope: null },
      cux: { scope: null },
      cuy: { scope: null },
      cvg: { scope: null },
      cvn: { scope: null },
      cwa: { scope: null },
      cwb: { scope: null },
      cwd: { scope: null },
      cwe: { scope: null },
      cwg: { scope: null },
      cwt: { scope: null },
      cya: { scope: null },
      cyb: { scope: null },
      cyo: { scope: null },
      czh: { scope: null },
      czk: { scope: null },
      czn: { scope: null },
      czo: { scope: null },
      czt: { scope: null },
      daa: { scope: null },
      dac: { scope: null },
      dad: { scope: null },
      dae: { scope: null },
      daf: { scope: null },
      dag: { scope: null },
      dah: { scope: null },
      dai: { scope: null },
      daj: { scope: null },
      dak: { scope: null },
      dal: { scope: null },
      dam: { scope: null },
      dao: { scope: null },
      dap: { scope: null },
      daq: { scope: null },
      dar: { scope: null },
      das: { scope: null },
      dau: { scope: null },
      dav: { scope: null },
      daw: { scope: null },
      dax: { scope: null },
      day: { scope: "collection" },
      daz: { scope: null },
      dba: { scope: null },
      dbb: { scope: null },
      dbd: { scope: null },
      dbe: { scope: null },
      dbf: { scope: null },
      dbg: { scope: null },
      dbi: { scope: null },
      dbj: { scope: null },
      dbl: { scope: null },
      dbm: { scope: null },
      dbn: { scope: null },
      dbo: { scope: null },
      dbp: { scope: null },
      dbq: { scope: null },
      dbr: { scope: null },
      dbt: { scope: null },
      dbu: { scope: null },
      dbv: { scope: null },
      dbw: { scope: null },
      dby: { scope: null },
      dcc: { scope: null },
      dcr: { scope: null },
      dda: { scope: null },
      ddd: { scope: null },
      dde: { scope: null },
      ddg: { scope: null },
      ddi: { scope: null },
      ddj: { scope: null },
      ddn: { scope: null },
      ddo: { scope: null },
      ddr: { scope: null },
      dds: { scope: null },
      ddw: { scope: null },
      dec: { scope: null },
      ded: { scope: null },
      dee: { scope: null },
      def: { scope: null },
      deg: { scope: null },
      deh: { scope: null },
      dei: { scope: null },
      dek: { scope: null },
      del: { scope: "macrolanguage" },
      dem: { scope: null },
      den: { scope: "macrolanguage" },
      dep: { scope: null },
      deq: { scope: null },
      der: { scope: null },
      des: { scope: null },
      dev: { scope: null },
      dez: { scope: null },
      dga: { scope: null },
      dgb: { scope: null },
      dgc: { scope: null },
      dgd: { scope: null },
      dge: { scope: null },
      dgg: { scope: null },
      dgh: { scope: null },
      dgi: { scope: null },
      dgk: { scope: null },
      dgl: { scope: null },
      dgn: { scope: null },
      dgo: { scope: null },
      dgr: { scope: null },
      dgs: { scope: null },
      dgt: { scope: null },
      dgu: { scope: null },
      dgw: { scope: null },
      dgx: { scope: null },
      dgz: { scope: null },
      dha: { scope: null },
      dhd: { scope: null },
      dhg: { scope: null },
      dhi: { scope: null },
      dhl: { scope: null },
      dhm: { scope: null },
      dhn: { scope: null },
      dho: { scope: null },
      dhr: { scope: null },
      dhs: { scope: null },
      dhu: { scope: null },
      dhv: { scope: null },
      dhw: { scope: null },
      dhx: { scope: null },
      dia: { scope: null },
      dib: { scope: null },
      dic: { scope: null },
      did: { scope: null },
      dif: { scope: null },
      dig: { scope: null },
      dih: { scope: null },
      dii: { scope: null },
      dij: { scope: null },
      dik: { scope: null },
      dil: { scope: null },
      dim: { scope: null },
      din: { scope: "macrolanguage" },
      dio: { scope: null },
      dip: { scope: null },
      diq: { scope: null },
      dir: { scope: null },
      dis: { scope: null },
      dit: { scope: null },
      diu: { scope: null },
      diw: { scope: null },
      dix: { scope: null },
      diy: { scope: null },
      diz: { scope: null },
      dja: { scope: null },
      djb: { scope: null },
      djc: { scope: null },
      djd: { scope: null },
      dje: { scope: null },
      djf: { scope: null },
      dji: { scope: null },
      djj: { scope: null },
      djk: { scope: null },
      djl: { scope: null },
      djm: { scope: null },
      djn: { scope: null },
      djo: { scope: null },
      djr: { scope: null },
      dju: { scope: null },
      djw: { scope: null },
      dka: { scope: null },
      dkg: { scope: null },
      dkk: { scope: null },
      dkl: { scope: null },
      dkr: { scope: null },
      dks: { scope: null },
      dkx: { scope: null },
      dlg: { scope: null },
      dlk: { scope: null },
      dlm: { scope: null },
      dln: { scope: null },
      dma: { scope: null },
      dmb: { scope: null },
      dmc: { scope: null },
      dmd: { scope: null },
      dme: { scope: null },
      dmf: { scope: null },
      dmg: { scope: null },
      dmk: { scope: null },
      dml: { scope: null },
      dmm: { scope: null },
      dmn: { scope: "collection" },
      dmo: { scope: null },
      dmr: { scope: null },
      dms: { scope: null },
      dmu: { scope: null },
      dmv: { scope: null },
      dmw: { scope: null },
      dmx: { scope: null },
      dmy: { scope: null },
      dna: { scope: null },
      dnd: { scope: null },
      dne: { scope: null },
      dng: { scope: null },
      dni: { scope: null },
      dnj: { scope: null },
      dnk: { scope: null },
      dnn: { scope: null },
      dno: { scope: null },
      dnr: { scope: null },
      dnt: { scope: null },
      dnu: { scope: null },
      dnv: { scope: null },
      dnw: { scope: null },
      dny: { scope: null },
      doa: { scope: null },
      dob: { scope: null },
      doc: { scope: null },
      doe: { scope: null },
      dof: { scope: null },
      doh: { scope: null },
      doi: { scope: "macrolanguage" },
      dok: { scope: null },
      dol: { scope: null },
      don: { scope: null },
      doo: { scope: null },
      dop: { scope: null },
      doq: { scope: null },
      dor: { scope: null },
      dos: { scope: null },
      dot: { scope: null },
      dov: { scope: null },
      dow: { scope: null },
      dox: { scope: null },
      doy: { scope: null },
      doz: { scope: null },
      dpp: { scope: null },
      dra: { scope: "collection" },
      drb: { scope: null },
      drc: { scope: null },
      drd: { scope: null },
      dre: { scope: null },
      drg: { scope: null },
      drh: { scope: null },
      dri: { scope: null },
      drl: { scope: null },
      drn: { scope: null },
      dro: { scope: null },
      drq: { scope: null },
      drr: { scope: null },
      drs: { scope: null },
      drt: { scope: null },
      dru: { scope: null },
      drw: { scope: null },
      dry: { scope: null },
      dsb: { scope: null },
      dse: { scope: null },
      dsh: { scope: null },
      dsi: { scope: null },
      dsl: { scope: null },
      dsn: { scope: null },
      dso: { scope: null },
      dsq: { scope: null },
      dta: { scope: null },
      dtb: { scope: null },
      dtd: { scope: null },
      dth: { scope: null },
      dti: { scope: null },
      dtk: { scope: null },
      dtm: { scope: null },
      dtn: { scope: null },
      dto: { scope: null },
      dtp: { scope: null },
      dtr: { scope: null },
      dts: { scope: null },
      dtt: { scope: null },
      dtu: { scope: null },
      dty: { scope: null },
      dua: { scope: null },
      dub: { scope: null },
      duc: { scope: null },
      dud: { scope: null },
      due: { scope: null },
      duf: { scope: null },
      dug: { scope: null },
      duh: { scope: null },
      dui: { scope: null },
      duj: { scope: null },
      duk: { scope: null },
      dul: { scope: null },
      dum: { scope: null },
      dun: { scope: null },
      duo: { scope: null },
      dup: { scope: null },
      duq: { scope: null },
      dur: { scope: null },
      dus: { scope: null },
      duu: { scope: null },
      duv: { scope: null },
      duw: { scope: null },
      dux: { scope: null },
      duy: { scope: null },
      duz: { scope: null },
      dva: { scope: null },
      dwa: { scope: null },
      dwk: { scope: null },
      dwl: { scope: null },
      dwr: { scope: null },
      dws: { scope: null },
      dwu: { scope: null },
      dww: { scope: null },
      dwy: { scope: null },
      dwz: { scope: null },
      dya: { scope: null },
      dyb: { scope: null },
      dyd: { scope: null },
      dyg: { scope: null },
      dyi: { scope: null },
      dym: { scope: null },
      dyn: { scope: null },
      dyo: { scope: null },
      dyu: { scope: null },
      dyy: { scope: null },
      dza: { scope: null },
      dzd: { scope: null },
      dze: { scope: null },
      dzg: { scope: null },
      dzl: { scope: null },
      dzn: { scope: null },
      eaa: { scope: null },
      ebc: { scope: null },
      ebg: { scope: null },
      ebk: { scope: null },
      ebo: { scope: null },
      ebr: { scope: null },
      ebu: { scope: null },
      ecr: { scope: null },
      ecs: { scope: null },
      ecy: { scope: null },
      eee: { scope: null },
      efa: { scope: null },
      efe: { scope: null },
      efi: { scope: null },
      ega: { scope: null },
      egl: { scope: null },
      ego: { scope: null },
      egx: { scope: "collection" },
      egy: { scope: null },
      ehs: { scope: null },
      ehu: { scope: null },
      eip: { scope: null },
      eit: { scope: null },
      eiv: { scope: null },
      eja: { scope: null },
      eka: { scope: null },
      ekc: { scope: null },
      eke: { scope: null },
      ekg: { scope: null },
      eki: { scope: null },
      ekk: { scope: null },
      ekl: { scope: null },
      ekm: { scope: null },
      eko: { scope: null },
      ekp: { scope: null },
      ekr: { scope: null },
      eky: { scope: null },
      ele: { scope: null },
      elh: { scope: null },
      eli: { scope: null },
      elk: { scope: null },
      elm: { scope: null },
      elo: { scope: null },
      elp: { scope: null },
      elu: { scope: null },
      elx: { scope: null },
      ema: { scope: null },
      emb: { scope: null },
      eme: { scope: null },
      emg: { scope: null },
      emi: { scope: null },
      emk: { scope: null },
      emm: { scope: null },
      emn: { scope: null },
      emo: { scope: null },
      emp: { scope: null },
      emq: { scope: null },
      ems: { scope: null },
      emu: { scope: null },
      emw: { scope: null },
      emx: { scope: null },
      emy: { scope: null },
      emz: { scope: null },
      ena: { scope: null },
      enb: { scope: null },
      enc: { scope: null },
      end: { scope: null },
      enf: { scope: null },
      enh: { scope: null },
      enl: { scope: null },
      enm: { scope: null },
      enn: { scope: null },
      eno: { scope: null },
      enq: { scope: null },
      enr: { scope: null },
      enu: { scope: null },
      env: { scope: null },
      enw: { scope: null },
      enx: { scope: null },
      eot: { scope: null },
      epi: { scope: null },
      era: { scope: null },
      erg: { scope: null },
      erh: { scope: null },
      eri: { scope: null },
      erk: { scope: null },
      ero: { scope: null },
      err: { scope: null },
      ers: { scope: null },
      ert: { scope: null },
      erw: { scope: null },
      ese: { scope: null },
      esg: { scope: null },
      esh: { scope: null },
      esi: { scope: null },
      esk: { scope: null },
      esl: { scope: null },
      esm: { scope: null },
      esn: { scope: null },
      eso: { scope: null },
      esq: { scope: null },
      ess: { scope: null },
      esu: { scope: null },
      esx: { scope: "collection" },
      esy: { scope: null },
      etb: { scope: null },
      etc: { scope: null },
      eth: { scope: null },
      etn: { scope: null },
      eto: { scope: null },
      etr: { scope: null },
      ets: { scope: null },
      ett: { scope: null },
      etu: { scope: null },
      etx: { scope: null },
      etz: { scope: null },
      euq: { scope: "collection" },
      eve: { scope: null },
      evh: { scope: null },
      evn: { scope: null },
      ewo: { scope: null },
      ext: { scope: null },
      eya: { scope: null },
      eyo: { scope: null },
      eza: { scope: null },
      eze: { scope: null },
      faa: { scope: null },
      fab: { scope: null },
      fad: { scope: null },
      faf: { scope: null },
      fag: { scope: null },
      fah: { scope: null },
      fai: { scope: null },
      faj: { scope: null },
      fak: { scope: null },
      fal: { scope: null },
      fam: { scope: null },
      fan: { scope: null },
      fap: { scope: null },
      far: { scope: null },
      fat: { scope: null },
      fau: { scope: null },
      fax: { scope: null },
      fay: { scope: null },
      faz: { scope: null },
      fbl: { scope: null },
      fcs: { scope: null },
      fer: { scope: null },
      ffi: { scope: null },
      ffm: { scope: null },
      fgr: { scope: null },
      fia: { scope: null },
      fie: { scope: null },
      fif: { scope: null },
      fil: { scope: null },
      fip: { scope: null },
      fir: { scope: null },
      fit: { scope: null },
      fiu: { scope: "collection" },
      fiw: { scope: null },
      fkk: { scope: null },
      fkv: { scope: null },
      fla: { scope: null },
      flh: { scope: null },
      fli: { scope: null },
      fll: { scope: null },
      fln: { scope: null },
      flr: { scope: null },
      fly: { scope: null },
      fmp: { scope: null },
      fmu: { scope: null },
      fnb: { scope: null },
      fng: { scope: null },
      fni: { scope: null },
      fod: { scope: null },
      foi: { scope: null },
      fom: { scope: null },
      fon: { scope: null },
      for: { scope: null },
      fos: { scope: null },
      fox: { scope: "collection" },
      fpe: { scope: null },
      fqs: { scope: null },
      frc: { scope: null },
      frd: { scope: null },
      frk: { scope: null },
      frm: { scope: null },
      fro: { scope: null },
      frp: { scope: null },
      frq: { scope: null },
      frr: { scope: null },
      frs: { scope: null },
      frt: { scope: null },
      fse: { scope: null },
      fsl: { scope: null },
      fss: { scope: null },
      fub: { scope: null },
      fuc: { scope: null },
      fud: { scope: null },
      fue: { scope: null },
      fuf: { scope: null },
      fuh: { scope: null },
      fui: { scope: null },
      fuj: { scope: null },
      fum: { scope: null },
      fun: { scope: null },
      fuq: { scope: null },
      fur: { scope: null },
      fut: { scope: null },
      fuu: { scope: null },
      fuv: { scope: null },
      fuy: { scope: null },
      fvr: { scope: null },
      fwa: { scope: null },
      fwe: { scope: null },
      gaa: { scope: null },
      gab: { scope: null },
      gac: { scope: null },
      gad: { scope: null },
      gae: { scope: null },
      gaf: { scope: null },
      gag: { scope: null },
      gah: { scope: null },
      gai: { scope: null },
      gaj: { scope: null },
      gak: { scope: null },
      gal: { scope: null },
      gam: { scope: null },
      gan: { scope: null },
      gao: { scope: null },
      gap: { scope: null },
      gaq: { scope: null },
      gar: { scope: null },
      gas: { scope: null },
      gat: { scope: null },
      gau: { scope: null },
      gav: { scope: null },
      gaw: { scope: null },
      gax: { scope: null },
      gay: { scope: null },
      gaz: { scope: null },
      gba: { scope: "macrolanguage" },
      gbb: { scope: null },
      gbc: { scope: null },
      gbd: { scope: null },
      gbe: { scope: null },
      gbf: { scope: null },
      gbg: { scope: null },
      gbh: { scope: null },
      gbi: { scope: null },
      gbj: { scope: null },
      gbk: { scope: null },
      gbl: { scope: null },
      gbm: { scope: null },
      gbn: { scope: null },
      gbo: { scope: null },
      gbp: { scope: null },
      gbq: { scope: null },
      gbr: { scope: null },
      gbs: { scope: null },
      gbu: { scope: null },
      gbv: { scope: null },
      gbw: { scope: null },
      gbx: { scope: null },
      gby: { scope: null },
      gbz: { scope: null },
      gcc: { scope: null },
      gcd: { scope: null },
      gce: { scope: null },
      gcf: { scope: null },
      gcl: { scope: null },
      gcn: { scope: null },
      gcr: { scope: null },
      gct: { scope: null },
      gda: { scope: null },
      gdb: { scope: null },
      gdc: { scope: null },
      gdd: { scope: null },
      gde: { scope: null },
      gdf: { scope: null },
      gdg: { scope: null },
      gdh: { scope: null },
      gdi: { scope: null },
      gdj: { scope: null },
      gdk: { scope: null },
      gdl: { scope: null },
      gdm: { scope: null },
      gdn: { scope: null },
      gdo: { scope: null },
      gdq: { scope: null },
      gdr: { scope: null },
      gds: { scope: null },
      gdt: { scope: null },
      gdu: { scope: null },
      gdx: { scope: null },
      gea: { scope: null },
      geb: { scope: null },
      gec: { scope: null },
      ged: { scope: null },
      gef: { scope: null },
      geg: { scope: null },
      geh: { scope: null },
      gei: { scope: null },
      gej: { scope: null },
      gek: { scope: null },
      gel: { scope: null },
      gem: { scope: "collection" },
      geq: { scope: null },
      ges: { scope: null },
      gev: { scope: null },
      gew: { scope: null },
      gex: { scope: null },
      gey: { scope: null },
      gez: { scope: null },
      gfk: { scope: null },
      gft: { scope: null },
      gfx: { scope: null },
      gga: { scope: null },
      ggb: { scope: null },
      ggd: { scope: null },
      gge: { scope: null },
      ggg: { scope: null },
      ggk: { scope: null },
      ggl: { scope: null },
      ggn: { scope: null },
      ggo: { scope: null },
      ggr: { scope: null },
      ggt: { scope: null },
      ggu: { scope: null },
      ggw: { scope: null },
      gha: { scope: null },
      ghc: { scope: null },
      ghe: { scope: null },
      ghh: { scope: null },
      ghk: { scope: null },
      ghl: { scope: null },
      ghn: { scope: null },
      gho: { scope: null },
      ghr: { scope: null },
      ghs: { scope: null },
      ght: { scope: null },
      gia: { scope: null },
      gib: { scope: null },
      gic: { scope: null },
      gid: { scope: null },
      gie: { scope: null },
      gig: { scope: null },
      gih: { scope: null },
      gii: { scope: null },
      gil: { scope: null },
      gim: { scope: null },
      gin: { scope: null },
      gio: { scope: null },
      gip: { scope: null },
      giq: { scope: null },
      gir: { scope: null },
      gis: { scope: null },
      git: { scope: null },
      giu: { scope: null },
      giw: { scope: null },
      gix: { scope: null },
      giy: { scope: null },
      giz: { scope: null },
      gji: { scope: null },
      gjk: { scope: null },
      gjm: { scope: null },
      gjn: { scope: null },
      gjr: { scope: null },
      gju: { scope: null },
      gka: { scope: null },
      gkd: { scope: null },
      gke: { scope: null },
      gkn: { scope: null },
      gko: { scope: null },
      gkp: { scope: null },
      gku: { scope: null },
      glb: { scope: null },
      glc: { scope: null },
      gld: { scope: null },
      glh: { scope: null },
      gli: { scope: null },
      glj: { scope: null },
      glk: { scope: null },
      gll: { scope: null },
      glo: { scope: null },
      glr: { scope: null },
      glu: { scope: null },
      glw: { scope: null },
      gly: { scope: null },
      gma: { scope: null },
      gmb: { scope: null },
      gmd: { scope: null },
      gme: { scope: "collection" },
      gmg: { scope: null },
      gmh: { scope: null },
      gml: { scope: null },
      gmm: { scope: null },
      gmn: { scope: null },
      gmq: { scope: "collection" },
      gmr: { scope: null },
      gmu: { scope: null },
      gmv: { scope: null },
      gmw: { scope: "collection" },
      gmx: { scope: null },
      gmy: { scope: null },
      gmz: { scope: null },
      gna: { scope: null },
      gnb: { scope: null },
      gnc: { scope: null },
      gnd: { scope: null },
      gne: { scope: null },
      gng: { scope: null },
      gnh: { scope: null },
      gni: { scope: null },
      gnj: { scope: null },
      gnk: { scope: null },
      gnl: { scope: null },
      gnm: { scope: null },
      gnn: { scope: null },
      gno: { scope: null },
      gnq: { scope: null },
      gnr: { scope: null },
      gnt: { scope: null },
      gnu: { scope: null },
      gnw: { scope: null },
      gnz: { scope: null },
      goa: { scope: null },
      gob: { scope: null },
      goc: { scope: null },
      god: { scope: null },
      goe: { scope: null },
      gof: { scope: null },
      gog: { scope: null },
      goh: { scope: null },
      goi: { scope: null },
      goj: { scope: null },
      gok: { scope: null },
      gol: { scope: null },
      gom: { scope: null },
      gon: { scope: "macrolanguage" },
      goo: { scope: null },
      gop: { scope: null },
      goq: { scope: null },
      gor: { scope: null },
      gos: { scope: null },
      got: { scope: null },
      gou: { scope: null },
      gow: { scope: null },
      gox: { scope: null },
      goy: { scope: null },
      goz: { scope: null },
      gpa: { scope: null },
      gpe: { scope: null },
      gpn: { scope: null },
      gqa: { scope: null },
      gqi: { scope: null },
      gqn: { scope: null },
      gqr: { scope: null },
      gqu: { scope: null },
      gra: { scope: null },
      grb: { scope: "macrolanguage" },
      grc: { scope: null },
      grd: { scope: null },
      grg: { scope: null },
      grh: { scope: null },
      gri: { scope: null },
      grj: { scope: null },
      grk: { scope: "collection" },
      grm: { scope: null },
      gro: { scope: null },
      grq: { scope: null },
      grr: { scope: null },
      grs: { scope: null },
      grt: { scope: null },
      gru: { scope: null },
      grv: { scope: null },
      grw: { scope: null },
      grx: { scope: null },
      gry: { scope: null },
      grz: { scope: null },
      gse: { scope: null },
      gsg: { scope: null },
      gsl: { scope: null },
      gsm: { scope: null },
      gsn: { scope: null },
      gso: { scope: null },
      gsp: { scope: null },
      gss: { scope: null },
      gsw: { scope: null },
      gta: { scope: null },
      gti: { scope: null },
      gtu: { scope: null },
      gua: { scope: null },
      gub: { scope: null },
      guc: { scope: null },
      gud: { scope: null },
      gue: { scope: null },
      guf: { scope: null },
      gug: { scope: null },
      guh: { scope: null },
      gui: { scope: null },
      guk: { scope: null },
      gul: { scope: null },
      gum: { scope: null },
      gun: { scope: null },
      guo: { scope: null },
      gup: { scope: null },
      guq: { scope: null },
      gur: { scope: null },
      gus: { scope: null },
      gut: { scope: null },
      guu: { scope: null },
      guv: { scope: null },
      guw: { scope: null },
      gux: { scope: null },
      guz: { scope: null },
      gva: { scope: null },
      gvc: { scope: null },
      gve: { scope: null },
      gvf: { scope: null },
      gvj: { scope: null },
      gvl: { scope: null },
      gvm: { scope: null },
      gvn: { scope: null },
      gvo: { scope: null },
      gvp: { scope: null },
      gvr: { scope: null },
      gvs: { scope: null },
      gvy: { scope: null },
      gwa: { scope: null },
      gwb: { scope: null },
      gwc: { scope: null },
      gwd: { scope: null },
      gwe: { scope: null },
      gwf: { scope: null },
      gwg: { scope: null },
      gwi: { scope: null },
      gwj: { scope: null },
      gwm: { scope: null },
      gwn: { scope: null },
      gwr: { scope: null },
      gwt: { scope: null },
      gwu: { scope: null },
      gww: { scope: null },
      gwx: { scope: null },
      gxx: { scope: null },
      gya: { scope: null },
      gyb: { scope: null },
      gyd: { scope: null },
      gye: { scope: null },
      gyf: { scope: null },
      gyg: { scope: null },
      gyi: { scope: null },
      gyl: { scope: null },
      gym: { scope: null },
      gyn: { scope: null },
      gyo: { scope: null },
      gyr: { scope: null },
      gyy: { scope: null },
      gyz: { scope: null },
      gza: { scope: null },
      gzi: { scope: null },
      gzn: { scope: null },
      haa: { scope: null },
      hab: { scope: null },
      hac: { scope: null },
      had: { scope: null },
      hae: { scope: null },
      haf: { scope: null },
      hag: { scope: null },
      hah: { scope: null },
      hai: { scope: "macrolanguage" },
      haj: { scope: null },
      hak: { scope: null },
      hal: { scope: null },
      ham: { scope: null },
      han: { scope: null },
      hao: { scope: null },
      hap: { scope: null },
      haq: { scope: null },
      har: { scope: null },
      has: { scope: null },
      hav: { scope: null },
      haw: { scope: null },
      hax: { scope: null },
      hay: { scope: null },
      haz: { scope: null },
      hba: { scope: null },
      hbb: { scope: null },
      hbn: { scope: null },
      hbo: { scope: null },
      hbu: { scope: null },
      hca: { scope: null },
      hch: { scope: null },
      hdn: { scope: null },
      hds: { scope: null },
      hdy: { scope: null },
      hea: { scope: null },
      hed: { scope: null },
      heg: { scope: null },
      heh: { scope: null },
      hei: { scope: null },
      hem: { scope: null },
      hgm: { scope: null },
      hgw: { scope: null },
      hhi: { scope: null },
      hhr: { scope: null },
      hhy: { scope: null },
      hia: { scope: null },
      hib: { scope: null },
      hid: { scope: null },
      hif: { scope: null },
      hig: { scope: null },
      hih: { scope: null },
      hii: { scope: null },
      hij: { scope: null },
      hik: { scope: null },
      hil: { scope: null },
      him: { scope: "collection" },
      hio: { scope: null },
      hir: { scope: null },
      hit: { scope: null },
      hiw: { scope: null },
      hix: { scope: null },
      hji: { scope: null },
      hka: { scope: null },
      hke: { scope: null },
      hkh: { scope: null },
      hkk: { scope: null },
      hkn: { scope: null },
      hks: { scope: null },
      hla: { scope: null },
      hlb: { scope: null },
      hld: { scope: null },
      hle: { scope: null },
      hlt: { scope: null },
      hlu: { scope: null },
      hma: { scope: null },
      hmb: { scope: null },
      hmc: { scope: null },
      hmd: { scope: null },
      hme: { scope: null },
      hmf: { scope: null },
      hmg: { scope: null },
      hmh: { scope: null },
      hmi: { scope: null },
      hmj: { scope: null },
      hmk: { scope: null },
      hml: { scope: null },
      hmm: { scope: null },
      hmn: { scope: "macrolanguage" },
      hmp: { scope: null },
      hmq: { scope: null },
      hmr: { scope: null },
      hms: { scope: null },
      hmt: { scope: null },
      hmu: { scope: null },
      hmv: { scope: null },
      hmw: { scope: null },
      hmx: { scope: "collection" },
      hmy: { scope: null },
      hmz: { scope: null },
      hna: { scope: null },
      hnd: { scope: null },
      hne: { scope: null },
      hng: { scope: null },
      hnh: { scope: null },
      hni: { scope: null },
      hnj: { scope: null },
      hnn: { scope: null },
      hno: { scope: null },
      hns: { scope: null },
      hnu: { scope: null },
      hoa: { scope: null },
      hob: { scope: null },
      hoc: { scope: null },
      hod: { scope: null },
      hoe: { scope: null },
      hoh: { scope: null },
      hoi: { scope: null },
      hoj: { scope: null },
      hok: { scope: "collection" },
      hol: { scope: null },
      hom: { scope: null },
      hoo: { scope: null },
      hop: { scope: null },
      hor: { scope: null },
      hos: { scope: null },
      hot: { scope: null },
      hov: { scope: null },
      how: { scope: null },
      hoy: { scope: null },
      hoz: { scope: null },
      hpo: { scope: null },
      hps: { scope: null },
      hra: { scope: null },
      hrc: { scope: null },
      hre: { scope: null },
      hrk: { scope: null },
      hrm: { scope: null },
      hro: { scope: null },
      hrp: { scope: null },
      hrr: { scope: null },
      hrt: { scope: null },
      hru: { scope: null },
      hrw: { scope: null },
      hrx: { scope: null },
      hrz: { scope: null },
      hsb: { scope: null },
      hsh: { scope: null },
      hsl: { scope: null },
      hsn: { scope: null },
      hss: { scope: null },
      hti: { scope: null },
      hto: { scope: null },
      hts: { scope: null },
      htu: { scope: null },
      htx: { scope: null },
      hub: { scope: null },
      huc: { scope: null },
      hud: { scope: null },
      hue: { scope: null },
      huf: { scope: null },
      hug: { scope: null },
      huh: { scope: null },
      hui: { scope: null },
      huj: { scope: null },
      huk: { scope: null },
      hul: { scope: null },
      hum: { scope: null },
      huo: { scope: null },
      hup: { scope: null },
      huq: { scope: null },
      hur: { scope: null },
      hus: { scope: null },
      hut: { scope: null },
      huu: { scope: null },
      huv: { scope: null },
      huw: { scope: null },
      hux: { scope: null },
      huy: { scope: null },
      huz: { scope: null },
      hvc: { scope: null },
      hve: { scope: null },
      hvk: { scope: null },
      hvn: { scope: null },
      hvv: { scope: null },
      hwa: { scope: null },
      hwc: { scope: null },
      hwo: { scope: null },
      hya: { scope: null },
      hyw: { scope: null },
      hyx: { scope: "collection" },
      iai: { scope: null },
      ian: { scope: null },
      iap: { scope: null },
      iar: { scope: null },
      iba: { scope: null },
      ibb: { scope: null },
      ibd: { scope: null },
      ibe: { scope: null },
      ibg: { scope: null },
      ibh: { scope: null },
      ibi: { scope: null },
      ibl: { scope: null },
      ibm: { scope: null },
      ibn: { scope: null },
      ibr: { scope: null },
      ibu: { scope: null },
      iby: { scope: null },
      ica: { scope: null },
      ich: { scope: null },
      icl: { scope: null },
      icr: { scope: null },
      ida: { scope: null },
      idb: { scope: null },
      idc: { scope: null },
      idd: { scope: null },
      ide: { scope: null },
      idi: { scope: null },
      idr: { scope: null },
      ids: { scope: null },
      idt: { scope: null },
      idu: { scope: null },
      ifa: { scope: null },
      ifb: { scope: null },
      ife: { scope: null },
      iff: { scope: null },
      ifk: { scope: null },
      ifm: { scope: null },
      ifu: { scope: null },
      ify: { scope: null },
      igb: { scope: null },
      ige: { scope: null },
      igg: { scope: null },
      igl: { scope: null },
      igm: { scope: null },
      ign: { scope: null },
      igo: { scope: null },
      igs: { scope: null },
      igw: { scope: null },
      ihb: { scope: null },
      ihi: { scope: null },
      ihp: { scope: null },
      ihw: { scope: null },
      iin: { scope: null },
      iir: { scope: "collection" },
      ijc: { scope: null },
      ije: { scope: null },
      ijj: { scope: null },
      ijn: { scope: null },
      ijo: { scope: "collection" },
      ijs: { scope: null },
      ike: { scope: null },
      iki: { scope: null },
      ikk: { scope: null },
      ikl: { scope: null },
      iko: { scope: null },
      ikp: { scope: null },
      ikr: { scope: null },
      iks: { scope: null },
      ikt: { scope: null },
      ikv: { scope: null },
      ikw: { scope: null },
      ikx: { scope: null },
      ikz: { scope: null },
      ila: { scope: null },
      ilb: { scope: null },
      ilg: { scope: null },
      ili: { scope: null },
      ilk: { scope: null },
      ill: { scope: null },
      ilm: { scope: null },
      ilo: { scope: null },
      ilp: { scope: null },
      ils: { scope: null },
      ilu: { scope: null },
      ilv: { scope: null },
      ilw: { scope: null },
      ima: { scope: null },
      ime: { scope: null },
      imi: { scope: null },
      iml: { scope: null },
      imn: { scope: null },
      imo: { scope: null },
      imr: { scope: null },
      ims: { scope: null },
      imy: { scope: null },
      inb: { scope: null },
      inc: { scope: "collection" },
      ine: { scope: "collection" },
      ing: { scope: null },
      inh: { scope: null },
      inj: { scope: null },
      inl: { scope: null },
      inm: { scope: null },
      inn: { scope: null },
      ino: { scope: null },
      inp: { scope: null },
      ins: { scope: null },
      int: { scope: null },
      inz: { scope: null },
      ior: { scope: null },
      iou: { scope: null },
      iow: { scope: null },
      ipi: { scope: null },
      ipo: { scope: null },
      iqu: { scope: null },
      iqw: { scope: null },
      ira: { scope: "collection" },
      ire: { scope: null },
      irh: { scope: null },
      iri: { scope: null },
      irk: { scope: null },
      irn: { scope: null },
      iro: { scope: "collection" },
      irr: { scope: null },
      iru: { scope: null },
      irx: { scope: null },
      iry: { scope: null },
      isa: { scope: null },
      isc: { scope: null },
      isd: { scope: null },
      ise: { scope: null },
      isg: { scope: null },
      ish: { scope: null },
      isi: { scope: null },
      isk: { scope: null },
      ism: { scope: null },
      isn: { scope: null },
      iso: { scope: null },
      isr: { scope: null },
      ist: { scope: null },
      isu: { scope: null },
      itb: { scope: null },
      itc: { scope: "collection" },
      itd: { scope: null },
      ite: { scope: null },
      iti: { scope: null },
      itk: { scope: null },
      itl: { scope: null },
      itm: { scope: null },
      ito: { scope: null },
      itr: { scope: null },
      its: { scope: null },
      itt: { scope: null },
      itv: { scope: null },
      itw: { scope: null },
      itx: { scope: null },
      ity: { scope: null },
      itz: { scope: null },
      ium: { scope: null },
      ivb: { scope: null },
      ivv: { scope: null },
      iwk: { scope: null },
      iwm: { scope: null },
      iwo: { scope: null },
      iws: { scope: null },
      ixc: { scope: null },
      ixl: { scope: null },
      iya: { scope: null },
      iyo: { scope: null },
      iyx: { scope: null },
      izh: { scope: null },
      izi: { scope: null },
      izr: { scope: null },
      izz: { scope: null },
      jaa: { scope: null },
      jab: { scope: null },
      jac: { scope: null },
      jad: { scope: null },
      jae: { scope: null },
      jaf: { scope: null },
      jah: { scope: null },
      jaj: { scope: null },
      jak: { scope: null },
      jal: { scope: null },
      jam: { scope: null },
      jan: { scope: null },
      jao: { scope: null },
      jaq: { scope: null },
      jar: { scope: null },
      jas: { scope: null },
      jat: { scope: null },
      jau: { scope: null },
      jax: { scope: null },
      jay: { scope: null },
      jaz: { scope: null },
      jbe: { scope: null },
      jbi: { scope: null },
      jbj: { scope: null },
      jbk: { scope: null },
      jbm: { scope: null },
      jbn: { scope: null },
      jbo: { scope: null },
      jbr: { scope: null },
      jbt: { scope: null },
      jbu: { scope: null },
      jbw: { scope: null },
      jcs: { scope: null },
      jct: { scope: null },
      jda: { scope: null },
      jdg: { scope: null },
      jdt: { scope: null },
      jeb: { scope: null },
      jee: { scope: null },
      jeg: { scope: null },
      jeh: { scope: null },
      jei: { scope: null },
      jek: { scope: null },
      jel: { scope: null },
      jen: { scope: null },
      jer: { scope: null },
      jet: { scope: null },
      jeu: { scope: null },
      jgb: { scope: null },
      jge: { scope: null },
      jgk: { scope: null },
      jgo: { scope: null },
      jhi: { scope: null },
      jhs: { scope: null },
      jia: { scope: null },
      jib: { scope: null },
      jic: { scope: null },
      jid: { scope: null },
      jie: { scope: null },
      jig: { scope: null },
      jih: { scope: null },
      jii: { scope: null },
      jil: { scope: null },
      jim: { scope: null },
      jio: { scope: null },
      jiq: { scope: null },
      jit: { scope: null },
      jiu: { scope: null },
      jiv: { scope: null },
      jiy: { scope: null },
      jje: { scope: null },
      jjr: { scope: null },
      jka: { scope: null },
      jkm: { scope: null },
      jko: { scope: null },
      jkp: { scope: null },
      jkr: { scope: null },
      jks: { scope: null },
      jku: { scope: null },
      jle: { scope: null },
      jls: { scope: null },
      jma: { scope: null },
      jmb: { scope: null },
      jmc: { scope: null },
      jmd: { scope: null },
      jmi: { scope: null },
      jml: { scope: null },
      jmn: { scope: null },
      jmr: { scope: null },
      jms: { scope: null },
      jmw: { scope: null },
      jmx: { scope: null },
      jna: { scope: null },
      jnd: { scope: null },
      jng: { scope: null },
      jni: { scope: null },
      jnj: { scope: null },
      jnl: { scope: null },
      jns: { scope: null },
      job: { scope: null },
      jod: { scope: null },
      jog: { scope: null },
      jor: { scope: null },
      jos: { scope: null },
      jow: { scope: null },
      jpa: { scope: null },
      jpr: { scope: null },
      jpx: { scope: "collection" },
      jqr: { scope: null },
      jra: { scope: null },
      jrb: { scope: "macrolanguage" },
      jrr: { scope: null },
      jrt: { scope: null },
      jru: { scope: null },
      jsl: { scope: null },
      jua: { scope: null },
      jub: { scope: null },
      juc: { scope: null },
      jud: { scope: null },
      juh: { scope: null },
      jui: { scope: null },
      juk: { scope: null },
      jul: { scope: null },
      jum: { scope: null },
      jun: { scope: null },
      juo: { scope: null },
      jup: { scope: null },
      jur: { scope: null },
      jus: { scope: null },
      jut: { scope: null },
      juu: { scope: null },
      juw: { scope: null },
      juy: { scope: null },
      jvd: { scope: null },
      jvn: { scope: null },
      jwi: { scope: null },
      jya: { scope: null },
      jye: { scope: null },
      jyy: { scope: null },
      kaa: { scope: null },
      kab: { scope: null },
      kac: { scope: null },
      kad: { scope: null },
      kae: { scope: null },
      kaf: { scope: null },
      kag: { scope: null },
      kah: { scope: null },
      kai: { scope: null },
      kaj: { scope: null },
      kak: { scope: null },
      kam: { scope: null },
      kao: { scope: null },
      kap: { scope: null },
      kaq: { scope: null },
      kar: { scope: "collection" },
      kav: { scope: null },
      kaw: { scope: null },
      kax: { scope: null },
      kay: { scope: null },
      kba: { scope: null },
      kbb: { scope: null },
      kbc: { scope: null },
      kbd: { scope: null },
      kbe: { scope: null },
      kbf: { scope: null },
      kbg: { scope: null },
      kbh: { scope: null },
      kbi: { scope: null },
      kbj: { scope: null },
      kbk: { scope: null },
      kbl: { scope: null },
      kbm: { scope: null },
      kbn: { scope: null },
      kbo: { scope: null },
      kbp: { scope: null },
      kbq: { scope: null },
      kbr: { scope: null },
      kbs: { scope: null },
      kbt: { scope: null },
      kbu: { scope: null },
      kbv: { scope: null },
      kbw: { scope: null },
      kbx: { scope: null },
      kby: { scope: null },
      kbz: { scope: null },
      kca: { scope: null },
      kcb: { scope: null },
      kcc: { scope: null },
      kcd: { scope: null },
      kce: { scope: null },
      kcf: { scope: null },
      kcg: { scope: null },
      kch: { scope: null },
      kci: { scope: null },
      kcj: { scope: null },
      kck: { scope: null },
      kcl: { scope: null },
      kcm: { scope: null },
      kcn: { scope: null },
      kco: { scope: null },
      kcp: { scope: null },
      kcq: { scope: null },
      kcr: { scope: null },
      kcs: { scope: null },
      kct: { scope: null },
      kcu: { scope: null },
      kcv: { scope: null },
      kcw: { scope: null },
      kcx: { scope: null },
      kcy: { scope: null },
      kcz: { scope: null },
      kda: { scope: null },
      kdc: { scope: null },
      kdd: { scope: null },
      kde: { scope: null },
      kdf: { scope: null },
      kdg: { scope: null },
      kdh: { scope: null },
      kdi: { scope: null },
      kdj: { scope: null },
      kdk: { scope: null },
      kdl: { scope: null },
      kdm: { scope: null },
      kdn: { scope: null },
      kdo: { scope: "collection" },
      kdp: { scope: null },
      kdq: { scope: null },
      kdr: { scope: null },
      kdt: { scope: null },
      kdu: { scope: null },
      kdv: { scope: null },
      kdw: { scope: null },
      kdx: { scope: null },
      kdy: { scope: null },
      kdz: { scope: null },
      kea: { scope: null },
      keb: { scope: null },
      kec: { scope: null },
      ked: { scope: null },
      kee: { scope: null },
      kef: { scope: null },
      keg: { scope: null },
      keh: { scope: null },
      kei: { scope: null },
      kej: { scope: null },
      kek: { scope: null },
      kel: { scope: null },
      kem: { scope: null },
      ken: { scope: null },
      keo: { scope: null },
      kep: { scope: null },
      keq: { scope: null },
      ker: { scope: null },
      kes: { scope: null },
      ket: { scope: null },
      keu: { scope: null },
      kev: { scope: null },
      kew: { scope: null },
      kex: { scope: null },
      key: { scope: null },
      kez: { scope: null },
      kfa: { scope: null },
      kfb: { scope: null },
      kfc: { scope: null },
      kfd: { scope: null },
      kfe: { scope: null },
      kff: { scope: null },
      kfg: { scope: null },
      kfh: { scope: null },
      kfi: { scope: null },
      kfj: { scope: null },
      kfk: { scope: null },
      kfl: { scope: null },
      kfm: { scope: null },
      kfn: { scope: null },
      kfo: { scope: null },
      kfp: { scope: null },
      kfq: { scope: null },
      kfr: { scope: null },
      kfs: { scope: null },
      kft: { scope: null },
      kfu: { scope: null },
      kfv: { scope: null },
      kfw: { scope: null },
      kfx: { scope: null },
      kfy: { scope: null },
      kfz: { scope: null },
      kga: { scope: null },
      kgb: { scope: null },
      kgc: { scope: null },
      kgd: { scope: null },
      kge: { scope: null },
      kgf: { scope: null },
      kgg: { scope: null },
      kgh: { scope: null },
      kgi: { scope: null },
      kgj: { scope: null },
      kgk: { scope: null },
      kgl: { scope: null },
      kgm: { scope: null },
      kgn: { scope: null },
      kgo: { scope: null },
      kgp: { scope: null },
      kgq: { scope: null },
      kgr: { scope: null },
      kgs: { scope: null },
      kgt: { scope: null },
      kgu: { scope: null },
      kgv: { scope: null },
      kgw: { scope: null },
      kgx: { scope: null },
      kgy: { scope: null },
      kha: { scope: null },
      khb: { scope: null },
      khc: { scope: null },
      khd: { scope: null },
      khe: { scope: null },
      khf: { scope: null },
      khg: { scope: null },
      khh: { scope: null },
      khi: { scope: "collection" },
      khj: { scope: null },
      khk: { scope: null },
      khl: { scope: null },
      khn: { scope: null },
      kho: { scope: null },
      khp: { scope: null },
      khq: { scope: null },
      khr: { scope: null },
      khs: { scope: null },
      kht: { scope: null },
      khu: { scope: null },
      khv: { scope: null },
      khw: { scope: null },
      khx: { scope: null },
      khy: { scope: null },
      khz: { scope: null },
      kia: { scope: null },
      kib: { scope: null },
      kic: { scope: null },
      kid: { scope: null },
      kie: { scope: null },
      kif: { scope: null },
      kig: { scope: null },
      kih: { scope: null },
      kii: { scope: null },
      kij: { scope: null },
      kil: { scope: null },
      kim: { scope: null },
      kio: { scope: null },
      kip: { scope: null },
      kiq: { scope: null },
      kis: { scope: null },
      kit: { scope: null },
      kiu: { scope: null },
      kiv: { scope: null },
      kiw: { scope: null },
      kix: { scope: null },
      kiy: { scope: null },
      kiz: { scope: null },
      kja: { scope: null },
      kjb: { scope: null },
      kjc: { scope: null },
      kjd: { scope: null },
      kje: { scope: null },
      kjf: { scope: null },
      kjg: { scope: null },
      kjh: { scope: null },
      kji: { scope: null },
      kjj: { scope: null },
      kjk: { scope: null },
      kjl: { scope: null },
      kjm: { scope: null },
      kjn: { scope: null },
      kjo: { scope: null },
      kjp: { scope: null },
      kjq: { scope: null },
      kjr: { scope: null },
      kjs: { scope: null },
      kjt: { scope: null },
      kju: { scope: null },
      kjv: { scope: null },
      kjx: { scope: null },
      kjy: { scope: null },
      kjz: { scope: null },
      kka: { scope: null },
      kkb: { scope: null },
      kkc: { scope: null },
      kkd: { scope: null },
      kke: { scope: null },
      kkf: { scope: null },
      kkg: { scope: null },
      kkh: { scope: null },
      kki: { scope: null },
      kkj: { scope: null },
      kkk: { scope: null },
      kkl: { scope: null },
      kkm: { scope: null },
      kkn: { scope: null },
      kko: { scope: null },
      kkp: { scope: null },
      kkq: { scope: null },
      kkr: { scope: null },
      kks: { scope: null },
      kkt: { scope: null },
      kku: { scope: null },
      kkv: { scope: null },
      kkw: { scope: null },
      kkx: { scope: null },
      kky: { scope: null },
      kkz: { scope: null },
      kla: { scope: null },
      klb: { scope: null },
      klc: { scope: null },
      kld: { scope: null },
      kle: { scope: null },
      klf: { scope: null },
      klg: { scope: null },
      klh: { scope: null },
      kli: { scope: null },
      klj: { scope: null },
      klk: { scope: null },
      kll: { scope: null },
      klm: { scope: null },
      kln: { scope: "macrolanguage" },
      klo: { scope: null },
      klp: { scope: null },
      klq: { scope: null },
      klr: { scope: null },
      kls: { scope: null },
      klt: { scope: null },
      klu: { scope: null },
      klv: { scope: null },
      klw: { scope: null },
      klx: { scope: null },
      kly: { scope: null },
      klz: { scope: null },
      kma: { scope: null },
      kmb: { scope: null },
      kmc: { scope: null },
      kmd: { scope: null },
      kme: { scope: null },
      kmf: { scope: null },
      kmg: { scope: null },
      kmh: { scope: null },
      kmi: { scope: null },
      kmj: { scope: null },
      kmk: { scope: null },
      kml: { scope: null },
      kmm: { scope: null },
      kmn: { scope: null },
      kmo: { scope: null },
      kmp: { scope: null },
      kmq: { scope: null },
      kmr: { scope: null },
      kms: { scope: null },
      kmt: { scope: null },
      kmu: { scope: null },
      kmv: { scope: null },
      kmw: { scope: null },
      kmx: { scope: null },
      kmy: { scope: null },
      kmz: { scope: null },
      kna: { scope: null },
      knb: { scope: null },
      knc: { scope: null },
      knd: { scope: null },
      kne: { scope: null },
      knf: { scope: null },
      kng: { scope: null },
      kni: { scope: null },
      knj: { scope: null },
      knk: { scope: null },
      knl: { scope: null },
      knm: { scope: null },
      knn: { scope: null },
      kno: { scope: null },
      knp: { scope: null },
      knq: { scope: null },
      knr: { scope: null },
      kns: { scope: null },
      knt: { scope: null },
      knu: { scope: null },
      knv: { scope: null },
      knw: { scope: null },
      knx: { scope: null },
      kny: { scope: null },
      knz: { scope: null },
      koa: { scope: null },
      koc: { scope: null },
      kod: { scope: null },
      koe: { scope: null },
      kof: { scope: null },
      kog: { scope: null },
      koh: { scope: null },
      koi: { scope: null },
      koj: { scope: null },
      kok: { scope: "macrolanguage" },
      kol: { scope: null },
      koo: { scope: null },
      kop: { scope: null },
      koq: { scope: null },
      kos: { scope: null },
      kot: { scope: null },
      kou: { scope: null },
      kov: { scope: null },
      kow: { scope: null },
      kox: { scope: null },
      koy: { scope: null },
      koz: { scope: null },
      kpa: { scope: null },
      kpb: { scope: null },
      kpc: { scope: null },
      kpd: { scope: null },
      kpe: { scope: "macrolanguage" },
      kpf: { scope: null },
      kpg: { scope: null },
      kph: { scope: null },
      kpi: { scope: null },
      kpj: { scope: null },
      kpk: { scope: null },
      kpl: { scope: null },
      kpm: { scope: null },
      kpn: { scope: null },
      kpo: { scope: null },
      kpp: { scope: null },
      kpq: { scope: null },
      kpr: { scope: null },
      kps: { scope: null },
      kpt: { scope: null },
      kpu: { scope: null },
      kpv: { scope: null },
      kpw: { scope: null },
      kpx: { scope: null },
      kpy: { scope: null },
      kpz: { scope: null },
      kqa: { scope: null },
      kqb: { scope: null },
      kqc: { scope: null },
      kqd: { scope: null },
      kqe: { scope: null },
      kqf: { scope: null },
      kqg: { scope: null },
      kqh: { scope: null },
      kqi: { scope: null },
      kqj: { scope: null },
      kqk: { scope: null },
      kql: { scope: null },
      kqm: { scope: null },
      kqn: { scope: null },
      kqo: { scope: null },
      kqp: { scope: null },
      kqq: { scope: null },
      kqr: { scope: null },
      kqs: { scope: null },
      kqt: { scope: null },
      kqu: { scope: null },
      kqv: { scope: null },
      kqw: { scope: null },
      kqx: { scope: null },
      kqy: { scope: null },
      kqz: { scope: null },
      kra: { scope: null },
      krb: { scope: null },
      krc: { scope: null },
      krd: { scope: null },
      kre: { scope: null },
      krf: { scope: null },
      krh: { scope: null },
      kri: { scope: null },
      krj: { scope: null },
      krk: { scope: null },
      krl: { scope: null },
      krm: { scope: null },
      krn: { scope: null },
      kro: { scope: "collection" },
      krp: { scope: null },
      krr: { scope: null },
      krs: { scope: null },
      krt: { scope: null },
      kru: { scope: null },
      krv: { scope: null },
      krw: { scope: null },
      krx: { scope: null },
      kry: { scope: null },
      krz: { scope: null },
      ksa: { scope: null },
      ksb: { scope: null },
      ksc: { scope: null },
      ksd: { scope: null },
      kse: { scope: null },
      ksf: { scope: null },
      ksg: { scope: null },
      ksh: { scope: null },
      ksi: { scope: null },
      ksj: { scope: null },
      ksk: { scope: null },
      ksl: { scope: null },
      ksm: { scope: null },
      ksn: { scope: null },
      kso: { scope: null },
      ksp: { scope: null },
      ksq: { scope: null },
      ksr: { scope: null },
      kss: { scope: null },
      kst: { scope: null },
      ksu: { scope: null },
      ksv: { scope: null },
      ksw: { scope: null },
      ksx: { scope: null },
      ksy: { scope: null },
      ksz: { scope: null },
      kta: { scope: null },
      ktb: { scope: null },
      ktc: { scope: null },
      ktd: { scope: null },
      kte: { scope: null },
      ktf: { scope: null },
      ktg: { scope: null },
      kth: { scope: null },
      kti: { scope: null },
      ktj: { scope: null },
      ktk: { scope: null },
      ktl: { scope: null },
      ktm: { scope: null },
      ktn: { scope: null },
      kto: { scope: null },
      ktp: { scope: null },
      ktq: { scope: null },
      ktr: { scope: null },
      kts: { scope: null },
      ktt: { scope: null },
      ktu: { scope: null },
      ktv: { scope: null },
      ktw: { scope: null },
      ktx: { scope: null },
      kty: { scope: null },
      ktz: { scope: null },
      kub: { scope: null },
      kuc: { scope: null },
      kud: { scope: null },
      kue: { scope: null },
      kuf: { scope: null },
      kug: { scope: null },
      kuh: { scope: null },
      kui: { scope: null },
      kuj: { scope: null },
      kuk: { scope: null },
      kul: { scope: null },
      kum: { scope: null },
      kun: { scope: null },
      kuo: { scope: null },
      kup: { scope: null },
      kuq: { scope: null },
      kus: { scope: null },
      kut: { scope: null },
      kuu: { scope: null },
      kuv: { scope: null },
      kuw: { scope: null },
      kux: { scope: null },
      kuy: { scope: null },
      kuz: { scope: null },
      kva: { scope: null },
      kvb: { scope: null },
      kvc: { scope: null },
      kvd: { scope: null },
      kve: { scope: null },
      kvf: { scope: null },
      kvg: { scope: null },
      kvh: { scope: null },
      kvi: { scope: null },
      kvj: { scope: null },
      kvk: { scope: null },
      kvl: { scope: null },
      kvm: { scope: null },
      kvn: { scope: null },
      kvo: { scope: null },
      kvp: { scope: null },
      kvq: { scope: null },
      kvr: { scope: null },
      kvs: { scope: null },
      kvt: { scope: null },
      kvu: { scope: null },
      kvv: { scope: null },
      kvw: { scope: null },
      kvx: { scope: null },
      kvy: { scope: null },
      kvz: { scope: null },
      kwa: { scope: null },
      kwb: { scope: null },
      kwc: { scope: null },
      kwd: { scope: null },
      kwe: { scope: null },
      kwf: { scope: null },
      kwg: { scope: null },
      kwh: { scope: null },
      kwi: { scope: null },
      kwj: { scope: null },
      kwk: { scope: null },
      kwl: { scope: null },
      kwm: { scope: null },
      kwn: { scope: null },
      kwo: { scope: null },
      kwp: { scope: null },
      kwq: { scope: null },
      kwr: { scope: null },
      kws: { scope: null },
      kwt: { scope: null },
      kwu: { scope: null },
      kwv: { scope: null },
      kww: { scope: null },
      kwx: { scope: null },
      kwy: { scope: null },
      kwz: { scope: null },
      kxa: { scope: null },
      kxb: { scope: null },
      kxc: { scope: null },
      kxd: { scope: null },
      kxe: { scope: null },
      kxf: { scope: null },
      kxh: { scope: null },
      kxi: { scope: null },
      kxj: { scope: null },
      kxk: { scope: null },
      kxl: { scope: null },
      kxm: { scope: null },
      kxn: { scope: null },
      kxo: { scope: null },
      kxp: { scope: null },
      kxq: { scope: null },
      kxr: { scope: null },
      kxs: { scope: null },
      kxt: { scope: null },
      kxu: { scope: null },
      kxv: { scope: null },
      kxw: { scope: null },
      kxx: { scope: null },
      kxy: { scope: null },
      kxz: { scope: null },
      kya: { scope: null },
      kyb: { scope: null },
      kyc: { scope: null },
      kyd: { scope: null },
      kye: { scope: null },
      kyf: { scope: null },
      kyg: { scope: null },
      kyh: { scope: null },
      kyi: { scope: null },
      kyj: { scope: null },
      kyk: { scope: null },
      kyl: { scope: null },
      kym: { scope: null },
      kyn: { scope: null },
      kyo: { scope: null },
      kyp: { scope: null },
      kyq: { scope: null },
      kyr: { scope: null },
      kys: { scope: null },
      kyt: { scope: null },
      kyu: { scope: null },
      kyv: { scope: null },
      kyw: { scope: null },
      kyx: { scope: null },
      kyy: { scope: null },
      kyz: { scope: null },
      kza: { scope: null },
      kzb: { scope: null },
      kzc: { scope: null },
      kzd: { scope: null },
      kze: { scope: null },
      kzf: { scope: null },
      kzg: { scope: null },
      kzh: { scope: null },
      kzi: { scope: null },
      kzj: { scope: null },
      kzk: { scope: null },
      kzl: { scope: null },
      kzm: { scope: null },
      kzn: { scope: null },
      kzo: { scope: null },
      kzp: { scope: null },
      kzq: { scope: null },
      kzr: { scope: null },
      kzs: { scope: null },
      kzt: { scope: null },
      kzu: { scope: null },
      kzv: { scope: null },
      kzw: { scope: null },
      kzx: { scope: null },
      kzy: { scope: null },
      kzz: { scope: null },
      laa: { scope: null },
      lab: { scope: null },
      lac: { scope: null },
      lad: { scope: null },
      lae: { scope: null },
      laf: { scope: null },
      lag: { scope: null },
      lah: { scope: "macrolanguage" },
      lai: { scope: null },
      laj: { scope: null },
      lak: { scope: null },
      lal: { scope: null },
      lam: { scope: null },
      lan: { scope: null },
      lap: { scope: null },
      laq: { scope: null },
      lar: { scope: null },
      las: { scope: null },
      lau: { scope: null },
      law: { scope: null },
      lax: { scope: null },
      lay: { scope: null },
      laz: { scope: null },
      lba: { scope: null },
      lbb: { scope: null },
      lbc: { scope: null },
      lbe: { scope: null },
      lbf: { scope: null },
      lbg: { scope: null },
      lbi: { scope: null },
      lbj: { scope: null },
      lbk: { scope: null },
      lbl: { scope: null },
      lbm: { scope: null },
      lbn: { scope: null },
      lbo: { scope: null },
      lbq: { scope: null },
      lbr: { scope: null },
      lbs: { scope: null },
      lbt: { scope: null },
      lbu: { scope: null },
      lbv: { scope: null },
      lbw: { scope: null },
      lbx: { scope: null },
      lby: { scope: null },
      lbz: { scope: null },
      lcc: { scope: null },
      lcd: { scope: null },
      lce: { scope: null },
      lcf: { scope: null },
      lch: { scope: null },
      lcl: { scope: null },
      lcm: { scope: null },
      lcp: { scope: null },
      lcq: { scope: null },
      lcs: { scope: null },
      lda: { scope: null },
      ldb: { scope: null },
      ldd: { scope: null },
      ldg: { scope: null },
      ldh: { scope: null },
      ldi: { scope: null },
      ldj: { scope: null },
      ldk: { scope: null },
      ldl: { scope: null },
      ldm: { scope: null },
      ldn: { scope: null },
      ldo: { scope: null },
      ldp: { scope: null },
      ldq: { scope: null },
      lea: { scope: null },
      leb: { scope: null },
      lec: { scope: null },
      led: { scope: null },
      lee: { scope: null },
      lef: { scope: null },
      leg: { scope: null },
      leh: { scope: null },
      lei: { scope: null },
      lej: { scope: null },
      lek: { scope: null },
      lel: { scope: null },
      lem: { scope: null },
      len: { scope: null },
      leo: { scope: null },
      lep: { scope: null },
      leq: { scope: null },
      ler: { scope: null },
      les: { scope: null },
      let: { scope: null },
      leu: { scope: null },
      lev: { scope: null },
      lew: { scope: null },
      lex: { scope: null },
      ley: { scope: null },
      lez: { scope: null },
      lfa: { scope: null },
      lfn: { scope: null },
      lga: { scope: null },
      lgb: { scope: null },
      lgg: { scope: null },
      lgh: { scope: null },
      lgi: { scope: null },
      lgk: { scope: null },
      lgl: { scope: null },
      lgm: { scope: null },
      lgn: { scope: null },
      lgq: { scope: null },
      lgr: { scope: null },
      lgt: { scope: null },
      lgu: { scope: null },
      lgz: { scope: null },
      lha: { scope: null },
      lhh: { scope: null },
      lhi: { scope: null },
      lhl: { scope: null },
      lhm: { scope: null },
      lhn: { scope: null },
      lhp: { scope: null },
      lhs: { scope: null },
      lht: { scope: null },
      lhu: { scope: null },
      lia: { scope: null },
      lib: { scope: null },
      lic: { scope: null },
      lid: { scope: null },
      lie: { scope: null },
      lif: { scope: null },
      lig: { scope: null },
      lih: { scope: null },
      lii: { scope: null },
      lij: { scope: null },
      lik: { scope: null },
      lil: { scope: null },
      lio: { scope: null },
      lip: { scope: null },
      liq: { scope: null },
      lir: { scope: null },
      lis: { scope: null },
      liu: { scope: null },
      liv: { scope: null },
      liw: { scope: null },
      lix: { scope: null },
      liy: { scope: null },
      liz: { scope: null },
      lja: { scope: null },
      lje: { scope: null },
      lji: { scope: null },
      ljl: { scope: null },
      ljp: { scope: null },
      ljw: { scope: null },
      ljx: { scope: null },
      lka: { scope: null },
      lkb: { scope: null },
      lkc: { scope: null },
      lkd: { scope: null },
      lke: { scope: null },
      lkh: { scope: null },
      lki: { scope: null },
      lkj: { scope: null },
      lkl: { scope: null },
      lkm: { scope: null },
      lkn: { scope: null },
      lko: { scope: null },
      lkr: { scope: null },
      lks: { scope: null },
      lkt: { scope: null },
      lku: { scope: null },
      lky: { scope: null },
      lla: { scope: null },
      llb: { scope: null },
      llc: { scope: null },
      lld: { scope: null },
      lle: { scope: null },
      llf: { scope: null },
      llg: { scope: null },
      llh: { scope: null },
      lli: { scope: null },
      llj: { scope: null },
      llk: { scope: null },
      lll: { scope: null },
      llm: { scope: null },
      lln: { scope: null },
      llo: { scope: null },
      llp: { scope: null },
      llq: { scope: null },
      lls: { scope: null },
      llu: { scope: null },
      llx: { scope: null },
      lma: { scope: null },
      lmb: { scope: null },
      lmc: { scope: null },
      lmd: { scope: null },
      lme: { scope: null },
      lmf: { scope: null },
      lmg: { scope: null },
      lmh: { scope: null },
      lmi: { scope: null },
      lmj: { scope: null },
      lmk: { scope: null },
      lml: { scope: null },
      lmm: { scope: null },
      lmn: { scope: null },
      lmo: { scope: null },
      lmp: { scope: null },
      lmq: { scope: null },
      lmr: { scope: null },
      lmu: { scope: null },
      lmv: { scope: null },
      lmw: { scope: null },
      lmx: { scope: null },
      lmy: { scope: null },
      lmz: { scope: null },
      lna: { scope: null },
      lnb: { scope: null },
      lnd: { scope: null },
      lng: { scope: null },
      lnh: { scope: null },
      lni: { scope: null },
      lnj: { scope: null },
      lnl: { scope: null },
      lnm: { scope: null },
      lnn: { scope: null },
      lno: { scope: null },
      lns: { scope: null },
      lnu: { scope: null },
      lnw: { scope: null },
      lnz: { scope: null },
      loa: { scope: null },
      lob: { scope: null },
      loc: { scope: null },
      loe: { scope: null },
      lof: { scope: null },
      log: { scope: null },
      loh: { scope: null },
      loi: { scope: null },
      loj: { scope: null },
      lok: { scope: null },
      lol: { scope: null },
      lom: { scope: null },
      lon: { scope: null },
      loo: { scope: null },
      lop: { scope: null },
      loq: { scope: null },
      lor: { scope: null },
      los: { scope: null },
      lot: { scope: null },
      lou: { scope: null },
      lov: { scope: null },
      low: { scope: null },
      lox: { scope: null },
      loy: { scope: null },
      loz: { scope: null },
      lpa: { scope: null },
      lpe: { scope: null },
      lpn: { scope: null },
      lpo: { scope: null },
      lpx: { scope: null },
      lra: { scope: null },
      lrc: { scope: null },
      lre: { scope: null },
      lrg: { scope: null },
      lri: { scope: null },
      lrk: { scope: null },
      lrl: { scope: null },
      lrm: { scope: null },
      lrn: { scope: null },
      lro: { scope: null },
      lrr: { scope: null },
      lrt: { scope: null },
      lrv: { scope: null },
      lrz: { scope: null },
      lsa: { scope: null },
      lsb: { scope: null },
      lsd: { scope: null },
      lse: { scope: null },
      lsg: { scope: null },
      lsh: { scope: null },
      lsi: { scope: null },
      lsl: { scope: null },
      lsm: { scope: null },
      lsn: { scope: null },
      lso: { scope: null },
      lsp: { scope: null },
      lsr: { scope: null },
      lss: { scope: null },
      lst: { scope: null },
      lsv: { scope: null },
      lsy: { scope: null },
      ltc: { scope: null },
      ltg: { scope: null },
      lth: { scope: null },
      lti: { scope: null },
      ltn: { scope: null },
      lto: { scope: null },
      lts: { scope: null },
      ltu: { scope: null },
      lua: { scope: null },
      luc: { scope: null },
      lud: { scope: null },
      lue: { scope: null },
      luf: { scope: null },
      lui: { scope: null },
      luj: { scope: null },
      luk: { scope: null },
      lul: { scope: null },
      lum: { scope: null },
      lun: { scope: null },
      luo: { scope: null },
      lup: { scope: null },
      luq: { scope: null },
      lur: { scope: null },
      lus: { scope: null },
      lut: { scope: null },
      luu: { scope: null },
      luv: { scope: null },
      luw: { scope: null },
      luy: { scope: "macrolanguage" },
      luz: { scope: null },
      lva: { scope: null },
      lvi: { scope: null },
      lvk: { scope: null },
      lvs: { scope: null },
      lvu: { scope: null },
      lwa: { scope: null },
      lwe: { scope: null },
      lwg: { scope: null },
      lwh: { scope: null },
      lwl: { scope: null },
      lwm: { scope: null },
      lwo: { scope: null },
      lws: { scope: null },
      lwt: { scope: null },
      lwu: { scope: null },
      lww: { scope: null },
      lxm: { scope: null },
      lya: { scope: null },
      lyg: { scope: null },
      lyn: { scope: null },
      lzh: { scope: null },
      lzl: { scope: null },
      lzn: { scope: null },
      lzz: { scope: null },
      maa: { scope: null },
      mab: { scope: null },
      mad: { scope: null },
      mae: { scope: null },
      maf: { scope: null },
      mag: { scope: null },
      mai: { scope: null },
      maj: { scope: null },
      mak: { scope: null },
      mam: { scope: null },
      man: { scope: "macrolanguage" },
      map: { scope: "collection" },
      maq: { scope: null },
      mas: { scope: null },
      mat: { scope: null },
      mau: { scope: null },
      mav: { scope: null },
      maw: { scope: null },
      max: { scope: null },
      maz: { scope: null },
      mba: { scope: null },
      mbb: { scope: null },
      mbc: { scope: null },
      mbd: { scope: null },
      mbe: { scope: null },
      mbf: { scope: null },
      mbh: { scope: null },
      mbi: { scope: null },
      mbj: { scope: null },
      mbk: { scope: null },
      mbl: { scope: null },
      mbm: { scope: null },
      mbn: { scope: null },
      mbo: { scope: null },
      mbp: { scope: null },
      mbq: { scope: null },
      mbr: { scope: null },
      mbs: { scope: null },
      mbt: { scope: null },
      mbu: { scope: null },
      mbv: { scope: null },
      mbw: { scope: null },
      mbx: { scope: null },
      mby: { scope: null },
      mbz: { scope: null },
      mca: { scope: null },
      mcb: { scope: null },
      mcc: { scope: null },
      mcd: { scope: null },
      mce: { scope: null },
      mcf: { scope: null },
      mcg: { scope: null },
      mch: { scope: null },
      mci: { scope: null },
      mcj: { scope: null },
      mck: { scope: null },
      mcl: { scope: null },
      mcm: { scope: null },
      mcn: { scope: null },
      mco: { scope: null },
      mcp: { scope: null },
      mcq: { scope: null },
      mcr: { scope: null },
      mcs: { scope: null },
      mct: { scope: null },
      mcu: { scope: null },
      mcv: { scope: null },
      mcw: { scope: null },
      mcx: { scope: null },
      mcy: { scope: null },
      mcz: { scope: null },
      mda: { scope: null },
      mdb: { scope: null },
      mdc: { scope: null },
      mdd: { scope: null },
      mde: { scope: null },
      mdf: { scope: null },
      mdg: { scope: null },
      mdh: { scope: null },
      mdi: { scope: null },
      mdj: { scope: null },
      mdk: { scope: null },
      mdl: { scope: null },
      mdm: { scope: null },
      mdn: { scope: null },
      mdp: { scope: null },
      mdq: { scope: null },
      mdr: { scope: null },
      mds: { scope: null },
      mdt: { scope: null },
      mdu: { scope: null },
      mdv: { scope: null },
      mdw: { scope: null },
      mdx: { scope: null },
      mdy: { scope: null },
      mdz: { scope: null },
      mea: { scope: null },
      meb: { scope: null },
      mec: { scope: null },
      med: { scope: null },
      mee: { scope: null },
      mef: { scope: null },
      meg: { scope: null },
      meh: { scope: null },
      mei: { scope: null },
      mej: { scope: null },
      mek: { scope: null },
      mel: { scope: null },
      mem: { scope: null },
      men: { scope: null },
      meo: { scope: null },
      mep: { scope: null },
      meq: { scope: null },
      mer: { scope: null },
      mes: { scope: null },
      met: { scope: null },
      meu: { scope: null },
      mev: { scope: null },
      mew: { scope: null },
      mey: { scope: null },
      mez: { scope: null },
      mfa: { scope: null },
      mfb: { scope: null },
      mfc: { scope: null },
      mfd: { scope: null },
      mfe: { scope: null },
      mff: { scope: null },
      mfg: { scope: null },
      mfh: { scope: null },
      mfi: { scope: null },
      mfj: { scope: null },
      mfk: { scope: null },
      mfl: { scope: null },
      mfm: { scope: null },
      mfn: { scope: null },
      mfo: { scope: null },
      mfp: { scope: null },
      mfq: { scope: null },
      mfr: { scope: null },
      mfs: { scope: null },
      mft: { scope: null },
      mfu: { scope: null },
      mfv: { scope: null },
      mfw: { scope: null },
      mfx: { scope: null },
      mfy: { scope: null },
      mfz: { scope: null },
      mga: { scope: null },
      mgb: { scope: null },
      mgc: { scope: null },
      mgd: { scope: null },
      mge: { scope: null },
      mgf: { scope: null },
      mgg: { scope: null },
      mgh: { scope: null },
      mgi: { scope: null },
      mgj: { scope: null },
      mgk: { scope: null },
      mgl: { scope: null },
      mgm: { scope: null },
      mgn: { scope: null },
      mgo: { scope: null },
      mgp: { scope: null },
      mgq: { scope: null },
      mgr: { scope: null },
      mgs: { scope: null },
      mgt: { scope: null },
      mgu: { scope: null },
      mgv: { scope: null },
      mgw: { scope: null },
      mgx: { scope: null },
      mgy: { scope: null },
      mgz: { scope: null },
      mha: { scope: null },
      mhb: { scope: null },
      mhc: { scope: null },
      mhd: { scope: null },
      mhe: { scope: null },
      mhf: { scope: null },
      mhg: { scope: null },
      mhh: { scope: null },
      mhi: { scope: null },
      mhj: { scope: null },
      mhk: { scope: null },
      mhl: { scope: null },
      mhm: { scope: null },
      mhn: { scope: null },
      mho: { scope: null },
      mhp: { scope: null },
      mhq: { scope: null },
      mhr: { scope: null },
      mhs: { scope: null },
      mht: { scope: null },
      mhu: { scope: null },
      mhw: { scope: null },
      mhx: { scope: null },
      mhy: { scope: null },
      mhz: { scope: null },
      mia: { scope: null },
      mib: { scope: null },
      mic: { scope: null },
      mid: { scope: null },
      mie: { scope: null },
      mif: { scope: null },
      mig: { scope: null },
      mih: { scope: null },
      mii: { scope: null },
      mij: { scope: null },
      mik: { scope: null },
      mil: { scope: null },
      mim: { scope: null },
      min: { scope: null },
      mio: { scope: null },
      mip: { scope: null },
      miq: { scope: null },
      mir: { scope: null },
      mis: { scope: "special" },
      mit: { scope: null },
      miu: { scope: null },
      miw: { scope: null },
      mix: { scope: null },
      miy: { scope: null },
      miz: { scope: null },
      mja: { scope: null },
      mjb: { scope: null },
      mjc: { scope: null },
      mjd: { scope: null },
      mje: { scope: null },
      mjg: { scope: null },
      mjh: { scope: null },
      mji: { scope: null },
      mjj: { scope: null },
      mjk: { scope: null },
      mjl: { scope: null },
      mjm: { scope: null },
      mjn: { scope: null },
      mjo: { scope: null },
      mjp: { scope: null },
      mjq: { scope: null },
      mjr: { scope: null },
      mjs: { scope: null },
      mjt: { scope: null },
      mju: { scope: null },
      mjv: { scope: null },
      mjw: { scope: null },
      mjx: { scope: null },
      mjy: { scope: null },
      mjz: { scope: null },
      mka: { scope: null },
      mkb: { scope: null },
      mkc: { scope: null },
      mke: { scope: null },
      mkf: { scope: null },
      mkg: { scope: null },
      mkh: { scope: "collection" },
      mki: { scope: null },
      mkj: { scope: null },
      mkk: { scope: null },
      mkl: { scope: null },
      mkm: { scope: null },
      mkn: { scope: null },
      mko: { scope: null },
      mkp: { scope: null },
      mkq: { scope: null },
      mkr: { scope: null },
      mks: { scope: null },
      mkt: { scope: null },
      mku: { scope: null },
      mkv: { scope: null },
      mkw: { scope: null },
      mkx: { scope: null },
      mky: { scope: null },
      mkz: { scope: null },
      mla: { scope: null },
      mlb: { scope: null },
      mlc: { scope: null },
      mld: { scope: null },
      mle: { scope: null },
      mlf: { scope: null },
      mlh: { scope: null },
      mli: { scope: null },
      mlj: { scope: null },
      mlk: { scope: null },
      mll: { scope: null },
      mlm: { scope: null },
      mln: { scope: null },
      mlo: { scope: null },
      mlp: { scope: null },
      mlq: { scope: null },
      mlr: { scope: null },
      mls: { scope: null },
      mlu: { scope: null },
      mlv: { scope: null },
      mlw: { scope: null },
      mlx: { scope: null },
      mlz: { scope: null },
      mma: { scope: null },
      mmb: { scope: null },
      mmc: { scope: null },
      mmd: { scope: null },
      mme: { scope: null },
      mmf: { scope: null },
      mmg: { scope: null },
      mmh: { scope: null },
      mmi: { scope: null },
      mmj: { scope: null },
      mmk: { scope: null },
      mml: { scope: null },
      mmm: { scope: null },
      mmn: { scope: null },
      mmo: { scope: null },
      mmp: { scope: null },
      mmq: { scope: null },
      mmr: { scope: null },
      mmt: { scope: null },
      mmu: { scope: null },
      mmv: { scope: null },
      mmw: { scope: null },
      mmx: { scope: null },
      mmy: { scope: null },
      mmz: { scope: null },
      mna: { scope: null },
      mnb: { scope: null },
      mnc: { scope: null },
      mnd: { scope: null },
      mne: { scope: null },
      mnf: { scope: null },
      mng: { scope: null },
      mnh: { scope: null },
      mni: { scope: null },
      mnj: { scope: null },
      mnk: { scope: null },
      mnl: { scope: null },
      mnm: { scope: null },
      mnn: { scope: null },
      mno: { scope: "collection" },
      mnp: { scope: null },
      mnq: { scope: null },
      mnr: { scope: null },
      mns: { scope: null },
      mnt: { scope: null },
      mnu: { scope: null },
      mnv: { scope: null },
      mnw: { scope: null },
      mnx: { scope: null },
      mny: { scope: null },
      mnz: { scope: null },
      moa: { scope: null },
      moc: { scope: null },
      mod: { scope: null },
      moe: { scope: null },
      mof: { scope: null },
      mog: { scope: null },
      moh: { scope: null },
      moi: { scope: null },
      moj: { scope: null },
      mok: { scope: null },
      mom: { scope: null },
      moo: { scope: null },
      mop: { scope: null },
      moq: { scope: null },
      mor: { scope: null },
      mos: { scope: null },
      mot: { scope: null },
      mou: { scope: null },
      mov: { scope: null },
      mow: { scope: null },
      mox: { scope: null },
      moy: { scope: null },
      moz: { scope: null },
      mpa: { scope: null },
      mpb: { scope: null },
      mpc: { scope: null },
      mpd: { scope: null },
      mpe: { scope: null },
      mpg: { scope: null },
      mph: { scope: null },
      mpi: { scope: null },
      mpj: { scope: null },
      mpk: { scope: null },
      mpl: { scope: null },
      mpm: { scope: null },
      mpn: { scope: null },
      mpo: { scope: null },
      mpp: { scope: null },
      mpq: { scope: null },
      mpr: { scope: null },
      mps: { scope: null },
      mpt: { scope: null },
      mpu: { scope: null },
      mpv: { scope: null },
      mpw: { scope: null },
      mpx: { scope: null },
      mpy: { scope: null },
      mpz: { scope: null },
      mqa: { scope: null },
      mqb: { scope: null },
      mqc: { scope: null },
      mqe: { scope: null },
      mqf: { scope: null },
      mqg: { scope: null },
      mqh: { scope: null },
      mqi: { scope: null },
      mqj: { scope: null },
      mqk: { scope: null },
      mql: { scope: null },
      mqm: { scope: null },
      mqn: { scope: null },
      mqo: { scope: null },
      mqp: { scope: null },
      mqq: { scope: null },
      mqr: { scope: null },
      mqs: { scope: null },
      mqt: { scope: null },
      mqu: { scope: null },
      mqv: { scope: null },
      mqw: { scope: null },
      mqx: { scope: null },
      mqy: { scope: null },
      mqz: { scope: null },
      mra: { scope: null },
      mrb: { scope: null },
      mrc: { scope: null },
      mrd: { scope: null },
      mre: { scope: null },
      mrf: { scope: null },
      mrg: { scope: null },
      mrh: { scope: null },
      mrj: { scope: null },
      mrk: { scope: null },
      mrl: { scope: null },
      mrm: { scope: null },
      mrn: { scope: null },
      mro: { scope: null },
      mrp: { scope: null },
      mrq: { scope: null },
      mrr: { scope: null },
      mrs: { scope: null },
      mrt: { scope: null },
      mru: { scope: null },
      mrv: { scope: null },
      mrw: { scope: null },
      mrx: { scope: null },
      mry: { scope: null },
      mrz: { scope: null },
      msb: { scope: null },
      msc: { scope: null },
      msd: { scope: null },
      mse: { scope: null },
      msf: { scope: null },
      msg: { scope: null },
      msh: { scope: null },
      msi: { scope: null },
      msj: { scope: null },
      msk: { scope: null },
      msl: { scope: null },
      msm: { scope: null },
      msn: { scope: null },
      mso: { scope: null },
      msp: { scope: null },
      msq: { scope: null },
      msr: { scope: null },
      mss: { scope: null },
      mst: { scope: null },
      msu: { scope: null },
      msv: { scope: null },
      msw: { scope: null },
      msx: { scope: null },
      msy: { scope: null },
      msz: { scope: null },
      mta: { scope: null },
      mtb: { scope: null },
      mtc: { scope: null },
      mtd: { scope: null },
      mte: { scope: null },
      mtf: { scope: null },
      mtg: { scope: null },
      mth: { scope: null },
      mti: { scope: null },
      mtj: { scope: null },
      mtk: { scope: null },
      mtl: { scope: null },
      mtm: { scope: null },
      mtn: { scope: null },
      mto: { scope: null },
      mtp: { scope: null },
      mtq: { scope: null },
      mtr: { scope: null },
      mts: { scope: null },
      mtt: { scope: null },
      mtu: { scope: null },
      mtv: { scope: null },
      mtw: { scope: null },
      mtx: { scope: null },
      mty: { scope: null },
      mua: { scope: null },
      mub: { scope: null },
      muc: { scope: null },
      mud: { scope: null },
      mue: { scope: null },
      mug: { scope: null },
      muh: { scope: null },
      mui: { scope: null },
      muj: { scope: null },
      muk: { scope: null },
      mul: { scope: "special" },
      mum: { scope: null },
      mun: { scope: "collection" },
      muo: { scope: null },
      mup: { scope: null },
      muq: { scope: null },
      mur: { scope: null },
      mus: { scope: null },
      mut: { scope: null },
      muu: { scope: null },
      muv: { scope: null },
      mux: { scope: null },
      muy: { scope: null },
      muz: { scope: null },
      mva: { scope: null },
      mvb: { scope: null },
      mvd: { scope: null },
      mve: { scope: null },
      mvf: { scope: null },
      mvg: { scope: null },
      mvh: { scope: null },
      mvi: { scope: null },
      mvk: { scope: null },
      mvl: { scope: null },
      mvm: { scope: null },
      mvn: { scope: null },
      mvo: { scope: null },
      mvp: { scope: null },
      mvq: { scope: null },
      mvr: { scope: null },
      mvs: { scope: null },
      mvt: { scope: null },
      mvu: { scope: null },
      mvv: { scope: null },
      mvw: { scope: null },
      mvx: { scope: null },
      mvy: { scope: null },
      mvz: { scope: null },
      mwa: { scope: null },
      mwb: { scope: null },
      mwc: { scope: null },
      mwd: { scope: null },
      mwe: { scope: null },
      mwf: { scope: null },
      mwg: { scope: null },
      mwh: { scope: null },
      mwi: { scope: null },
      mwj: { scope: null },
      mwk: { scope: null },
      mwl: { scope: null },
      mwm: { scope: null },
      mwn: { scope: null },
      mwo: { scope: null },
      mwp: { scope: null },
      mwq: { scope: null },
      mwr: { scope: "macrolanguage" },
      mws: { scope: null },
      mwt: { scope: null },
      mwu: { scope: null },
      mwv: { scope: null },
      mww: { scope: null },
      mwx: { scope: null },
      mwy: { scope: null },
      mwz: { scope: null },
      mxa: { scope: null },
      mxb: { scope: null },
      mxc: { scope: null },
      mxd: { scope: null },
      mxe: { scope: null },
      mxf: { scope: null },
      mxg: { scope: null },
      mxh: { scope: null },
      mxi: { scope: null },
      mxj: { scope: null },
      mxk: { scope: null },
      mxl: { scope: null },
      mxm: { scope: null },
      mxn: { scope: null },
      mxo: { scope: null },
      mxp: { scope: null },
      mxq: { scope: null },
      mxr: { scope: null },
      mxs: { scope: null },
      mxt: { scope: null },
      mxu: { scope: null },
      mxv: { scope: null },
      mxw: { scope: null },
      mxx: { scope: null },
      mxy: { scope: null },
      mxz: { scope: null },
      myb: { scope: null },
      myc: { scope: null },
      myd: { scope: null },
      mye: { scope: null },
      myf: { scope: null },
      myg: { scope: null },
      myh: { scope: null },
      myi: { scope: null },
      myj: { scope: null },
      myk: { scope: null },
      myl: { scope: null },
      mym: { scope: null },
      myn: { scope: "collection" },
      myo: { scope: null },
      myp: { scope: null },
      myq: { scope: null },
      myr: { scope: null },
      mys: { scope: null },
      myt: { scope: null },
      myu: { scope: null },
      myv: { scope: null },
      myw: { scope: null },
      myx: { scope: null },
      myy: { scope: null },
      myz: { scope: null },
      mza: { scope: null },
      mzb: { scope: null },
      mzc: { scope: null },
      mzd: { scope: null },
      mze: { scope: null },
      mzg: { scope: null },
      mzh: { scope: null },
      mzi: { scope: null },
      mzj: { scope: null },
      mzk: { scope: null },
      mzl: { scope: null },
      mzm: { scope: null },
      mzn: { scope: null },
      mzo: { scope: null },
      mzp: { scope: null },
      mzq: { scope: null },
      mzr: { scope: null },
      mzs: { scope: null },
      mzt: { scope: null },
      mzu: { scope: null },
      mzv: { scope: null },
      mzw: { scope: null },
      mzx: { scope: null },
      mzy: { scope: null },
      mzz: { scope: null },
      naa: { scope: null },
      nab: { scope: null },
      nac: { scope: null },
      nad: { scope: null },
      nae: { scope: null },
      naf: { scope: null },
      nag: { scope: null },
      nah: { scope: "collection" },
      nai: { scope: "collection" },
      naj: { scope: null },
      nak: { scope: null },
      nal: { scope: null },
      nam: { scope: null },
      nan: { scope: null },
      nao: { scope: null },
      nap: { scope: null },
      naq: { scope: null },
      nar: { scope: null },
      nas: { scope: null },
      nat: { scope: null },
      naw: { scope: null },
      nax: { scope: null },
      nay: { scope: null },
      naz: { scope: null },
      nba: { scope: null },
      nbb: { scope: null },
      nbc: { scope: null },
      nbd: { scope: null },
      nbe: { scope: null },
      nbf: { scope: null },
      nbg: { scope: null },
      nbh: { scope: null },
      nbi: { scope: null },
      nbj: { scope: null },
      nbk: { scope: null },
      nbm: { scope: null },
      nbn: { scope: null },
      nbo: { scope: null },
      nbp: { scope: null },
      nbq: { scope: null },
      nbr: { scope: null },
      nbs: { scope: null },
      nbt: { scope: null },
      nbu: { scope: null },
      nbv: { scope: null },
      nbw: { scope: null },
      nbx: { scope: null },
      nby: { scope: null },
      nca: { scope: null },
      ncb: { scope: null },
      ncc: { scope: null },
      ncd: { scope: null },
      nce: { scope: null },
      ncf: { scope: null },
      ncg: { scope: null },
      nch: { scope: null },
      nci: { scope: null },
      ncj: { scope: null },
      nck: { scope: null },
      ncl: { scope: null },
      ncm: { scope: null },
      ncn: { scope: null },
      nco: { scope: null },
      ncp: { scope: null },
      ncq: { scope: null },
      ncr: { scope: null },
      ncs: { scope: null },
      nct: { scope: null },
      ncu: { scope: null },
      ncx: { scope: null },
      ncz: { scope: null },
      nda: { scope: null },
      ndb: { scope: null },
      ndc: { scope: null },
      ndd: { scope: null },
      ndf: { scope: null },
      ndg: { scope: null },
      ndh: { scope: null },
      ndi: { scope: null },
      ndj: { scope: null },
      ndk: { scope: null },
      ndl: { scope: null },
      ndm: { scope: null },
      ndn: { scope: null },
      ndp: { scope: null },
      ndq: { scope: null },
      ndr: { scope: null },
      nds: { scope: null },
      ndt: { scope: null },
      ndu: { scope: null },
      ndv: { scope: null },
      ndw: { scope: null },
      ndx: { scope: null },
      ndy: { scope: null },
      ndz: { scope: null },
      nea: { scope: null },
      neb: { scope: null },
      nec: { scope: null },
      ned: { scope: null },
      nee: { scope: null },
      nef: { scope: null },
      neg: { scope: null },
      neh: { scope: null },
      nei: { scope: null },
      nej: { scope: null },
      nek: { scope: null },
      nem: { scope: null },
      nen: { scope: null },
      neo: { scope: null },
      neq: { scope: null },
      ner: { scope: null },
      nes: { scope: null },
      net: { scope: null },
      neu: { scope: null },
      nev: { scope: null },
      new: { scope: null },
      nex: { scope: null },
      ney: { scope: null },
      nez: { scope: null },
      nfa: { scope: null },
      nfd: { scope: null },
      nfl: { scope: null },
      nfr: { scope: null },
      nfu: { scope: null },
      nga: { scope: null },
      ngb: { scope: null },
      ngc: { scope: null },
      ngd: { scope: null },
      nge: { scope: null },
      ngf: { scope: "collection" },
      ngg: { scope: null },
      ngh: { scope: null },
      ngi: { scope: null },
      ngj: { scope: null },
      ngk: { scope: null },
      ngl: { scope: null },
      ngm: { scope: null },
      ngn: { scope: null },
      ngo: { scope: null },
      ngp: { scope: null },
      ngq: { scope: null },
      ngr: { scope: null },
      ngs: { scope: null },
      ngt: { scope: null },
      ngu: { scope: null },
      ngv: { scope: null },
      ngw: { scope: null },
      ngx: { scope: null },
      ngy: { scope: null },
      ngz: { scope: null },
      nha: { scope: null },
      nhb: { scope: null },
      nhc: { scope: null },
      nhd: { scope: null },
      nhe: { scope: null },
      nhf: { scope: null },
      nhg: { scope: null },
      nhh: { scope: null },
      nhi: { scope: null },
      nhk: { scope: null },
      nhm: { scope: null },
      nhn: { scope: null },
      nho: { scope: null },
      nhp: { scope: null },
      nhq: { scope: null },
      nhr: { scope: null },
      nht: { scope: null },
      nhu: { scope: null },
      nhv: { scope: null },
      nhw: { scope: null },
      nhx: { scope: null },
      nhy: { scope: null },
      nhz: { scope: null },
      nia: { scope: null },
      nib: { scope: null },
      nic: { scope: "collection" },
      nid: { scope: null },
      nie: { scope: null },
      nif: { scope: null },
      nig: { scope: null },
      nih: { scope: null },
      nii: { scope: null },
      nij: { scope: null },
      nik: { scope: null },
      nil: { scope: null },
      nim: { scope: null },
      nin: { scope: null },
      nio: { scope: null },
      niq: { scope: null },
      nir: { scope: null },
      nis: { scope: null },
      nit: { scope: null },
      niu: { scope: null },
      niv: { scope: null },
      niw: { scope: null },
      nix: { scope: null },
      niy: { scope: null },
      niz: { scope: null },
      nja: { scope: null },
      njb: { scope: null },
      njd: { scope: null },
      njh: { scope: null },
      nji: { scope: null },
      njj: { scope: null },
      njl: { scope: null },
      njm: { scope: null },
      njn: { scope: null },
      njo: { scope: null },
      njr: { scope: null },
      njs: { scope: null },
      njt: { scope: null },
      nju: { scope: null },
      njx: { scope: null },
      njy: { scope: null },
      njz: { scope: null },
      nka: { scope: null },
      nkb: { scope: null },
      nkc: { scope: null },
      nkd: { scope: null },
      nke: { scope: null },
      nkf: { scope: null },
      nkg: { scope: null },
      nkh: { scope: null },
      nki: { scope: null },
      nkj: { scope: null },
      nkk: { scope: null },
      nkm: { scope: null },
      nkn: { scope: null },
      nko: { scope: null },
      nkp: { scope: null },
      nkq: { scope: null },
      nkr: { scope: null },
      nks: { scope: null },
      nkt: { scope: null },
      nku: { scope: null },
      nkv: { scope: null },
      nkw: { scope: null },
      nkx: { scope: null },
      nkz: { scope: null },
      nla: { scope: null },
      nlc: { scope: null },
      nle: { scope: null },
      nlg: { scope: null },
      nli: { scope: null },
      nlj: { scope: null },
      nlk: { scope: null },
      nll: { scope: null },
      nlm: { scope: null },
      nln: { scope: null },
      nlo: { scope: null },
      nlq: { scope: null },
      nlr: { scope: null },
      nlu: { scope: null },
      nlv: { scope: null },
      nlw: { scope: null },
      nlx: { scope: null },
      nly: { scope: null },
      nlz: { scope: null },
      nma: { scope: null },
      nmb: { scope: null },
      nmc: { scope: null },
      nmd: { scope: null },
      nme: { scope: null },
      nmf: { scope: null },
      nmg: { scope: null },
      nmh: { scope: null },
      nmi: { scope: null },
      nmj: { scope: null },
      nmk: { scope: null },
      nml: { scope: null },
      nmm: { scope: null },
      nmn: { scope: null },
      nmo: { scope: null },
      nmp: { scope: null },
      nmq: { scope: null },
      nmr: { scope: null },
      nms: { scope: null },
      nmt: { scope: null },
      nmu: { scope: null },
      nmv: { scope: null },
      nmw: { scope: null },
      nmx: { scope: null },
      nmy: { scope: null },
      nmz: { scope: null },
      nna: { scope: null },
      nnb: { scope: null },
      nnc: { scope: null },
      nnd: { scope: null },
      nne: { scope: null },
      nnf: { scope: null },
      nng: { scope: null },
      nnh: { scope: null },
      nni: { scope: null },
      nnj: { scope: null },
      nnk: { scope: null },
      nnl: { scope: null },
      nnm: { scope: null },
      nnn: { scope: null },
      nnp: { scope: null },
      nnq: { scope: null },
      nnr: { scope: null },
      nns: { scope: null },
      nnt: { scope: null },
      nnu: { scope: null },
      nnv: { scope: null },
      nnw: { scope: null },
      nnx: { scope: null },
      nny: { scope: null },
      nnz: { scope: null },
      noa: { scope: null },
      noc: { scope: null },
      nod: { scope: null },
      noe: { scope: null },
      nof: { scope: null },
      nog: { scope: null },
      noh: { scope: null },
      noi: { scope: null },
      noj: { scope: null },
      nok: { scope: null },
      nol: { scope: null },
      nom: { scope: null },
      non: { scope: null },
      noo: { scope: null },
      nop: { scope: null },
      noq: { scope: null },
      nos: { scope: null },
      not: { scope: null },
      nou: { scope: null },
      nov: { scope: null },
      now: { scope: null },
      noy: { scope: null },
      noz: { scope: null },
      npa: { scope: null },
      npb: { scope: null },
      npg: { scope: null },
      nph: { scope: null },
      npi: { scope: null },
      npl: { scope: null },
      npn: { scope: null },
      npo: { scope: null },
      nps: { scope: null },
      npu: { scope: null },
      npx: { scope: null },
      npy: { scope: null },
      nqg: { scope: null },
      nqk: { scope: null },
      nql: { scope: null },
      nqm: { scope: null },
      nqn: { scope: null },
      nqo: { scope: null },
      nqq: { scope: null },
      nqt: { scope: null },
      nqy: { scope: null },
      nra: { scope: null },
      nrb: { scope: null },
      nrc: { scope: null },
      nre: { scope: null },
      nrf: { scope: null },
      nrg: { scope: null },
      nri: { scope: null },
      nrk: { scope: null },
      nrl: { scope: null },
      nrm: { scope: null },
      nrn: { scope: null },
      nrp: { scope: null },
      nrr: { scope: null },
      nrt: { scope: null },
      nru: { scope: null },
      nrx: { scope: null },
      nrz: { scope: null },
      nsa: { scope: null },
      nsb: { scope: null },
      nsc: { scope: null },
      nsd: { scope: null },
      nse: { scope: null },
      nsf: { scope: null },
      nsg: { scope: null },
      nsh: { scope: null },
      nsi: { scope: null },
      nsk: { scope: null },
      nsl: { scope: null },
      nsm: { scope: null },
      nsn: { scope: null },
      nso: { scope: null },
      nsp: { scope: null },
      nsq: { scope: null },
      nsr: { scope: null },
      nss: { scope: null },
      nst: { scope: null },
      nsu: { scope: null },
      nsv: { scope: null },
      nsw: { scope: null },
      nsx: { scope: null },
      nsy: { scope: null },
      nsz: { scope: null },
      ntd: { scope: null },
      nte: { scope: null },
      ntg: { scope: null },
      nti: { scope: null },
      ntj: { scope: null },
      ntk: { scope: null },
      ntm: { scope: null },
      nto: { scope: null },
      ntp: { scope: null },
      ntr: { scope: null },
      nts: { scope: null },
      ntu: { scope: null },
      ntw: { scope: null },
      ntx: { scope: null },
      nty: { scope: null },
      ntz: { scope: null },
      nua: { scope: null },
      nub: { scope: "collection" },
      nuc: { scope: null },
      nud: { scope: null },
      nue: { scope: null },
      nuf: { scope: null },
      nug: { scope: null },
      nuh: { scope: null },
      nui: { scope: null },
      nuj: { scope: null },
      nuk: { scope: null },
      nul: { scope: null },
      num: { scope: null },
      nun: { scope: null },
      nuo: { scope: null },
      nup: { scope: null },
      nuq: { scope: null },
      nur: { scope: null },
      nus: { scope: null },
      nut: { scope: null },
      nuu: { scope: null },
      nuv: { scope: null },
      nuw: { scope: null },
      nux: { scope: null },
      nuy: { scope: null },
      nuz: { scope: null },
      nvh: { scope: null },
      nvm: { scope: null },
      nvo: { scope: null },
      nwa: { scope: null },
      nwb: { scope: null },
      nwc: { scope: null },
      nwe: { scope: null },
      nwg: { scope: null },
      nwi: { scope: null },
      nwm: { scope: null },
      nwo: { scope: null },
      nwr: { scope: null },
      nwx: { scope: null },
      nwy: { scope: null },
      nxa: { scope: null },
      nxd: { scope: null },
      nxe: { scope: null },
      nxg: { scope: null },
      nxi: { scope: null },
      nxk: { scope: null },
      nxl: { scope: null },
      nxm: { scope: null },
      nxn: { scope: null },
      nxo: { scope: null },
      nxq: { scope: null },
      nxr: { scope: null },
      nxu: { scope: null },
      nxx: { scope: null },
      nyb: { scope: null },
      nyc: { scope: null },
      nyd: { scope: null },
      nye: { scope: null },
      nyf: { scope: null },
      nyg: { scope: null },
      nyh: { scope: null },
      nyi: { scope: null },
      nyj: { scope: null },
      nyk: { scope: null },
      nyl: { scope: null },
      nym: { scope: null },
      nyn: { scope: null },
      nyo: { scope: null },
      nyp: { scope: null },
      nyq: { scope: null },
      nyr: { scope: null },
      nys: { scope: null },
      nyt: { scope: null },
      nyu: { scope: null },
      nyv: { scope: null },
      nyw: { scope: null },
      nyx: { scope: null },
      nyy: { scope: null },
      nza: { scope: null },
      nzb: { scope: null },
      nzd: { scope: null },
      nzi: { scope: null },
      nzk: { scope: null },
      nzm: { scope: null },
      nzs: { scope: null },
      nzu: { scope: null },
      nzy: { scope: null },
      nzz: { scope: null },
      oaa: { scope: null },
      oac: { scope: null },
      oar: { scope: null },
      oav: { scope: null },
      obi: { scope: null },
      obk: { scope: null },
      obl: { scope: null },
      obm: { scope: null },
      obo: { scope: null },
      obr: { scope: null },
      obt: { scope: null },
      obu: { scope: null },
      oca: { scope: null },
      och: { scope: null },
      ocm: { scope: null },
      oco: { scope: null },
      ocu: { scope: null },
      oda: { scope: null },
      odk: { scope: null },
      odt: { scope: null },
      odu: { scope: null },
      ofo: { scope: null },
      ofs: { scope: null },
      ofu: { scope: null },
      ogb: { scope: null },
      ogc: { scope: null },
      oge: { scope: null },
      ogg: { scope: null },
      ogo: { scope: null },
      ogu: { scope: null },
      oht: { scope: null },
      ohu: { scope: null },
      oia: { scope: null },
      oin: { scope: null },
      ojb: { scope: null },
      ojc: { scope: null },
      ojg: { scope: null },
      ojp: { scope: null },
      ojs: { scope: null },
      ojv: { scope: null },
      ojw: { scope: null },
      oka: { scope: null },
      okb: { scope: null },
      okc: { scope: null },
      okd: { scope: null },
      oke: { scope: null },
      okg: { scope: null },
      okh: { scope: null },
      oki: { scope: null },
      okj: { scope: null },
      okk: { scope: null },
      okl: { scope: null },
      okm: { scope: null },
      okn: { scope: null },
      oko: { scope: null },
      okr: { scope: null },
      oks: { scope: null },
      oku: { scope: null },
      okv: { scope: null },
      okx: { scope: null },
      okz: { scope: null },
      ola: { scope: null },
      old: { scope: null },
      ole: { scope: null },
      olk: { scope: null },
      olm: { scope: null },
      olo: { scope: null },
      olr: { scope: null },
      olt: { scope: null },
      olu: { scope: null },
      oma: { scope: null },
      omb: { scope: null },
      omc: { scope: null },
      ome: { scope: null },
      omg: { scope: null },
      omi: { scope: null },
      omk: { scope: null },
      oml: { scope: null },
      omn: { scope: null },
      omo: { scope: null },
      omp: { scope: null },
      omq: { scope: "collection" },
      omr: { scope: null },
      omt: { scope: null },
      omu: { scope: null },
      omv: { scope: "collection" },
      omw: { scope: null },
      omx: { scope: null },
      omy: { scope: null },
      ona: { scope: null },
      onb: { scope: null },
      one: { scope: null },
      ong: { scope: null },
      oni: { scope: null },
      onj: { scope: null },
      onk: { scope: null },
      onn: { scope: null },
      ono: { scope: null },
      onp: { scope: null },
      onr: { scope: null },
      ons: { scope: null },
      ont: { scope: null },
      onu: { scope: null },
      onw: { scope: null },
      onx: { scope: null },
      ood: { scope: null },
      oog: { scope: null },
      oon: { scope: null },
      oor: { scope: null },
      oos: { scope: null },
      opa: { scope: null },
      opk: { scope: null },
      opm: { scope: null },
      opo: { scope: null },
      opt: { scope: null },
      opy: { scope: null },
      ora: { scope: null },
      orc: { scope: null },
      ore: { scope: null },
      org: { scope: null },
      orh: { scope: null },
      orn: { scope: null },
      oro: { scope: null },
      orr: { scope: null },
      ors: { scope: null },
      ort: { scope: null },
      oru: { scope: null },
      orv: { scope: null },
      orw: { scope: null },
      orx: { scope: null },
      ory: { scope: null },
      orz: { scope: null },
      osa: { scope: null },
      osc: { scope: null },
      osi: { scope: null },
      osn: { scope: null },
      oso: { scope: null },
      osp: { scope: null },
      ost: { scope: null },
      osu: { scope: null },
      osx: { scope: null },
      ota: { scope: null },
      otb: { scope: null },
      otd: { scope: null },
      ote: { scope: null },
      oti: { scope: null },
      otk: { scope: null },
      otl: { scope: null },
      otm: { scope: null },
      otn: { scope: null },
      oto: { scope: "collection" },
      otq: { scope: null },
      otr: { scope: null },
      ots: { scope: null },
      ott: { scope: null },
      otu: { scope: null },
      otw: { scope: null },
      otx: { scope: null },
      oty: { scope: null },
      otz: { scope: null },
      oua: { scope: null },
      oub: { scope: null },
      oue: { scope: null },
      oui: { scope: null },
      oum: { scope: null },
      oun: { scope: null },
      ovd: { scope: null },
      owi: { scope: null },
      owl: { scope: null },
      oyb: { scope: null },
      oyd: { scope: null },
      oym: { scope: null },
      oyy: { scope: null },
      ozm: { scope: null },
      paa: { scope: "collection" },
      pab: { scope: null },
      pac: { scope: null },
      pad: { scope: null },
      pae: { scope: null },
      paf: { scope: null },
      pag: { scope: null },
      pah: { scope: null },
      pai: { scope: null },
      pak: { scope: null },
      pal: { scope: null },
      pam: { scope: null },
      pao: { scope: null },
      pap: { scope: null },
      paq: { scope: null },
      par: { scope: null },
      pas: { scope: null },
      pat: { scope: null },
      pau: { scope: null },
      pav: { scope: null },
      paw: { scope: null },
      pax: { scope: null },
      pay: { scope: null },
      paz: { scope: null },
      pbb: { scope: null },
      pbc: { scope: null },
      pbe: { scope: null },
      pbf: { scope: null },
      pbg: { scope: null },
      pbh: { scope: null },
      pbi: { scope: null },
      pbl: { scope: null },
      pbm: { scope: null },
      pbn: { scope: null },
      pbo: { scope: null },
      pbp: { scope: null },
      pbr: { scope: null },
      pbs: { scope: null },
      pbt: { scope: null },
      pbu: { scope: null },
      pbv: { scope: null },
      pby: { scope: null },
      pbz: { scope: null },
      pca: { scope: null },
      pcb: { scope: null },
      pcc: { scope: null },
      pcd: { scope: null },
      pce: { scope: null },
      pcf: { scope: null },
      pcg: { scope: null },
      pch: { scope: null },
      pci: { scope: null },
      pcj: { scope: null },
      pck: { scope: null },
      pcl: { scope: null },
      pcm: { scope: null },
      pcn: { scope: null },
      pcp: { scope: null },
      pcr: { scope: null },
      pcw: { scope: null },
      pda: { scope: null },
      pdc: { scope: null },
      pdi: { scope: null },
      pdn: { scope: null },
      pdo: { scope: null },
      pdt: { scope: null },
      pdu: { scope: null },
      pea: { scope: null },
      peb: { scope: null },
      ped: { scope: null },
      pee: { scope: null },
      pef: { scope: null },
      peg: { scope: null },
      peh: { scope: null },
      pei: { scope: null },
      pej: { scope: null },
      pek: { scope: null },
      pel: { scope: null },
      pem: { scope: null },
      peo: { scope: null },
      pep: { scope: null },
      peq: { scope: null },
      pes: { scope: null },
      pev: { scope: null },
      pex: { scope: null },
      pey: { scope: null },
      pez: { scope: null },
      pfa: { scope: null },
      pfe: { scope: null },
      pfl: { scope: null },
      pga: { scope: null },
      pgd: { scope: null },
      pgg: { scope: null },
      pgi: { scope: null },
      pgk: { scope: null },
      pgl: { scope: null },
      pgn: { scope: null },
      pgs: { scope: null },
      pgu: { scope: null },
      pgy: { scope: null },
      pgz: { scope: null },
      pha: { scope: null },
      phd: { scope: null },
      phg: { scope: null },
      phh: { scope: null },
      phi: { scope: "collection" },
      phk: { scope: null },
      phl: { scope: null },
      phm: { scope: null },
      phn: { scope: null },
      pho: { scope: null },
      phq: { scope: null },
      phr: { scope: null },
      pht: { scope: null },
      phu: { scope: null },
      phv: { scope: null },
      phw: { scope: null },
      pia: { scope: null },
      pib: { scope: null },
      pic: { scope: null },
      pid: { scope: null },
      pie: { scope: null },
      pif: { scope: null },
      pig: { scope: null },
      pih: { scope: null },
      pii: { scope: null },
      pij: { scope: null },
      pil: { scope: null },
      pim: { scope: null },
      pin: { scope: null },
      pio: { scope: null },
      pip: { scope: null },
      pir: { scope: null },
      pis: { scope: null },
      pit: { scope: null },
      piu: { scope: null },
      piv: { scope: null },
      piw: { scope: null },
      pix: { scope: null },
      piy: { scope: null },
      piz: { scope: null },
      pjt: { scope: null },
      pka: { scope: null },
      pkb: { scope: null },
      pkc: { scope: null },
      pkg: { scope: null },
      pkh: { scope: null },
      pkn: { scope: null },
      pko: { scope: null },
      pkp: { scope: null },
      pkr: { scope: null },
      pks: { scope: null },
      pkt: { scope: null },
      pku: { scope: null },
      pla: { scope: null },
      plb: { scope: null },
      plc: { scope: null },
      pld: { scope: null },
      ple: { scope: null },
      plf: { scope: "collection" },
      plg: { scope: null },
      plh: { scope: null },
      plj: { scope: null },
      plk: { scope: null },
      pll: { scope: null },
      pln: { scope: null },
      plo: { scope: null },
      plp: { scope: null },
      plq: { scope: null },
      plr: { scope: null },
      pls: { scope: null },
      plt: { scope: null },
      plu: { scope: null },
      plv: { scope: null },
      plw: { scope: null },
      ply: { scope: null },
      plz: { scope: null },
      pma: { scope: null },
      pmb: { scope: null },
      pmc: { scope: null },
      pmd: { scope: null },
      pme: { scope: null },
      pmf: { scope: null },
      pmh: { scope: null },
      pmi: { scope: null },
      pmj: { scope: null },
      pmk: { scope: null },
      pml: { scope: null },
      pmm: { scope: null },
      pmn: { scope: null },
      pmo: { scope: null },
      pmq: { scope: null },
      pmr: { scope: null },
      pms: { scope: null },
      pmt: { scope: null },
      pmu: { scope: null },
      pmw: { scope: null },
      pmx: { scope: null },
      pmy: { scope: null },
      pmz: { scope: null },
      pna: { scope: null },
      pnb: { scope: null },
      pnc: { scope: null },
      pnd: { scope: null },
      pne: { scope: null },
      png: { scope: null },
      pnh: { scope: null },
      pni: { scope: null },
      pnj: { scope: null },
      pnk: { scope: null },
      pnl: { scope: null },
      pnm: { scope: null },
      pnn: { scope: null },
      pno: { scope: null },
      pnp: { scope: null },
      pnq: { scope: null },
      pnr: { scope: null },
      pns: { scope: null },
      pnt: { scope: null },
      pnu: { scope: null },
      pnv: { scope: null },
      pnw: { scope: null },
      pnx: { scope: null },
      pny: { scope: null },
      pnz: { scope: null },
      poc: { scope: null },
      pod: { scope: null },
      poe: { scope: null },
      pof: { scope: null },
      pog: { scope: null },
      poh: { scope: null },
      poi: { scope: null },
      pok: { scope: null },
      pom: { scope: null },
      pon: { scope: null },
      poo: { scope: null },
      pop: { scope: null },
      poq: { scope: null },
      pos: { scope: null },
      pot: { scope: null },
      pov: { scope: null },
      pow: { scope: null },
      pox: { scope: null },
      poy: { scope: null },
      poz: { scope: "collection" },
      ppa: { scope: null },
      ppe: { scope: null },
      ppi: { scope: null },
      ppk: { scope: null },
      ppl: { scope: null },
      ppm: { scope: null },
      ppn: { scope: null },
      ppo: { scope: null },
      ppp: { scope: null },
      ppq: { scope: null },
      ppr: { scope: null },
      pps: { scope: null },
      ppt: { scope: null },
      ppu: { scope: null },
      pqa: { scope: null },
      pqe: { scope: "collection" },
      pqm: { scope: null },
      pqw: { scope: "collection" },
      pra: { scope: "collection" },
      prb: { scope: null },
      prc: { scope: null },
      prd: { scope: null },
      pre: { scope: null },
      prf: { scope: null },
      prg: { scope: null },
      prh: { scope: null },
      pri: { scope: null },
      prk: { scope: null },
      prl: { scope: null },
      prm: { scope: null },
      prn: { scope: null },
      pro: { scope: null },
      prp: { scope: null },
      prq: { scope: null },
      prr: { scope: null },
      prs: { scope: null },
      prt: { scope: null },
      pru: { scope: null },
      prw: { scope: null },
      prx: { scope: null },
      pry: { scope: null },
      prz: { scope: null },
      psa: { scope: null },
      psc: { scope: null },
      psd: { scope: null },
      pse: { scope: null },
      psg: { scope: null },
      psh: { scope: null },
      psi: { scope: null },
      psl: { scope: null },
      psm: { scope: null },
      psn: { scope: null },
      pso: { scope: null },
      psp: { scope: null },
      psq: { scope: null },
      psr: { scope: null },
      pss: { scope: null },
      pst: { scope: null },
      psu: { scope: null },
      psw: { scope: null },
      psy: { scope: null },
      pta: { scope: null },
      pth: { scope: null },
      pti: { scope: null },
      ptn: { scope: null },
      pto: { scope: null },
      ptp: { scope: null },
      ptq: { scope: null },
      ptr: { scope: null },
      ptt: { scope: null },
      ptu: { scope: null },
      ptv: { scope: null },
      ptw: { scope: null },
      pty: { scope: null },
      pua: { scope: null },
      pub: { scope: null },
      puc: { scope: null },
      pud: { scope: null },
      pue: { scope: null },
      puf: { scope: null },
      pug: { scope: null },
      pui: { scope: null },
      puj: { scope: null },
      puk: { scope: null },
      pum: { scope: null },
      puo: { scope: null },
      pup: { scope: null },
      puq: { scope: null },
      pur: { scope: null },
      put: { scope: null },
      puu: { scope: null },
      puw: { scope: null },
      pux: { scope: null },
      puy: { scope: null },
      puz: { scope: null },
      pwa: { scope: null },
      pwb: { scope: null },
      pwg: { scope: null },
      pwi: { scope: null },
      pwm: { scope: null },
      pwn: { scope: null },
      pwo: { scope: null },
      pwr: { scope: null },
      pww: { scope: null },
      pxm: { scope: null },
      pye: { scope: null },
      pym: { scope: null },
      pyn: { scope: null },
      pys: { scope: null },
      pyu: { scope: null },
      pyx: { scope: null },
      pyy: { scope: null },
      pzn: { scope: null },
      qaa: { scope: "private-use" },
      qab: { scope: "private-use" },
      qac: { scope: "private-use" },
      qad: { scope: "private-use" },
      qae: { scope: "private-use" },
      qaf: { scope: "private-use" },
      qag: { scope: "private-use" },
      qah: { scope: "private-use" },
      qai: { scope: "private-use" },
      qaj: { scope: "private-use" },
      qak: { scope: "private-use" },
      qal: { scope: "private-use" },
      qam: { scope: "private-use" },
      qan: { scope: "private-use" },
      qao: { scope: "private-use" },
      qap: { scope: "private-use" },
      qaq: { scope: "private-use" },
      qar: { scope: "private-use" },
      qas: { scope: "private-use" },
      qat: { scope: "private-use" },
      qau: { scope: "private-use" },
      qav: { scope: "private-use" },
      qaw: { scope: "private-use" },
      qax: { scope: "private-use" },
      qay: { scope: "private-use" },
      qaz: { scope: "private-use" },
      qba: { scope: "private-use" },
      qbb: { scope: "private-use" },
      qbc: { scope: "private-use" },
      qbd: { scope: "private-use" },
      qbe: { scope: "private-use" },
      qbf: { scope: "private-use" },
      qbg: { scope: "private-use" },
      qbh: { scope: "private-use" },
      qbi: { scope: "private-use" },
      qbj: { scope: "private-use" },
      qbk: { scope: "private-use" },
      qbl: { scope: "private-use" },
      qbm: { scope: "private-use" },
      qbn: { scope: "private-use" },
      qbo: { scope: "private-use" },
      qbp: { scope: "private-use" },
      qbq: { scope: "private-use" },
      qbr: { scope: "private-use" },
      qbs: { scope: "private-use" },
      qbt: { scope: "private-use" },
      qbu: { scope: "private-use" },
      qbv: { scope: "private-use" },
      qbw: { scope: "private-use" },
      qbx: { scope: "private-use" },
      qby: { scope: "private-use" },
      qbz: { scope: "private-use" },
      qca: { scope: "private-use" },
      qcb: { scope: "private-use" },
      qcc: { scope: "private-use" },
      qcd: { scope: "private-use" },
      qce: { scope: "private-use" },
      qcf: { scope: "private-use" },
      qcg: { scope: "private-use" },
      qch: { scope: "private-use" },
      qci: { scope: "private-use" },
      qcj: { scope: "private-use" },
      qck: { scope: "private-use" },
      qcl: { scope: "private-use" },
      qcm: { scope: "private-use" },
      qcn: { scope: "private-use" },
      qco: { scope: "private-use" },
      qcp: { scope: "private-use" },
      qcq: { scope: "private-use" },
      qcr: { scope: "private-use" },
      qcs: { scope: "private-use" },
      qct: { scope: "private-use" },
      qcu: { scope: "private-use" },
      qcv: { scope: "private-use" },
      qcw: { scope: "private-use" },
      qcx: { scope: "private-use" },
      qcy: { scope: "private-use" },
      qcz: { scope: "private-use" },
      qda: { scope: "private-use" },
      qdb: { scope: "private-use" },
      qdc: { scope: "private-use" },
      qdd: { scope: "private-use" },
      qde: { scope: "private-use" },
      qdf: { scope: "private-use" },
      qdg: { scope: "private-use" },
      qdh: { scope: "private-use" },
      qdi: { scope: "private-use" },
      qdj: { scope: "private-use" },
      qdk: { scope: "private-use" },
      qdl: { scope: "private-use" },
      qdm: { scope: "private-use" },
      qdn: { scope: "private-use" },
      qdo: { scope: "private-use" },
      qdp: { scope: "private-use" },
      qdq: { scope: "private-use" },
      qdr: { scope: "private-use" },
      qds: { scope: "private-use" },
      qdt: { scope: "private-use" },
      qdu: { scope: "private-use" },
      qdv: { scope: "private-use" },
      qdw: { scope: "private-use" },
      qdx: { scope: "private-use" },
      qdy: { scope: "private-use" },
      qdz: { scope: "private-use" },
      qea: { scope: "private-use" },
      qeb: { scope: "private-use" },
      qec: { scope: "private-use" },
      qed: { scope: "private-use" },
      qee: { scope: "private-use" },
      qef: { scope: "private-use" },
      qeg: { scope: "private-use" },
      qeh: { scope: "private-use" },
      qei: { scope: "private-use" },
      qej: { scope: "private-use" },
      qek: { scope: "private-use" },
      qel: { scope: "private-use" },
      qem: { scope: "private-use" },
      qen: { scope: "private-use" },
      qeo: { scope: "private-use" },
      qep: { scope: "private-use" },
      qeq: { scope: "private-use" },
      qer: { scope: "private-use" },
      qes: { scope: "private-use" },
      qet: { scope: "private-use" },
      qeu: { scope: "private-use" },
      qev: { scope: "private-use" },
      qew: { scope: "private-use" },
      qex: { scope: "private-use" },
      qey: { scope: "private-use" },
      qez: { scope: "private-use" },
      qfa: { scope: "private-use" },
      qfb: { scope: "private-use" },
      qfc: { scope: "private-use" },
      qfd: { scope: "private-use" },
      qfe: { scope: "private-use" },
      qff: { scope: "private-use" },
      qfg: { scope: "private-use" },
      qfh: { scope: "private-use" },
      qfi: { scope: "private-use" },
      qfj: { scope: "private-use" },
      qfk: { scope: "private-use" },
      qfl: { scope: "private-use" },
      qfm: { scope: "private-use" },
      qfn: { scope: "private-use" },
      qfo: { scope: "private-use" },
      qfp: { scope: "private-use" },
      qfq: { scope: "private-use" },
      qfr: { scope: "private-use" },
      qfs: { scope: "private-use" },
      qft: { scope: "private-use" },
      qfu: { scope: "private-use" },
      qfv: { scope: "private-use" },
      qfw: { scope: "private-use" },
      qfx: { scope: "private-use" },
      qfy: { scope: "private-use" },
      qfz: { scope: "private-use" },
      qga: { scope: "private-use" },
      qgb: { scope: "private-use" },
      qgc: { scope: "private-use" },
      qgd: { scope: "private-use" },
      qge: { scope: "private-use" },
      qgf: { scope: "private-use" },
      qgg: { scope: "private-use" },
      qgh: { scope: "private-use" },
      qgi: { scope: "private-use" },
      qgj: { scope: "private-use" },
      qgk: { scope: "private-use" },
      qgl: { scope: "private-use" },
      qgm: { scope: "private-use" },
      qgn: { scope: "private-use" },
      qgo: { scope: "private-use" },
      qgp: { scope: "private-use" },
      qgq: { scope: "private-use" },
      qgr: { scope: "private-use" },
      qgs: { scope: "private-use" },
      qgt: { scope: "private-use" },
      qgu: { scope: "private-use" },
      qgv: { scope: "private-use" },
      qgw: { scope: "private-use" },
      qgx: { scope: "private-use" },
      qgy: { scope: "private-use" },
      qgz: { scope: "private-use" },
      qha: { scope: "private-use" },
      qhb: { scope: "private-use" },
      qhc: { scope: "private-use" },
      qhd: { scope: "private-use" },
      qhe: { scope: "private-use" },
      qhf: { scope: "private-use" },
      qhg: { scope: "private-use" },
      qhh: { scope: "private-use" },
      qhi: { scope: "private-use" },
      qhj: { scope: "private-use" },
      qhk: { scope: "private-use" },
      qhl: { scope: "private-use" },
      qhm: { scope: "private-use" },
      qhn: { scope: "private-use" },
      qho: { scope: "private-use" },
      qhp: { scope: "private-use" },
      qhq: { scope: "private-use" },
      qhr: { scope: "private-use" },
      qhs: { scope: "private-use" },
      qht: { scope: "private-use" },
      qhu: { scope: "private-use" },
      qhv: { scope: "private-use" },
      qhw: { scope: "private-use" },
      qhx: { scope: "private-use" },
      qhy: { scope: "private-use" },
      qhz: { scope: "private-use" },
      qia: { scope: "private-use" },
      qib: { scope: "private-use" },
      qic: { scope: "private-use" },
      qid: { scope: "private-use" },
      qie: { scope: "private-use" },
      qif: { scope: "private-use" },
      qig: { scope: "private-use" },
      qih: { scope: "private-use" },
      qii: { scope: "private-use" },
      qij: { scope: "private-use" },
      qik: { scope: "private-use" },
      qil: { scope: "private-use" },
      qim: { scope: "private-use" },
      qin: { scope: "private-use" },
      qio: { scope: "private-use" },
      qip: { scope: "private-use" },
      qiq: { scope: "private-use" },
      qir: { scope: "private-use" },
      qis: { scope: "private-use" },
      qit: { scope: "private-use" },
      qiu: { scope: "private-use" },
      qiv: { scope: "private-use" },
      qiw: { scope: "private-use" },
      qix: { scope: "private-use" },
      qiy: { scope: "private-use" },
      qiz: { scope: "private-use" },
      qja: { scope: "private-use" },
      qjb: { scope: "private-use" },
      qjc: { scope: "private-use" },
      qjd: { scope: "private-use" },
      qje: { scope: "private-use" },
      qjf: { scope: "private-use" },
      qjg: { scope: "private-use" },
      qjh: { scope: "private-use" },
      qji: { scope: "private-use" },
      qjj: { scope: "private-use" },
      qjk: { scope: "private-use" },
      qjl: { scope: "private-use" },
      qjm: { scope: "private-use" },
      qjn: { scope: "private-use" },
      qjo: { scope: "private-use" },
      qjp: { scope: "private-use" },
      qjq: { scope: "private-use" },
      qjr: { scope: "private-use" },
      qjs: { scope: "private-use" },
      qjt: { scope: "private-use" },
      qju: { scope: "private-use" },
      qjv: { scope: "private-use" },
      qjw: { scope: "private-use" },
      qjx: { scope: "private-use" },
      qjy: { scope: "private-use" },
      qjz: { scope: "private-use" },
      qka: { scope: "private-use" },
      qkb: { scope: "private-use" },
      qkc: { scope: "private-use" },
      qkd: { scope: "private-use" },
      qke: { scope: "private-use" },
      qkf: { scope: "private-use" },
      qkg: { scope: "private-use" },
      qkh: { scope: "private-use" },
      qki: { scope: "private-use" },
      qkj: { scope: "private-use" },
      qkk: { scope: "private-use" },
      qkl: { scope: "private-use" },
      qkm: { scope: "private-use" },
      qkn: { scope: "private-use" },
      qko: { scope: "private-use" },
      qkp: { scope: "private-use" },
      qkq: { scope: "private-use" },
      qkr: { scope: "private-use" },
      qks: { scope: "private-use" },
      qkt: { scope: "private-use" },
      qku: { scope: "private-use" },
      qkv: { scope: "private-use" },
      qkw: { scope: "private-use" },
      qkx: { scope: "private-use" },
      qky: { scope: "private-use" },
      qkz: { scope: "private-use" },
      qla: { scope: "private-use" },
      qlb: { scope: "private-use" },
      qlc: { scope: "private-use" },
      qld: { scope: "private-use" },
      qle: { scope: "private-use" },
      qlf: { scope: "private-use" },
      qlg: { scope: "private-use" },
      qlh: { scope: "private-use" },
      qli: { scope: "private-use" },
      qlj: { scope: "private-use" },
      qlk: { scope: "private-use" },
      qll: { scope: "private-use" },
      qlm: { scope: "private-use" },
      qln: { scope: "private-use" },
      qlo: { scope: "private-use" },
      qlp: { scope: "private-use" },
      qlq: { scope: "private-use" },
      qlr: { scope: "private-use" },
      qls: { scope: "private-use" },
      qlt: { scope: "private-use" },
      qlu: { scope: "private-use" },
      qlv: { scope: "private-use" },
      qlw: { scope: "private-use" },
      qlx: { scope: "private-use" },
      qly: { scope: "private-use" },
      qlz: { scope: "private-use" },
      qma: { scope: "private-use" },
      qmb: { scope: "private-use" },
      qmc: { scope: "private-use" },
      qmd: { scope: "private-use" },
      qme: { scope: "private-use" },
      qmf: { scope: "private-use" },
      qmg: { scope: "private-use" },
      qmh: { scope: "private-use" },
      qmi: { scope: "private-use" },
      qmj: { scope: "private-use" },
      qmk: { scope: "private-use" },
      qml: { scope: "private-use" },
      qmm: { scope: "private-use" },
      qmn: { scope: "private-use" },
      qmo: { scope: "private-use" },
      qmp: { scope: "private-use" },
      qmq: { scope: "private-use" },
      qmr: { scope: "private-use" },
      qms: { scope: "private-use" },
      qmt: { scope: "private-use" },
      qmu: { scope: "private-use" },
      qmv: { scope: "private-use" },
      qmw: { scope: "private-use" },
      qmx: { scope: "private-use" },
      qmy: { scope: "private-use" },
      qmz: { scope: "private-use" },
      qna: { scope: "private-use" },
      qnb: { scope: "private-use" },
      qnc: { scope: "private-use" },
      qnd: { scope: "private-use" },
      qne: { scope: "private-use" },
      qnf: { scope: "private-use" },
      qng: { scope: "private-use" },
      qnh: { scope: "private-use" },
      qni: { scope: "private-use" },
      qnj: { scope: "private-use" },
      qnk: { scope: "private-use" },
      qnl: { scope: "private-use" },
      qnm: { scope: "private-use" },
      qnn: { scope: "private-use" },
      qno: { scope: "private-use" },
      qnp: { scope: "private-use" },
      qnq: { scope: "private-use" },
      qnr: { scope: "private-use" },
      qns: { scope: "private-use" },
      qnt: { scope: "private-use" },
      qnu: { scope: "private-use" },
      qnv: { scope: "private-use" },
      qnw: { scope: "private-use" },
      qnx: { scope: "private-use" },
      qny: { scope: "private-use" },
      qnz: { scope: "private-use" },
      qoa: { scope: "private-use" },
      qob: { scope: "private-use" },
      qoc: { scope: "private-use" },
      qod: { scope: "private-use" },
      qoe: { scope: "private-use" },
      qof: { scope: "private-use" },
      qog: { scope: "private-use" },
      qoh: { scope: "private-use" },
      qoi: { scope: "private-use" },
      qoj: { scope: "private-use" },
      qok: { scope: "private-use" },
      qol: { scope: "private-use" },
      qom: { scope: "private-use" },
      qon: { scope: "private-use" },
      qoo: { scope: "private-use" },
      qop: { scope: "private-use" },
      qoq: { scope: "private-use" },
      qor: { scope: "private-use" },
      qos: { scope: "private-use" },
      qot: { scope: "private-use" },
      qou: { scope: "private-use" },
      qov: { scope: "private-use" },
      qow: { scope: "private-use" },
      qox: { scope: "private-use" },
      qoy: { scope: "private-use" },
      qoz: { scope: "private-use" },
      qpa: { scope: "private-use" },
      qpb: { scope: "private-use" },
      qpc: { scope: "private-use" },
      qpd: { scope: "private-use" },
      qpe: { scope: "private-use" },
      qpf: { scope: "private-use" },
      qpg: { scope: "private-use" },
      qph: { scope: "private-use" },
      qpi: { scope: "private-use" },
      qpj: { scope: "private-use" },
      qpk: { scope: "private-use" },
      qpl: { scope: "private-use" },
      qpm: { scope: "private-use" },
      qpn: { scope: "private-use" },
      qpo: { scope: "private-use" },
      qpp: { scope: "private-use" },
      qpq: { scope: "private-use" },
      qpr: { scope: "private-use" },
      qps: { scope: "private-use" },
      qpt: { scope: "private-use" },
      qpu: { scope: "private-use" },
      qpv: { scope: "private-use" },
      qpw: { scope: "private-use" },
      qpx: { scope: "private-use" },
      qpy: { scope: "private-use" },
      qpz: { scope: "private-use" },
      qqa: { scope: "private-use" },
      qqb: { scope: "private-use" },
      qqc: { scope: "private-use" },
      qqd: { scope: "private-use" },
      qqe: { scope: "private-use" },
      qqf: { scope: "private-use" },
      qqg: { scope: "private-use" },
      qqh: { scope: "private-use" },
      qqi: { scope: "private-use" },
      qqj: { scope: "private-use" },
      qqk: { scope: "private-use" },
      qql: { scope: "private-use" },
      qqm: { scope: "private-use" },
      qqn: { scope: "private-use" },
      qqo: { scope: "private-use" },
      qqp: { scope: "private-use" },
      qqq: { scope: "private-use" },
      qqr: { scope: "private-use" },
      qqs: { scope: "private-use" },
      qqt: { scope: "private-use" },
      qqu: { scope: "private-use" },
      qqv: { scope: "private-use" },
      qqw: { scope: "private-use" },
      qqx: { scope: "private-use" },
      qqy: { scope: "private-use" },
      qqz: { scope: "private-use" },
      qra: { scope: "private-use" },
      qrb: { scope: "private-use" },
      qrc: { scope: "private-use" },
      qrd: { scope: "private-use" },
      qre: { scope: "private-use" },
      qrf: { scope: "private-use" },
      qrg: { scope: "private-use" },
      qrh: { scope: "private-use" },
      qri: { scope: "private-use" },
      qrj: { scope: "private-use" },
      qrk: { scope: "private-use" },
      qrl: { scope: "private-use" },
      qrm: { scope: "private-use" },
      qrn: { scope: "private-use" },
      qro: { scope: "private-use" },
      qrp: { scope: "private-use" },
      qrq: { scope: "private-use" },
      qrr: { scope: "private-use" },
      qrs: { scope: "private-use" },
      qrt: { scope: "private-use" },
      qru: { scope: "private-use" },
      qrv: { scope: "private-use" },
      qrw: { scope: "private-use" },
      qrx: { scope: "private-use" },
      qry: { scope: "private-use" },
      qrz: { scope: "private-use" },
      qsa: { scope: "private-use" },
      qsb: { scope: "private-use" },
      qsc: { scope: "private-use" },
      qsd: { scope: "private-use" },
      qse: { scope: "private-use" },
      qsf: { scope: "private-use" },
      qsg: { scope: "private-use" },
      qsh: { scope: "private-use" },
      qsi: { scope: "private-use" },
      qsj: { scope: "private-use" },
      qsk: { scope: "private-use" },
      qsl: { scope: "private-use" },
      qsm: { scope: "private-use" },
      qsn: { scope: "private-use" },
      qso: { scope: "private-use" },
      qsp: { scope: "private-use" },
      qsq: { scope: "private-use" },
      qsr: { scope: "private-use" },
      qss: { scope: "private-use" },
      qst: { scope: "private-use" },
      qsu: { scope: "private-use" },
      qsv: { scope: "private-use" },
      qsw: { scope: "private-use" },
      qsx: { scope: "private-use" },
      qsy: { scope: "private-use" },
      qsz: { scope: "private-use" },
      qta: { scope: "private-use" },
      qtb: { scope: "private-use" },
      qtc: { scope: "private-use" },
      qtd: { scope: "private-use" },
      qte: { scope: "private-use" },
      qtf: { scope: "private-use" },
      qtg: { scope: "private-use" },
      qth: { scope: "private-use" },
      qti: { scope: "private-use" },
      qtj: { scope: "private-use" },
      qtk: { scope: "private-use" },
      qtl: { scope: "private-use" },
      qtm: { scope: "private-use" },
      qtn: { scope: "private-use" },
      qto: { scope: "private-use" },
      qtp: { scope: "private-use" },
      qtq: { scope: "private-use" },
      qtr: { scope: "private-use" },
      qts: { scope: "private-use" },
      qtt: { scope: "private-use" },
      qtu: { scope: "private-use" },
      qtv: { scope: "private-use" },
      qtw: { scope: "private-use" },
      qtx: { scope: "private-use" },
      qty: { scope: "private-use" },
      qtz: { scope: "private-use" },
      qua: { scope: null },
      qub: { scope: null },
      quc: { scope: null },
      qud: { scope: null },
      quf: { scope: null },
      qug: { scope: null },
      quh: { scope: null },
      qui: { scope: null },
      quk: { scope: null },
      qul: { scope: null },
      qum: { scope: null },
      qun: { scope: null },
      qup: { scope: null },
      quq: { scope: null },
      qur: { scope: null },
      qus: { scope: null },
      quv: { scope: null },
      quw: { scope: null },
      qux: { scope: null },
      quy: { scope: null },
      quz: { scope: null },
      qva: { scope: null },
      qvc: { scope: null },
      qve: { scope: null },
      qvh: { scope: null },
      qvi: { scope: null },
      qvj: { scope: null },
      qvl: { scope: null },
      qvm: { scope: null },
      qvn: { scope: null },
      qvo: { scope: null },
      qvp: { scope: null },
      qvs: { scope: null },
      qvw: { scope: null },
      qvy: { scope: null },
      qvz: { scope: null },
      qwa: { scope: null },
      qwc: { scope: null },
      qwe: { scope: "collection" },
      qwh: { scope: null },
      qwm: { scope: null },
      qws: { scope: null },
      qwt: { scope: null },
      qxa: { scope: null },
      qxc: { scope: null },
      qxh: { scope: null },
      qxl: { scope: null },
      qxn: { scope: null },
      qxo: { scope: null },
      qxp: { scope: null },
      qxq: { scope: null },
      qxr: { scope: null },
      qxs: { scope: null },
      qxt: { scope: null },
      qxu: { scope: null },
      qxw: { scope: null },
      qya: { scope: null },
      qyp: { scope: null },
      raa: { scope: null },
      rab: { scope: null },
      rac: { scope: null },
      rad: { scope: null },
      raf: { scope: null },
      rag: { scope: null },
      rah: { scope: null },
      rai: { scope: null },
      raj: { scope: "macrolanguage" },
      rak: { scope: null },
      ral: { scope: null },
      ram: { scope: null },
      ran: { scope: null },
      rao: { scope: null },
      rap: { scope: null },
      raq: { scope: null },
      rar: { scope: null },
      ras: { scope: null },
      rat: { scope: null },
      rau: { scope: null },
      rav: { scope: null },
      raw: { scope: null },
      rax: { scope: null },
      ray: { scope: null },
      raz: { scope: null },
      rbb: { scope: null },
      rbk: { scope: null },
      rbl: { scope: null },
      rbp: { scope: null },
      rcf: { scope: null },
      rdb: { scope: null },
      rea: { scope: null },
      reb: { scope: null },
      ree: { scope: null },
      reg: { scope: null },
      rei: { scope: null },
      rej: { scope: null },
      rel: { scope: null },
      rem: { scope: null },
      ren: { scope: null },
      rer: { scope: null },
      res: { scope: null },
      ret: { scope: null },
      rey: { scope: null },
      rga: { scope: null },
      rge: { scope: null },
      rgk: { scope: null },
      rgn: { scope: null },
      rgr: { scope: null },
      rgs: { scope: null },
      rgu: { scope: null },
      rhg: { scope: null },
      rhp: { scope: null },
      ria: { scope: null },
      rie: { scope: null },
      rif: { scope: null },
      ril: { scope: null },
      rim: { scope: null },
      rin: { scope: null },
      rir: { scope: null },
      rit: { scope: null },
      riu: { scope: null },
      rjg: { scope: null },
      rji: { scope: null },
      rjs: { scope: null },
      rka: { scope: null },
      rkb: { scope: null },
      rkh: { scope: null },
      rki: { scope: null },
      rkm: { scope: null },
      rkt: { scope: null },
      rkw: { scope: null },
      rma: { scope: null },
      rmb: { scope: null },
      rmc: { scope: null },
      rmd: { scope: null },
      rme: { scope: null },
      rmf: { scope: null },
      rmg: { scope: null },
      rmh: { scope: null },
      rmi: { scope: null },
      rmk: { scope: null },
      rml: { scope: null },
      rmm: { scope: null },
      rmn: { scope: null },
      rmo: { scope: null },
      rmp: { scope: null },
      rmq: { scope: null },
      rmr: { scope: null },
      rms: { scope: null },
      rmt: { scope: null },
      rmu: { scope: null },
      rmv: { scope: null },
      rmw: { scope: null },
      rmx: { scope: null },
      rmy: { scope: null },
      rmz: { scope: null },
      rna: { scope: null },
      rnd: { scope: null },
      rng: { scope: null },
      rnl: { scope: null },
      rnn: { scope: null },
      rnp: { scope: null },
      rnr: { scope: null },
      rnw: { scope: null },
      roa: { scope: "collection" },
      rob: { scope: null },
      roc: { scope: null },
      rod: { scope: null },
      roe: { scope: null },
      rof: { scope: null },
      rog: { scope: null },
      rol: { scope: null },
      rom: { scope: "macrolanguage" },
      roo: { scope: null },
      rop: { scope: null },
      ror: { scope: null },
      rou: { scope: null },
      row: { scope: null },
      rpn: { scope: null },
      rpt: { scope: null },
      rri: { scope: null },
      rro: { scope: null },
      rrt: { scope: null },
      rsb: { scope: null },
      rsi: { scope: null },
      rsl: { scope: null },
      rsm: { scope: null },
      rtc: { scope: null },
      rth: { scope: null },
      rtm: { scope: null },
      rts: { scope: null },
      rtw: { scope: null },
      rub: { scope: null },
      ruc: { scope: null },
      rue: { scope: null },
      ruf: { scope: null },
      rug: { scope: null },
      ruh: { scope: null },
      rui: { scope: null },
      ruk: { scope: null },
      ruo: { scope: null },
      rup: { scope: null },
      ruq: { scope: null },
      rut: { scope: null },
      ruu: { scope: null },
      ruy: { scope: null },
      ruz: { scope: null },
      rwa: { scope: null },
      rwk: { scope: null },
      rwl: { scope: null },
      rwm: { scope: null },
      rwo: { scope: null },
      rwr: { scope: null },
      rxd: { scope: null },
      rxw: { scope: null },
      ryn: { scope: null },
      rys: { scope: null },
      ryu: { scope: null },
      rzh: { scope: null },
      saa: { scope: null },
      sab: { scope: null },
      sac: { scope: null },
      sad: { scope: null },
      sae: { scope: null },
      saf: { scope: null },
      sah: { scope: null },
      sai: { scope: "collection" },
      saj: { scope: null },
      sak: { scope: null },
      sal: { scope: "collection" },
      sam: { scope: null },
      sao: { scope: null },
      sap: { scope: null },
      saq: { scope: null },
      sar: { scope: null },
      sas: { scope: null },
      sat: { scope: null },
      sau: { scope: null },
      sav: { scope: null },
      saw: { scope: null },
      sax: { scope: null },
      say: { scope: null },
      saz: { scope: null },
      sba: { scope: null },
      sbb: { scope: null },
      sbc: { scope: null },
      sbd: { scope: null },
      sbe: { scope: null },
      sbf: { scope: null },
      sbg: { scope: null },
      sbh: { scope: null },
      sbi: { scope: null },
      sbj: { scope: null },
      sbk: { scope: null },
      sbl: { scope: null },
      sbm: { scope: null },
      sbn: { scope: null },
      sbo: { scope: null },
      sbp: { scope: null },
      sbq: { scope: null },
      sbr: { scope: null },
      sbs: { scope: null },
      sbt: { scope: null },
      sbu: { scope: null },
      sbv: { scope: null },
      sbw: { scope: null },
      sbx: { scope: null },
      sby: { scope: null },
      sbz: { scope: null },
      sca: { scope: null },
      scb: { scope: null },
      sce: { scope: null },
      scf: { scope: null },
      scg: { scope: null },
      sch: { scope: null },
      sci: { scope: null },
      sck: { scope: null },
      scl: { scope: null },
      scn: { scope: null },
      sco: { scope: null },
      scp: { scope: null },
      scq: { scope: null },
      scs: { scope: null },
      sct: { scope: null },
      scu: { scope: null },
      scv: { scope: null },
      scw: { scope: null },
      scx: { scope: null },
      sda: { scope: null },
      sdb: { scope: null },
      sdc: { scope: null },
      sde: { scope: null },
      sdf: { scope: null },
      sdg: { scope: null },
      sdh: { scope: null },
      sdj: { scope: null },
      sdk: { scope: null },
      sdl: { scope: null },
      sdm: { scope: null },
      sdn: { scope: null },
      sdo: { scope: null },
      sdp: { scope: null },
      sdq: { scope: null },
      sdr: { scope: null },
      sds: { scope: null },
      sdt: { scope: null },
      sdu: { scope: null },
      sdv: { scope: "collection" },
      sdx: { scope: null },
      sdz: { scope: null },
      sea: { scope: null },
      seb: { scope: null },
      sec: { scope: null },
      sed: { scope: null },
      see: { scope: null },
      sef: { scope: null },
      seg: { scope: null },
      seh: { scope: null },
      sei: { scope: null },
      sej: { scope: null },
      sek: { scope: null },
      sel: { scope: null },
      sem: { scope: "collection" },
      sen: { scope: null },
      seo: { scope: null },
      sep: { scope: null },
      seq: { scope: null },
      ser: { scope: null },
      ses: { scope: null },
      set: { scope: null },
      seu: { scope: null },
      sev: { scope: null },
      sew: { scope: null },
      sey: { scope: null },
      sez: { scope: null },
      sfb: { scope: null },
      sfe: { scope: null },
      sfm: { scope: null },
      sfs: { scope: null },
      sfw: { scope: null },
      sga: { scope: null },
      sgb: { scope: null },
      sgc: { scope: null },
      sgd: { scope: null },
      sge: { scope: null },
      sgg: { scope: null },
      sgh: { scope: null },
      sgi: { scope: null },
      sgj: { scope: null },
      sgk: { scope: null },
      sgl: { scope: null },
      sgm: { scope: null },
      sgn: { scope: "collection" },
      sgo: { scope: null },
      sgp: { scope: null },
      sgr: { scope: null },
      sgs: { scope: null },
      sgt: { scope: null },
      sgu: { scope: null },
      sgw: { scope: null },
      sgx: { scope: null },
      sgy: { scope: null },
      sgz: { scope: null },
      sha: { scope: null },
      shb: { scope: null },
      shc: { scope: null },
      shd: { scope: null },
      she: { scope: null },
      shg: { scope: null },
      shh: { scope: null },
      shi: { scope: null },
      shj: { scope: null },
      shk: { scope: null },
      shl: { scope: null },
      shm: { scope: null },
      shn: { scope: null },
      sho: { scope: null },
      shp: { scope: null },
      shq: { scope: null },
      shr: { scope: null },
      shs: { scope: null },
      sht: { scope: null },
      shu: { scope: null },
      shv: { scope: null },
      shw: { scope: null },
      shx: { scope: null },
      shy: { scope: null },
      shz: { scope: null },
      sia: { scope: null },
      sib: { scope: null },
      sid: { scope: null },
      sie: { scope: null },
      sif: { scope: null },
      sig: { scope: null },
      sih: { scope: null },
      sii: { scope: null },
      sij: { scope: null },
      sik: { scope: null },
      sil: { scope: null },
      sim: { scope: null },
      sio: { scope: "collection" },
      sip: { scope: null },
      siq: { scope: null },
      sir: { scope: null },
      sis: { scope: null },
      sit: { scope: "collection" },
      siu: { scope: null },
      siv: { scope: null },
      siw: { scope: null },
      six: { scope: null },
      siy: { scope: null },
      siz: { scope: null },
      sja: { scope: null },
      sjb: { scope: null },
      sjd: { scope: null },
      sje: { scope: null },
      sjg: { scope: null },
      sjk: { scope: null },
      sjl: { scope: null },
      sjm: { scope: null },
      sjn: { scope: null },
      sjo: { scope: null },
      sjp: { scope: null },
      sjr: { scope: null },
      sjs: { scope: null },
      sjt: { scope: null },
      sju: { scope: null },
      sjw: { scope: null },
      ska: { scope: null },
      skb: { scope: null },
      skc: { scope: null },
      skd: { scope: null },
      ske: { scope: null },
      skf: { scope: null },
      skg: { scope: null },
      skh: { scope: null },
      ski: { scope: null },
      skj: { scope: null },
      skk: { scope: null },
      skm: { scope: null },
      skn: { scope: null },
      sko: { scope: null },
      skp: { scope: null },
      skq: { scope: null },
      skr: { scope: null },
      sks: { scope: null },
      skt: { scope: null },
      sku: { scope: null },
      skv: { scope: null },
      skw: { scope: null },
      skx: { scope: null },
      sky: { scope: null },
      skz: { scope: null },
      sla: { scope: "collection" },
      slc: { scope: null },
      sld: { scope: null },
      sle: { scope: null },
      slf: { scope: null },
      slg: { scope: null },
      slh: { scope: null },
      sli: { scope: null },
      slj: { scope: null },
      sll: { scope: null },
      slm: { scope: null },
      sln: { scope: null },
      slp: { scope: null },
      slq: { scope: null },
      slr: { scope: null },
      sls: { scope: null },
      slt: { scope: null },
      slu: { scope: null },
      slw: { scope: null },
      slx: { scope: null },
      sly: { scope: null },
      slz: { scope: null },
      sma: { scope: null },
      smb: { scope: null },
      smc: { scope: null },
      smd: { scope: null },
      smf: { scope: null },
      smg: { scope: null },
      smh: { scope: null },
      smi: { scope: "collection" },
      smj: { scope: null },
      smk: { scope: null },
      sml: { scope: null },
      smm: { scope: null },
      smn: { scope: null },
      smp: { scope: null },
      smq: { scope: null },
      smr: { scope: null },
      sms: { scope: null },
      smt: { scope: null },
      smu: { scope: null },
      smv: { scope: null },
      smw: { scope: null },
      smx: { scope: null },
      smy: { scope: null },
      smz: { scope: null },
      snb: { scope: null },
      snc: { scope: null },
      sne: { scope: null },
      snf: { scope: null },
      sng: { scope: null },
      snh: { scope: null },
      sni: { scope: null },
      snj: { scope: null },
      snk: { scope: null },
      snl: { scope: null },
      snm: { scope: null },
      snn: { scope: null },
      sno: { scope: null },
      snp: { scope: null },
      snq: { scope: null },
      snr: { scope: null },
      sns: { scope: null },
      snu: { scope: null },
      snv: { scope: null },
      snw: { scope: null },
      snx: { scope: null },
      sny: { scope: null },
      snz: { scope: null },
      soa: { scope: null },
      sob: { scope: null },
      soc: { scope: null },
      sod: { scope: null },
      soe: { scope: null },
      sog: { scope: null },
      soh: { scope: null },
      soi: { scope: null },
      soj: { scope: null },
      sok: { scope: null },
      sol: { scope: null },
      son: { scope: "collection" },
      soo: { scope: null },
      sop: { scope: null },
      soq: { scope: null },
      sor: { scope: null },
      sos: { scope: null },
      sou: { scope: null },
      sov: { scope: null },
      sow: { scope: null },
      sox: { scope: null },
      soy: { scope: null },
      soz: { scope: null },
      spb: { scope: null },
      spc: { scope: null },
      spd: { scope: null },
      spe: { scope: null },
      spg: { scope: null },
      spi: { scope: null },
      spk: { scope: null },
      spl: { scope: null },
      spm: { scope: null },
      spn: { scope: null },
      spo: { scope: null },
      spp: { scope: null },
      spq: { scope: null },
      spr: { scope: null },
      sps: { scope: null },
      spt: { scope: null },
      spu: { scope: null },
      spv: { scope: null },
      spx: { scope: null },
      spy: { scope: null },
      sqa: { scope: null },
      sqh: { scope: null },
      sqj: { scope: "collection" },
      sqk: { scope: null },
      sqm: { scope: null },
      sqn: { scope: null },
      sqo: { scope: null },
      sqq: { scope: null },
      sqr: { scope: null },
      sqs: { scope: null },
      sqt: { scope: null },
      squ: { scope: null },
      sqx: { scope: null },
      sra: { scope: null },
      srb: { scope: null },
      src: { scope: null },
      sre: { scope: null },
      srf: { scope: null },
      srg: { scope: null },
      srh: { scope: null },
      sri: { scope: null },
      srk: { scope: null },
      srl: { scope: null },
      srm: { scope: null },
      srn: { scope: null },
      sro: { scope: null },
      srq: { scope: null },
      srr: { scope: null },
      srs: { scope: null },
      srt: { scope: null },
      sru: { scope: null },
      srv: { scope: null },
      srw: { scope: null },
      srx: { scope: null },
      sry: { scope: null },
      srz: { scope: null },
      ssa: { scope: "collection" },
      ssb: { scope: null },
      ssc: { scope: null },
      ssd: { scope: null },
      sse: { scope: null },
      ssf: { scope: null },
      ssg: { scope: null },
      ssh: { scope: null },
      ssi: { scope: null },
      ssj: { scope: null },
      ssk: { scope: null },
      ssl: { scope: null },
      ssm: { scope: null },
      ssn: { scope: null },
      sso: { scope: null },
      ssp: { scope: null },
      ssq: { scope: null },
      ssr: { scope: null },
      sss: { scope: null },
      sst: { scope: null },
      ssu: { scope: null },
      ssv: { scope: null },
      ssx: { scope: null },
      ssy: { scope: null },
      ssz: { scope: null },
      sta: { scope: null },
      stb: { scope: null },
      std: { scope: null },
      ste: { scope: null },
      stf: { scope: null },
      stg: { scope: null },
      sth: { scope: null },
      sti: { scope: null },
      stj: { scope: null },
      stk: { scope: null },
      stl: { scope: null },
      stm: { scope: null },
      stn: { scope: null },
      sto: { scope: null },
      stp: { scope: null },
      stq: { scope: null },
      str: { scope: null },
      sts: { scope: null },
      stt: { scope: null },
      stu: { scope: null },
      stv: { scope: null },
      stw: { scope: null },
      sty: { scope: null },
      sua: { scope: null },
      sub: { scope: null },
      suc: { scope: null },
      sue: { scope: null },
      sug: { scope: null },
      sui: { scope: null },
      suj: { scope: null },
      suk: { scope: null },
      sul: { scope: null },
      sum: { scope: null },
      suo: { scope: null },
      suq: { scope: null },
      sur: { scope: null },
      sus: { scope: null },
      sut: { scope: null },
      suv: { scope: null },
      suw: { scope: null },
      sux: { scope: null },
      suy: { scope: null },
      suz: { scope: null },
      sva: { scope: null },
      svb: { scope: null },
      svc: { scope: null },
      sve: { scope: null },
      svk: { scope: null },
      svm: { scope: null },
      svr: { scope: null },
      svs: { scope: null },
      svx: { scope: null },
      swb: { scope: null },
      swc: { scope: null },
      swf: { scope: null },
      swg: { scope: null },
      swh: { scope: null },
      swi: { scope: null },
      swj: { scope: null },
      swk: { scope: null },
      swl: { scope: null },
      swm: { scope: null },
      swn: { scope: null },
      swo: { scope: null },
      swp: { scope: null },
      swq: { scope: null },
      swr: { scope: null },
      sws: { scope: null },
      swt: { scope: null },
      swu: { scope: null },
      swv: { scope: null },
      sww: { scope: null },
      swx: { scope: null },
      swy: { scope: null },
      sxb: { scope: null },
      sxc: { scope: null },
      sxe: { scope: null },
      sxg: { scope: null },
      sxk: { scope: null },
      sxl: { scope: null },
      sxm: { scope: null },
      sxn: { scope: null },
      sxo: { scope: null },
      sxr: { scope: null },
      sxs: { scope: null },
      sxu: { scope: null },
      sxw: { scope: null },
      sya: { scope: null },
      syb: { scope: null },
      syc: { scope: null },
      syd: { scope: "collection" },
      syi: { scope: null },
      syk: { scope: null },
      syl: { scope: null },
      sym: { scope: null },
      syn: { scope: null },
      syo: { scope: null },
      syr: { scope: "macrolanguage" },
      sys: { scope: null },
      syw: { scope: null },
      syx: { scope: null },
      syy: { scope: null },
      sza: { scope: null },
      szb: { scope: null },
      szc: { scope: null },
      szd: { scope: null },
      sze: { scope: null },
      szg: { scope: null },
      szl: { scope: null },
      szn: { scope: null },
      szp: { scope: null },
      szs: { scope: null },
      szv: { scope: null },
      szw: { scope: null },
      szy: { scope: null },
      taa: { scope: null },
      tab: { scope: null },
      tac: { scope: null },
      tad: { scope: null },
      tae: { scope: null },
      taf: { scope: null },
      tag: { scope: null },
      tai: { scope: "collection" },
      taj: { scope: null },
      tak: { scope: null },
      tal: { scope: null },
      tan: { scope: null },
      tao: { scope: null },
      tap: { scope: null },
      taq: { scope: null },
      tar: { scope: null },
      tas: { scope: null },
      tau: { scope: null },
      tav: { scope: null },
      taw: { scope: null },
      tax: { scope: null },
      tay: { scope: null },
      taz: { scope: null },
      tba: { scope: null },
      tbb: { scope: null },
      tbc: { scope: null },
      tbd: { scope: null },
      tbe: { scope: null },
      tbf: { scope: null },
      tbg: { scope: null },
      tbh: { scope: null },
      tbi: { scope: null },
      tbj: { scope: null },
      tbk: { scope: null },
      tbl: { scope: null },
      tbm: { scope: null },
      tbn: { scope: null },
      tbo: { scope: null },
      tbp: { scope: null },
      tbq: { scope: "collection" },
      tbr: { scope: null },
      tbs: { scope: null },
      tbt: { scope: null },
      tbu: { scope: null },
      tbv: { scope: null },
      tbw: { scope: null },
      tbx: { scope: null },
      tby: { scope: null },
      tbz: { scope: null },
      tca: { scope: null },
      tcb: { scope: null },
      tcc: { scope: null },
      tcd: { scope: null },
      tce: { scope: null },
      tcf: { scope: null },
      tcg: { scope: null },
      tch: { scope: null },
      tci: { scope: null },
      tck: { scope: null },
      tcl: { scope: null },
      tcm: { scope: null },
      tcn: { scope: null },
      tco: { scope: null },
      tcp: { scope: null },
      tcq: { scope: null },
      tcs: { scope: null },
      tct: { scope: null },
      tcu: { scope: null },
      tcw: { scope: null },
      tcx: { scope: null },
      tcy: { scope: null },
      tcz: { scope: null },
      tda: { scope: null },
      tdb: { scope: null },
      tdc: { scope: null },
      tdd: { scope: null },
      tde: { scope: null },
      tdf: { scope: null },
      tdg: { scope: null },
      tdh: { scope: null },
      tdi: { scope: null },
      tdj: { scope: null },
      tdk: { scope: null },
      tdl: { scope: null },
      tdm: { scope: null },
      tdn: { scope: null },
      tdo: { scope: null },
      tdq: { scope: null },
      tdr: { scope: null },
      tds: { scope: null },
      tdt: { scope: null },
      tdu: { scope: null },
      tdv: { scope: null },
      tdx: { scope: null },
      tdy: { scope: null },
      tea: { scope: null },
      teb: { scope: null },
      tec: { scope: null },
      ted: { scope: null },
      tee: { scope: null },
      tef: { scope: null },
      teg: { scope: null },
      teh: { scope: null },
      tei: { scope: null },
      tek: { scope: null },
      tem: { scope: null },
      ten: { scope: null },
      teo: { scope: null },
      tep: { scope: null },
      teq: { scope: null },
      ter: { scope: null },
      tes: { scope: null },
      tet: { scope: null },
      teu: { scope: null },
      tev: { scope: null },
      tew: { scope: null },
      tex: { scope: null },
      tey: { scope: null },
      tez: { scope: null },
      tfi: { scope: null },
      tfn: { scope: null },
      tfo: { scope: null },
      tfr: { scope: null },
      tft: { scope: null },
      tga: { scope: null },
      tgb: { scope: null },
      tgc: { scope: null },
      tgd: { scope: null },
      tge: { scope: null },
      tgf: { scope: null },
      tgg: { scope: null },
      tgh: { scope: null },
      tgi: { scope: null },
      tgj: { scope: null },
      tgn: { scope: null },
      tgo: { scope: null },
      tgp: { scope: null },
      tgq: { scope: null },
      tgr: { scope: null },
      tgs: { scope: null },
      tgt: { scope: null },
      tgu: { scope: null },
      tgv: { scope: null },
      tgw: { scope: null },
      tgx: { scope: null },
      tgy: { scope: null },
      tgz: { scope: null },
      thc: { scope: null },
      thd: { scope: null },
      the: { scope: null },
      thf: { scope: null },
      thh: { scope: null },
      thi: { scope: null },
      thk: { scope: null },
      thl: { scope: null },
      thm: { scope: null },
      thn: { scope: null },
      thp: { scope: null },
      thq: { scope: null },
      thr: { scope: null },
      ths: { scope: null },
      tht: { scope: null },
      thu: { scope: null },
      thv: { scope: null },
      thw: { scope: null },
      thx: { scope: null },
      thy: { scope: null },
      thz: { scope: null },
      tia: { scope: null },
      tic: { scope: null },
      tid: { scope: null },
      tie: { scope: null },
      tif: { scope: null },
      tig: { scope: null },
      tih: { scope: null },
      tii: { scope: null },
      tij: { scope: null },
      tik: { scope: null },
      til: { scope: null },
      tim: { scope: null },
      tin: { scope: null },
      tio: { scope: null },
      tip: { scope: null },
      tiq: { scope: null },
      tis: { scope: null },
      tit: { scope: null },
      tiu: { scope: null },
      tiv: { scope: null },
      tiw: { scope: null },
      tix: { scope: null },
      tiy: { scope: null },
      tiz: { scope: null },
      tja: { scope: null },
      tjg: { scope: null },
      tji: { scope: null },
      tjj: { scope: null },
      tjl: { scope: null },
      tjm: { scope: null },
      tjn: { scope: null },
      tjo: { scope: null },
      tjp: { scope: null },
      tjs: { scope: null },
      tju: { scope: null },
      tjw: { scope: null },
      tka: { scope: null },
      tkb: { scope: null },
      tkd: { scope: null },
      tke: { scope: null },
      tkf: { scope: null },
      tkg: { scope: null },
      tkk: { scope: null },
      tkl: { scope: null },
      tkm: { scope: null },
      tkn: { scope: null },
      tkp: { scope: null },
      tkq: { scope: null },
      tkr: { scope: null },
      tks: { scope: null },
      tkt: { scope: null },
      tku: { scope: null },
      tkv: { scope: null },
      tkw: { scope: null },
      tkx: { scope: null },
      tkz: { scope: null },
      tla: { scope: null },
      tlb: { scope: null },
      tlc: { scope: null },
      tld: { scope: null },
      tlf: { scope: null },
      tlg: { scope: null },
      tlh: { scope: null },
      tli: { scope: null },
      tlj: { scope: null },
      tlk: { scope: null },
      tll: { scope: null },
      tlm: { scope: null },
      tln: { scope: null },
      tlo: { scope: null },
      tlp: { scope: null },
      tlq: { scope: null },
      tlr: { scope: null },
      tls: { scope: null },
      tlt: { scope: null },
      tlu: { scope: null },
      tlv: { scope: null },
      tlw: { scope: null },
      tlx: { scope: null },
      tly: { scope: null },
      tma: { scope: null },
      tmb: { scope: null },
      tmc: { scope: null },
      tmd: { scope: null },
      tme: { scope: null },
      tmf: { scope: null },
      tmg: { scope: null },
      tmh: { scope: "macrolanguage" },
      tmi: { scope: null },
      tmj: { scope: null },
      tmk: { scope: null },
      tml: { scope: null },
      tmm: { scope: null },
      tmn: { scope: null },
      tmo: { scope: null },
      tmp: { scope: null },
      tmq: { scope: null },
      tmr: { scope: null },
      tms: { scope: null },
      tmt: { scope: null },
      tmu: { scope: null },
      tmv: { scope: null },
      tmw: { scope: null },
      tmy: { scope: null },
      tmz: { scope: null },
      tna: { scope: null },
      tnb: { scope: null },
      tnc: { scope: null },
      tnd: { scope: null },
      tne: { scope: null },
      tnf: { scope: null },
      tng: { scope: null },
      tnh: { scope: null },
      tni: { scope: null },
      tnk: { scope: null },
      tnl: { scope: null },
      tnm: { scope: null },
      tnn: { scope: null },
      tno: { scope: null },
      tnp: { scope: null },
      tnq: { scope: null },
      tnr: { scope: null },
      tns: { scope: null },
      tnt: { scope: null },
      tnu: { scope: null },
      tnv: { scope: null },
      tnw: { scope: null },
      tnx: { scope: null },
      tny: { scope: null },
      tnz: { scope: null },
      tob: { scope: null },
      toc: { scope: null },
      tod: { scope: null },
      toe: { scope: null },
      tof: { scope: null },
      tog: { scope: null },
      toh: { scope: null },
      toi: { scope: null },
      toj: { scope: null },
      tol: { scope: null },
      tom: { scope: null },
      too: { scope: null },
      top: { scope: null },
      toq: { scope: null },
      tor: { scope: null },
      tos: { scope: null },
      tou: { scope: null },
      tov: { scope: null },
      tow: { scope: null },
      tox: { scope: null },
      toy: { scope: null },
      toz: { scope: null },
      tpa: { scope: null },
      tpc: { scope: null },
      tpe: { scope: null },
      tpf: { scope: null },
      tpg: { scope: null },
      tpi: { scope: null },
      tpj: { scope: null },
      tpk: { scope: null },
      tpl: { scope: null },
      tpm: { scope: null },
      tpn: { scope: null },
      tpo: { scope: null },
      tpp: { scope: null },
      tpq: { scope: null },
      tpr: { scope: null },
      tpt: { scope: null },
      tpu: { scope: null },
      tpv: { scope: null },
      tpw: { scope: null },
      tpx: { scope: null },
      tpy: { scope: null },
      tpz: { scope: null },
      tqb: { scope: null },
      tql: { scope: null },
      tqm: { scope: null },
      tqn: { scope: null },
      tqo: { scope: null },
      tqp: { scope: null },
      tqq: { scope: null },
      tqr: { scope: null },
      tqt: { scope: null },
      tqu: { scope: null },
      tqw: { scope: null },
      tra: { scope: null },
      trb: { scope: null },
      trc: { scope: null },
      trd: { scope: null },
      tre: { scope: null },
      trf: { scope: null },
      trg: { scope: null },
      trh: { scope: null },
      tri: { scope: null },
      trj: { scope: null },
      trk: { scope: "collection" },
      trl: { scope: null },
      trm: { scope: null },
      trn: { scope: null },
      tro: { scope: null },
      trp: { scope: null },
      trq: { scope: null },
      trr: { scope: null },
      trs: { scope: null },
      trt: { scope: null },
      tru: { scope: null },
      trv: { scope: null },
      trw: { scope: null },
      trx: { scope: null },
      try: { scope: null },
      trz: { scope: null },
      tsa: { scope: null },
      tsb: { scope: null },
      tsc: { scope: null },
      tsd: { scope: null },
      tse: { scope: null },
      tsf: { scope: null },
      tsg: { scope: null },
      tsh: { scope: null },
      tsi: { scope: null },
      tsj: { scope: null },
      tsk: { scope: null },
      tsl: { scope: null },
      tsm: { scope: null },
      tsp: { scope: null },
      tsq: { scope: null },
      tsr: { scope: null },
      tss: { scope: null },
      tst: { scope: null },
      tsu: { scope: null },
      tsv: { scope: null },
      tsw: { scope: null },
      tsx: { scope: null },
      tsy: { scope: null },
      tsz: { scope: null },
      tta: { scope: null },
      ttb: { scope: null },
      ttc: { scope: null },
      ttd: { scope: null },
      tte: { scope: null },
      ttf: { scope: null },
      ttg: { scope: null },
      tth: { scope: null },
      tti: { scope: null },
      ttj: { scope: null },
      ttk: { scope: null },
      ttl: { scope: null },
      ttm: { scope: null },
      ttn: { scope: null },
      tto: { scope: null },
      ttp: { scope: null },
      ttq: { scope: null },
      ttr: { scope: null },
      tts: { scope: null },
      ttt: { scope: null },
      ttu: { scope: null },
      ttv: { scope: null },
      ttw: { scope: null },
      tty: { scope: null },
      ttz: { scope: null },
      tua: { scope: null },
      tub: { scope: null },
      tuc: { scope: null },
      tud: { scope: null },
      tue: { scope: null },
      tuf: { scope: null },
      tug: { scope: null },
      tuh: { scope: null },
      tui: { scope: null },
      tuj: { scope: null },
      tul: { scope: null },
      tum: { scope: null },
      tun: { scope: null },
      tuo: { scope: null },
      tup: { scope: "collection" },
      tuq: { scope: null },
      tus: { scope: null },
      tut: { scope: "collection" },
      tuu: { scope: null },
      tuv: { scope: null },
      tuw: { scope: "collection" },
      tux: { scope: null },
      tuy: { scope: null },
      tuz: { scope: null },
      tva: { scope: null },
      tvd: { scope: null },
      tve: { scope: null },
      tvk: { scope: null },
      tvl: { scope: null },
      tvm: { scope: null },
      tvn: { scope: null },
      tvo: { scope: null },
      tvs: { scope: null },
      tvt: { scope: null },
      tvu: { scope: null },
      tvw: { scope: null },
      tvx: { scope: null },
      tvy: { scope: null },
      twa: { scope: null },
      twb: { scope: null },
      twc: { scope: null },
      twd: { scope: null },
      twe: { scope: null },
      twf: { scope: null },
      twg: { scope: null },
      twh: { scope: null },
      twl: { scope: null },
      twm: { scope: null },
      twn: { scope: null },
      two: { scope: null },
      twp: { scope: null },
      twq: { scope: null },
      twr: { scope: null },
      twt: { scope: null },
      twu: { scope: null },
      tww: { scope: null },
      twx: { scope: null },
      twy: { scope: null },
      txa: { scope: null },
      txb: { scope: null },
      txc: { scope: null },
      txe: { scope: null },
      txg: { scope: null },
      txh: { scope: null },
      txi: { scope: null },
      txj: { scope: null },
      txm: { scope: null },
      txn: { scope: null },
      txo: { scope: null },
      txq: { scope: null },
      txr: { scope: null },
      txs: { scope: null },
      txt: { scope: null },
      txu: { scope: null },
      txx: { scope: null },
      txy: { scope: null },
      tya: { scope: null },
      tye: { scope: null },
      tyh: { scope: null },
      tyi: { scope: null },
      tyj: { scope: null },
      tyl: { scope: null },
      tyn: { scope: null },
      typ: { scope: null },
      tyr: { scope: null },
      tys: { scope: null },
      tyt: { scope: null },
      tyu: { scope: null },
      tyv: { scope: null },
      tyx: { scope: null },
      tyy: { scope: null },
      tyz: { scope: null },
      tza: { scope: null },
      tzh: { scope: null },
      tzj: { scope: null },
      tzl: { scope: null },
      tzm: { scope: null },
      tzn: { scope: null },
      tzo: { scope: null },
      tzx: { scope: null },
      uam: { scope: null },
      uan: { scope: null },
      uar: { scope: null },
      uba: { scope: null },
      ubi: { scope: null },
      ubl: { scope: null },
      ubr: { scope: null },
      ubu: { scope: null },
      uby: { scope: null },
      uda: { scope: null },
      ude: { scope: null },
      udg: { scope: null },
      udi: { scope: null },
      udj: { scope: null },
      udl: { scope: null },
      udm: { scope: null },
      udu: { scope: null },
      ues: { scope: null },
      ufi: { scope: null },
      uga: { scope: null },
      ugb: { scope: null },
      uge: { scope: null },
      ugn: { scope: null },
      ugo: { scope: null },
      ugy: { scope: null },
      uha: { scope: null },
      uhn: { scope: null },
      uis: { scope: null },
      uiv: { scope: null },
      uji: { scope: null },
      uka: { scope: null },
      ukg: { scope: null },
      ukh: { scope: null },
      uki: { scope: null },
      ukk: { scope: null },
      ukl: { scope: null },
      ukp: { scope: null },
      ukq: { scope: null },
      uks: { scope: null },
      uku: { scope: null },
      ukv: { scope: null },
      ukw: { scope: null },
      uky: { scope: null },
      ula: { scope: null },
      ulb: { scope: null },
      ulc: { scope: null },
      ule: { scope: null },
      ulf: { scope: null },
      uli: { scope: null },
      ulk: { scope: null },
      ull: { scope: null },
      ulm: { scope: null },
      uln: { scope: null },
      ulu: { scope: null },
      ulw: { scope: null },
      uma: { scope: null },
      umb: { scope: null },
      umc: { scope: null },
      umd: { scope: null },
      umg: { scope: null },
      umi: { scope: null },
      umm: { scope: null },
      umn: { scope: null },
      umo: { scope: null },
      ump: { scope: null },
      umr: { scope: null },
      ums: { scope: null },
      umu: { scope: null },
      una: { scope: null },
      und: { scope: "special" },
      une: { scope: null },
      ung: { scope: null },
      uni: { scope: null },
      unk: { scope: null },
      unm: { scope: null },
      unn: { scope: null },
      unp: { scope: null },
      unr: { scope: null },
      unu: { scope: null },
      unx: { scope: null },
      unz: { scope: null },
      uok: { scope: null },
      upi: { scope: null },
      upv: { scope: null },
      ura: { scope: null },
      urb: { scope: null },
      urc: { scope: null },
      ure: { scope: null },
      urf: { scope: null },
      urg: { scope: null },
      urh: { scope: null },
      uri: { scope: null },
      urj: { scope: "collection" },
      urk: { scope: null },
      url: { scope: null },
      urm: { scope: null },
      urn: { scope: null },
      uro: { scope: null },
      urp: { scope: null },
      urr: { scope: null },
      urt: { scope: null },
      uru: { scope: null },
      urv: { scope: null },
      urw: { scope: null },
      urx: { scope: null },
      ury: { scope: null },
      urz: { scope: null },
      usa: { scope: null },
      ush: { scope: null },
      usi: { scope: null },
      usk: { scope: null },
      usp: { scope: null },
      uss: { scope: null },
      usu: { scope: null },
      uta: { scope: null },
      ute: { scope: null },
      uth: { scope: null },
      utp: { scope: null },
      utr: { scope: null },
      utu: { scope: null },
      uum: { scope: null },
      uun: { scope: null },
      uur: { scope: null },
      uuu: { scope: null },
      uve: { scope: null },
      uvh: { scope: null },
      uvl: { scope: null },
      uwa: { scope: null },
      uya: { scope: null },
      uzn: { scope: null },
      uzs: { scope: null },
      vaa: { scope: null },
      vae: { scope: null },
      vaf: { scope: null },
      vag: { scope: null },
      vah: { scope: null },
      vai: { scope: null },
      vaj: { scope: null },
      val: { scope: null },
      vam: { scope: null },
      van: { scope: null },
      vao: { scope: null },
      vap: { scope: null },
      var: { scope: null },
      vas: { scope: null },
      vau: { scope: null },
      vav: { scope: null },
      vay: { scope: null },
      vbb: { scope: null },
      vbk: { scope: null },
      vec: { scope: null },
      ved: { scope: null },
      vel: { scope: null },
      vem: { scope: null },
      veo: { scope: null },
      vep: { scope: null },
      ver: { scope: null },
      vgr: { scope: null },
      vgt: { scope: null },
      vic: { scope: null },
      vid: { scope: null },
      vif: { scope: null },
      vig: { scope: null },
      vil: { scope: null },
      vin: { scope: null },
      vis: { scope: null },
      vit: { scope: null },
      viv: { scope: null },
      vka: { scope: null },
      vki: { scope: null },
      vkj: { scope: null },
      vkk: { scope: null },
      vkl: { scope: null },
      vkm: { scope: null },
      vkn: { scope: null },
      vko: { scope: null },
      vkp: { scope: null },
      vkt: { scope: null },
      vku: { scope: null },
      vkz: { scope: null },
      vlp: { scope: null },
      vls: { scope: null },
      vma: { scope: null },
      vmb: { scope: null },
      vmc: { scope: null },
      vmd: { scope: null },
      vme: { scope: null },
      vmf: { scope: null },
      vmg: { scope: null },
      vmh: { scope: null },
      vmi: { scope: null },
      vmj: { scope: null },
      vmk: { scope: null },
      vml: { scope: null },
      vmm: { scope: null },
      vmp: { scope: null },
      vmq: { scope: null },
      vmr: { scope: null },
      vms: { scope: null },
      vmu: { scope: null },
      vmv: { scope: null },
      vmw: { scope: null },
      vmx: { scope: null },
      vmy: { scope: null },
      vmz: { scope: null },
      vnk: { scope: null },
      vnm: { scope: null },
      vnp: { scope: null },
      vor: { scope: null },
      vot: { scope: null },
      vra: { scope: null },
      vro: { scope: null },
      vrs: { scope: null },
      vrt: { scope: null },
      vsi: { scope: null },
      vsl: { scope: null },
      vsv: { scope: null },
      vto: { scope: null },
      vum: { scope: null },
      vun: { scope: null },
      vut: { scope: null },
      vwa: { scope: null },
      waa: { scope: null },
      wab: { scope: null },
      wac: { scope: null },
      wad: { scope: null },
      wae: { scope: null },
      waf: { scope: null },
      wag: { scope: null },
      wah: { scope: null },
      wai: { scope: null },
      waj: { scope: null },
      wak: { scope: "collection" },
      wal: { scope: null },
      wam: { scope: null },
      wan: { scope: null },
      wao: { scope: null },
      wap: { scope: null },
      waq: { scope: null },
      war: { scope: null },
      was: { scope: null },
      wat: { scope: null },
      wau: { scope: null },
      wav: { scope: null },
      waw: { scope: null },
      wax: { scope: null },
      way: { scope: null },
      waz: { scope: null },
      wba: { scope: null },
      wbb: { scope: null },
      wbe: { scope: null },
      wbf: { scope: null },
      wbh: { scope: null },
      wbi: { scope: null },
      wbj: { scope: null },
      wbk: { scope: null },
      wbl: { scope: null },
      wbm: { scope: null },
      wbp: { scope: null },
      wbq: { scope: null },
      wbr: { scope: null },
      wbs: { scope: null },
      wbt: { scope: null },
      wbv: { scope: null },
      wbw: { scope: null },
      wca: { scope: null },
      wci: { scope: null },
      wdd: { scope: null },
      wdg: { scope: null },
      wdj: { scope: null },
      wdk: { scope: null },
      wdu: { scope: null },
      wdy: { scope: null },
      wea: { scope: null },
      wec: { scope: null },
      wed: { scope: null },
      weg: { scope: null },
      weh: { scope: null },
      wei: { scope: null },
      wem: { scope: null },
      wen: { scope: "collection" },
      weo: { scope: null },
      wep: { scope: null },
      wer: { scope: null },
      wes: { scope: null },
      wet: { scope: null },
      weu: { scope: null },
      wew: { scope: null },
      wfg: { scope: null },
      wga: { scope: null },
      wgb: { scope: null },
      wgg: { scope: null },
      wgi: { scope: null },
      wgo: { scope: null },
      wgu: { scope: null },
      wgw: { scope: null },
      wgy: { scope: null },
      wha: { scope: null },
      whg: { scope: null },
      whk: { scope: null },
      whu: { scope: null },
      wib: { scope: null },
      wic: { scope: null },
      wie: { scope: null },
      wif: { scope: null },
      wig: { scope: null },
      wih: { scope: null },
      wii: { scope: null },
      wij: { scope: null },
      wik: { scope: null },
      wil: { scope: null },
      wim: { scope: null },
      win: { scope: null },
      wir: { scope: null },
      wit: { scope: null },
      wiu: { scope: null },
      wiv: { scope: null },
      wiw: { scope: null },
      wiy: { scope: null },
      wja: { scope: null },
      wji: { scope: null },
      wka: { scope: null },
      wkb: { scope: null },
      wkd: { scope: null },
      wkl: { scope: null },
      wkr: { scope: null },
      wku: { scope: null },
      wkw: { scope: null },
      wky: { scope: null },
      wla: { scope: null },
      wlc: { scope: null },
      wle: { scope: null },
      wlg: { scope: null },
      wlh: { scope: null },
      wli: { scope: null },
      wlk: { scope: null },
      wll: { scope: null },
      wlm: { scope: null },
      wlo: { scope: null },
      wlr: { scope: null },
      wls: { scope: null },
      wlu: { scope: null },
      wlv: { scope: null },
      wlw: { scope: null },
      wlx: { scope: null },
      wly: { scope: null },
      wma: { scope: null },
      wmb: { scope: null },
      wmc: { scope: null },
      wmd: { scope: null },
      wme: { scope: null },
      wmg: { scope: null },
      wmh: { scope: null },
      wmi: { scope: null },
      wmm: { scope: null },
      wmn: { scope: null },
      wmo: { scope: null },
      wms: { scope: null },
      wmt: { scope: null },
      wmw: { scope: null },
      wmx: { scope: null },
      wnb: { scope: null },
      wnc: { scope: null },
      wnd: { scope: null },
      wne: { scope: null },
      wng: { scope: null },
      wni: { scope: null },
      wnk: { scope: null },
      wnm: { scope: null },
      wnn: { scope: null },
      wno: { scope: null },
      wnp: { scope: null },
      wnu: { scope: null },
      wnw: { scope: null },
      wny: { scope: null },
      woa: { scope: null },
      wob: { scope: null },
      woc: { scope: null },
      wod: { scope: null },
      woe: { scope: null },
      wof: { scope: null },
      wog: { scope: null },
      woi: { scope: null },
      wok: { scope: null },
      wom: { scope: null },
      won: { scope: null },
      woo: { scope: null },
      wor: { scope: null },
      wos: { scope: null },
      wow: { scope: null },
      woy: { scope: null },
      wpc: { scope: null },
      wra: { scope: null },
      wrb: { scope: null },
      wrd: { scope: null },
      wrg: { scope: null },
      wrh: { scope: null },
      wri: { scope: null },
      wrk: { scope: null },
      wrl: { scope: null },
      wrm: { scope: null },
      wrn: { scope: null },
      wro: { scope: null },
      wrp: { scope: null },
      wrr: { scope: null },
      wrs: { scope: null },
      wru: { scope: null },
      wrv: { scope: null },
      wrw: { scope: null },
      wrx: { scope: null },
      wry: { scope: null },
      wrz: { scope: null },
      wsa: { scope: null },
      wsg: { scope: null },
      wsi: { scope: null },
      wsk: { scope: null },
      wsr: { scope: null },
      wss: { scope: null },
      wsu: { scope: null },
      wsv: { scope: null },
      wtf: { scope: null },
      wth: { scope: null },
      wti: { scope: null },
      wtk: { scope: null },
      wtm: { scope: null },
      wtw: { scope: null },
      wua: { scope: null },
      wub: { scope: null },
      wud: { scope: null },
      wuh: { scope: null },
      wul: { scope: null },
      wum: { scope: null },
      wun: { scope: null },
      wur: { scope: null },
      wut: { scope: null },
      wuu: { scope: null },
      wuv: { scope: null },
      wux: { scope: null },
      wuy: { scope: null },
      wwa: { scope: null },
      wwb: { scope: null },
      wwo: { scope: null },
      wwr: { scope: null },
      www: { scope: null },
      wxa: { scope: null },
      wxw: { scope: null },
      wya: { scope: null },
      wyb: { scope: null },
      wyi: { scope: null },
      wym: { scope: null },
      wyr: { scope: null },
      wyy: { scope: null },
      xaa: { scope: null },
      xab: { scope: null },
      xac: { scope: null },
      xad: { scope: null },
      xae: { scope: null },
      xag: { scope: null },
      xai: { scope: null },
      xaj: { scope: null },
      xak: { scope: null },
      xal: { scope: null },
      xam: { scope: null },
      xan: { scope: null },
      xao: { scope: null },
      xap: { scope: null },
      xaq: { scope: null },
      xar: { scope: null },
      xas: { scope: null },
      xat: { scope: null },
      xau: { scope: null },
      xav: { scope: null },
      xaw: { scope: null },
      xay: { scope: null },
      xba: { scope: null },
      xbb: { scope: null },
      xbc: { scope: null },
      xbd: { scope: null },
      xbe: { scope: null },
      xbg: { scope: null },
      xbi: { scope: null },
      xbj: { scope: null },
      xbm: { scope: null },
      xbn: { scope: null },
      xbo: { scope: null },
      xbp: { scope: null },
      xbr: { scope: null },
      xbw: { scope: null },
      xbx: { scope: null },
      xby: { scope: null },
      xcb: { scope: null },
      xcc: { scope: null },
      xce: { scope: null },
      xcg: { scope: null },
      xch: { scope: null },
      xcl: { scope: null },
      xcm: { scope: null },
      xcn: { scope: null },
      xco: { scope: null },
      xcr: { scope: null },
      xct: { scope: null },
      xcu: { scope: null },
      xcv: { scope: null },
      xcw: { scope: null },
      xcy: { scope: null },
      xda: { scope: null },
      xdc: { scope: null },
      xdk: { scope: null },
      xdm: { scope: null },
      xdo: { scope: null },
      xdy: { scope: null },
      xeb: { scope: null },
      xed: { scope: null },
      xeg: { scope: null },
      xel: { scope: null },
      xem: { scope: null },
      xep: { scope: null },
      xer: { scope: null },
      xes: { scope: null },
      xet: { scope: null },
      xeu: { scope: null },
      xfa: { scope: null },
      xga: { scope: null },
      xgb: { scope: null },
      xgd: { scope: null },
      xgf: { scope: null },
      xgg: { scope: null },
      xgi: { scope: null },
      xgl: { scope: null },
      xgm: { scope: null },
      xgn: { scope: "collection" },
      xgr: { scope: null },
      xgu: { scope: null },
      xgw: { scope: null },
      xha: { scope: null },
      xhc: { scope: null },
      xhd: { scope: null },
      xhe: { scope: null },
      xhr: { scope: null },
      xht: { scope: null },
      xhu: { scope: null },
      xhv: { scope: null },
      xia: { scope: null },
      xib: { scope: null },
      xii: { scope: null },
      xil: { scope: null },
      xin: { scope: null },
      xip: { scope: null },
      xir: { scope: null },
      xis: { scope: null },
      xiv: { scope: null },
      xiy: { scope: null },
      xjb: { scope: null },
      xjt: { scope: null },
      xka: { scope: null },
      xkb: { scope: null },
      xkc: { scope: null },
      xkd: { scope: null },
      xke: { scope: null },
      xkf: { scope: null },
      xkg: { scope: null },
      xkh: { scope: null },
      xki: { scope: null },
      xkj: { scope: null },
      xkk: { scope: null },
      xkl: { scope: null },
      xkn: { scope: null },
      xko: { scope: null },
      xkp: { scope: null },
      xkq: { scope: null },
      xkr: { scope: null },
      xks: { scope: null },
      xkt: { scope: null },
      xku: { scope: null },
      xkv: { scope: null },
      xkw: { scope: null },
      xkx: { scope: null },
      xky: { scope: null },
      xkz: { scope: null },
      xla: { scope: null },
      xlb: { scope: null },
      xlc: { scope: null },
      xld: { scope: null },
      xle: { scope: null },
      xlg: { scope: null },
      xli: { scope: null },
      xln: { scope: null },
      xlo: { scope: null },
      xlp: { scope: null },
      xls: { scope: null },
      xlu: { scope: null },
      xly: { scope: null },
      xma: { scope: null },
      xmb: { scope: null },
      xmc: { scope: null },
      xmd: { scope: null },
      xme: { scope: null },
      xmf: { scope: null },
      xmg: { scope: null },
      xmh: { scope: null },
      xmj: { scope: null },
      xmk: { scope: null },
      xml: { scope: null },
      xmm: { scope: null },
      xmn: { scope: null },
      xmo: { scope: null },
      xmp: { scope: null },
      xmq: { scope: null },
      xmr: { scope: null },
      xms: { scope: null },
      xmt: { scope: null },
      xmu: { scope: null },
      xmv: { scope: null },
      xmw: { scope: null },
      xmx: { scope: null },
      xmy: { scope: null },
      xmz: { scope: null },
      xna: { scope: null },
      xnb: { scope: null },
      xnd: { scope: "collection" },
      xng: { scope: null },
      xnh: { scope: null },
      xni: { scope: null },
      xnj: { scope: null },
      xnk: { scope: null },
      xnm: { scope: null },
      xnn: { scope: null },
      xno: { scope: null },
      xnq: { scope: null },
      xnr: { scope: null },
      xns: { scope: null },
      xnt: { scope: null },
      xnu: { scope: null },
      xny: { scope: null },
      xnz: { scope: null },
      xoc: { scope: null },
      xod: { scope: null },
      xog: { scope: null },
      xoi: { scope: null },
      xok: { scope: null },
      xom: { scope: null },
      xon: { scope: null },
      xoo: { scope: null },
      xop: { scope: null },
      xor: { scope: null },
      xow: { scope: null },
      xpa: { scope: null },
      xpb: { scope: null },
      xpc: { scope: null },
      xpd: { scope: null },
      xpe: { scope: null },
      xpf: { scope: null },
      xpg: { scope: null },
      xph: { scope: null },
      xpi: { scope: null },
      xpj: { scope: null },
      xpk: { scope: null },
      xpl: { scope: null },
      xpm: { scope: null },
      xpn: { scope: null },
      xpo: { scope: null },
      xpp: { scope: null },
      xpq: { scope: null },
      xpr: { scope: null },
      xps: { scope: null },
      xpt: { scope: null },
      xpu: { scope: null },
      xpv: { scope: null },
      xpw: { scope: null },
      xpx: { scope: null },
      xpy: { scope: null },
      xpz: { scope: null },
      xqa: { scope: null },
      xqt: { scope: null },
      xra: { scope: null },
      xrb: { scope: null },
      xrd: { scope: null },
      xre: { scope: null },
      xrg: { scope: null },
      xri: { scope: null },
      xrm: { scope: null },
      xrn: { scope: null },
      xrq: { scope: null },
      xrr: { scope: null },
      xrt: { scope: null },
      xru: { scope: null },
      xrw: { scope: null },
      xsa: { scope: null },
      xsb: { scope: null },
      xsc: { scope: null },
      xsd: { scope: null },
      xse: { scope: null },
      xsh: { scope: null },
      xsi: { scope: null },
      xsj: { scope: null },
      xsl: { scope: null },
      xsm: { scope: null },
      xsn: { scope: null },
      xso: { scope: null },
      xsp: { scope: null },
      xsq: { scope: null },
      xsr: { scope: null },
      xss: { scope: null },
      xsu: { scope: null },
      xsv: { scope: null },
      xsy: { scope: null },
      xta: { scope: null },
      xtb: { scope: null },
      xtc: { scope: null },
      xtd: { scope: null },
      xte: { scope: null },
      xtg: { scope: null },
      xth: { scope: null },
      xti: { scope: null },
      xtj: { scope: null },
      xtl: { scope: null },
      xtm: { scope: null },
      xtn: { scope: null },
      xto: { scope: null },
      xtp: { scope: null },
      xtq: { scope: null },
      xtr: { scope: null },
      xts: { scope: null },
      xtt: { scope: null },
      xtu: { scope: null },
      xtv: { scope: null },
      xtw: { scope: null },
      xty: { scope: null },
      xtz: { scope: null },
      xua: { scope: null },
      xub: { scope: null },
      xud: { scope: null },
      xug: { scope: null },
      xuj: { scope: null },
      xul: { scope: null },
      xum: { scope: null },
      xun: { scope: null },
      xuo: { scope: null },
      xup: { scope: null },
      xur: { scope: null },
      xut: { scope: null },
      xuu: { scope: null },
      xve: { scope: null },
      xvi: { scope: null },
      xvn: { scope: null },
      xvo: { scope: null },
      xvs: { scope: null },
      xwa: { scope: null },
      xwc: { scope: null },
      xwd: { scope: null },
      xwe: { scope: null },
      xwg: { scope: null },
      xwj: { scope: null },
      xwk: { scope: null },
      xwl: { scope: null },
      xwo: { scope: null },
      xwr: { scope: null },
      xwt: { scope: null },
      xww: { scope: null },
      xxb: { scope: null },
      xxk: { scope: null },
      xxm: { scope: null },
      xxr: { scope: null },
      xxt: { scope: null },
      xya: { scope: null },
      xyb: { scope: null },
      xyj: { scope: null },
      xyk: { scope: null },
      xyl: { scope: null },
      xyt: { scope: null },
      xyy: { scope: null },
      xzh: { scope: null },
      xzm: { scope: null },
      xzp: { scope: null },
      yaa: { scope: null },
      yab: { scope: null },
      yac: { scope: null },
      yad: { scope: null },
      yae: { scope: null },
      yaf: { scope: null },
      yag: { scope: null },
      yah: { scope: null },
      yai: { scope: null },
      yaj: { scope: null },
      yak: { scope: null },
      yal: { scope: null },
      yam: { scope: null },
      yan: { scope: null },
      yao: { scope: null },
      yap: { scope: null },
      yaq: { scope: null },
      yar: { scope: null },
      yas: { scope: null },
      yat: { scope: null },
      yau: { scope: null },
      yav: { scope: null },
      yaw: { scope: null },
      yax: { scope: null },
      yay: { scope: null },
      yaz: { scope: null },
      yba: { scope: null },
      ybb: { scope: null },
      ybd: { scope: null },
      ybe: { scope: null },
      ybh: { scope: null },
      ybi: { scope: null },
      ybj: { scope: null },
      ybk: { scope: null },
      ybl: { scope: null },
      ybm: { scope: null },
      ybn: { scope: null },
      ybo: { scope: null },
      ybx: { scope: null },
      yby: { scope: null },
      ych: { scope: null },
      ycl: { scope: null },
      ycn: { scope: null },
      ycp: { scope: null },
      yda: { scope: null },
      ydd: { scope: null },
      yde: { scope: null },
      ydg: { scope: null },
      ydk: { scope: null },
      yds: { scope: null },
      yea: { scope: null },
      yec: { scope: null },
      yee: { scope: null },
      yei: { scope: null },
      yej: { scope: null },
      yel: { scope: null },
      yen: { scope: null },
      yer: { scope: null },
      yes: { scope: null },
      yet: { scope: null },
      yeu: { scope: null },
      yev: { scope: null },
      yey: { scope: null },
      yga: { scope: null },
      ygi: { scope: null },
      ygl: { scope: null },
      ygm: { scope: null },
      ygp: { scope: null },
      ygr: { scope: null },
      ygs: { scope: null },
      ygu: { scope: null },
      ygw: { scope: null },
      yha: { scope: null },
      yhd: { scope: null },
      yhl: { scope: null },
      yhs: { scope: null },
      yia: { scope: null },
      yif: { scope: null },
      yig: { scope: null },
      yih: { scope: null },
      yii: { scope: null },
      yij: { scope: null },
      yik: { scope: null },
      yil: { scope: null },
      yim: { scope: null },
      yin: { scope: null },
      yip: { scope: null },
      yiq: { scope: null },
      yir: { scope: null },
      yis: { scope: null },
      yit: { scope: null },
      yiu: { scope: null },
      yiv: { scope: null },
      yix: { scope: null },
      yiy: { scope: null },
      yiz: { scope: null },
      yka: { scope: null },
      ykg: { scope: null },
      yki: { scope: null },
      ykk: { scope: null },
      ykl: { scope: null },
      ykm: { scope: null },
      ykn: { scope: null },
      yko: { scope: null },
      ykr: { scope: null },
      ykt: { scope: null },
      yku: { scope: null },
      yky: { scope: null },
      yla: { scope: null },
      ylb: { scope: null },
      yle: { scope: null },
      ylg: { scope: null },
      yli: { scope: null },
      yll: { scope: null },
      ylm: { scope: null },
      yln: { scope: null },
      ylo: { scope: null },
      ylr: { scope: null },
      ylu: { scope: null },
      yly: { scope: null },
      yma: { scope: null },
      ymb: { scope: null },
      ymc: { scope: null },
      ymd: { scope: null },
      yme: { scope: null },
      ymg: { scope: null },
      ymh: { scope: null },
      ymi: { scope: null },
      ymk: { scope: null },
      yml: { scope: null },
      ymm: { scope: null },
      ymn: { scope: null },
      ymo: { scope: null },
      ymp: { scope: null },
      ymq: { scope: null },
      ymr: { scope: null },
      yms: { scope: null },
      ymt: { scope: null },
      ymx: { scope: null },
      ymz: { scope: null },
      yna: { scope: null },
      ynd: { scope: null },
      yne: { scope: null },
      yng: { scope: null },
      ynh: { scope: null },
      ynk: { scope: null },
      ynl: { scope: null },
      ynn: { scope: null },
      yno: { scope: null },
      ynq: { scope: null },
      yns: { scope: null },
      ynu: { scope: null },
      yob: { scope: null },
      yog: { scope: null },
      yoi: { scope: null },
      yok: { scope: null },
      yol: { scope: null },
      yom: { scope: null },
      yon: { scope: null },
      yos: { scope: null },
      yot: { scope: null },
      yox: { scope: null },
      yoy: { scope: null },
      ypa: { scope: null },
      ypb: { scope: null },
      ypg: { scope: null },
      yph: { scope: null },
      ypk: { scope: "collection" },
      ypm: { scope: null },
      ypn: { scope: null },
      ypo: { scope: null },
      ypp: { scope: null },
      ypz: { scope: null },
      yra: { scope: null },
      yrb: { scope: null },
      yre: { scope: null },
      yri: { scope: null },
      yrk: { scope: null },
      yrl: { scope: null },
      yrm: { scope: null },
      yrn: { scope: null },
      yro: { scope: null },
      yrs: { scope: null },
      yrw: { scope: null },
      yry: { scope: null },
      ysc: { scope: null },
      ysd: { scope: null },
      ysg: { scope: null },
      ysl: { scope: null },
      ysm: { scope: null },
      ysn: { scope: null },
      yso: { scope: null },
      ysp: { scope: null },
      ysr: { scope: null },
      yss: { scope: null },
      ysy: { scope: null },
      yta: { scope: null },
      ytl: { scope: null },
      ytp: { scope: null },
      ytw: { scope: null },
      yty: { scope: null },
      yua: { scope: null },
      yub: { scope: null },
      yuc: { scope: null },
      yud: { scope: null },
      yue: { scope: null },
      yuf: { scope: null },
      yug: { scope: null },
      yui: { scope: null },
      yuj: { scope: null },
      yuk: { scope: null },
      yul: { scope: null },
      yum: { scope: null },
      yun: { scope: null },
      yup: { scope: null },
      yuq: { scope: null },
      yur: { scope: null },
      yut: { scope: null },
      yuu: { scope: null },
      yuw: { scope: null },
      yux: { scope: null },
      yuy: { scope: null },
      yuz: { scope: null },
      yva: { scope: null },
      yvt: { scope: null },
      ywa: { scope: null },
      ywg: { scope: null },
      ywl: { scope: null },
      ywn: { scope: null },
      ywq: { scope: null },
      ywr: { scope: null },
      ywt: { scope: null },
      ywu: { scope: null },
      yww: { scope: null },
      yxa: { scope: null },
      yxg: { scope: null },
      yxl: { scope: null },
      yxm: { scope: null },
      yxu: { scope: null },
      yxy: { scope: null },
      yyr: { scope: null },
      yyu: { scope: null },
      yyz: { scope: null },
      yzg: { scope: null },
      yzk: { scope: null },
      zaa: { scope: null },
      zab: { scope: null },
      zac: { scope: null },
      zad: { scope: null },
      zae: { scope: null },
      zaf: { scope: null },
      zag: { scope: null },
      zah: { scope: null },
      zai: { scope: null },
      zaj: { scope: null },
      zak: { scope: null },
      zal: { scope: null },
      zam: { scope: null },
      zao: { scope: null },
      zap: { scope: "macrolanguage" },
      zaq: { scope: null },
      zar: { scope: null },
      zas: { scope: null },
      zat: { scope: null },
      zau: { scope: null },
      zav: { scope: null },
      zaw: { scope: null },
      zax: { scope: null },
      zay: { scope: null },
      zaz: { scope: null },
      zba: { scope: null },
      zbc: { scope: null },
      zbe: { scope: null },
      zbl: { scope: null },
      zbt: { scope: null },
      zbu: { scope: null },
      zbw: { scope: null },
      zca: { scope: null },
      zch: { scope: null },
      zdj: { scope: null },
      zea: { scope: null },
      zeg: { scope: null },
      zeh: { scope: null },
      zen: { scope: null },
      zga: { scope: null },
      zgb: { scope: null },
      zgh: { scope: null },
      zgm: { scope: null },
      zgn: { scope: null },
      zgr: { scope: null },
      zhb: { scope: null },
      zhd: { scope: null },
      zhi: { scope: null },
      zhn: { scope: null },
      zhw: { scope: null },
      zhx: { scope: "collection" },
      zia: { scope: null },
      zib: { scope: null },
      zik: { scope: null },
      zil: { scope: null },
      zim: { scope: null },
      zin: { scope: null },
      zir: { scope: null },
      ziw: { scope: null },
      ziz: { scope: null },
      zka: { scope: null },
      zkb: { scope: null },
      zkd: { scope: null },
      zkg: { scope: null },
      zkh: { scope: null },
      zkk: { scope: null },
      zkn: { scope: null },
      zko: { scope: null },
      zkp: { scope: null },
      zkr: { scope: null },
      zkt: { scope: null },
      zku: { scope: null },
      zkv: { scope: null },
      zkz: { scope: null },
      zla: { scope: null },
      zle: { scope: "collection" },
      zlj: { scope: null },
      zlm: { scope: null },
      zln: { scope: null },
      zlq: { scope: null },
      zls: { scope: "collection" },
      zlw: { scope: "collection" },
      zma: { scope: null },
      zmb: { scope: null },
      zmc: { scope: null },
      zmd: { scope: null },
      zme: { scope: null },
      zmf: { scope: null },
      zmg: { scope: null },
      zmh: { scope: null },
      zmi: { scope: null },
      zmj: { scope: null },
      zmk: { scope: null },
      zml: { scope: null },
      zmm: { scope: null },
      zmn: { scope: null },
      zmo: { scope: null },
      zmp: { scope: null },
      zmq: { scope: null },
      zmr: { scope: null },
      zms: { scope: null },
      zmt: { scope: null },
      zmu: { scope: null },
      zmv: { scope: null },
      zmw: { scope: null },
      zmx: { scope: null },
      zmy: { scope: null },
      zmz: { scope: null },
      zna: { scope: null },
      znd: { scope: "collection" },
      zne: { scope: null },
      zng: { scope: null },
      znk: { scope: null },
      zns: { scope: null },
      zoc: { scope: null },
      zoh: { scope: null },
      zom: { scope: null },
      zoo: { scope: null },
      zoq: { scope: null },
      zor: { scope: null },
      zos: { scope: null },
      zpa: { scope: null },
      zpb: { scope: null },
      zpc: { scope: null },
      zpd: { scope: null },
      zpe: { scope: null },
      zpf: { scope: null },
      zpg: { scope: null },
      zph: { scope: null },
      zpi: { scope: null },
      zpj: { scope: null },
      zpk: { scope: null },
      zpl: { scope: null },
      zpm: { scope: null },
      zpn: { scope: null },
      zpo: { scope: null },
      zpp: { scope: null },
      zpq: { scope: null },
      zpr: { scope: null },
      zps: { scope: null },
      zpt: { scope: null },
      zpu: { scope: null },
      zpv: { scope: null },
      zpw: { scope: null },
      zpx: { scope: null },
      zpy: { scope: null },
      zpz: { scope: null },
      zqe: { scope: null },
      zra: { scope: null },
      zrg: { scope: null },
      zrn: { scope: null },
      zro: { scope: null },
      zrp: { scope: null },
      zrs: { scope: null },
      zsa: { scope: null },
      zsk: { scope: null },
      zsl: { scope: null },
      zsm: { scope: null },
      zsr: { scope: null },
      zsu: { scope: null },
      zte: { scope: null },
      ztg: { scope: null },
      ztl: { scope: null },
      ztm: { scope: null },
      ztn: { scope: null },
      ztp: { scope: null },
      ztq: { scope: null },
      zts: { scope: null },
      ztt: { scope: null },
      ztu: { scope: null },
      ztx: { scope: null },
      zty: { scope: null },
      zua: { scope: null },
      zuh: { scope: null },
      zum: { scope: null },
      zun: { scope: null },
      zuy: { scope: null },
      zwa: { scope: null },
      zxx: { scope: "special" },
      zyb: { scope: null },
      zyg: { scope: null },
      zyj: { scope: null },
      zyn: { scope: null },
      zyp: { scope: null },
      zza: { scope: "macrolanguage" },
      zzj: { scope: null }
    },
    extended: {
      aao: { prefix: "ar" },
      abh: { prefix: "ar" },
      abv: { prefix: "ar" },
      acm: { prefix: "ar" },
      acq: { prefix: "ar" },
      acw: { prefix: "ar" },
      acx: { prefix: "ar" },
      acy: { prefix: "ar" },
      adf: { prefix: "ar" },
      ads: { prefix: "sgn" },
      aeb: { prefix: "ar" },
      aec: { prefix: "ar" },
      aed: { prefix: "sgn" },
      aen: { prefix: "sgn" },
      afb: { prefix: "ar" },
      afg: { prefix: "sgn" },
      ajp: { prefix: "ar" },
      apc: { prefix: "ar" },
      apd: { prefix: "ar" },
      arb: { prefix: "ar" },
      arq: { prefix: "ar" },
      ars: { prefix: "ar" },
      ary: { prefix: "ar" },
      arz: { prefix: "ar" },
      ase: { prefix: "sgn" },
      asf: { prefix: "sgn" },
      asp: { prefix: "sgn" },
      asq: { prefix: "sgn" },
      asw: { prefix: "sgn" },
      auz: { prefix: "ar" },
      avl: { prefix: "ar" },
      ayh: { prefix: "ar" },
      ayl: { prefix: "ar" },
      ayn: { prefix: "ar" },
      ayp: { prefix: "ar" },
      bbz: { prefix: "ar" },
      bfi: { prefix: "sgn" },
      bfk: { prefix: "sgn" },
      bjn: { prefix: "ms" },
      bog: { prefix: "sgn" },
      bqn: { prefix: "sgn" },
      bqy: { prefix: "sgn" },
      btj: { prefix: "ms" },
      bve: { prefix: "ms" },
      bvl: { prefix: "sgn" },
      bvu: { prefix: "ms" },
      bzs: { prefix: "sgn" },
      cdo: { prefix: "zh" },
      cds: { prefix: "sgn" },
      cjy: { prefix: "zh" },
      cmn: { prefix: "zh" },
      cnp: { prefix: "zh" },
      coa: { prefix: "ms" },
      cpx: { prefix: "zh" },
      csc: { prefix: "sgn" },
      csd: { prefix: "sgn" },
      cse: { prefix: "sgn" },
      csf: { prefix: "sgn" },
      csg: { prefix: "sgn" },
      csl: { prefix: "sgn" },
      csn: { prefix: "sgn" },
      csp: { prefix: "zh" },
      csq: { prefix: "sgn" },
      csr: { prefix: "sgn" },
      csx: { prefix: "sgn" },
      czh: { prefix: "zh" },
      czo: { prefix: "zh" },
      doq: { prefix: "sgn" },
      dse: { prefix: "sgn" },
      dsl: { prefix: "sgn" },
      dup: { prefix: "ms" },
      ecs: { prefix: "sgn" },
      ehs: { prefix: "sgn" },
      esl: { prefix: "sgn" },
      esn: { prefix: "sgn" },
      eso: { prefix: "sgn" },
      eth: { prefix: "sgn" },
      fcs: { prefix: "sgn" },
      fse: { prefix: "sgn" },
      fsl: { prefix: "sgn" },
      fss: { prefix: "sgn" },
      gan: { prefix: "zh" },
      gds: { prefix: "sgn" },
      gom: { prefix: "kok" },
      gse: { prefix: "sgn" },
      gsg: { prefix: "sgn" },
      gsm: { prefix: "sgn" },
      gss: { prefix: "sgn" },
      gus: { prefix: "sgn" },
      hab: { prefix: "sgn" },
      haf: { prefix: "sgn" },
      hak: { prefix: "zh" },
      hds: { prefix: "sgn" },
      hji: { prefix: "ms" },
      hks: { prefix: "sgn" },
      hos: { prefix: "sgn" },
      hps: { prefix: "sgn" },
      hsh: { prefix: "sgn" },
      hsl: { prefix: "sgn" },
      hsn: { prefix: "zh" },
      icl: { prefix: "sgn" },
      iks: { prefix: "sgn" },
      ils: { prefix: "sgn" },
      inl: { prefix: "sgn" },
      ins: { prefix: "sgn" },
      ise: { prefix: "sgn" },
      isg: { prefix: "sgn" },
      isr: { prefix: "sgn" },
      jak: { prefix: "ms" },
      jax: { prefix: "ms" },
      jcs: { prefix: "sgn" },
      jhs: { prefix: "sgn" },
      jks: { prefix: "sgn" },
      jls: { prefix: "sgn" },
      jos: { prefix: "sgn" },
      jsl: { prefix: "sgn" },
      jus: { prefix: "sgn" },
      kgi: { prefix: "sgn" },
      knn: { prefix: "kok" },
      kvb: { prefix: "ms" },
      kvk: { prefix: "sgn" },
      kvr: { prefix: "ms" },
      kxd: { prefix: "ms" },
      lbs: { prefix: "sgn" },
      lce: { prefix: "ms" },
      lcf: { prefix: "ms" },
      liw: { prefix: "ms" },
      lls: { prefix: "sgn" },
      lsb: { prefix: "sgn" },
      lsg: { prefix: "sgn" },
      lsl: { prefix: "sgn" },
      lsn: { prefix: "sgn" },
      lso: { prefix: "sgn" },
      lsp: { prefix: "sgn" },
      lst: { prefix: "sgn" },
      lsv: { prefix: "sgn" },
      lsy: { prefix: "sgn" },
      ltg: { prefix: "lv" },
      lvs: { prefix: "lv" },
      lws: { prefix: "sgn" },
      lzh: { prefix: "zh" },
      max: { prefix: "ms" },
      mdl: { prefix: "sgn" },
      meo: { prefix: "ms" },
      mfa: { prefix: "ms" },
      mfb: { prefix: "ms" },
      mfs: { prefix: "sgn" },
      min: { prefix: "ms" },
      mnp: { prefix: "zh" },
      mqg: { prefix: "ms" },
      mre: { prefix: "sgn" },
      msd: { prefix: "sgn" },
      msi: { prefix: "ms" },
      msr: { prefix: "sgn" },
      mui: { prefix: "ms" },
      mzc: { prefix: "sgn" },
      mzg: { prefix: "sgn" },
      mzy: { prefix: "sgn" },
      nan: { prefix: "zh" },
      nbs: { prefix: "sgn" },
      ncs: { prefix: "sgn" },
      nsi: { prefix: "sgn" },
      nsl: { prefix: "sgn" },
      nsp: { prefix: "sgn" },
      nsr: { prefix: "sgn" },
      nzs: { prefix: "sgn" },
      okl: { prefix: "sgn" },
      orn: { prefix: "ms" },
      ors: { prefix: "ms" },
      pel: { prefix: "ms" },
      pga: { prefix: "ar" },
      pgz: { prefix: "sgn" },
      pks: { prefix: "sgn" },
      prl: { prefix: "sgn" },
      prz: { prefix: "sgn" },
      psc: { prefix: "sgn" },
      psd: { prefix: "sgn" },
      pse: { prefix: "ms" },
      psg: { prefix: "sgn" },
      psl: { prefix: "sgn" },
      pso: { prefix: "sgn" },
      psp: { prefix: "sgn" },
      psr: { prefix: "sgn" },
      pys: { prefix: "sgn" },
      rms: { prefix: "sgn" },
      rsi: { prefix: "sgn" },
      rsl: { prefix: "sgn" },
      rsm: { prefix: "sgn" },
      sdl: { prefix: "sgn" },
      sfb: { prefix: "sgn" },
      sfs: { prefix: "sgn" },
      sgg: { prefix: "sgn" },
      sgx: { prefix: "sgn" },
      shu: { prefix: "ar" },
      slf: { prefix: "sgn" },
      sls: { prefix: "sgn" },
      sqk: { prefix: "sgn" },
      sqs: { prefix: "sgn" },
      sqx: { prefix: "sgn" },
      ssh: { prefix: "ar" },
      ssp: { prefix: "sgn" },
      ssr: { prefix: "sgn" },
      svk: { prefix: "sgn" },
      swc: { prefix: "sw" },
      swh: { prefix: "sw" },
      swl: { prefix: "sgn" },
      syy: { prefix: "sgn" },
      szs: { prefix: "sgn" },
      tmw: { prefix: "ms" },
      tse: { prefix: "sgn" },
      tsm: { prefix: "sgn" },
      tsq: { prefix: "sgn" },
      tss: { prefix: "sgn" },
      tsy: { prefix: "sgn" },
      tza: { prefix: "sgn" },
      ugn: { prefix: "sgn" },
      ugy: { prefix: "sgn" },
      ukl: { prefix: "sgn" },
      uks: { prefix: "sgn" },
      urk: { prefix: "ms" },
      uzn: { prefix: "uz" },
      uzs: { prefix: "uz" },
      vgt: { prefix: "sgn" },
      vkk: { prefix: "ms" },
      vkt: { prefix: "ms" },
      vsi: { prefix: "sgn" },
      vsl: { prefix: "sgn" },
      vsv: { prefix: "sgn" },
      wbs: { prefix: "sgn" },
      wuu: { prefix: "zh" },
      xki: { prefix: "sgn" },
      xml: { prefix: "sgn" },
      xmm: { prefix: "ms" },
      xms: { prefix: "sgn" },
      yds: { prefix: "sgn" },
      ygs: { prefix: "sgn" },
      yhs: { prefix: "sgn" },
      ysl: { prefix: "sgn" },
      ysm: { prefix: "sgn" },
      yue: { prefix: "zh" },
      zib: { prefix: "sgn" },
      zlm: { prefix: "ms" },
      zmi: { prefix: "ms" },
      zsl: { prefix: "sgn" },
      zsm: { prefix: "ms" }
    },
    script: {
      adlm: {},
      afak: {},
      aghb: {},
      ahom: {},
      arab: {},
      aran: {},
      armi: {},
      armn: {},
      avst: {},
      bali: {},
      bamu: {},
      bass: {},
      batk: {},
      beng: {},
      bhks: {},
      blis: {},
      bopo: {},
      brah: {},
      brai: {},
      bugi: {},
      buhd: {},
      cakm: {},
      cans: {},
      cari: {},
      cham: {},
      cher: {},
      chrs: {},
      cirt: {},
      copt: {},
      cpmn: {},
      cprt: {},
      cyrl: {},
      cyrs: {},
      deva: {},
      diak: {},
      dogr: {},
      dsrt: {},
      dupl: {},
      egyd: {},
      egyh: {},
      egyp: {},
      elba: {},
      elym: {},
      ethi: {},
      geok: {},
      geor: {},
      glag: {},
      gong: {},
      gonm: {},
      goth: {},
      gran: {},
      grek: {},
      gujr: {},
      guru: {},
      hanb: {},
      hang: {},
      hani: {},
      hano: {},
      hans: {},
      hant: {},
      hatr: {},
      hebr: {},
      hira: {},
      hluw: {},
      hmng: {},
      hmnp: {},
      hrkt: {},
      hung: {},
      inds: {},
      ital: {},
      jamo: {},
      java: {},
      jpan: {},
      jurc: {},
      kali: {},
      kana: {},
      khar: {},
      khmr: {},
      khoj: {},
      kitl: {},
      kits: {},
      knda: {},
      kore: {},
      kpel: {},
      kthi: {},
      lana: {},
      laoo: {},
      latf: {},
      latg: {},
      latn: {},
      leke: {},
      lepc: {},
      limb: {},
      lina: {},
      linb: {},
      lisu: {},
      loma: {},
      lyci: {},
      lydi: {},
      mahj: {},
      maka: {},
      mand: {},
      mani: {},
      marc: {},
      maya: {},
      medf: {},
      mend: {},
      merc: {},
      mero: {},
      mlym: {},
      modi: {},
      mong: {},
      moon: {},
      mroo: {},
      mtei: {},
      mult: {},
      mymr: {},
      nand: {},
      narb: {},
      nbat: {},
      newa: {},
      nkdb: {},
      nkgb: {},
      nkoo: {},
      nshu: {},
      ogam: {},
      olck: {},
      orkh: {},
      orya: {},
      osge: {},
      osma: {},
      ougr: {},
      palm: {},
      pauc: {},
      pcun: {},
      pelm: {},
      perm: {},
      phag: {},
      phli: {},
      phlp: {},
      phlv: {},
      phnx: {},
      piqd: {},
      plrd: {},
      prti: {},
      psin: {},
      qaaa: {},
      qaab: {},
      qaac: {},
      qaad: {},
      qaae: {},
      qaaf: {},
      qaag: {},
      qaah: {},
      qaai: {},
      qaaj: {},
      qaak: {},
      qaal: {},
      qaam: {},
      qaan: {},
      qaao: {},
      qaap: {},
      qaaq: {},
      qaar: {},
      qaas: {},
      qaat: {},
      qaau: {},
      qaav: {},
      qaaw: {},
      qaax: {},
      qaba: {},
      qabb: {},
      qabc: {},
      qabd: {},
      qabe: {},
      qabf: {},
      qabg: {},
      qabh: {},
      qabi: {},
      qabj: {},
      qabk: {},
      qabl: {},
      qabm: {},
      qabn: {},
      qabo: {},
      qabp: {},
      qabq: {},
      qabr: {},
      qabs: {},
      qabt: {},
      qabu: {},
      qabv: {},
      qabw: {},
      qabx: {},
      ranj: {},
      rjng: {},
      rohg: {},
      roro: {},
      runr: {},
      samr: {},
      sara: {},
      sarb: {},
      saur: {},
      sgnw: {},
      shaw: {},
      shrd: {},
      shui: {},
      sidd: {},
      sind: {},
      sinh: {},
      sogd: {},
      sogo: {},
      sora: {},
      soyo: {},
      sund: {},
      sylo: {},
      syrc: {},
      syre: {},
      syrj: {},
      syrn: {},
      tagb: {},
      takr: {},
      tale: {},
      talu: {},
      taml: {},
      tang: {},
      tavt: {},
      telu: {},
      teng: {},
      tfng: {},
      tglg: {},
      thaa: {},
      thai: {},
      tibt: {},
      tirh: {},
      tnsa: {},
      toto: {},
      ugar: {},
      vaii: {},
      visp: {},
      vith: {},
      wara: {},
      wcho: {},
      wole: {},
      xpeo: {},
      xsux: {},
      yezi: {},
      yiii: {},
      zanb: {},
      zinh: {},
      zmth: {},
      zsye: {},
      zsym: {},
      zxxx: {},
      zyyy: {},
      zzzz: {}
    },
    region: {
      aa: {},
      ac: {},
      ad: {},
      ae: {},
      af: {},
      ag: {},
      ai: {},
      al: {},
      am: {},
      an: {},
      ao: {},
      aq: {},
      ar: {},
      as: {},
      at: {},
      au: {},
      aw: {},
      ax: {},
      az: {},
      ba: {},
      bb: {},
      bd: {},
      be: {},
      bf: {},
      bg: {},
      bh: {},
      bi: {},
      bj: {},
      bl: {},
      bm: {},
      bn: {},
      bo: {},
      bq: {},
      br: {},
      bs: {},
      bt: {},
      bu: {},
      bv: {},
      bw: {},
      by: {},
      bz: {},
      ca: {},
      cc: {},
      cd: {},
      cf: {},
      cg: {},
      ch: {},
      ci: {},
      ck: {},
      cl: {},
      cm: {},
      cn: {},
      co: {},
      cp: {},
      cr: {},
      cs: {},
      cu: {},
      cv: {},
      cw: {},
      cx: {},
      cy: {},
      cz: {},
      dd: {},
      de: {},
      dg: {},
      dj: {},
      dk: {},
      dm: {},
      do: {},
      dz: {},
      ea: {},
      ec: {},
      ee: {},
      eg: {},
      eh: {},
      er: {},
      es: {},
      et: {},
      eu: {},
      ez: {},
      fi: {},
      fj: {},
      fk: {},
      fm: {},
      fo: {},
      fr: {},
      fx: {},
      ga: {},
      gb: {},
      gd: {},
      ge: {},
      gf: {},
      gg: {},
      gh: {},
      gi: {},
      gl: {},
      gm: {},
      gn: {},
      gp: {},
      gq: {},
      gr: {},
      gs: {},
      gt: {},
      gu: {},
      gw: {},
      gy: {},
      hk: {},
      hm: {},
      hn: {},
      hr: {},
      ht: {},
      hu: {},
      ic: {},
      id: {},
      ie: {},
      il: {},
      im: {},
      in: {},
      io: {},
      iq: {},
      ir: {},
      is: {},
      it: {},
      je: {},
      jm: {},
      jo: {},
      jp: {},
      ke: {},
      kg: {},
      kh: {},
      ki: {},
      km: {},
      kn: {},
      kp: {},
      kr: {},
      kw: {},
      ky: {},
      kz: {},
      la: {},
      lb: {},
      lc: {},
      li: {},
      lk: {},
      lr: {},
      ls: {},
      lt: {},
      lu: {},
      lv: {},
      ly: {},
      ma: {},
      mc: {},
      md: {},
      me: {},
      mf: {},
      mg: {},
      mh: {},
      mk: {},
      ml: {},
      mm: {},
      mn: {},
      mo: {},
      mp: {},
      mq: {},
      mr: {},
      ms: {},
      mt: {},
      mu: {},
      mv: {},
      mw: {},
      mx: {},
      my: {},
      mz: {},
      na: {},
      nc: {},
      ne: {},
      nf: {},
      ng: {},
      ni: {},
      nl: {},
      no: {},
      np: {},
      nr: {},
      nt: {},
      nu: {},
      nz: {},
      om: {},
      pa: {},
      pe: {},
      pf: {},
      pg: {},
      ph: {},
      pk: {},
      pl: {},
      pm: {},
      pn: {},
      pr: {},
      ps: {},
      pt: {},
      pw: {},
      py: {},
      qa: {},
      qm: {},
      qn: {},
      qo: {},
      qp: {},
      qq: {},
      qr: {},
      qs: {},
      qt: {},
      qu: {},
      qv: {},
      qw: {},
      qx: {},
      qy: {},
      qz: {},
      re: {},
      ro: {},
      rs: {},
      ru: {},
      rw: {},
      sa: {},
      sb: {},
      sc: {},
      sd: {},
      se: {},
      sg: {},
      sh: {},
      si: {},
      sj: {},
      sk: {},
      sl: {},
      sm: {},
      sn: {},
      so: {},
      sr: {},
      ss: {},
      st: {},
      su: {},
      sv: {},
      sx: {},
      sy: {},
      sz: {},
      ta: {},
      tc: {},
      td: {},
      tf: {},
      tg: {},
      th: {},
      tj: {},
      tk: {},
      tl: {},
      tm: {},
      tn: {},
      to: {},
      tp: {},
      tr: {},
      tt: {},
      tv: {},
      tw: {},
      tz: {},
      ua: {},
      ug: {},
      um: {},
      un: {},
      us: {},
      uy: {},
      uz: {},
      va: {},
      vc: {},
      ve: {},
      vg: {},
      vi: {},
      vn: {},
      vu: {},
      wf: {},
      ws: {},
      xa: {},
      xb: {},
      xc: {},
      xd: {},
      xe: {},
      xf: {},
      xg: {},
      xh: {},
      xi: {},
      xj: {},
      xk: {},
      xl: {},
      xm: {},
      xn: {},
      xo: {},
      xp: {},
      xq: {},
      xr: {},
      xs: {},
      xt: {},
      xu: {},
      xv: {},
      xw: {},
      xx: {},
      xy: {},
      xz: {},
      yd: {},
      ye: {},
      yt: {},
      yu: {},
      za: {},
      zm: {},
      zr: {},
      zw: {},
      zz: {},
      "001": {},
      "002": {},
      "003": {},
      "005": {},
      "009": {},
      "011": {},
      "013": {},
      "014": {},
      "015": {},
      "017": {},
      "018": {},
      "019": {},
      "021": {},
      "029": {},
      "030": {},
      "034": {},
      "035": {},
      "039": {},
      "053": {},
      "054": {},
      "057": {},
      "061": {},
      "142": {},
      "143": {},
      "145": {},
      "150": {},
      "151": {},
      "154": {},
      "155": {},
      "202": {},
      "419": {}
    },
    variant: {
      "1606nict": { prefixes: ["frm"] },
      "1694acad": { prefixes: ["fr"] },
      "1901": { prefixes: ["de"] },
      "1959acad": { prefixes: ["be"] },
      "1994": {
        prefixes: [
          "sl-rozaj",
          "sl-rozaj-biske",
          "sl-rozaj-njiva",
          "sl-rozaj-osojs",
          "sl-rozaj-solba"
        ]
      },
      "1996": { prefixes: ["de"] },
      abl1943: { prefixes: ["pt-BR"] },
      akuapem: { prefixes: ["tw"] },
      alalc97: { prefixes: [] },
      aluku: { prefixes: ["djk"] },
      ao1990: { prefixes: ["pt", "gl"] },
      aranes: { prefixes: ["oc"] },
      arevela: { prefixes: ["hy"] },
      arevmda: { prefixes: ["hy"] },
      arkaika: { prefixes: ["eo"] },
      asante: { prefixes: ["tw"] },
      auvern: { prefixes: ["oc"] },
      baku1926: {
        prefixes: ["az", "ba", "crh", "kk", "krc", "ky", "sah", "tk", "tt", "uz"]
      },
      balanka: { prefixes: ["blo"] },
      barla: { prefixes: ["kea"] },
      basiceng: { prefixes: ["en"] },
      bauddha: { prefixes: ["sa"] },
      biscayan: { prefixes: ["eu"] },
      biske: { prefixes: ["sl-rozaj"] },
      bohoric: { prefixes: ["sl"] },
      boont: { prefixes: ["en"] },
      bornholm: { prefixes: ["da"] },
      cisaup: { prefixes: ["oc"] },
      colb1945: { prefixes: ["pt"] },
      cornu: { prefixes: ["en"] },
      creiss: { prefixes: ["oc"] },
      dajnko: { prefixes: ["sl"] },
      ekavsk: { prefixes: ["sr", "sr-Latn", "sr-Cyrl"] },
      emodeng: { prefixes: ["en"] },
      fonipa: { prefixes: [] },
      fonkirsh: { prefixes: [] },
      fonnapa: { prefixes: [] },
      fonupa: { prefixes: [] },
      fonxsamp: { prefixes: [] },
      gallo: { prefixes: ["fr"] },
      gascon: { prefixes: ["oc"] },
      grclass: {
        prefixes: [
          "oc",
          "oc-aranes",
          "oc-auvern",
          "oc-cisaup",
          "oc-creiss",
          "oc-gascon",
          "oc-lemosin",
          "oc-lengadoc",
          "oc-nicard",
          "oc-provenc",
          "oc-vivaraup"
        ]
      },
      grital: { prefixes: ["oc", "oc-cisaup", "oc-nicard", "oc-provenc"] },
      grmistr: {
        prefixes: [
          "oc",
          "oc-aranes",
          "oc-auvern",
          "oc-cisaup",
          "oc-creiss",
          "oc-gascon",
          "oc-lemosin",
          "oc-lengadoc",
          "oc-nicard",
          "oc-provenc",
          "oc-vivaraup"
        ]
      },
      hepburn: { prefixes: ["ja-Latn"] },
      heploc: { prefixes: ["ja-Latn-hepburn"] },
      hognorsk: { prefixes: ["nn"] },
      hsistemo: { prefixes: ["eo"] },
      ijekavsk: { prefixes: ["sr", "sr-Latn", "sr-Cyrl"] },
      itihasa: { prefixes: ["sa"] },
      ivanchov: { prefixes: ["bg"] },
      jauer: { prefixes: ["rm"] },
      jyutping: { prefixes: ["yue"] },
      kkcor: { prefixes: ["kw"] },
      kociewie: { prefixes: ["pl"] },
      kscor: { prefixes: ["kw"] },
      laukika: { prefixes: ["sa"] },
      lemosin: { prefixes: ["oc"] },
      lengadoc: { prefixes: ["oc"] },
      lipaw: { prefixes: ["sl-rozaj"] },
      luna1918: { prefixes: ["ru"] },
      metelko: { prefixes: ["sl"] },
      monoton: { prefixes: ["el"] },
      ndyuka: { prefixes: ["djk"] },
      nedis: { prefixes: ["sl"] },
      newfound: { prefixes: ["en-CA"] },
      nicard: { prefixes: ["oc"] },
      njiva: { prefixes: ["sl-rozaj"] },
      nulik: { prefixes: ["vo"] },
      osojs: { prefixes: ["sl-rozaj"] },
      oxendict: { prefixes: ["en"] },
      pahawh2: { prefixes: ["mww", "hnj"] },
      pahawh3: { prefixes: ["mww", "hnj"] },
      pahawh4: { prefixes: ["mww", "hnj"] },
      pamaka: { prefixes: ["djk"] },
      peano: { prefixes: ["la"] },
      petr1708: { prefixes: ["ru"] },
      pinyin: { prefixes: ["zh-Latn", "bo-Latn"] },
      polyton: { prefixes: ["el"] },
      provenc: { prefixes: ["oc"] },
      puter: { prefixes: ["rm"] },
      rigik: { prefixes: ["vo"] },
      rozaj: { prefixes: ["sl"] },
      rumgr: { prefixes: ["rm"] },
      scotland: { prefixes: ["en"] },
      scouse: { prefixes: ["en"] },
      simple: { prefixes: [] },
      solba: { prefixes: ["sl-rozaj"] },
      sotav: { prefixes: ["kea"] },
      spanglis: { prefixes: ["en", "es"] },
      surmiran: { prefixes: ["rm"] },
      sursilv: { prefixes: ["rm"] },
      sutsilv: { prefixes: ["rm"] },
      synnejyl: { prefixes: ["da"] },
      tarask: { prefixes: ["be"] },
      tongyong: { prefixes: ["zh-Latn"] },
      tunumiit: { prefixes: ["kl"] },
      uccor: { prefixes: ["kw"] },
      ucrcor: { prefixes: ["kw"] },
      ulster: { prefixes: ["sco"] },
      unifon: { prefixes: ["en", "hup", "kyh", "tol", "yur"] },
      vaidika: { prefixes: ["sa"] },
      valencia: { prefixes: ["ca"] },
      vallader: { prefixes: ["rm"] },
      vecdruka: { prefixes: ["lv"] },
      vivaraup: { prefixes: ["oc"] },
      wadegile: { prefixes: ["zh-Latn"] },
      xsistemo: { prefixes: ["eo"] }
    }
  };

  // node_modules/@siteimprove/alfa-iana/dist/language.js
  var Language = class _Language {
    static of(primary, extended = None, script = None, region = None, variants = []) {
      return new _Language(primary, extended, script, region, variants);
    }
    _primary;
    _extended;
    _script;
    _region;
    _variants;
    constructor(primary, extended, script, region, variants) {
      this._primary = primary;
      this._extended = extended;
      this._script = script;
      this._region = region;
      this._variants = variants;
    }
    get primary() {
      return this._primary;
    }
    get extended() {
      return this._extended;
    }
    get script() {
      return this._script;
    }
    get region() {
      return this._region;
    }
    get variants() {
      return this._variants;
    }
    equals(value) {
      return value instanceof _Language && value._primary.equals(this._primary) && value._extended.equals(this._extended) && value._script.equals(this._script) && value._region.equals(this._region) && value._variants.length === this._variants.length && value._variants.every((variant, i) => variant.equals(this._variants[i]));
    }
    toJSON() {
      return {
        type: "language",
        primary: this._primary.toJSON(),
        extended: this._extended.map((extended) => extended.toJSON()).getOr(null),
        script: this._script.map((script) => script.toJSON()).getOr(null),
        region: this._region.map((region) => region.toJSON()).getOr(null),
        variants: this._variants.map((variant) => variant.toJSON())
      };
    }
    toString() {
      return [
        this._primary,
        ...this._extended,
        ...this._script,
        ...this._region,
        ...this._variants
      ].join("-");
    }
  };
  (function(Language2) {
    class Subtag {
      _name;
      constructor(name) {
        this._name = name;
      }
      /**
       * {@link https://tools.ietf.org/html/bcp47#section-3.1.4}
       */
      get name() {
        return this._name;
      }
      toString() {
        return this._name;
      }
    }
    Language2.Subtag = Subtag;
    class Primary extends Subtag {
      static of(name) {
        return new Primary(name);
      }
      constructor(name) {
        super(name);
      }
      get type() {
        return "primary";
      }
      /**
       * {@link https://tools.ietf.org/html/bcp47#section-3.1.11}
       */
      get scope() {
        return Option.from(Languages.primary[this._name].scope);
      }
      equals(value) {
        return value instanceof Primary && value._name === this._name;
      }
      toJSON() {
        return {
          type: "primary",
          name: this._name,
          scope: this.scope.getOr(null)
        };
      }
    }
    Language2.Primary = Primary;
    (function(Primary2) {
      function isPrimary(value) {
        return value instanceof Primary2;
      }
      Primary2.isPrimary = isPrimary;
      function isName2(name) {
        return name in Languages.primary;
      }
      Primary2.isName = isName2;
    })(Primary = Language2.Primary || (Language2.Primary = {}));
    Language2.primary = Primary.of, Language2.isPrimary = Primary.isPrimary, Language2.isPrimaryName = Primary.isName;
    class Extended extends Subtag {
      static of(name) {
        return new Extended(name);
      }
      constructor(name) {
        super(name);
      }
      get type() {
        return "extended";
      }
      /**
       * {@link https://tools.ietf.org/html/bcp47#section-3.1.8}
       */
      get prefix() {
        return Languages.extended[this._name].prefix;
      }
      equals(value) {
        return value instanceof Extended && value._name === this._name;
      }
      toJSON() {
        return {
          type: "extended",
          name: this._name,
          prefix: this.prefix
        };
      }
    }
    Language2.Extended = Extended;
    (function(Extended2) {
      function isExtended(value) {
        return value instanceof Extended2;
      }
      Extended2.isExtended = isExtended;
      function isName2(name) {
        return name in Languages.extended;
      }
      Extended2.isName = isName2;
    })(Extended = Language2.Extended || (Language2.Extended = {}));
    Language2.extended = Extended.of, Language2.isExtended = Extended.isExtended, Language2.isExtendedName = Extended.isName;
    class Script extends Subtag {
      static of(name) {
        return new Script(name);
      }
      constructor(name) {
        super(name);
      }
      get type() {
        return "script";
      }
      equals(value) {
        return value instanceof Script && value._name === this._name;
      }
      toJSON() {
        return {
          type: "script",
          name: this._name
        };
      }
    }
    Language2.Script = Script;
    (function(Script2) {
      function isScript(value) {
        return value instanceof Script2;
      }
      Script2.isScript = isScript;
      function isName2(name) {
        return name in Languages.script;
      }
      Script2.isName = isName2;
    })(Script = Language2.Script || (Language2.Script = {}));
    Language2.script = Script.of, Language2.isScript = Script.isScript, Language2.isScriptName = Script.isName;
    class Region extends Subtag {
      static of(name) {
        return new Region(name);
      }
      constructor(name) {
        super(name);
      }
      get type() {
        return "region";
      }
      equals(value) {
        return value instanceof Region && value._name === this._name;
      }
      toJSON() {
        return {
          type: "region",
          name: this._name
        };
      }
    }
    Language2.Region = Region;
    (function(Region2) {
      function isRegion(value) {
        return value instanceof Region2;
      }
      Region2.isRegion = isRegion;
      function isName2(name) {
        return name in Languages.region;
      }
      Region2.isName = isName2;
    })(Region = Language2.Region || (Language2.Region = {}));
    Language2.region = Region.of, Language2.isRegion = Region.isRegion, Language2.isRegionName = Region.isName;
    class Variant extends Subtag {
      static of(name) {
        return new Variant(name);
      }
      constructor(name) {
        super(name);
      }
      get type() {
        return "variant";
      }
      /**
       * {@link https://tools.ietf.org/html/bcp47#section-3.1.8}
       */
      get prefixes() {
        return Languages.variant[this._name].prefixes;
      }
      equals(value) {
        return value instanceof Variant && value._name === this._name;
      }
      toJSON() {
        return {
          type: "variant",
          name: this._name,
          prefixes: [...this.prefixes]
        };
      }
    }
    Language2.Variant = Variant;
    (function(Variant2) {
      function isVariant(value) {
        return value instanceof Variant2;
      }
      Variant2.isVariant = isVariant;
      function isName2(name) {
        return name in Languages.variant;
      }
      Variant2.isName = isName2;
    })(Variant = Language2.Variant || (Language2.Variant = {}));
    Language2.variant = Variant.of, Language2.isVariant = Variant.isVariant, Language2.isVariantName = Variant.isName;
  })(Language || (Language = {}));
  (function(Language2) {
    function parse57(input) {
      let parts = Slice.of(input.toLowerCase().split("-"));
      return parts.get(0).map((name) => {
        if (!Language2.isPrimaryName(name)) {
          return Err.of(`${name} is not a valid primary language`);
        }
        const primary = Language2.Primary.of(name);
        parts = parts.slice(1);
        const extended = parts.get(0).filter(Language2.isExtendedName).map(Language2.Extended.of);
        if (extended.isSome()) {
          parts = parts.slice(1);
        }
        const script = parts.get(0).filter(Language2.isScriptName).map(Language2.Script.of);
        if (script.isSome()) {
          parts = parts.slice(1);
        }
        const region = parts.get(0).filter(Language2.isRegionName).map(Language2.Region.of);
        if (region.isSome()) {
          parts = parts.slice(1);
        }
        const variants = [];
        while (true) {
          const variant = parts.get(0).filter(Language2.isVariantName).map(Language2.Variant.of);
          if (variant.isSome()) {
            parts = parts.slice(1);
            variants.push(variant.get());
          } else {
            break;
          }
        }
        return Result.of(Language2.of(primary, extended, script, region, variants));
      }).getOrElse(() => Err.of(`Expected a primary language name`));
    }
    Language2.parse = parse57;
  })(Language || (Language = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r109/rule.js
  var { hasAttribute: hasAttribute6 } = Element;
  var rule_default4 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r109",
    requirements: [Criterion.of("3.1.1"), Technique.of("H57")],
    tags: [Scope.Page, Stability.Experimental],
    evaluate({ document: document2 }) {
      let programmaticLanguage;
      return {
        applicability() {
          return withDocumentElement(document2, hasAttribute6("lang", (lang) => Language.parse(lang).tee((lang2) => {
            programmaticLanguage = lang2;
          }).isOk()));
        },
        expectations(target) {
          return {
            1: Question2.of("document-language", target).map((language) => Language.parse(language).mapOrElse((naturalLanguage) => expectation(programmaticLanguage.primary.equals(naturalLanguage.primary), () => Outcomes4.HasCorrectLang(programmaticLanguage, naturalLanguage), () => Outcomes4.HasIncorrectLang(programmaticLanguage, naturalLanguage)), (_) => Option.of(Outcomes4.HasNoLanguage(programmaticLanguage))))
          };
        }
      };
    }
  });
  var Outcomes4;
  (function(Outcomes87) {
    Outcomes87.HasCorrectLang = (programmatic, natural) => Ok.of(Languages2.of(`The document's \`lang\` attribute (${programmatic}) matches its language (${natural})`, programmatic, natural));
    Outcomes87.HasIncorrectLang = (programmatic, natural) => Err.of(Languages2.of(`The document's \`lang\` attribute (${programmatic}) does not match its language (${natural})`, programmatic, natural));
    Outcomes87.HasNoLanguage = (programmatic) => Err.of(Languages2.of("The document has no identifiable natural language", programmatic));
  })(Outcomes4 || (Outcomes4 = {}));
  var Languages2 = class _Languages extends Diagnostic {
    static of(message, programmatic = Language.of(Language.Primary.of("en")), natural) {
      return new _Languages(message, programmatic, Option.from(natural));
    }
    _programmatic;
    _natural;
    constructor(message, programmatic, natural) {
      super(message);
      this._programmatic = programmatic;
      this._natural = natural;
    }
    get programmatic() {
      return this._programmatic;
    }
    get natural() {
      return this._natural;
    }
    equals(value) {
      return value instanceof _Languages && value._message === this._message && value._programmatic.equals(this._programmatic) && value._natural.equals(this._natural);
    }
    hash(hash2) {
      super.hash(hash2);
      hash2.writeString(this._programmatic.primary.name);
      this._natural.forEach((lang) => hash2.writeString(lang.primary.name));
    }
    toJSON(options) {
      return {
        ...super.toJSON(options),
        programmatic: this._programmatic.toJSON(),
        natural: this._natural.toJSON()
      };
    }
  };
  (function(Languages3) {
    function isLanguages(value) {
      return value instanceof Languages3;
    }
    Languages3.isLanguages = isLanguages;
  })(Languages2 || (Languages2 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r14/rule.js
  var { hasAccessibleName: hasAccessibleName2, hasRole: hasRole6, isPerceivableForAll: isPerceivableForAll4 } = DOM;
  var { hasAttribute: hasAttribute7, hasNamespace: hasNamespace5 } = Element;
  var { hasDescendant: hasDescendant2 } = Node4;
  var { and: and36, test: test24 } = Predicate;
  var { isFocusable: isFocusable2 } = Style;
  var { getElementDescendants: getElementDescendants7 } = Query3;
  var rule_default5 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r14",
    requirements: [Criterion.of("2.5.3"), Technique.of("G208")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return getElementDescendants7(document2, Node4.fullTree).filter(and36(hasNamespace5(Namespace.HTML, Namespace.SVG), hasAttribute7((attribute) => attribute.name === "aria-label" || attribute.name === "aria-labelledby"), isFocusable2(device), hasRole6(device, (role) => role.isWidget() && role.isNamedBy("contents")), hasDescendant2(and36(Text.isText, isPerceivableForAll4(device)), Node4.flatTree)));
        },
        expectations(target) {
          const removePunctuationAndNormalise = String2.and(String2.removePunctuation, String2.normalize);
          const textContent = removePunctuationAndNormalise(Style.innerText(device, isPerceivableForAll4)(target));
          let name = "";
          const accessibleNameIncludesTextContent = test24(hasAccessibleName2(device, (accessibleName) => {
            name = removePunctuationAndNormalise(accessibleName.value);
            return name.includes(textContent);
          }), target);
          return {
            1: expectation(accessibleNameIncludesTextContent, () => Outcomes5.VisibleIsInName(textContent, name), () => Outcomes5.VisibleIsNotInName(textContent, name))
          };
        }
      };
    }
  });
  var Outcomes5;
  (function(Outcomes87) {
    Outcomes87.VisibleIsInName = (textContent, name) => Ok.of(LabelAndName.of(`The visible text content of the element is included within its accessible name`, textContent, name));
    Outcomes87.VisibleIsNotInName = (textContent, name) => Err.of(LabelAndName.of(`The visible text content of the element is not included within its accessible name`, textContent, name));
  })(Outcomes5 || (Outcomes5 = {}));
  var LabelAndName = class _LabelAndName extends Diagnostic {
    static of(message, textContent = "", name = "") {
      return new _LabelAndName(message, textContent, name);
    }
    _textContent;
    _name;
    constructor(message, textContent, name) {
      super(message);
      this._textContent = textContent;
      this._name = name;
    }
    get textContent() {
      return this._textContent;
    }
    get name() {
      return this._name;
    }
    equals(value) {
      return value instanceof _LabelAndName && value._message === this._message && value._textContent === this._textContent && value._name === this._name;
    }
    hash(hash2) {
      super.hash(hash2);
      hash2.writeString(this._name);
      hash2.writeString(this._textContent);
    }
    toJSON(options) {
      return {
        ...super.toJSON(options),
        textContent: this._textContent,
        name: this._name
      };
    }
  };
  (function(LabelAndName2) {
    function isLabelAndName(value) {
      return value instanceof LabelAndName2;
    }
    LabelAndName2.isLabelAndName = isLabelAndName;
  })(LabelAndName || (LabelAndName = {}));

  // node_modules/@siteimprove/alfa-rules/dist/common/predicate/is-aria-controls-optional.js
  var { hasAttribute: hasAttribute8, hasRole: hasRole7 } = Node5;
  var { and: and37 } = Predicate;
  var isAriaControlsOptional = and37(hasRole7("combobox"), hasAttribute8("aria-expanded", (expanded) => expanded !== "true"));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r16/rule.js
  var { hasNonDefaultRole: hasNonDefaultRole2, isIncludedInTheAccessibilityTree: isIncludedInTheAccessibilityTree3 } = DOM;
  var { hasNamespace: hasNamespace6 } = Element;
  var { isEmpty: isEmpty5 } = Iterable;
  var { and: and38, property: property8 } = Predicate;
  var { isFocusable: isFocusable3 } = Style;
  var { getElementDescendants: getElementDescendants8 } = Query3;
  var rule_default6 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r16",
    requirements: [
      Criterion.of("1.3.1"),
      Criterion.of("4.1.2"),
      Technique.of("ARIA5")
    ],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return getElementDescendants8(document2, Node4.composedNested).filter(and38(hasNamespace6(Namespace.HTML, Namespace.SVG), hasNonDefaultRole2)).filter(isIncludedInTheAccessibilityTree3(device));
        },
        expectations(target) {
          return { 1: hasRequiredValues(device, target) };
        }
      };
    }
  });
  function hasRequiredValues(device, element) {
    const node = Node5.from(element, device);
    for (const role of node.role) {
      if (role.is("separator") && !isFocusable3(device)(element)) {
        return Outcomes6.HasAllStates(role.name, [], []);
      }
      const required = role.requiredAttributes;
      const missing = [];
      let result = true;
      for (const attribute of required) {
        if (node.attribute(attribute).every(property8("value", isEmpty5)) && !(isAriaControlsOptional(node) && attribute === "aria-controls")) {
          missing.push(attribute);
          result = false;
        }
      }
      return result ? Outcomes6.HasAllStates(role.name, required, missing) : Outcomes6.HasNotAllStates(role.name, required, missing);
    }
    return Outcomes6.RuleError;
  }
  var RoleAndRequiredAttributes = class _RoleAndRequiredAttributes extends Diagnostic {
    static of(message, role, requiredAttributes, missingAttributes) {
      return role === void 0 ? Diagnostic.of(message) : new _RoleAndRequiredAttributes(
        message,
        role,
        // Presence is ensured by the overload
        requiredAttributes,
        missingAttributes
      );
    }
    _role;
    _requiredAttributes;
    _missingAttributes;
    constructor(message, role, requiredAttributes, missingAttributes) {
      super(message);
      this._role = role;
      this._requiredAttributes = requiredAttributes;
      this._missingAttributes = missingAttributes;
    }
    get role() {
      return this._role;
    }
    get requiredAttributes() {
      return this._requiredAttributes;
    }
    get missingAttributes() {
      return this._missingAttributes;
    }
    equals(value) {
      return value instanceof _RoleAndRequiredAttributes && value._message === this._message && value._role === this._role && Array2.equals(value._requiredAttributes, this._requiredAttributes) && Array2.equals(value._missingAttributes, this._missingAttributes);
    }
    hash(hash2) {
      super.hash(hash2);
      hash2.writeString(this._role);
      this._requiredAttributes.forEach((attr) => hash2.writeString(attr));
      this._missingAttributes.forEach((attr) => hash2.writeString(attr));
    }
    toJSON(options) {
      return {
        ...super.toJSON(options),
        role: this._role,
        attributes: {
          required: Array2.copy(this._requiredAttributes),
          missing: Array2.copy(this._missingAttributes)
        }
      };
    }
  };
  (function(RoleAndRequiredAttributes2) {
    function isRoleAndRequiredAttributes(value) {
      return value instanceof RoleAndRequiredAttributes2;
    }
    RoleAndRequiredAttributes2.isRoleAndRequiredAttributes = isRoleAndRequiredAttributes;
  })(RoleAndRequiredAttributes || (RoleAndRequiredAttributes = {}));
  var Outcomes6;
  (function(Outcomes87) {
    Outcomes87.HasAllStates = (role, required, missing) => Ok.of(RoleAndRequiredAttributes.of("The element has all required states and properties", role, required, missing));
    Outcomes87.HasNotAllStates = (role, required, missing) => Err.of(RoleAndRequiredAttributes.of("The element does not have all required states and properties", role, required, missing));
    Outcomes87.RuleError = Err.of(RoleAndRequiredAttributes.of("", "generic", [], []));
  })(Outcomes6 || (Outcomes6 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/common/act/group.js
  var Group2 = class _Group {
    static of(members) {
      return new _Group(Array2.from(members));
    }
    _members;
    constructor(members) {
      this._members = members;
    }
    get size() {
      return this._members.length;
    }
    *[Symbol.iterator]() {
      yield* this._members;
    }
    equals(value) {
      return value instanceof _Group && value._members.length === this._members.length && value._members.every((member, i) => Equatable.equals(member, this._members[i]));
    }
    hash(hash2) {
      for (const member of this._members) {
        member.hash(hash2);
      }
    }
    toJSON(options) {
      return this._members.map((member) => Serializable.toJSON(member, options));
    }
    toEARL() {
      return {
        "@context": {
          ptr: "http://www.w3.org/2009/pointers#"
        },
        "@type": ["ptr:Pointer", "ptr:PointersGroup", "ptr:RelatedPointers"],
        "ptr:groupPointer": {
          "@list": Array2.collect(this._members, (member) => Serializable2.toEARL(member))
        }
      };
    }
    toSARIF() {
      return {
        logicalLocations: Array2.flatMap(this._members, (member) => Serializable3.toSARIF(member).map((location) => location.logicalLocations ?? []).getOr([]))
      };
    }
  };
  (function(Group3) {
    function isGroup(value) {
      return value instanceof Group3;
    }
    Group3.isGroup = isGroup;
  })(Group2 || (Group2 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r55/rule.js
  var { hasIncorrectRoleWithoutName: hasIncorrectRoleWithoutName2, hasRole: hasRole8, isIncludedInTheAccessibilityTree: isIncludedInTheAccessibilityTree4 } = DOM;
  var { hasNamespace: hasNamespace7 } = Element;
  var { and: and39, equals: equals23 } = Predicate;
  var { getElementDescendants: getElementDescendants9 } = Query3;
  var rule_default7 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r55",
    requirements: [
      ARIA.of("https://www.w3.org/WAI/ARIA/apg/practices/landmark-regions/#aria_lh_step3")
    ],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return getElementDescendants9(document2, Node4.fullTree).filter(and39(hasNamespace7(equals23(Namespace.HTML)), isIncludedInTheAccessibilityTree4(device), hasRole8(device, (role) => role.is("landmark")))).reject(hasIncorrectRoleWithoutName2(device)).groupBy((landmark) => Node5.from(landmark, device).name.map((name) => String2.normalize(name.value))).filter((landmarks) => landmarks.size > 1).flatMap((sameName) => sameName.groupBy((landmark) => Node5.from(landmark, device).role.getUnsafe())).filter((elements) => elements.size > 1).map(Group2.of).values();
        },
        expectations(target) {
          const first = Node5.from(Iterable.first(target).getUnsafe(), device);
          const role = first.role.map((role2) => role2.name).getOr("generic");
          const name = first.name.map((name2) => name2.value).getOr("");
          const sameResource = Question2.of("is-content-equivalent", target, `Do these ${role} landmarks have the same or equivalent content?`, {
            diagnostic: WithRoleAndName.of(`Do these ${role} landmarks have the same or equivalent content?`, role, name)
          });
          return {
            1: sameResource.map((same) => expectation(same, () => Outcomes7.SameResource(role, name), () => Outcomes7.DifferentResources(role, name)))
          };
        }
      };
    }
  });
  var Outcomes7;
  (function(Outcomes87) {
    Outcomes87.SameResource = (role, name) => Ok.of(WithRoleAndName.of(`No two \`${role}\` have the same name and different content.`, role, name));
    Outcomes87.DifferentResources = (role, name) => Err.of(WithRoleAndName.of(`Some \`${role}\` have the same name and different content.`, role, name));
  })(Outcomes7 || (Outcomes7 = {}));
  var WithRoleAndName = class _WithRoleAndName extends WithRole {
    static of(message, role, name) {
      return role === void 0 ? new Diagnostic(message) : name === void 0 ? new WithRole(message, role) : new _WithRoleAndName(message, role, name);
    }
    _name;
    constructor(message, role, name) {
      super(message, role);
      this._name = name;
    }
    get name() {
      return this._name;
    }
    equals(value) {
      return value instanceof _WithRoleAndName && value._message === this._message && value._role === this._role && value._name === this._name;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        name: this._name
      };
    }
  };
  (function(WithRoleAndName2) {
    function isWithRoleAndName(value) {
      return value instanceof WithRoleAndName2;
    }
    WithRoleAndName2.isWithRoleAndName = isWithRoleAndName;
  })(WithRoleAndName || (WithRoleAndName = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r56/rule.js
  var { hasIncorrectRoleWithoutName: hasIncorrectRoleWithoutName3, hasRole: hasRole9, isIncludedInTheAccessibilityTree: isIncludedInTheAccessibilityTree5 } = DOM;
  var { hasNamespace: hasNamespace8 } = Element;
  var { and: and40, equals: equals24 } = Predicate;
  var { getElementDescendants: getElementDescendants10 } = Query3;
  var rule_default8 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r56",
    requirements: [
      ARIA.of("https://www.w3.org/WAI/ARIA/apg/practices/landmark-regions/#aria_lh_step3")
    ],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return getElementDescendants10(document2, Node4.fullTree).filter(and40(hasNamespace8(equals24(Namespace.HTML)), isIncludedInTheAccessibilityTree5(device), hasRole9(device, (role) => role.is("landmark")))).reject(hasIncorrectRoleWithoutName3(device)).groupBy((landmark) => Node5.from(landmark, device).role.getUnsafe()).filter((elements) => elements.size > 1).map(Group2.of).values();
        },
        expectations(target) {
          const role = Node5.from(Iterable.first(target).getUnsafe(), device).role.map((role2) => role2.name).getOr("generic");
          const byNames = List.from(target).groupBy((landmark) => Node5.from(landmark, device).name.map((name) => String2.normalize(name.value))).filter((landmarks) => landmarks.size > 1);
          return {
            1: expectation(byNames.size === 0, () => Outcomes8.differentNames(role), () => Outcomes8.sameNames(role, byNames.values()))
          };
        }
      };
    }
  });
  var Outcomes8;
  (function(Outcomes87) {
    Outcomes87.differentNames = (role) => Ok.of(SameNames.of(`No two \`${role}\` have the same name.`, role, []));
    Outcomes87.sameNames = (role, errors) => Err.of(SameNames.of(`Some \`${role}\` have the same name.`, role, errors));
  })(Outcomes8 || (Outcomes8 = {}));
  var SameNames = class _SameNames extends Diagnostic {
    static of(message, role = "none", errors = []) {
      return new _SameNames(message, role, Array2.from(errors).map(List.from));
    }
    _role;
    _errors;
    constructor(message, role, errors) {
      super(message);
      this._role = role;
      this._errors = errors;
    }
    get role() {
      return this._role;
    }
    *[Symbol.iterator]() {
      yield* this._errors;
    }
    equals(value) {
      return value instanceof _SameNames && value._message === this._message && value._role === this._role && value._errors.every((list, idx) => list.equals(this._errors[idx]));
    }
    hash(hash2) {
      super.hash(hash2);
      hash2.writeString(this._role);
      this._errors.forEach((element) => element.hash(hash2));
    }
    toJSON(options) {
      return {
        ...super.toJSON(options),
        role: this._role,
        errors: Array2.toJSON(this._errors, options)
      };
    }
  };
  (function(SameNames2) {
    function isSameNames(value) {
      return value instanceof SameNames2;
    }
    SameNames2.isSameNames = isSameNames;
  })(SameNames || (SameNames = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r61/rule.js
  var { hasRole: hasRole10, isIncludedInTheAccessibilityTree: isIncludedInTheAccessibilityTree6 } = DOM;
  var { isElement: isElement34 } = Element;
  var { and: and41 } = Refinement;
  var rule_default9 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r61",
    requirements: [BestPractice.of("document-start-with-level-1-heading")],
    tags: [Scope.Page, Stability.Stable],
    evaluate({ device, document: document2 }) {
      const firstHeading = document2.descendants(Node4.flatTree).filter(and41(isElement34, isIncludedInTheAccessibilityTree6(device))).find(hasRole10(device, "heading"));
      return {
        applicability() {
          return withDocumentElement(document2, () => firstHeading.isSome());
        },
        expectations(target) {
          const heading = firstHeading.getUnsafe();
          const level = Node5.from(heading, device).attribute("aria-level").map((level2) => Number(level2.value)).getOr(0);
          return {
            1: expectation(level === 1, () => Outcomes9.StartWithLevel1Heading(heading, level), () => Outcomes9.StartWithHigherLevelHeading(heading, level))
          };
        }
      };
    }
  });
  var Outcomes9;
  (function(Outcomes87) {
    Outcomes87.StartWithLevel1Heading = (heading, level) => Ok.of(WithFirstHeading.of(`The document starts with a level 1 heading`, heading, level));
    Outcomes87.StartWithHigherLevelHeading = (heading, level) => Err.of(WithFirstHeading.of(`The document does not start with a level 1 heading`, heading, level));
  })(Outcomes9 || (Outcomes9 = {}));
  var WithFirstHeading = class _WithFirstHeading extends Diagnostic {
    static of(message, firstHeading, level) {
      return firstHeading === void 0 || level === void 0 ? Diagnostic.of(message) : new _WithFirstHeading(message, firstHeading, level);
    }
    _firstHeading;
    _level;
    constructor(message, firstHeading, level) {
      super(message);
      this._firstHeading = firstHeading;
      this._level = level;
    }
    get firstHeading() {
      return this._firstHeading;
    }
    get firstHeadingLevel() {
      return this._level;
    }
    equals(value) {
      return value instanceof _WithFirstHeading && value._message === this._message && value._firstHeading.equals(this._firstHeading) && value._level === this._level;
    }
    hash(hash2) {
      super.hash(hash2);
      hash2.writeNumber(this._level);
      this._firstHeading.hash(hash2);
    }
    toJSON(options) {
      return {
        ...super.toJSON(options),
        firstHeading: this._firstHeading.toJSON(options),
        firstHeadingLevel: this._level
      };
    }
  };
  (function(WithFirstHeading2) {
    function isWithFirstHeading(value) {
      return value instanceof WithFirstHeading2;
    }
    WithFirstHeading2.isWithFirstHeading = isWithFirstHeading;
  })(WithFirstHeading || (WithFirstHeading = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r62/serialise.js
  var Serialise;
  (function(Serialise2) {
    function borderShorthand(style, property16) {
      const shorthand = `border-${property16}`;
      function getLongHand(side) {
        return style.computed(`border-${side}-${property16}`).toString();
      }
      let top = getLongHand("top");
      let right38 = getLongHand("right");
      let bottom = getLongHand("bottom");
      let left22 = getLongHand("left");
      if (left22 === right38) {
        left22 = "";
        if (bottom === top) {
          bottom = "";
          if (right38 === top) {
            right38 = "";
            if (top === Longhands.get(`border-top-${property16}`).initial.toString()) {
              top = "";
            }
          }
        }
      }
      return [shorthand, `${top} ${right38} ${bottom} ${left22}`.trim()];
    }
    Serialise2.borderShorthand = borderShorthand;
    function getLonghand(style, name) {
      const property16 = style.computed(name).toString();
      return property16 === Longhands.get(name).initial.toString() ? "" : property16;
    }
    Serialise2.getLonghand = getLonghand;
    function outline(style) {
      return String2.normalize(["color", "style", "width"].map((property16) => getLonghand(style, `outline-${property16}`)).join(" "));
    }
    Serialise2.outline = outline;
    function textDecoration(style) {
      return String2.normalize(["line", "color", "style", "thickness"].map((property16) => getLonghand(style, `text-decoration-${property16}`)).join(" "));
    }
    Serialise2.textDecoration = textDecoration;
    function boxShadow(style) {
      const boxShadow2 = style.computed("box-shadow").value;
      if (Keyword.isKeyword(boxShadow2)) {
        return "";
      }
      const serializedShadows = [];
      for (const shadow of boxShadow2) {
        const { vertical, horizontal, blur, spread, isInset, color } = shadow;
        const omitBlur = Numeric2.isZero(spread) && Numeric2.isZero(blur);
        const omitSpread = Numeric2.isZero(spread);
        const blurToString = omitBlur ? "" : blur.toString();
        const spreadToString = omitSpread ? "" : spread.toString();
        const insetToString = isInset ? "inset" : "";
        const colorToString = Keyword.isKeyword(color) ? "" : `${color}`;
        const serialized = String2.normalize(`${horizontal.toString()} ${vertical.toString()} ${blurToString} ${spreadToString} ${colorToString} ${insetToString}`);
        serializedShadows.push(serialized);
      }
      return serializedShadows.join(", ");
    }
    Serialise2.boxShadow = boxShadow;
    function font(style) {
      const optional = ["style", "weight"].map((property16) => getLonghand(style, `font-${property16}`)).join(" ");
      const size = style.computed("font-size");
      const family = style.computed("font-family");
      if (optional !== " ") {
        return String2.normalize(`${optional} ${size} ${family}`);
      }
      if (size.value.equals(Longhands.get("font-size").initial.value) && family.value.values[0].equals(Longhands.get("font-family").initial.values[0])) {
        return "";
      }
      return String2.normalize(`${size} ${family}`);
    }
    Serialise2.font = font;
    function background(style) {
      const attachment = style.computed("background-attachment").value.values;
      const clip = style.computed("background-clip").value.values;
      const image = style.computed("background-image").value.values;
      const origin = style.computed("background-origin").value.values;
      const positionX = style.computed("background-position-x").value.values;
      const positionY = style.computed("background-position-y").value.values;
      const repeatX = style.computed("background-repeat-x").value.values;
      const repeatY = style.computed("background-repeat-y").value.values;
      const size = style.computed("background-size").value.values;
      function getValue(array, n, property16) {
        const value = `${array?.[n] ?? array[0]}`;
        if (property16 === void 0) {
          return value;
        }
        return value === Longhands.get(property16).initial.toString() ? "" : value;
      }
      function getSize(n) {
        const value = getValue(size, n, "background-size");
        return value === "" ? "" : " / " + value;
      }
      function getPosition(n) {
        const posX = getValue(positionX, n, "background-position-x");
        const posY = getValue(positionY, n, "background-position-y");
        const value = (posX === "" && posY !== "" ? "0px" : posX) + " " + posY;
        const size2 = getSize(n);
        return size2 === "" ? value : (value === " " ? "0px 0px" : value) + size2;
      }
      function getRepeat(n) {
        const value = getValue(repeatX, n) + " " + getValue(repeatY, n);
        switch (value) {
          case "repeat no-repeat":
            return "repeat-x";
          case "no-repeat repeat":
            return "repeat-y";
          case "repeat repeat":
            return "";
          // initial value
          case "space space":
            return "space";
          case "round round":
            return "round";
          case "no-repeat no-repeat":
            return "no-repeat";
          default:
            return value;
        }
      }
      function getBoxes(n) {
        const originBox = getValue(origin, n);
        const clipBox = getValue(clip, n);
        return originBox === clipBox ? (
          // Since they have different initial value, they can't be both at their
          // initial value and therefore we need to output something
          originBox
        ) : originBox === Longhands.get("background-origin").initial.toString() && clipBox === Longhands.get("background-clip").initial.toString() ? (
          // They are both at their initial value and nothing is needed
          ""
        ) : (
          // They are different and at least one is not initial, hence needed;
          // we can't skip one without the remaining value leaking to both.
          originBox + " " + clipBox
        );
      }
      function getLayer(n) {
        const imageValue = getValue(image, n);
        return imageValue === "none" ? "" : `${imageValue} ${getPosition(n)} ${getRepeat(n)} ${getValue(attachment, n, "background-attachment")} ${getBoxes(n)}`;
      }
      const layers = image.map((_, i) => getLayer(i));
      layers[layers.length - 1] = getLonghand(style, "background-color") + " " + layers[layers.length - 1];
      return layers.map((input) => String2.normalize(input, true)).filter((layer) => layer !== "").join(", ");
    }
    Serialise2.background = background;
  })(Serialise || (Serialise = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r62/diagnostics.js
  var ElementDistinguishable = class _ElementDistinguishable {
    static of(distinguishingProperties2 = [], style = [], pairings = []) {
      return new _ElementDistinguishable(Array2.from(distinguishingProperties2), Map2.from(style), Array2.from(pairings));
    }
    _distinguishingProperties;
    _style;
    _pairings;
    constructor(distinguishingProperties2, style, pairings) {
      this._distinguishingProperties = distinguishingProperties2;
      this._style = style;
      this._pairings = pairings;
    }
    get distinguishingProperties() {
      return this._distinguishingProperties;
    }
    get style() {
      return this._style;
    }
    get pairings() {
      return this._pairings;
    }
    withDistinguishingProperties(distinguishingProperties2) {
      return _ElementDistinguishable.of([...this._distinguishingProperties, ...distinguishingProperties2], this._style, this._pairings);
    }
    withStyle(...styles) {
      return _ElementDistinguishable.of(this._distinguishingProperties, [...this._style, ...styles], this._pairings);
    }
    withPairings(pairings) {
      return _ElementDistinguishable.of(this._distinguishingProperties, this._style, pairings);
    }
    equals(value) {
      return value instanceof _ElementDistinguishable && value._style.equals(this._style) && Array2.equals(value._pairings, this._pairings) && Array2.equals(value._distinguishingProperties, this._distinguishingProperties);
    }
    hash(hash2) {
      Array2.hash(this._distinguishingProperties, hash2);
      this._style.hash(hash2);
      Array2.hash(this._pairings, hash2);
    }
    toJSON() {
      return {
        distinguishingProperties: Array2.toJSON(this._distinguishingProperties),
        style: this._style.toJSON(),
        pairings: Array2.toJSON(this._pairings)
      };
    }
  };
  (function(ElementDistinguishable2) {
    function from(element, device, target, context = Context.empty(), distinguishingProperties2, pairings) {
      const style = Style.from(element, device, context);
      const border = ["color", "style", "width"].map((property16) => Serialise.borderShorthand(style, property16));
      const cursor = context.isHovered(target) ? [["cursor", Serialise.getLonghand(style, "cursor")]] : [];
      return ElementDistinguishable2.of(distinguishingProperties2, [
        ...border,
        ...cursor,
        ["color", Serialise.getLonghand(style, "color")],
        ["font", Serialise.font(style)],
        [
          "vertical-align",
          Serialise.getLonghand(style, "vertical-align")
        ],
        ["background", Serialise.background(style)],
        ["outline", Serialise.outline(style)],
        ["text-decoration", Serialise.textDecoration(style)],
        ["box-shadow", Serialise.boxShadow(style)]
      ].filter(([_, value]) => value !== ""), Array2.sort(Array2.from(pairings)));
    }
    ElementDistinguishable2.from = from;
  })(ElementDistinguishable || (ElementDistinguishable = {}));
  var DistinguishingStyles = class _DistinguishingStyles extends Diagnostic {
    static of(message, defaultStyles = Sequence.empty(), hoverStyles = Sequence.empty(), focusStyles = Sequence.empty()) {
      return new _DistinguishingStyles(message, Sequence.from(defaultStyles), Sequence.from(hoverStyles), Sequence.from(focusStyles));
    }
    _defaultStyles;
    _hoverStyles;
    _focusStyles;
    constructor(message, defaultStyles, hoverStyles, focusStyles) {
      super(message);
      this._defaultStyles = defaultStyles;
      this._hoverStyles = hoverStyles;
      this._focusStyles = focusStyles;
    }
    get defaultStyles() {
      return this._defaultStyles;
    }
    get hoverStyles() {
      return this._hoverStyles;
    }
    get focusStyles() {
      return this._focusStyles;
    }
    equals(value) {
      return value instanceof _DistinguishingStyles && value._defaultStyles.equals(this._defaultStyles) && value._hoverStyles.equals(this._hoverStyles) && value._focusStyles.equals(this._focusStyles);
    }
    toJSON(options) {
      return {
        ...super.toJSON(options),
        defaultStyle: this._defaultStyles.toJSON(),
        hoverStyle: this._hoverStyles.toJSON(),
        focusStyle: this._focusStyles.toJSON()
      };
    }
  };
  (function(DistinguishingStyles2) {
    function isDistinguishingStyles(value) {
      return value instanceof DistinguishingStyles2;
    }
    DistinguishingStyles2.isDistinguishingStyles = isDistinguishingStyles;
  })(DistinguishingStyles || (DistinguishingStyles = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r65/diagnostics.js
  var MatchingClasses = class _MatchingClasses extends Diagnostic {
    static of(message, matchingTargets = Map2.empty(), matchingNonTargets = Map2.empty()) {
      return new _MatchingClasses(message, matchingTargets, matchingNonTargets);
    }
    _matchingTargets;
    _matchingNonTargets;
    constructor(message, matchingTargets, matchingNonTargets) {
      super(message);
      this._matchingTargets = matchingTargets;
      this._matchingNonTargets = matchingNonTargets;
    }
    get matchingTargets() {
      return this._matchingTargets;
    }
    get matchingNonTargets() {
      return this._matchingNonTargets;
    }
    equals(value) {
      return value instanceof _MatchingClasses && value._matchingTargets.equals(this._matchingTargets) && value._matchingNonTargets.equals(this._matchingNonTargets);
    }
    hash(hash2) {
      super.hash(hash2);
      this._matchingTargets.hash(hash2);
      this._matchingNonTargets.hash(hash2);
    }
    toJSON(options) {
      return {
        ...super.toJSON(options),
        matchingTargets: this._matchingTargets.toJSON(options),
        matchingNonTargets: this._matchingNonTargets.toJSON(options)
      };
    }
  };
  (function(MatchingClasses2) {
    function isMatchingClasses(value) {
      return value instanceof MatchingClasses2;
    }
    MatchingClasses2.isMatchingClasses = isMatchingClasses;
  })(MatchingClasses || (MatchingClasses = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r75/rule.js
  var { hasNamespace: hasNamespace9, hasName: hasName21 } = Element;
  var { isText: isText6 } = Text;
  var { or: or26, not: not31 } = Predicate;
  var { and: and42 } = Refinement;
  var { hasCascadedStyle: hasCascadedStyle2, hasComputedStyle: hasComputedStyle4, hasSpecifiedStyle: hasSpecifiedStyle2, isVisible: isVisible4 } = Style;
  var { getElementDescendants: getElementDescendants11 } = Query3;
  var rule_default10 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r75",
    requirements: [BestPractice.of("font-size-above-minimum")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      const visibleTextCache = Cache2.empty();
      return {
        applicability() {
          return getElementDescendants11(document2, Node4.fullTree).filter(and42(hasNamespace9(Namespace.HTML), not31(hasName21("sup", "sub")), not31((node) => visibleTextCache.get(node, () => node.descendants(Node4.fullTree).filter(and42(isText6, isVisible4(device)))).isEmpty()), hasCascadedStyle2(`font-size`, () => true, device)));
        },
        expectations(target) {
          const declaration = Style.from(target, device).cascaded("font-size").getUnsafe().source;
          const texts = visibleTextCache.get(target).getUnsafe().reject((text) => text.data.trim() === "").every(or26(hasSpecifiedStyle2("font-size", (_, source) => (
            // We do need to compare with physical identity, not structural
            // identity (.equals) to differentiate, e.g., two
            // "font-size: 100%" declarations
            source !== declaration
          ), device), hasComputedStyle4("font-size", (fontSize, _) => fontSize.value >= 9, device)));
          return {
            1: expectation(texts, () => Outcomes10.IsSufficient(declaration), () => Outcomes10.IsInsufficient(declaration))
          };
        }
      };
    }
  });
  var Outcomes10;
  (function(Outcomes87) {
    Outcomes87.IsSufficient = (declaration) => Ok.of(WithDeclaration.of(`The font size is greater than 9 pixels`, declaration));
    Outcomes87.IsInsufficient = (declaration) => Err.of(WithDeclaration.of(`The font size is smaller than 9 pixels`, declaration));
  })(Outcomes10 || (Outcomes10 = {}));
  var WithDeclaration = class _WithDeclaration extends Diagnostic {
    static of(message, declaration = None) {
      return new _WithDeclaration(message, declaration);
    }
    _declaration;
    constructor(message, declaration) {
      super(message);
      this._declaration = declaration;
    }
    get declaration() {
      return this._declaration;
    }
    equals(value) {
      return value instanceof _WithDeclaration && value._message === this.message && value._declaration === this._declaration;
    }
    toJSON(options) {
      return {
        ...super.toJSON(options),
        declaration: this._declaration.toJSON()
      };
    }
  };
  (function(WithDeclaration2) {
    function isWithDeclaration(value) {
      return value instanceof WithDeclaration2;
    }
    WithDeclaration2.isWithDeclaration = isWithDeclaration;
  })(WithDeclaration || (WithDeclaration = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r83/rule.js
  var { isHeight, isWidth } = Feature.Media.Feature;
  var { Discrete: Discrete3, Range: Range2 } = Feature.Media.Value;
  var { or: or27, not: not32, equals: equals25 } = Predicate;
  var { and: and43, test: test25 } = Refinement;
  var { hasAttribute: hasAttribute9, hasBox: hasBox5, hasName: hasName22, hasNamespace: hasNamespace10, isElement: isElement35 } = Element;
  var { isText: isText7 } = Text;
  var { getPositioningParent: getPositioningParent2, hasCascadedStyle: hasCascadedStyle3, hasComputedStyle: hasComputedStyle5, hasUsedStyle: hasUsedStyle2, isVisible: isVisible5 } = Style;
  var rule_default11 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r83",
    requirements: [Criterion.of("1.4.4")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return document2.inclusiveDescendants(Node4.Traversal.of(Node4.Traversal.composed, Node4.Traversal.flattened)).find(and43(isElement35, hasName22("body"))).map((body) => body.children()).getOr(Sequence.empty()).flatMap((node) => Sequence.from(visit3(node)));
          function* visit3(node, collect = false) {
            if (test25(and43(isElement35, or27(hasAttribute9("aria-hidden", equals25("true")), not32(hasNamespace10(Namespace.HTML)))), node)) {
              return;
            }
            if (isElement35(node) && (overflow(node, device, "x") === Overflow.Clip || overflow(node, device, "y") === Overflow.Clip)) {
              collect = true;
            }
            if (collect && test25(and43(isText7, isVisible5(device)), node)) {
              yield node;
            }
            for (const child of node.children(Node4.fullTree)) {
              yield* visit3(child, collect);
            }
          }
        },
        expectations(target) {
          return target.parent(Node4.fullTree).filter(isElement35).map((parent) => {
            const horizontallyClippedBy = ClippingAncestor.horizontal(device, parent);
            const verticallyClippedBy = ClippingAncestor.vertical(device, parent);
            const hasBig = isTwiceAsBig(parent, device);
            return {
              1: expectation(horizontallyClippedBy.isSome() || verticallyClippedBy.isSome(), () => (
                // If the clipping ancestor happens to be twice as big as the text
                // (parent), clipping only occurs after 200% zoom, which is OK.
                // We do not really care where is the text inside the clipping
                // ancestor, and simply assume that if it's big enough it will have
                // room to grow. This is not always true as the text may be pushed
                // to the far side already and ends up being clipped anyway.
                // This would only create false negatives, so this is OK.
                // There may be another further ancestor that is actually small and
                // clips both the text and the found clipping ancestors. We assume
                // this is not likely and just ignore it. This would only create
                // false negatives.
                expectation(horizontallyClippedBy.every(hasBig("width")) && verticallyClippedBy.every(hasBig("height")), () => Outcomes11.IsContainer(horizontallyClippedBy, verticallyClippedBy), () => Outcomes11.ClipsText(horizontallyClippedBy, verticallyClippedBy))
              ), () => Outcomes11.WrapsText)
            };
          }).getOr({ 1: Outcomes11.WrapsText });
        }
      };
    }
  });
  var Overflow;
  (function(Overflow2) {
    Overflow2["Clip"] = "Clip";
    Overflow2["Handle"] = "Handle";
    Overflow2["Overflow"] = "Overflow";
  })(Overflow || (Overflow = {}));
  function overflow(element, device, dimension) {
    return Style.from(element, device).used(`overflow-${dimension}`).map((overflow2) => {
      switch (overflow2.value.value) {
        case "clip":
        case "hidden":
          return Overflow.Clip;
        case "scroll":
        case "auto":
          return Overflow.Handle;
        case "visible":
          return Overflow.Overflow;
      }
    }).getOr(Overflow.Overflow);
  }
  function isTwiceAsBig(target, device) {
    return (dimension) => hasBox5((clippingBox) => test25(hasBox5((targetBox) => clippingBox[dimension] >= 2 * targetBox[dimension], device), target), device);
  }
  var ClippingAncestor;
  (function(ClippingAncestor2) {
    ClippingAncestor2.vertical = clipper("height", localVerticalOverflow);
    ClippingAncestor2.horizontal = (device, element) => clipper("width", localHorizontalOverflow())(device, element);
    const predicates = { height: isHeight, width: isWidth };
    const clipperCaches = {
      height: Cache2.empty(),
      width: Cache2.empty()
    };
    function clipper(dimension, localOverflow) {
      return (device, element) => {
        function clipper2(element2) {
          return clipperCaches[dimension].get(device, Cache2.empty).get(element2, () => {
            if (hasFontRelativeValue(device, dimension)(element2)) {
              return None;
            }
            if (test25(Media4.usesFontRelativeMediaRule(device, predicates[dimension]), element2)) {
              return None;
            }
            switch (localOverflow(device, element2)) {
              case Overflow.Clip:
                return Option.of(element2);
              case Overflow.Handle:
                return None;
              case Overflow.Overflow:
                return getPositioningParent2(element2, device).flatMap(clipper2);
            }
          });
        }
        return clipper2(element);
      };
    }
    function localVerticalOverflow(device, element) {
      const verticalOverflow = overflow(element, device, "y");
      switch (verticalOverflow) {
        case Overflow.Clip:
          return hasFixedDimension(device, "height")(element) ? Overflow.Clip : Overflow.Overflow;
        default:
          return verticalOverflow;
      }
    }
    function localHorizontalOverflow() {
      let inSameBlock = true;
      return (device, element) => {
        const style = Style.from(element, device);
        if (inSameBlock && test25(and43(hasComputedStyle5("white-space", (value) => !value.is("nowrap", "pre"), device), hasSoftWrapPoints(device)), element)) {
          return Overflow.Handle;
        }
        if (hasUsedStyle2("flex-wrap", (value) => !value.is("nowrap"), device)(element)) {
          return Overflow.Handle;
        }
        let horizontalOverflow = overflow(element, device, "x");
        if (horizontalOverflow === Overflow.Clip) {
          if (inSameBlock && hasUsedStyle2("text-overflow", (value) => value.is("ellipsis"), device)(element)) {
            horizontalOverflow = Overflow.Handle;
          }
          if (constrainingAncestor(element, device, "width").every(isTwiceAsBig(element, device)("width"))) {
            horizontalOverflow = Overflow.Handle;
          }
        }
        if (Style.isBlockContainer(style)) {
          inSameBlock = false;
        }
        return horizontalOverflow;
      };
    }
    const _softWrapPointsCache = Cache2.empty();
    function hasSoftWrapPoints(device) {
      return (node) => _softWrapPointsCache.get(device, Cache2.empty).get(node, () => {
        if (isText7(node)) {
          return String2.hasSoftWrapOpportunity(node.data);
        }
        if (isElement35(node)) {
          if (hasComputedStyle5("white-space", (value) => value.is("nowrap", "pre"), device)(node)) {
            return false;
          }
          const children = node.children(Node4.fullTree);
          return children.size > 1 || children.first().some(hasSoftWrapPoints(device));
        }
        return false;
      });
    }
    const constrainingCaches = {
      height: Cache2.empty(),
      width: Cache2.empty()
    };
    function constrainingAncestor(element, device, dimension) {
      return constrainingCaches[dimension].get(device, Cache2.empty).get(element, () => hasFixedDimension(device, dimension)(element) || // The <body> element is horizontally constrained by the viewport
      // That is we consider infinite scroll vertically, not horizontally.
      dimension === "width" && hasName22("body")(element) ? Option.of(element) : getPositioningParent2(element, device).flatMap((parent) => constrainingAncestor(parent, device, dimension)));
    }
    function hasFixedDimension(device, dimension) {
      return hasCascadedStyle3(dimension, (value, source) => (
        // not a length => "auto", i.e not fixed.
        Length2.isLength(value) && // We bail out on calculated dimensions
        !value.hasCalculation() && // 0 is a special case making the content invisible anyway.
        value.value > 0 && // Font relative dimension is good
        !value.isFontRelative() && // No source means the style is set via the `style` attribute
        source.some((declaration) => declaration.parent.isSome())
      ), device);
    }
  })(ClippingAncestor || (ClippingAncestor = {}));
  function hasFontRelativeValue(device, property16) {
    return or27(hasCascadedStyle3(property16, (value) => Length2.isLength(value) && (value.hasCalculation() || value.value > 0 && value.isFontRelative()), device), hasCascadedStyle3(`min-${property16}`, (value) => Length2.isLength(value) && (value.hasCalculation() || value.value > 0 && value.isFontRelative()), device));
  }
  var Media4;
  (function(Media5) {
    function usesFontRelativeMediaRule(device, predicate, context = Context.empty()) {
      return usesMediaRule(isFontRelativeMediaRule(predicate), device, context);
    }
    Media5.usesFontRelativeMediaRule = usesFontRelativeMediaRule;
    const _mediaRulesCache = Cache2.empty();
    function ancestorMediaRules(rule) {
      if (rule === null) {
        return Sequence.empty();
      }
      return _mediaRulesCache.get(rule, () => {
        const mediaRules = rule.parent.map((parent) => ancestorMediaRules(parent)).getOrElse(Sequence.empty);
        return MediaRule.isMediaRule(rule) ? mediaRules.prepend(rule) : mediaRules;
      });
    }
    const _ruleTreeCache = Cache2.empty();
    function ancestorsInRuleTree(rule) {
      return _ruleTreeCache.get(rule, () => Sequence.from(rule.inclusiveAncestors()));
    }
    function getUsedMediaRules(element, device, context = Context.empty()) {
      const root = element.root();
      if (!Document.isDocument(root)) {
        return Sequence.empty();
      }
      return ancestorsInRuleTree(Cascade.from(root, device).get(element, context)).flatMap((node) => ancestorMediaRules(node.block.rule));
    }
    function usesMediaRule(predicate = () => true, device, context = Context.empty()) {
      return (element) => getUsedMediaRules(element, device, context).some(predicate);
    }
    function isFontRelativeMediaRule(predicate) {
      return (rule) => Iterable.some(rule.queries.queries, (query) => query.condition.some((condition) => Iterable.some(condition, (feature) => predicate(feature) && feature.value.some((value) => Range2.isRange(value) ? value.minimum.some((min4) => Length2.isLength(min4.value) && (min4.value.hasCalculation() || min4.value.isFontRelative())) : Discrete3.isDiscrete(value) && (value.value.hasCalculation() || value.value.isFontRelative())))));
    }
  })(Media4 || (Media4 = {}));
  var ClippingAncestors = class _ClippingAncestors extends Diagnostic {
    static of(message, horizontal = None, vertical = None) {
      return new _ClippingAncestors(message, horizontal, vertical);
    }
    _horizontal;
    _vertical;
    constructor(message, horizontal, vertical) {
      super(message);
      this._horizontal = horizontal;
      this._vertical = vertical;
    }
    get horizontal() {
      return this._horizontal;
    }
    get vertical() {
      return this._vertical;
    }
    equals(value) {
      return super.equals(value) && value instanceof _ClippingAncestors && value._horizontal.equals(this._horizontal) && value._vertical.equals(this._vertical);
    }
    hash(hash2) {
      super.hash(hash2);
      this._vertical.hash(hash2);
      this._horizontal.hash(hash2);
    }
    toJSON(options) {
      return {
        ...super.toJSON(options),
        horizontal: this._horizontal.toJSON(options),
        vertical: this._vertical.toJSON(options)
      };
    }
  };
  (function(ClippingAncestors2) {
    function isClippingAncestors(value) {
      return value instanceof ClippingAncestors2;
    }
    ClippingAncestors2.isClippingAncestors = isClippingAncestors;
  })(ClippingAncestors || (ClippingAncestors = {}));
  var Outcomes11;
  (function(Outcomes87) {
    Outcomes87.WrapsText = Ok.of(ClippingAncestors.of(`The text is wrapped without being clipped`));
    Outcomes87.ClipsText = (horizontal, vertical) => Err.of(ClippingAncestors.of(`The text is clipped`, horizontal, vertical));
    Outcomes87.IsContainer = (horizontal, vertical) => Ok.of(ClippingAncestors.of("The text would be clipped but the clipper is more than twice as large", horizontal, vertical));
  })(Outcomes11 || (Outcomes11 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/common/dom/get-colors/color.js
  var Color2;
  (function(Color3) {
    function resolve3(color, style) {
      switch (color.type) {
        case "keyword":
          if (color.value === "currentcolor") {
            color = style.computed("color").value;
            if (color.type === "color") {
              return Option.of(RGB.of(color.red, color.green, color.blue, Percentage2.of(color.alpha.value)));
            }
          }
          if (color.value === "canvastext") {
            return Option.of(RGB.of(Percentage2.of(0), Percentage2.of(0), Percentage2.of(0), Percentage2.of(1)));
          }
          return None;
        case "color":
          return Option.of(RGB.of(color.red, color.green, color.blue, Percentage2.of(color.alpha.value)));
      }
    }
    Color3.resolve = resolve3;
    function composite(foreground, background, opacity) {
      const foregroundOpacity = foreground.alpha.value * opacity;
      if (foregroundOpacity === 1) {
        return foreground;
      }
      const alpha = background.alpha.value * (1 - foregroundOpacity);
      const [red, green, blue] = [
        [foreground.red, background.red],
        [foreground.green, background.green],
        [foreground.blue, background.blue]
      ].map(([a, b]) => a.value * foregroundOpacity + b.value * alpha);
      return RGB.of(Percentage2.of(red), Percentage2.of(green), Percentage2.of(blue), Percentage2.of(foregroundOpacity + alpha));
    }
    Color3.composite = composite;
  })(Color2 || (Color2 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/common/dom/get-colors/color-error.js
  var ColorErrors = class _ColorErrors extends Diagnostic {
    static of(messageOrErrors) {
      return typeof messageOrErrors === "string" ? Diagnostic.of(messageOrErrors) : new _ColorErrors("Could not fully resolve colors", Array2.copy(messageOrErrors));
    }
    _errors;
    constructor(message, errors) {
      super(message);
      this._errors = errors;
    }
    get errors() {
      return this._errors;
    }
    equals(value) {
      return value instanceof _ColorErrors && value._message === this._message && Array2.equals(value._errors, this._errors);
    }
    hash(hash2) {
      super.hash(hash2);
      this._errors.forEach((error) => error.hash(hash2));
    }
    toJSON(options) {
      return {
        ...super.toJSON(options),
        errors: Array2.toJSON(this._errors, options)
      };
    }
  };
  (function(ColorErrors2) {
    function isColorErrors(value) {
      return value instanceof ColorErrors2;
    }
    ColorErrors2.isColorErrors = isColorErrors;
    function prepend(old, cur) {
      return ColorErrors2.of([
        ...cur,
        ...old.err().map((old2) => old2.errors).getOr([])
      ]);
    }
    ColorErrors2.prepend = prepend;
  })(ColorErrors || (ColorErrors = {}));
  var ColorError = class _ColorError extends Diagnostic {
    _element;
    _type;
    _kind;
    constructor(message, element, type, kind) {
      super(message);
      this._element = element;
      this._type = type;
      this._kind = kind;
    }
    get element() {
      return this._element;
    }
    get type() {
      return this._type;
    }
    get kind() {
      return this._kind;
    }
    equals(value) {
      return value instanceof _ColorError && value._message === this._message && value._element.equals(this._element) && value._type === this._type && value._kind === this._kind;
    }
    hash(hash2) {
      super.hash(hash2);
      this._element.hash(hash2);
      hash2.writeString(this._kind);
      hash2.writeString(this._type);
    }
    toJSON(options) {
      return {
        ...super.toJSON(options),
        element: this._element.toJSON(options),
        type: this._type,
        kind: this._kind
      };
    }
  };
  (function(ColorError2) {
    function isColorError(value) {
      return value instanceof ColorError2;
    }
    ColorError2.isColorError = isColorError;
    class WithProperty extends ColorError2 {
      static of(message, diagnostic) {
        return diagnostic !== void 0 ? new WithProperty(message, diagnostic.type, diagnostic.kind, diagnostic.element, diagnostic.property, diagnostic.value) : Diagnostic.of(message);
      }
      _property;
      _value;
      constructor(message, type, kind, element, proprety, value) {
        super(message, element, type, kind);
        this._property = proprety;
        this._value = value;
      }
      get property() {
        return this._property;
      }
      get value() {
        return this._value;
      }
      equals(value) {
        return super.equals(value) && value instanceof WithProperty && value._property === this._property && Equatable.equals(value._value, this._value);
      }
      toJSON() {
        return {
          ...super.toJSON(),
          property: this._property,
          value: Serializable.toJSON(this._value)
        };
      }
    }
    ColorError2.WithProperty = WithProperty;
    (function(WithProperty2) {
      function from(type, kind, property16, message) {
        return (element, value) => WithProperty2.of(message, { type, kind, element, property: property16, value });
      }
      WithProperty2.from = from;
      function isWithProperty(value) {
        return value instanceof WithProperty2;
      }
      WithProperty2.isWithProperty = isWithProperty;
    })(WithProperty = ColorError2.WithProperty || (ColorError2.WithProperty = {}));
    ColorError2.isWithProperty = WithProperty.isWithProperty;
    ColorError2.unresolvableBackgroundColor = WithProperty.from("layer", "unresolvable-background-color", "background-color", "Could not resolve background-color");
    ColorError2.backgroundSize = WithProperty.from("layer", "background-size", "background-size", "A background-size was encountered");
    ColorError2.externalBackgroundImage = WithProperty.from("layer", "background-image", "background-image", "A background-image with a url() was encountered");
    ColorError2.nonStaticPosition = WithProperty.from("layer", "non-static", "position", "A non-statically positioned element was encountered");
    ColorError2.unresolvableForegroundColor = WithProperty.from("foreground", "unresolvable-foreground-color", "color", "Could not resolve foreground color");
    ColorError2.textShadow = WithProperty.from("background", "text-shadow", "text-shadow", "A text-shadow was encountered");
    class HasUnresolvableGradientStop extends WithProperty {
      static create(element, value, color) {
        return new HasUnresolvableGradientStop(element, value, color);
      }
      _color;
      constructor(element, value, color) {
        super("Could not resolve gradient color stop", "layer", "unresolvable-gradient", element, "background-image", value);
        this._color = color;
      }
      get color() {
        return this._color;
      }
      equals(value) {
        return super.equals(value) && value instanceof HasUnresolvableGradientStop && value._color.equals(this._color);
      }
      toJSON() {
        return {
          ...super.toJSON(),
          color: this._color.toJSON()
        };
      }
    }
    ColorError2.HasUnresolvableGradientStop = HasUnresolvableGradientStop;
    (function(HasUnresolvableGradientStop2) {
      function isUnresolvableGradientStop(value) {
        return value instanceof HasUnresolvableGradientStop2;
      }
      HasUnresolvableGradientStop2.isUnresolvableGradientStop = isUnresolvableGradientStop;
    })(HasUnresolvableGradientStop = ColorError2.HasUnresolvableGradientStop || (ColorError2.HasUnresolvableGradientStop = {}));
    ColorError2.unresolvableGradientStop = HasUnresolvableGradientStop.create, ColorError2.isUnresolvableGradientStop = HasUnresolvableGradientStop.isUnresolvableGradientStop;
    class HasInterposedDescendants extends ColorError2 {
      static of(message, element, positionedDescendants) {
        return element !== void 0 && positionedDescendants !== void 0 ? new HasInterposedDescendants(message, element, Sequence.from(positionedDescendants)) : Diagnostic.of(message);
      }
      _positionedDescendants;
      constructor(message, element, positionedDescendants) {
        super(message, element, "layer", "interposed-descendant");
        this._positionedDescendants = positionedDescendants;
      }
      get positionedDescendants() {
        return this._positionedDescendants;
      }
      equals(value) {
        return super.equals(value) && value instanceof HasInterposedDescendants && value._positionedDescendants.equals(this._positionedDescendants);
      }
      toJSON() {
        return {
          ...super.toJSON(),
          positionedDescendants: this._positionedDescendants.toJSON()
        };
      }
    }
    ColorError2.HasInterposedDescendants = HasInterposedDescendants;
    (function(HasInterposedDescendants2) {
      function from(offsetParent, positionedDescendants) {
        return HasInterposedDescendants2.of("An interposed descendant element was encountered", offsetParent, positionedDescendants);
      }
      HasInterposedDescendants2.from = from;
      function isInterposedDescendants(value) {
        return value instanceof HasInterposedDescendants2;
      }
      HasInterposedDescendants2.isInterposedDescendants = isInterposedDescendants;
    })(HasInterposedDescendants = ColorError2.HasInterposedDescendants || (ColorError2.HasInterposedDescendants = {}));
    ColorError2.interposedDescendants = HasInterposedDescendants.from, ColorError2.isInterposedDescendants = HasInterposedDescendants.isInterposedDescendants;
  })(ColorError || (ColorError = {}));

  // node_modules/@siteimprove/alfa-rules/dist/common/dom/get-interposed-descendant.js
  var { isElement: isElement36 } = Element;
  var { and: and44 } = Refinement;
  var { getOffsetParent: getOffsetParent2, isPositioned: isPositioned2, isVisible: isVisible6 } = Style;
  var cache10 = Cache2.empty();
  function getInterposedDescendant(device, element) {
    const root = element.root(Node4.flatTree);
    return cache10.get(device, Cache2.empty).get(root, () => root.inclusiveDescendants(Node4.flatTree).filter(and44(isElement36, and44(isPositioned2(device, "absolute", "fixed"), isVisible6(device)))).filter((element2) => getOffsetParent2(element2, device).isSome()).groupBy((element2) => getOffsetParent2(element2, device).getUnsafe())).get(element).getOr(Sequence.empty());
  }

  // node_modules/@siteimprove/alfa-rules/dist/common/dom/get-colors/get-layers.js
  var { isElement: isElement37 } = Element;
  var { hasTransparentBackground: hasTransparentBackground2, isPositioned: isPositioned3 } = Style;
  var Layer3 = class _Layer {
    static of(colors, opacity) {
      return new _Layer(Array2.from(colors), opacity);
    }
    _colors;
    _opacity;
    constructor(colors, opacity) {
      this._colors = colors;
      this._opacity = opacity;
    }
    get colors() {
      return this._colors;
    }
    get opacity() {
      return this._opacity;
    }
  };
  (function(Layer4) {
    const layersCacheWithFakeOpacity = Cache2.empty();
    const layersCacheWithDefaultOpacity = Cache2.empty();
    function getLayers(element, device, context = Context.empty(), opacity, ignoredInterposedDescendants = Set2.empty()) {
      const cache16 = opacity === void 0 ? layersCacheWithDefaultOpacity : layersCacheWithFakeOpacity;
      return cache16.get(device, Cache2.empty).get(context, Cache2.empty).get(ignoredInterposedDescendants, Cache2.empty).get(element, () => {
        const style = Style.from(element, device, context);
        const currentLayers = getCurrentLayers(element, device, context, opacity);
        const layers = currentLayers.getOr([]);
        const errors = currentLayers.getErrOr([]);
        if (errors.length === 0 && layers.length > 0 && layers.every((layer) => layer.opacity === 1 && layer.colors.every((color) => color.alpha.value === 1))) {
          return Result.of(layers);
        }
        if (isPositioned3(device, "absolute", "fixed")(element)) {
          errors.push(ColorError.nonStaticPosition(element, style.computed("position").value));
        }
        const interposedDescendants = getInterposedDescendant(device, element).reject(hasTransparentBackground2(device)).reject(ignoredInterposedDescendants.has.bind(ignoredInterposedDescendants));
        if (!interposedDescendants.isEmpty()) {
          errors.push(ColorError.interposedDescendants(element, interposedDescendants));
        }
        for (const parent of element.parent(Node4.flatTree).filter(isElement37)) {
          const layersColors = getLayers(
            parent,
            device,
            context,
            // The opacity override only applies to the last layer, so it is not
            // used in the recursive calls
            void 0,
            ignoredInterposedDescendants
          );
          return errors.length === 0 ? layersColors.map((parentLayers) => parentLayers.concat(layers)) : Err.of(ColorErrors.prepend(layersColors, errors));
        }
        return errors.length === 0 ? Result.of(layers) : Err.of(ColorErrors.of(errors));
      });
    }
    Layer4.getLayers = getLayers;
    function merge2(backdrops, layer) {
      return layer.colors.reduce((layers, color) => layers.concat(backdrops.map((backdrop) => Color2.composite(color, backdrop, layer.opacity))), []);
    }
    Layer4.merge = merge2;
    function getCurrentLayers(element, device, context = Context.empty(), opacity) {
      const style = Style.from(element, device, context);
      const backgroundColor = style.computed("background-color").value;
      const backgroundImage = style.computed("background-image").value;
      const backgroundSize = style.computed("background-size").value;
      const color = Color2.resolve(backgroundColor, style);
      opacity = opacity ?? style.computed("opacity").value.value;
      const layers = [];
      const errors = [];
      if (color.isSome()) {
        layers.push(Layer4.of([color.get()], opacity));
      } else {
        errors.push(ColorError.unresolvableBackgroundColor(element, backgroundColor));
      }
      for (const image of backgroundImage) {
        if (image.type === "keyword") {
          continue;
        }
        if (image.image.type === "url") {
          if (image.image.url !== "") {
            errors.push(ColorError.externalBackgroundImage(element, backgroundImage));
          }
          continue;
        }
        if (!backgroundSize.equals(style.initial("background-size").value)) {
          errors.push(ColorError.backgroundSize(element, backgroundSize));
          continue;
        }
        const stops = [];
        for (const item of image.image.items) {
          if (item.type === "stop") {
            const color2 = Color2.resolve(item.color, style);
            if (color2.isSome()) {
              stops.push(color2.get());
            } else {
              errors.push(ColorError.unresolvableGradientStop(element, backgroundImage, item.color));
            }
          }
        }
        layers.push(Layer4.of(stops, opacity));
      }
      return errors.length === 0 ? Result.of(layers) : Err.of(errors);
    }
  })(Layer3 || (Layer3 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/common/dom/get-colors/get-background.js
  var { isVisibleShadow: isVisibleShadow2 } = Style;
  var backgroundCacheWithFakeOpacity = Cache2.empty();
  var backgroundCacheWithDefaultOpacity = Cache2.empty();
  function getBackground(element, device, context = Context.empty(), opacity, ignoredInterposedDescendants = Set2.empty()) {
    const textShadow = Style.from(element, device, context).computed("text-shadow").value;
    const cache16 = opacity === void 0 ? backgroundCacheWithDefaultOpacity : backgroundCacheWithFakeOpacity;
    return cache16.get(device, Cache2.empty).get(context, Cache2.empty).get(ignoredInterposedDescendants, Cache2.empty).get(element, () => {
      let error = None;
      if (textShadow.type === "list" && Iterable.some(textShadow, (shadow) => isVisibleShadow2(shadow))) {
        error = Option.of(ColorError.textShadow(element, textShadow));
      }
      const layersColors = Layer3.getLayers(element, device, context, opacity, ignoredInterposedDescendants);
      return error.isNone() && layersColors.isOk() ? layersColors.map((layers) => layers.reduce(Layer3.merge, [white])) : Err.of(ColorErrors.prepend(layersColors, error));
    });
  }
  var white = RGB.of(Percentage2.of(1), Percentage2.of(1), Percentage2.of(1), Percentage2.of(1));

  // node_modules/@siteimprove/alfa-rules/dist/common/dom/get-colors/get-foreground.js
  var { isElement: isElement38 } = Element;
  var foregroundCache = Cache2.empty();
  function getForeground(element, device, context = Context.empty(), ignoredInterposedDescendants = Set2.empty()) {
    return foregroundCache.get(device, Cache2.empty).get(context, Cache2.empty).get(ignoredInterposedDescendants, Cache2.empty).get(element, () => {
      let error = None;
      const style = Style.from(element, device, context);
      let foregroundColor = style.computed("color").value;
      let parent = element.parent().filter(isElement38);
      const isCurrentColor = (color2) => color2.type === "keyword" && color2.value === "currentcolor";
      while (parent.isSome() && isCurrentColor(foregroundColor)) {
        foregroundColor = Style.from(parent.get(), device, context).computed("color").value;
        parent = parent.get().parent().filter(isElement38);
      }
      const color = Color2.resolve(foregroundColor, style);
      if (color.isNone()) {
        error = Option.of(ColorError.unresolvableForegroundColor(element, foregroundColor));
      }
      const opacity = style.computed("opacity").value;
      if (color.isSome() && color.get().alpha.value * opacity.value === 1) {
        return Result.of([color.get()]);
      }
      const backgroundColors = getBackground(element, device, context, 1, ignoredInterposedDescendants);
      if (color.isSome() && backgroundColors.isOk()) {
        const colors = backgroundColors.map((background) => background.map((backdrop) => Color2.composite(color.get(), backdrop, 1)));
        for (const parent2 of element.parent(Node4.flatTree).filter(isElement38)) {
          return colors.flatMap((colors2) => getBackground(parent2, device, context, void 0, ignoredInterposedDescendants).map((background) => colors2.flatMap((color2) => background.map((backdrop) => Color2.composite(color2, backdrop, opacity.value)))));
        }
        return colors;
      } else {
        return Err.of(ColorErrors.prepend(backgroundColors, error));
      }
    });
  }

  // node_modules/@siteimprove/alfa-rules/dist/common/act/diagnostic.js
  var Diagnostic2;
  (function(Diagnostic3) {
    Diagnostic3.Languages = Languages2;
    Diagnostic3.LabelAndName = LabelAndName;
    Diagnostic3.RoleAndRequiredAttributes = RoleAndRequiredAttributes;
    Diagnostic3.WithRoleAndName = WithRoleAndName;
    Diagnostic3.SameNames = SameNames;
    Diagnostic3.WithFirstHeading = WithFirstHeading;
    Diagnostic3.DistinguishingStyles = DistinguishingStyles;
    Diagnostic3.ElementDistinguishable = ElementDistinguishable;
    Diagnostic3.ColorError = ColorError;
    Diagnostic3.ColorErrors = ColorErrors;
    Diagnostic3.MatchingClasses = MatchingClasses;
    Diagnostic3.WithDeclaration = WithDeclaration;
    Diagnostic3.ClippingAncestors = ClippingAncestors;
    Diagnostic3.Contrast = Contrast;
    Diagnostic3.TextSpacing = TextSpacing;
    Diagnostic3.WithBadElements = WithBadElements;
    Diagnostic3.WithRole = WithRole;
    Diagnostic3.WithName = WithName2;
    Diagnostic3.WithOtherHeading = WithOtherHeading;
    Diagnostic3.WithBoundingBox = WithBoundingBox;
  })(Diagnostic2 || (Diagnostic2 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/common/act/is-passed.js
  function isPassed(outcome) {
    if (Outcome.isPassed(outcome)) {
      return true;
    }
    if (Outcome.isFailed(outcome)) {
      return false;
    }
    return void 0;
  }

  // node_modules/@siteimprove/alfa-rules/dist/sia-r114/rule.js
  var { and: and45 } = Refinement;
  var { hasName: hasName23, hasNamespace: hasNamespace11 } = Element;
  var rule_default12 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r114",
    requirements: [
      Criterion.of("2.4.2"),
      Technique.of("G88"),
      Technique.of("H25")
    ],
    tags: [Scope.Page, Stability.Experimental],
    evaluate({ document: document2 }) {
      return {
        applicability() {
          return Query3.getElementDescendants(document2).find(and45(hasNamespace11(Namespace.HTML), hasName23("title"))).filter((title) => title.descendants().filter(Text.isText).some((text) => !String2.isWhitespace(text.data)));
        },
        expectations(target) {
          return {
            1: Question2.of("is-title-descriptive", target).map((descriptive) => expectation(descriptive, () => Outcomes12.TitleIsDescriptive, () => Outcomes12.TitleIsNotDescriptive))
          };
        }
      };
    }
  });
  var Outcomes12;
  (function(Outcomes87) {
    Outcomes87.TitleIsDescriptive = Ok.of(Diagnostic.of("This `<title>` describes the content of the page"));
    Outcomes87.TitleIsNotDescriptive = Err.of(Diagnostic.of("This `<title>` does not describe the content of the page"));
  })(Outcomes12 || (Outcomes12 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-dr6/rule.js
  var { hasAttribute: hasAttribute10, isDocumentElement: isDocumentElement2 } = Element;
  var { isEmpty: isEmpty6 } = Iterable;
  var { and: and46, not: not33, tee, test: test26 } = Predicate;
  var rule_default13 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r6",
    requirements: [Criterion.of("3.1.1")],
    tags: [Scope.Page, Stability.Deprecated],
    evaluate({ document: document2 }) {
      let cachedLang;
      let cachedXmlLang;
      return {
        applicability() {
          return document2.children().filter(isDocumentElement2).filter((element) => test26(and46(hasAttribute10("lang", (value) => Language.parse(value).tee((lang) => {
            cachedLang = lang;
          }).isOk()), hasAttribute10("xml:lang", tee(not33(isEmpty6), (xmlLang) => {
            cachedXmlLang = xmlLang;
          }))), element));
        },
        expectations(target) {
          return {
            1: expectation(Language.parse(cachedXmlLang).every((xmlLang) => xmlLang.primary.equals(cachedLang.primary)), () => Outcomes13.HasMatchingLanguages, () => Outcomes13.HasNonMatchingLanguages)
          };
        }
      };
    }
  });
  var Outcomes13;
  (function(Outcomes87) {
    Outcomes87.HasMatchingLanguages = Ok.of(Diagnostic.of(`The \`lang\` and \`xml:lang\` attributes have matching primary language subtags`));
    Outcomes87.HasNonMatchingLanguages = Err.of(Diagnostic.of(`The \`lang\` and \`xml:lang\` attributes do not have matching primary language subtags`));
  })(Outcomes13 || (Outcomes13 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-dr18/rule.js
  var { hasRole: hasRole11, isIncludedInTheAccessibilityTree: isIncludedInTheAccessibilityTree7 } = DOM;
  var { hasDisplaySize: hasDisplaySize2, hasInputType: hasInputType5 } = Element;
  var { test: test27, property: property9 } = Predicate;
  var { getElementDescendants: getElementDescendants12 } = Query3;
  var rule_default14 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r18",
    requirements: [Technique.of("ARIA5")],
    tags: [Scope.Component, Stability.Deprecated],
    evaluate({ device, document: document2 }) {
      const global = Set2.from(Role.of("roletype").supportedAttributes);
      return {
        applicability() {
          return getElementDescendants12(document2, Node4.fullTree).filter(isIncludedInTheAccessibilityTree7(device)).flatMap((element) => Sequence.from(element.attributes).filter(property9("name", Attribute3.isName)));
        },
        expectations(target) {
          return {
            1: expectation(global.has(target.name) || test27(
              hasRole11(device, (role) => role.isAttributeSupported(target.name)),
              // Since the attribute was found on a element, it has a owner.
              target.owner.getUnsafe()
            ) || ariaHtmlAllowed(target), () => Outcomes14.IsAllowed, () => Outcomes14.IsNotAllowed)
          };
        }
      };
    }
  });
  function ariaHtmlAllowed(target) {
    const attributeName = target.name;
    for (const element of target.owner) {
      switch (element.name) {
        case "body":
          return Role.of("document").isAttributeSupported(attributeName);
        case "input":
          return hasInputType5("date", "datetime-local", "email", "month", "password", "time", "week")(element) && Role.of("textbox").isAttributeSupported(attributeName);
        case "select":
          return hasDisplaySize2((size) => size !== 1)(element) && Role.of("combobox").isAttributeSupported(attributeName) || Role.of("menu").isAttributeSupported(attributeName);
        case "video":
          return Role.of("application").isAttributeSupported(attributeName);
      }
    }
    return false;
  }
  var Outcomes14;
  (function(Outcomes87) {
    Outcomes87.IsAllowed = Ok.of(Diagnostic.of(`The attribute is allowed for the element on which it is specified`));
    Outcomes87.IsNotAllowed = Err.of(Diagnostic.of(`The attribute is not allowed for the element on which it is specified`));
  })(Outcomes14 || (Outcomes14 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/common/applicability/video.js
  var { isElement: isElement39, hasName: hasName24, hasNamespace: hasNamespace12 } = Element;
  var { and: and47 } = Predicate;
  var { isVisible: isVisible7 } = Style;
  var { getElementDescendants: getElementDescendants13 } = Query3;
  var visibleVideos = Cache2.empty();
  function video(document2, device, options) {
    const { audio: audio2, track } = options;
    const videos = visibleVideos.get(document2, Cache2.empty).get(device, () => getElementDescendants13(document2, Node4.fullTree).filter(and47(hasNamespace12(Namespace.HTML), hasName24("video"), isVisible7(device))));
    return (track === void 0 ? videos : videos.filter(hasTrack(track.has, track.kind))).map((element) => Question2.of("is-video-streaming", element).map((isStreaming) => {
      if (isStreaming) {
        return None;
      }
      return Question2.of("has-audio", element).map((hasAudio) => audio2.has === hasAudio ? Option.of(element) : None);
    }));
  }
  function hasTrack(has, kind) {
    return (element) => has === element.children().filter(isElement39).some(and47(hasName24("track"), (trackElement) => trackElement.attribute("kind").map((kind2) => kind2.enumerate("subtitles", "captions", "descriptions", "chapters", "metadata").getOr("metadata")).getOr("subtitles") === kind));
  }

  // node_modules/@siteimprove/alfa-rules/dist/common/expectation/video-description-track-accurate.js
  function videoDescriptionTrackAccurate(target) {
    return {
      1: Question2.of("track-describes-video", target).map((trackDescribesVideo) => expectation(trackDescribesVideo, () => Outcomes15.HasDescriptionTrack, () => Outcomes15.HasNoDescriptionTrack))
    };
  }
  var Outcomes15;
  (function(Outcomes87) {
    Outcomes87.HasDescriptionTrack = Ok.of(Diagnostic.of(`The \`<video>\` element has a track that describes its visual information
    in the language of the \`<video>\` element or the page`));
    Outcomes87.HasNoDescriptionTrack = Err.of(Diagnostic.of(`The \`<video>\` element does not have a track that describes its visual
    information in the language of the \`<video>\` element or the page`));
  })(Outcomes15 || (Outcomes15 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-dr34/rule.js
  var rule_default15 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r34",
    requirements: [Technique.of("H96")],
    tags: [Scope.Component, Stability.Deprecated],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return video(document2, device, {
            audio: { has: false },
            track: { has: true, kind: "descriptions" }
          });
        },
        expectations(target) {
          return videoDescriptionTrackAccurate(target);
        }
      };
    }
  });

  // node_modules/@siteimprove/alfa-rules/dist/sia-dr36/rule.js
  var rule_default16 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r36",
    requirements: [Technique.of("G78"), Technique.of("H96")],
    tags: [Scope.Component, Stability.Deprecated],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return video(document2, device, {
            audio: { has: true },
            track: { has: true, kind: "descriptions" }
          });
        },
        expectations(target) {
          return videoDescriptionTrackAccurate(target);
        }
      };
    }
  });

  // node_modules/@siteimprove/alfa-rules/dist/common/applicability/non-disabled-texts.js
  var { hasRole: hasRole12, isSemanticallyDisabled: isSemanticallyDisabled2 } = DOM;
  var { hasAttribute: hasAttribute11, hasName: hasName25, hasNamespace: hasNamespace13, isElement: isElement40 } = Element;
  var { or: or28, not: not34 } = Predicate;
  var { and: and48, test: test28 } = Refinement;
  var { isVisible: isVisible8 } = Style;
  var { isText: isText8 } = Text;
  var cache11 = Cache2.empty();
  function nonDisabledTexts(document2, device) {
    return cache11.get(document2, Cache2.empty).get(device, () => {
      const disabledWidgetNames = Set2.from(document2.descendants(Node4.fullTree).filter(and48(isElement40, isDisabledGroupOrWidget(device))).flatMap((element) => Node5.from(element, device).name.map((name) => Sequence.from(name.sourceNodes()).filter(isText8)).getOr(Sequence.empty())));
      return Sequence.from(visit(document2, device, disabledWidgetNames));
    });
  }
  function* visit(node, device, disabledWidgetNames) {
    if (test28(and48(isElement40, or28(not34(hasNamespace13(Namespace.HTML)), isDisabledGroupOrWidget(device))), node)) {
      return;
    }
    if (test28(and48(isText8, isVisible8(device)), node) && !disabledWidgetNames.has(node)) {
      yield node;
    }
    for (const child of node.children(Node4.fullTree)) {
      yield* visit(child, device, disabledWidgetNames);
    }
  }
  function isDisabledGroupOrWidget(device) {
    return or28(
      and48(hasRole12(device, (role) => role.isWidget() || role.is("group")), isSemanticallyDisabled2),
      // see https://github.com/act-rules/act-rules.github.io/issues/2215
      and48(hasName25("a", "area"), not34(hasAttribute11("href")), hasAttribute11("aria-disabled", (value) => value === "true"))
    );
  }

  // node_modules/@siteimprove/alfa-rules/dist/common/outcome/contrast.js
  var Contrast2;
  (function(Contrast3) {
    Contrast3.HasSufficientContrast = (highest, threshold4, pairings) => Ok.of(Contrast.of(`The highest possible contrast of the text is ${highest}:1 which is
        above the required contrast of ${threshold4}:1`, threshold4, pairings));
    Contrast3.HasInsufficientContrast = (highest, threshold4, pairings) => Err.of(Contrast.of(`The highest possible contrast of the text is ${highest}:1 which is
        below the required contrast of ${threshold4}:1`, threshold4, pairings));
  })(Contrast2 || (Contrast2 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/common/expectation/contrast.js
  var { isElement: isElement41 } = Element;
  var { flatMap: flatMap3, map: map125, takeWhile } = Iterable;
  var { min: min3, max: max3, round } = Math;
  function hasSufficientContrastDeprecated(target, device, largeTextThreshold, normalTextThreshold) {
    const parent = target.parent(Node4.flatTree).getUnsafe();
    const foregrounds = Question2.of("foreground-colors", target).answerIf(getForeground(parent, device));
    const backgrounds = Question2.of("background-colors", target).answerIf(getBackground(parent, device));
    const threshold4 = isLargeText(device)(target) ? largeTextThreshold : normalTextThreshold;
    return {
      1: foregrounds.map((foregrounds2) => backgrounds.map((backgrounds2) => {
        const { pairings, highest } = getPairings(foregrounds2, backgrounds2);
        return expectation(
          // Accept if  single pairing is good enough.
          highest >= threshold4,
          () => Contrast2.HasSufficientContrast(highest, threshold4, pairings),
          () => Contrast2.HasInsufficientContrast(highest, threshold4, pairings)
        );
      }))
    };
  }
  function hasSufficientContrast(target, device, largeTextThreshold, normalTextThreshold) {
    const parent = target.parent(Node4.flatTree).getUnsafe();
    const foreground = getForeground(parent, device).err().map((errors) => flatMap3(
      // We only keep the initial "interposed-descendants" problems. As soon as we
      // encounter some other problem, the "ignored-interposed-elements" question
      // won't solve it, and we'll ask for colors anyway. So there is no need to ask
      // "ignored-interposed-elements" for them.
      takeWhile(errors.errors, ColorError.isInterposedDescendants),
      // and keep the interposed elements.
      (error) => error.positionedDescendants
    )).getOr([]);
    const background = getBackground(parent, device).err().map((errors) => flatMap3(takeWhile(errors.errors, ColorError.isInterposedDescendants), (error) => error.positionedDescendants)).getOr([]);
    const interposedDescendants = Set2.from(foreground).concat(background);
    const ignoredInterposedElements = Question2.of("ignored-interposed-elements", Group2.of(interposedDescendants), target).answerIf(getIntersectors(parent, interposedDescendants, device).map((intersectors) => interposedDescendants.subtract(intersectors)));
    const foregrounds = Question2.of("foreground-colors", target);
    const backgrounds = Question2.of("background-colors", target);
    const threshold4 = isLargeText(device)(target) ? largeTextThreshold : normalTextThreshold;
    return {
      1: ignoredInterposedElements.map((ignored) => {
        const ignoredInterposed = Set2.from(ignored).filter(isElement41);
        return foregrounds.answerIf(getForeground(parent, device, void 0, ignoredInterposed)).map((foregrounds2) => backgrounds.answerIf(getBackground(parent, device, void 0, void 0, ignoredInterposed)).map((backgrounds2) => {
          const { pairings, highest } = getPairings(foregrounds2, backgrounds2);
          return expectation(
            // Accept if  single pairing is good enough.
            highest >= threshold4,
            () => Contrast2.HasSufficientContrast(highest, threshold4, pairings),
            () => Contrast2.HasInsufficientContrast(highest, threshold4, pairings)
          );
        }));
      })
    };
  }
  var cache12 = Cache2.empty();
  function getPairings(foregrounds, backgrounds) {
    return cache12.get(foregrounds, Cache2.empty).get(backgrounds, () => {
      const pairings = [
        ...flatMap3(foregrounds, (foreground) => map125(backgrounds, (background) => Contrast.Pairing.of(["foreground", foreground], ["background", background], contrast(foreground, background))))
      ];
      const highest = pairings.reduce((highest2, pairing) => max3(highest2, pairing.contrast), 0);
      return { pairings, highest };
    });
  }
  function luminance(color) {
    const [red, green, blue] = [color.red, color.green, color.blue].map((c) => {
      const component = c.type === "number" ? c.value / 255 : c.value;
      return component <= 0.03928 ? component / 12.92 : Math.pow((component + 0.055) / 1.055, 2.4);
    });
    return 0.2126 * red + 0.7152 * green + 0.0722 * blue;
  }
  function contrast(foreground, background) {
    const lf = luminance(foreground);
    const lb = luminance(background);
    const contrast2 = (max3(lf, lb) + 0.05) / (min3(lf, lb) + 0.05);
    return round(contrast2 * 100) / 100;
  }
  function getIntersectors(element, candidates, device) {
    if (Iterable.isEmpty(candidates)) {
      return Option.of(candidates);
    }
    const elementBox = element.getBoundingBox(device);
    if (!elementBox.isSome() || Iterable.some(candidates, (candidate) => candidate.getBoundingBox(device).isNone())) {
      return None;
    }
    return Option.of(Iterable.filter(candidates, (canditate) => elementBox.get().intersects(canditate.getBoundingBox(device).getUnsafe())));
  }

  // node_modules/@siteimprove/alfa-rules/dist/sia-dr66/rule.js
  var rule_default17 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r66",
    requirements: [Criterion.of("1.4.6")],
    tags: [Scope.Component, Stability.Deprecated],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return nonDisabledTexts(document2, device);
        },
        expectations(target) {
          return hasSufficientContrastDeprecated(target, device, 4.5, 7);
        }
      };
    }
  });

  // node_modules/@siteimprove/alfa-rules/dist/sia-dr69/rule.js
  var rule_default18 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r69",
    requirements: [Criterion.of("1.4.3"), Criterion.of("1.4.6")],
    tags: [Scope.Component, Stability.Deprecated],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return nonDisabledTexts(document2, device);
        },
        expectations(target) {
          return hasSufficientContrastDeprecated(target, device, 3, 4.5);
        }
      };
    }
  });

  // node_modules/@siteimprove/alfa-rules/dist/rules.js
  var rules_exports = {};
  __export(rules_exports, {
    R1: () => rule_default19,
    R10: () => rule_default27,
    R11: () => rule_default28,
    R110: () => rule_default99,
    R111: () => rule_default100,
    R113: () => rule_default101,
    R12: () => rule_default29,
    R13: () => rule_default30,
    R14: () => rule_default5,
    R15: () => rule_default31,
    R16: () => rule_default6,
    R17: () => rule_default32,
    R18: () => rule_default33,
    R19: () => rule_default34,
    R2: () => rule_default20,
    R20: () => rule_default35,
    R21: () => rule_default36,
    R22: () => rule_default37,
    R23: () => rule_default38,
    R24: () => rule_default39,
    R25: () => rule_default40,
    R26: () => rule_default41,
    R27: () => rule_default43,
    R28: () => rule_default44,
    R29: () => rule_default45,
    R3: () => rule_default21,
    R30: () => rule_default46,
    R31: () => rule_default42,
    R32: () => rule_default47,
    R33: () => rule_default48,
    R35: () => rule_default49,
    R37: () => rule_default50,
    R38: () => rule_default51,
    R39: () => rule_default52,
    R4: () => rule_default22,
    R40: () => rule_default53,
    R41: () => rule_default54,
    R42: () => rule_default55,
    R43: () => rule_default56,
    R44: () => rule_default57,
    R45: () => rule_default58,
    R46: () => rule_default59,
    R47: () => rule_default60,
    R48: () => rule_default61,
    R49: () => rule_default62,
    R5: () => rule_default23,
    R50: () => rule_default63,
    R53: () => rule_default64,
    R54: () => rule_default65,
    R55: () => rule_default7,
    R56: () => rule_default8,
    R57: () => rule_default66,
    R59: () => rule_default67,
    R60: () => rule_default68,
    R61: () => rule_default9,
    R62: () => rule_default69,
    R63: () => rule_default70,
    R64: () => rule_default71,
    R65: () => rule_default72,
    R66: () => rule_default73,
    R67: () => rule_default74,
    R68: () => rule_default75,
    R69: () => rule_default76,
    R7: () => rule_default24,
    R70: () => rule_default77,
    R71: () => rule_default78,
    R72: () => rule_default79,
    R73: () => rule_default80,
    R74: () => rule_default81,
    R75: () => rule_default10,
    R76: () => rule_default82,
    R77: () => rule_default83,
    R78: () => rule_default84,
    R79: () => rule_default85,
    R8: () => rule_default25,
    R80: () => rule_default86,
    R81: () => rule_default87,
    R83: () => rule_default11,
    R84: () => rule_default88,
    R85: () => rule_default89,
    R86: () => rule_default90,
    R87: () => rule_default91,
    R9: () => rule_default26,
    R90: () => rule_default92,
    R91: () => rule_default93,
    R92: () => rule_default94,
    R93: () => rule_default95,
    R94: () => rule_default96,
    R95: () => rule_default97,
    R96: () => rule_default98
  });

  // node_modules/@siteimprove/alfa-rules/dist/sia-r1/rule.js
  var { hasName: hasName26, hasNamespace: hasNamespace14 } = Element;
  var { hasTextContent: hasTextContent2 } = Node4;
  var { and: and49, not: not35 } = Predicate;
  var { getElementDescendants: getElementDescendants14 } = Query3;
  var rule_default19 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r1",
    requirements: [
      Criterion.of("2.4.2"),
      Technique.of("G88"),
      Technique.of("H25")
    ],
    tags: [Scope.Page, Stability.Stable],
    evaluate({ document: document2 }) {
      return {
        applicability() {
          return withDocumentElement(document2);
        },
        expectations(target) {
          const title = getElementDescendants14(target).find(and49(hasNamespace14(Namespace.HTML), hasName26("title")));
          return {
            1: expectation(title.isSome(), () => Outcomes16.HasTitle, () => Outcomes16.HasNoTitle),
            2: expectation(title.some(hasTextContent2(not35(String2.isWhitespace))), () => Outcomes16.HasNonEmptyTitle, () => Outcomes16.HasEmptyTitle)
          };
        }
      };
    }
  });
  var Outcomes16;
  (function(Outcomes87) {
    Outcomes87.HasTitle = Ok.of(Diagnostic.of(`The document has at least one \`<title>\` element`));
    Outcomes87.HasNoTitle = Err.of(Diagnostic.of(`The document does not have a \`<title>\` element`));
    Outcomes87.HasNonEmptyTitle = Ok.of(Diagnostic.of(`The first \`<title>\` element has text content`));
    Outcomes87.HasEmptyTitle = Err.of(Diagnostic.of(`The first \`<title>\` element has no text content`));
  })(Outcomes16 || (Outcomes16 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r2/rule.js
  var { hasNonEmptyAccessibleName: hasNonEmptyAccessibleName3, hasRole: hasRole13, isIncludedInTheAccessibilityTree: isIncludedInTheAccessibilityTree8 } = DOM;
  var { hasNamespace: hasNamespace15 } = Element;
  var { and: and50 } = Predicate;
  var { getElementDescendants: getElementDescendants15 } = Query3;
  var rule_default20 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r2",
    requirements: [
      Criterion.of("1.1.1"),
      Technique.of("G94"),
      Technique.of("G95")
    ],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return getElementDescendants15(document2, Node4.fullTree).filter(and50(hasNamespace15(Namespace.HTML), hasRole13(device, "img"), isIncludedInTheAccessibilityTree8(device)));
        },
        expectations(target) {
          return {
            1: expectation(hasNonEmptyAccessibleName3(device)(target), () => Outcomes17.HasAccessibleName, () => Outcomes17.HasNoAccessibleName)
          };
        }
      };
    }
  });
  var Outcomes17;
  (function(Outcomes87) {
    Outcomes87.HasAccessibleName = Ok.of(Diagnostic.of(`The image has an accessible name`));
    Outcomes87.HasNoAccessibleName = Err.of(Diagnostic.of(`The image does not have an accessible name`));
  })(Outcomes17 || (Outcomes17 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r3/rule.js
  var { isEmpty: isEmpty7 } = Iterable;
  var { not: not36, test: test29 } = Predicate;
  var { hasId: hasId2, hasUniqueId: hasUniqueId2 } = Element;
  var { getElementDescendants: getElementDescendants16 } = Query3;
  var rule_default21 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r3",
    requirements: [Criterion.of("4.1.1"), Technique.of("H93")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ document: document2 }) {
      return {
        applicability() {
          return getElementDescendants16(document2, Node4.composedNested).filter(hasId2(not36(isEmpty7)));
        },
        expectations(target) {
          return {
            1: expectation(test29(hasUniqueId2, target), () => Outcomes18.HasUniqueId, () => Outcomes18.HasNonUniqueId)
          };
        }
      };
    }
  });
  var Outcomes18;
  (function(Outcomes87) {
    Outcomes87.HasUniqueId = Ok.of(Diagnostic.of(`The element has a unique ID`));
    Outcomes87.HasNonUniqueId = Err.of(Diagnostic.of(`The element does not have a unique ID`));
  })(Outcomes18 || (Outcomes18 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r4/rule.js
  var { hasAttribute: hasAttribute12, isDocumentElement: isDocumentElement3 } = Element;
  var { not: not37 } = Predicate;
  var rule_default22 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r4",
    requirements: [Criterion.of("3.1.1"), Technique.of("H57")],
    tags: [Scope.Page, Stability.Stable],
    evaluate({ document: document2 }) {
      return {
        applicability() {
          return document2.children().filter(isDocumentElement3);
        },
        expectations(target) {
          return {
            1: expectation(hasAttribute12("lang", not37(String2.isWhitespace))(target), () => Outcomes19.HasLanguage, () => Outcomes19.HasNoLanguage)
          };
        }
      };
    }
  });
  var Outcomes19;
  (function(Outcomes87) {
    Outcomes87.HasLanguage = Ok.of(Diagnostic.of(`The \`lang\` attribute exists and is neither empty nor only whitespace`));
    Outcomes87.HasNoLanguage = Err.of(Diagnostic.of(`The \`lang\` attribute is either missing, empty, or only whitespace`));
  })(Outcomes19 || (Outcomes19 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r5/rule.js
  var { hasAttribute: hasAttribute13, isDocumentElement: isDocumentElement4 } = Element;
  var { not: not38 } = Predicate;
  var rule_default23 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r5",
    requirements: [Criterion.of("3.1.1"), Technique.of("H57")],
    tags: [Scope.Page, Stability.Stable],
    evaluate({ document: document2 }) {
      return {
        applicability() {
          return document2.children().filter(isDocumentElement4).filter(hasAttribute13("lang", not38(String2.isWhitespace))).map((element) => element.attribute("lang").getUnsafe());
        },
        expectations(target) {
          return {
            1: expectation(Language.parse(target.value).isOk(), () => Outcomes20.HasValidLanguage, () => Outcomes20.HasNoValidLanguage)
          };
        }
      };
    }
  });
  var Outcomes20;
  (function(Outcomes87) {
    Outcomes87.HasValidLanguage = Ok.of(Diagnostic.of(`The \`lang\` attribute has a valid primary language tag`));
    Outcomes87.HasNoValidLanguage = Err.of(Diagnostic.of(`The \`lang\` attribute does not have a valid primary language tag`));
  })(Outcomes20 || (Outcomes20 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r7/rule.js
  var { hasNonEmptyAccessibleName: hasNonEmptyAccessibleName4, isIncludedInTheAccessibilityTree: isIncludedInTheAccessibilityTree9 } = DOM;
  var { hasAttribute: hasAttribute14, hasName: hasName27, hasNamespace: hasNamespace16, isElement: isElement42 } = Element;
  var { isEmpty: isEmpty8 } = Iterable;
  var { not: not39, or: or29 } = Predicate;
  var { and: and51, test: test30 } = Refinement;
  var { isVisible: isVisible9 } = Style;
  var { isText: isText9 } = Text;
  var { getElementDescendants: getElementDescendants17 } = Query3;
  var rule_default24 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r7",
    requirements: [Criterion.of("3.1.2"), Technique.of("H58")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          function* visit3(node, lang) {
            if (test30(and51(isElement42, hasAttribute14("lang", not39(isEmpty8))), node)) {
              lang = node.attribute("lang");
            }
            if (lang.isSome()) {
              const isVisibleText = and51(isText9, and51(or29(isVisible9(device), isIncludedInTheAccessibilityTree9(device)), (text) => !String2.isWhitespace(text.data, false)));
              const isElementWithAccessibleName = and51(isElement42, hasNonEmptyAccessibleName4(device));
              if (test30(or29(isVisibleText, isElementWithAccessibleName), node)) {
                yield* lang;
              }
            }
            for (const child of node.children(Node4.flatTree)) {
              yield* visit3(child, lang);
            }
          }
          return getElementDescendants17(document2, Node4.fullTree).filter(and51(hasNamespace16(Namespace.HTML), hasName27("body"))).flatMap((element) => Sequence.from(visit3(element, None))).distinct();
        },
        expectations(target) {
          return {
            1: expectation(Language.parse(target.value).isOk(), () => Outcomes21.HasValidLanguage, () => Outcomes21.HasNoValidLanguage)
          };
        }
      };
    }
  });
  var Outcomes21;
  (function(Outcomes87) {
    Outcomes87.HasValidLanguage = Ok.of(Diagnostic.of(`The \`lang\` attribute has a valid primary language subtag`));
    Outcomes87.HasNoValidLanguage = Err.of(Diagnostic.of(`The \`lang\` attribute does not have a valid primary language subtag`));
  })(Outcomes21 || (Outcomes21 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r8/rule.js
  var { hasNonEmptyAccessibleName: hasNonEmptyAccessibleName5, hasRole: hasRole14, isIncludedInTheAccessibilityTree: isIncludedInTheAccessibilityTree10 } = DOM;
  var { hasNamespace: hasNamespace17 } = Element;
  var { and: and52 } = Predicate;
  var { getElementDescendants: getElementDescendants18 } = Query3;
  var rule_default25 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r8",
    requirements: [Criterion.of("4.1.2")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return getElementDescendants18(document2, Node4.fullTree).filter(and52(hasNamespace17(Namespace.HTML), hasRole14(device, "checkbox", "combobox", "listbox", "menuitemcheckbox", "menuitemradio", "radio", "searchbox", "slider", "spinbutton", "switch", "textbox"), isIncludedInTheAccessibilityTree10(device)));
        },
        expectations(target) {
          const role = WithRole.getRoleName(target, device);
          return {
            1: expectation(hasNonEmptyAccessibleName5(device)(target), () => Outcomes22.HasName(role), () => Outcomes22.HasNoName(role))
          };
        }
      };
    }
  });
  var Outcomes22;
  (function(Outcomes87) {
    Outcomes87.HasName = (role) => Ok.of(WithRole.of(`The form field has an accessible name`, role));
    Outcomes87.HasNoName = (role) => Err.of(WithRole.of(`The form field does not have an accessible name`, role));
  })(Outcomes22 || (Outcomes22 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/common/expectation/get-refresh-time.js
  var whitespace = /\s/;
  var digit2 = /\d/;
  function getRefreshTime(content) {
    if (content.length === 0) {
      return None;
    }
    let i = 0;
    while (whitespace.test(content[i])) {
      i++;
    }
    const start = i;
    while (digit2.test(content[i])) {
      i++;
    }
    if (start === i) {
      return None;
    }
    const next = content[i];
    if (next !== void 0 && next !== ";" && next !== ",") {
      return None;
    }
    return Option.of(parseInt(content.substring(start, i), 10));
  }

  // node_modules/@siteimprove/alfa-rules/dist/common/outcome/refresh-delay.js
  var RefreshDelay;
  (function(RefreshDelay2) {
    RefreshDelay2.HasImmediateRefresh = Ok.of(Diagnostic.of(`The refresh or redirect happens immediately`));
    RefreshDelay2.HasTwentyHoursDelayedRefresh = Ok.of(Diagnostic.of(`The refresh or redirect happens after 20 hours or more`));
    RefreshDelay2.HasDelayedRefresh = Err.of(Diagnostic.of(`The refresh or redirect is delayed`));
  })(RefreshDelay || (RefreshDelay = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r9/rule.js
  var { hasAttribute: hasAttribute15, hasName: hasName28, hasNamespace: hasNamespace18 } = Element;
  var { and: and53 } = Predicate;
  var { getElementDescendants: getElementDescendants19 } = Query3;
  var rule_default26 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r9",
    requirements: [
      Criterion.of("2.2.1"),
      Criterion.of("2.2.4"),
      Criterion.of("3.2.5"),
      Technique.of("G110"),
      Technique.of("H76")
    ],
    tags: [Scope.Page, Stability.Stable],
    evaluate({ document: document2 }) {
      let refreshTime;
      return {
        applicability() {
          return getElementDescendants19(document2).find(and53(hasNamespace18(Namespace.HTML), hasName28("meta"), hasAttribute15("http-equiv", (value) => value.toLowerCase() === "refresh"), hasAttribute15("content", (value) => getRefreshTime(value).map((time) => refreshTime = time).isSome()))).map((meta) => [meta]).getOr([]);
        },
        expectations(target) {
          return {
            1: expectation(refreshTime === 0, () => RefreshDelay.HasImmediateRefresh, () => expectation(
              refreshTime > 72e3,
              // 20 hours = 20*60*60 seconds
              () => RefreshDelay.HasTwentyHoursDelayedRefresh,
              () => RefreshDelay.HasDelayedRefresh
            ))
          };
        }
      };
    }
  });

  // node_modules/@siteimprove/alfa-rules/dist/sia-r10/rule.js
  var { hasRole: hasRole15, isPerceivableForAll: isPerceivableForAll5 } = DOM;
  var { hasAttribute: hasAttribute16, hasInputType: hasInputType6, hasName: hasName29, hasNamespace: hasNamespace19 } = Element;
  var { and: and54, or: or30, not: not40 } = Predicate;
  var { isTabbable: isTabbable3 } = Style;
  var { either: either99, end: end9, option: option63, right: right37, parseIf: parseIf4 } = Parser;
  var { getElementDescendants: getElementDescendants20 } = Query3;
  var rule_default27 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r10",
    requirements: [Criterion.of("1.3.5")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return getElementDescendants20(document2, Node4.fullTree).filter(and54(hasNamespace19(Namespace.HTML), hasName29("input", "select", "textarea"), not40(hasInputType6("hidden", "button", "submit", "reset")), hasAttribute16("autocomplete", hasTokens), hasAttribute16("autocomplete", (autocomplete) => String2.normalize(autocomplete) !== "on" && String2.normalize(autocomplete) !== "off"), or30(isTabbable3(device), hasRole15(device, (role) => role.isWidget())), isPerceivableForAll5(device), (element) => Node5.from(element, device).attribute("aria-disabled").none((disabled) => disabled.value === "true"))).map((element) => element.attribute("autocomplete").getUnsafe());
        },
        expectations(target) {
          return {
            1: expectation(isValidAutocomplete(target), () => Outcomes23.HasValidValue, () => Outcomes23.HasNoValidValue)
          };
        }
      };
    }
  });
  function hasTokens(input) {
    return input.trim() !== "" && input.split(/\s+/).length > 0;
  }
  var isValidAutocomplete = (autocomplete) => {
    const tokens = autocomplete.value.toLowerCase().trim().split(/\s+/);
    const parse57 = right37(
      option63(section),
      // 1.
      right37(
        option63(addressType),
        // 2.
        right37(
          // 3.
          either99(
            unmodifiable,
            // 3.a
            right37(
              option63(modifier),
              modifiable
              /*3.b.2*/
            )
          ),
          right37(
            option63(webauthn),
            // 4.
            end9((token) => `Expected EOF, but got ${token}`)
          )
        )
      )
    );
    return parse57(Slice.of(tokens)).isOk();
  };
  var unmodifiables = Array2.from([
    "name",
    "honorific-prefix",
    "given-name",
    "additional-name",
    "family-name",
    "honorific-suffix",
    "nickname",
    "username",
    "new-password",
    "current-password",
    "one-time-code",
    "organization-title",
    "organization",
    "street-address",
    "address-line1",
    "address-line2",
    "address-line3",
    "address-level4",
    "address-level3",
    "address-level2",
    "address-level1",
    "country",
    "country-name",
    "postal-code",
    "cc-name",
    "cc-given-name",
    "cc-additional-name",
    "cc-family-name",
    "cc-number",
    "cc-exp",
    "cc-exp-month",
    "cc-exp-year",
    "cc-csc",
    "cc-type",
    "transaction-currency",
    "transaction-amount",
    "language",
    "bday",
    "bday-day",
    "bday-month",
    "bday-year",
    "sex",
    "url",
    "photo"
  ]);
  var modifiables = Array2.from([
    "tel",
    "tel-country-code",
    "tel-national",
    "tel-area-code",
    "tel-local",
    "tel-local-prefix",
    "tel-local-suffix",
    "tel-extension",
    "email",
    "impp"
  ]);
  var modifiers = Array2.from(["home", "work", "mobile", "fax", "pager"]);
  var parseFirst = (input) => input.first().map((token) => Ok.of([input.rest(), token])).getOr(Err.of("No token left"));
  function parserOf(tokens) {
    return parseIf4((token) => tokens.includes(token), parseFirst, (token) => `Expected valid token, but got ${token}`);
  }
  var addressType = parserOf(["shipping", "billing"]);
  var unmodifiable = parserOf(unmodifiables);
  var section = parseIf4((token) => token.startsWith("section-"), parseFirst, (token) => `Expected token beginning with \`section-\`, but got ${token}`);
  var modifiable = parserOf(modifiables);
  var modifier = parserOf(modifiers);
  var webauthn = parserOf(["webauthn"]);
  var Outcomes23;
  (function(Outcomes87) {
    Outcomes87.HasValidValue = Ok.of(Diagnostic.of(`The \`autocomplete\` attribute has a valid value`));
    Outcomes87.HasNoValidValue = Err.of(Diagnostic.of(`The \`autocomplete\` attribute does not have a valid value`));
  })(Outcomes23 || (Outcomes23 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r11/rule.js
  var { hasNonEmptyAccessibleName: hasNonEmptyAccessibleName6, hasRole: hasRole16, isIncludedInTheAccessibilityTree: isIncludedInTheAccessibilityTree11 } = DOM;
  var { hasNamespace: hasNamespace20 } = Element;
  var { and: and55 } = Predicate;
  var { getElementDescendants: getElementDescendants21 } = Query3;
  var rule_default28 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r11",
    requirements: [
      Criterion.of("2.4.4"),
      Criterion.of("2.4.9"),
      Criterion.of("4.1.2"),
      Technique.of("G91")
    ],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return getElementDescendants21(document2, Node4.fullTree).filter(and55(hasNamespace20(Namespace.HTML), hasRole16(device, (role) => role.is("link")), isIncludedInTheAccessibilityTree11(device)));
        },
        expectations(target) {
          return {
            1: expectation(hasNonEmptyAccessibleName6(device)(target), () => Outcomes24.HasName, () => Outcomes24.HasNoName)
          };
        }
      };
    }
  });
  var Outcomes24;
  (function(Outcomes87) {
    Outcomes87.HasName = Ok.of(Diagnostic.of(`The link has an accessible name`));
    Outcomes87.HasNoName = Err.of(Diagnostic.of(`The link does not have an accessible name`));
  })(Outcomes24 || (Outcomes24 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r12/rule.js
  var { hasNonEmptyAccessibleName: hasNonEmptyAccessibleName7, hasRole: hasRole17, isIncludedInTheAccessibilityTree: isIncludedInTheAccessibilityTree12 } = DOM;
  var { hasInputType: hasInputType7, hasNamespace: hasNamespace21 } = Element;
  var { and: and56, not: not41 } = Predicate;
  var { getElementDescendants: getElementDescendants22 } = Query3;
  var rule_default29 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r12",
    requirements: [Criterion.of("4.1.2")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return getElementDescendants22(document2, Node4.fullTree).filter(and56(not41(hasInputType7("image")), hasNamespace21(Namespace.HTML), hasRole17(device, "button"), isIncludedInTheAccessibilityTree12(device)));
        },
        expectations(target) {
          return {
            1: expectation(hasNonEmptyAccessibleName7(device)(target), () => Outcomes25.HasName, () => Outcomes25.HasNoName)
          };
        }
      };
    }
  });
  var Outcomes25;
  (function(Outcomes87) {
    Outcomes87.HasName = Ok.of(Diagnostic.of(`The button has an accessible name`));
    Outcomes87.HasNoName = Err.of(Diagnostic.of(`The button does not have an accessible name`));
  })(Outcomes25 || (Outcomes25 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r13/rule.js
  var { hasNonEmptyAccessibleName: hasNonEmptyAccessibleName8, isIncludedInTheAccessibilityTree: isIncludedInTheAccessibilityTree13, isMarkedDecorative: isMarkedDecorative2 } = DOM;
  var { hasName: hasName30, hasNamespace: hasNamespace22, hasTabIndex: hasTabIndex4 } = Element;
  var { and: and57, not: not42 } = Predicate;
  var { getElementDescendants: getElementDescendants23 } = Query3;
  var rule_default30 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r13",
    requirements: [Criterion.of("4.1.2")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return getElementDescendants23(document2, Node4.fullTree).filter(and57(hasNamespace22(Namespace.HTML), hasName30("iframe"), isIncludedInTheAccessibilityTree13(device), not42(hasTabIndex4((n) => n < 0)), not42(isMarkedDecorative2)));
        },
        expectations(target) {
          return {
            1: expectation(hasNonEmptyAccessibleName8(device)(target), () => Outcomes26.HasName, () => Outcomes26.HasNoName)
          };
        }
      };
    }
  });
  var Outcomes26;
  (function(Outcomes87) {
    Outcomes87.HasName = Ok.of(Diagnostic.of(`The \`<iframe>\` has an accessible name`));
    Outcomes87.HasNoName = Err.of(Diagnostic.of(`The \`<iframe>\` does not have an accessible name`));
  })(Outcomes26 || (Outcomes26 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r15/rule.js
  var { hasNonEmptyAccessibleName: hasNonEmptyAccessibleName9, isIncludedInTheAccessibilityTree: isIncludedInTheAccessibilityTree14 } = DOM;
  var { hasName: hasName31, hasNamespace: hasNamespace23 } = Element;
  var { and: and58 } = Predicate;
  var { getElementDescendants: getElementDescendants24 } = Query3;
  var rule_default31 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r15",
    requirements: [Criterion.of("4.1.2")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2, response }) {
      return {
        applicability() {
          return getElementDescendants24(document2, Node4.fullTree).filter(and58(hasName31("iframe"), hasNamespace23(Namespace.HTML), isIncludedInTheAccessibilityTree14(device), hasNonEmptyAccessibleName9(device))).groupBy((iframe) => Node5.from(iframe, device).name.map((name) => String2.normalize(name.value))).filter((elements) => elements.size > 1).map(Group2.of).values();
        },
        expectations(target) {
          const embedSameResource = [...target].every((element, i, elements) => (
            // This is either the first element...
            i === 0 || // ...or an element that embeds the same resource as the element
            // before it.
            referenceSameResource(response.url)(element, elements[i - 1])
          ));
          const name = WithName2.getName(
            Iterable.first(target).getUnsafe(),
            // Existence of first element is guaranteed by applicability
            device
          ).getUnsafe();
          return {
            1: expectation(embedSameResource, () => Outcomes27.EmbedSameResources(name), () => Question2.of("reference-equivalent-resources", target, "Do the <iframe> elements embed equivalent resources?", {
              diagnostic: WithName2.of("Do the <iframe> elements embed equivalent resources?", name)
            }).map((embedEquivalentResources) => expectation(embedEquivalentResources, () => Outcomes27.EmbedEquivalentResources(name), () => Outcomes27.EmbedDifferentResources(name))))
          };
        }
      };
    }
  });
  var Outcomes27;
  (function(Outcomes87) {
    Outcomes87.EmbedSameResources = (name) => Ok.of(WithName2.of(`The \`<iframe>\` elements embed the same resource`, name));
    Outcomes87.EmbedEquivalentResources = (name) => Ok.of(WithName2.of(`The \`<iframe>\` elements embed equivalent resources`, name));
    Outcomes87.EmbedDifferentResources = (name) => Err.of(WithName2.of(`The \`<iframe>\` elements do not embed the same or equivalent resources`, name));
  })(Outcomes27 || (Outcomes27 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r17/rule.js
  var { hasAttribute: hasAttribute17, isElement: isElement43 } = Element;
  var { equals: equals26 } = Predicate;
  var { and: and59 } = Refinement;
  var { isTabbable: isTabbable4 } = Style;
  var { getElementDescendants: getElementDescendants25 } = Query3;
  var rule_default32 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r17",
    requirements: [Criterion.of("4.1.2")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return getElementDescendants25(document2, Node4.fullTree).filter(hasAttribute17("aria-hidden", equals26("true")));
        },
        expectations(target) {
          const tabbable = target.inclusiveDescendants(Node4.flatTree).filter(and59(isElement43, isTabbable4(device)));
          return {
            1: expectation(tabbable.isEmpty(), () => Outcomes28.IsNotTabbable, () => Outcomes28.IsTabbable(tabbable))
          };
        }
      };
    }
  });
  var Outcomes28;
  (function(Outcomes87) {
    Outcomes87.IsNotTabbable = Ok.of(Diagnostic.of(`The element is neither tabbable nor has tabbable descendants`));
    Outcomes87.IsTabbable = (errors) => Err.of(WithBadElements.of(`The element is either tabbable or has tabbable descendants`, errors));
  })(Outcomes28 || (Outcomes28 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r18/rule.js
  var { hasRole: hasRole18, isIncludedInTheAccessibilityTree: isIncludedInTheAccessibilityTree15 } = DOM;
  var { hasDisplaySize: hasDisplaySize3, hasInputType: hasInputType8, hasName: hasName32 } = Element;
  var { test: test31, property: property10 } = Predicate;
  var { getElementDescendants: getElementDescendants26 } = Query3;
  var rule_default33 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r18",
    requirements: [
      ARIA.of("https://www.w3.org/TR/wai-aria-1.2/#state_property_processing"),
      Technique.of("ARIA5")
    ],
    tags: [Scope.Component, Stability.Stable, Version.of(2)],
    evaluate({ device, document: document2 }) {
      const global = Set2.from(Role.of("roletype").supportedAttributes);
      return {
        applicability() {
          return getElementDescendants26(document2, Node4.fullTree).filter(isIncludedInTheAccessibilityTree15(device)).flatMap((element) => Sequence.from(element.attributes).filter(property10("name", Attribute3.isName)));
        },
        expectations(target) {
          const owner = target.owner.getUnsafe();
          return {
            1: expectation(global.has(target.name) || test31(hasRole18(device, (role) => role.isAttributeSupported(target.name)), owner) || ariaHtmlAllowed2(target), () => Outcomes29.IsAllowed, () => Outcomes29.IsNotAllowed),
            2: expectation(test31(hasRole18(device, (role) => role.isAttributeProhibited(target.name)), owner), () => Outcomes29.IsProhibited, () => Outcomes29.IsNotProhibited)
          };
        }
      };
    }
  });
  function allowedForInputType(attributeName) {
    return hasInputType8((inputType) => {
      switch (inputType) {
        // https://www.w3.org/TR/html-aria/#el-input-color
        case "color":
          return attributeName === "aria-disabled";
        // https://www.w3.org/TR/html-aria/#el-input-date
        case "date":
        // https://www.w3.org/TR/html-aria/#el-input-datetime-local
        case "datetime-local":
        // https://www.w3.org/TR/html-aria/#el-input-email
        case "email":
        // https://www.w3.org/TR/html-aria/#el-input-month
        case "month":
        // https://www.w3.org/TR/html-aria/#el-input-password
        case "password":
        // https://www.w3.org/TR/html-aria/#el-input-time
        case "time":
        // https://www.w3.org/TR/html-aria/#el-input-week
        case "week":
          return Role.of("textbox").isAttributeSupported(attributeName);
        // https://www.w3.org/TR/html-aria/#el-input-file
        case "file":
          return attributeName === "aria-disabled" || attributeName === "aria-invalid" || attributeName === "aria-required";
        default:
          return false;
      }
    });
  }
  function ariaHtmlAllowed2(target) {
    const attributeName = target.name;
    return target.owner.map((element) => Selective.of(element).if(hasName32("input"), allowedForInputType(attributeName)).if(hasName32("select"), (select) => hasDisplaySize3((size) => size !== 1)(select) && Role.of("combobox").isAttributeSupported(attributeName) || Role.of("menu").isAttributeSupported(attributeName)).else(() => false).get()).getOr(false);
  }
  var Outcomes29;
  (function(Outcomes87) {
    Outcomes87.IsAllowed = Ok.of(Diagnostic.of(`The attribute is allowed for the element on which it is specified`));
    Outcomes87.IsNotAllowed = Err.of(Diagnostic.of(`The attribute is not allowed for the element on which it is specified`));
    Outcomes87.IsProhibited = Err.of(Diagnostic.of(`The attribute is prohibited for the element on which it is specified`));
    Outcomes87.IsNotProhibited = Ok.of(Diagnostic.of(`The attribute is not prohibited for the element on which it is specified`));
  })(Outcomes29 || (Outcomes29 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r19/rule.js
  var { hasNamespace: hasNamespace24 } = Element;
  var { isEmpty: isEmpty9 } = Iterable;
  var { and: and60, not: not43, equals: equals27, property: property11 } = Predicate;
  var { getElementDescendants: getElementDescendants27 } = Query3;
  var rule_default34 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r19",
    requirements: [
      ARIA.of("https://www.w3.org/TR/wai-aria-1.2/#propcharacteristic_value")
    ],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return getElementDescendants27(document2, Node4.composedNested).filter(hasNamespace24(Namespace.HTML, Namespace.SVG)).flatMap((element) => Sequence.from(element.attributes).filter(and60(property11("name", Attribute3.isName), property11("value", not43(isEmpty9)))));
        },
        expectations(target) {
          const { name, value } = target;
          const attribute = Attribute3.of(name, value);
          const owner = target.owner.getUnsafe();
          return {
            1: expectation(isValid(attribute) && isAttributeOptionalOrValid(attribute, owner, device), () => Outcomes30.HasValidValue, () => Outcomes30.HasNoValidValue)
          };
        }
      };
    }
  });
  var Outcomes30;
  (function(Outcomes87) {
    Outcomes87.HasValidValue = Ok.of(Diagnostic.of(`The attribute has a valid value`));
    Outcomes87.HasNoValidValue = Err.of(Diagnostic.of(`The attribute does not have a valid value`));
  })(Outcomes30 || (Outcomes30 = {}));
  function isValid(attribute) {
    const { type, value, options } = attribute;
    switch (type) {
      case "true-false":
        return value === "true" || value === "false";
      case "true-false-undefined":
        return value === "true" || value === "false" || value === "undefined";
      case "tristate":
        return value === "true" || value === "false" || value === "mixed";
      case "id-reference":
        return !/\s+/.test(value);
      case "id-reference-list":
        return true;
      case "integer":
        return /^[+-]?\d+$/.test(value);
      case "number":
        return /^[+-]?\d+(\.\d+)?$/.test(value);
      case "string":
        return true;
      case "token":
        return value === "undefined" || options.some(equals27(value));
      case "token-list":
        return value.split(/\s+/).every((value2) => options.some(equals27(value2)));
    }
  }
  function treeHasId(id, node) {
    return Query3.getElementIdMap(node.root()).has(id);
  }
  function isAttributeOptionalOrValid(attribute, owner, device) {
    const node = Node5.from(owner, device);
    for (const role of node.role) {
      const { name, type, value } = attribute;
      if (isAriaControlsOptional(node) && name === "aria-controls") {
        return true;
      }
      if (role.isAttributeRequired(name) && (type === "id-reference" || type === "id-reference-list")) {
        return value.split(" ").some((token) => treeHasId(token.trim(), owner));
      }
      return true;
    }
    return true;
  }

  // node_modules/@siteimprove/alfa-rules/dist/sia-r20/rule.js
  var { getElementDescendants: getElementDescendants28 } = Query3;
  var rule_default35 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r20",
    requirements: [ARIA.of("https://www.w3.org/TR/wai-aria-1.2/#state_prop_def")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ document: document2 }) {
      return {
        applicability() {
          return getElementDescendants28(document2, Node4.composedNested).flatMap((element) => Sequence.from(element.attributes).filter((attribute) => attribute.name.startsWith("aria-")));
        },
        expectations(target) {
          const exists = Attribute3.isName(target.name);
          return {
            1: expectation(exists, () => Outcomes31.IsDefined, () => Outcomes31.IsNotDefined)
          };
        }
      };
    }
  });
  var Outcomes31;
  (function(Outcomes87) {
    Outcomes87.IsDefined = Ok.of(Diagnostic.of(`The attribute is defined`));
    Outcomes87.IsNotDefined = Err.of(Diagnostic.of(`The attribute is not defined`));
  })(Outcomes31 || (Outcomes31 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/common/applicability/role-attributes.js
  var { isProgrammaticallyHidden: isProgrammaticallyHidden2 } = DOM;
  var { hasAttribute: hasAttribute18, hasNamespace: hasNamespace25 } = Element;
  var { and: and61, not: not44 } = Predicate;
  var { getElementDescendants: getElementDescendants29 } = Query3;
  var cache13 = Cache2.empty();
  function roleAttributes(document2, device) {
    return cache13.get(document2, Cache2.empty).get(device, () => getElementDescendants29(document2, Node4.fullTree).filter(and61(hasNamespace25(Namespace.HTML, Namespace.SVG), hasAttribute18("role", (value) => value.trim().length > 0), not44(isProgrammaticallyHidden2(device)))).map((element) => element.attribute("role").getUnsafe()));
  }

  // node_modules/@siteimprove/alfa-rules/dist/sia-r21/rule.js
  var rule_default36 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r21",
    requirements: [BestPractice.of("all-roles-valid")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return roleAttributes(document2, device);
        },
        expectations(target) {
          return {
            1: expectation(target.tokens().every((token) => Role.isName(token) && Role.of(token).isConcrete()), () => Outcomes32.HasValidRole, () => Outcomes32.HasNoValidRole)
          };
        }
      };
    }
  });
  var Outcomes32;
  (function(Outcomes87) {
    Outcomes87.HasValidRole = Ok.of(Diagnostic.of(`The element has only valid roles`));
    Outcomes87.HasNoValidRole = Err.of(Diagnostic.of(`The element does not have at least one valid role`));
  })(Outcomes32 || (Outcomes32 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r22/rule.js
  var rule_default37 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r22",
    requirements: [Technique.of("G87"), Technique.of("G93"), Technique.of("H95")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return video(document2, device, { audio: { has: true } });
        },
        expectations(target) {
          return {
            1: Question2.of("has-captions", target).map((hasCaptions) => expectation(hasCaptions, () => Outcomes33.HasCaptions, () => Outcomes33.HasNoCaptions))
          };
        }
      };
    }
  });
  var Outcomes33;
  (function(Outcomes87) {
    Outcomes87.HasCaptions = Ok.of(Diagnostic.of(`The \`<video>\` element has captions`));
    Outcomes87.HasNoCaptions = Err.of(Diagnostic.of(`The \`<video>\` element does not have captions`));
  })(Outcomes33 || (Outcomes33 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/common/applicability/audio.js
  var { isPerceivableForAll: isPerceivableForAll6 } = DOM;
  var { isElement: isElement44, hasName: hasName33, hasNamespace: hasNamespace26, hasAttribute: hasAttribute19 } = Element;
  var { and: and62 } = Predicate;
  var { isRendered: isRendered3 } = Style;
  var { getElementDescendants: getElementDescendants30 } = Query3;
  var cache14 = Cache2.empty();
  function audio(document2, device) {
    return cache14.get(document2, Cache2.empty).get(device, () => getElementDescendants30(document2, Node4.fullTree).filter(
      // Non-rendered <audio> are not playing
      and62(hasNamespace26(Namespace.HTML), hasName33("audio"), isRendered3(device))
    ).map((element) => Question2.of("is-audio-streaming", element).map((isStreaming) => isStreaming ? None : Question2.of("is-playing", element).answerIf(hasAttribute19("autoplay"), true).map((isPlaying) => isPlaying ? Option.of(element) : Question2.of("play-button", element).answerIf(hasAttribute19("controls"), Option.of(element)).map((playButton) => playButton.some(and62(isElement44, isPerceivableForAll6(device))) ? Option.of(element) : None)))));
  }

  // node_modules/@siteimprove/alfa-rules/dist/common/expectation/media-transcript.js
  var { isPerceivableForAll: isPerceivableForAll7 } = DOM;
  var { isElement: isElement45 } = Element;
  var { and: and63 } = Predicate;
  function mediaTranscript(transcript, transcriptLink, device, kind) {
    return {
      1: transcript.map((transcript2) => {
        if (transcript2.isNone()) {
          return transcriptLink.map((transcriptLink2) => {
            if (transcriptLink2.isNone()) {
              return Option.of(Outcomes34.HasNoTranscriptLink(kind));
            }
            if (transcriptLink2.filter(and63(isElement45, isPerceivableForAll7(device))).isNone()) {
              return Option.of(Outcomes34.HasNonPerceivableLink(kind));
            }
            return Option.of(Outcomes34.HasPerceivableLink(kind));
          });
        }
        return expectation(transcript2.some(and63(isElement45, isPerceivableForAll7(device))), () => Outcomes34.HasPerceivableTranscript(kind), () => Outcomes34.HasNonPerceivableTranscript(kind));
      })
    };
  }
  function audioTranscript(target, device) {
    const alt = Question2.of("transcript", target, `Where is the transcript that describes the content of the \`<audio>\` element?`);
    const label = Question2.of("transcript-link", target, `Where is the link pointing to a perceivable transcript that describes the content of the \`<audio>\` element?`);
    return mediaTranscript(alt, label, device, "<audio>");
  }
  function videoTranscript(target, device) {
    const alt = Question2.of("transcript", target, `Where is the transcript that describes the content of the \`<video>\` element?`);
    const label = Question2.of("transcript-link", target, `Where is the link pointing to a perceivable transcript that describes the content of the \`<video>\` element?`);
    return mediaTranscript(alt, label, device, "<video>");
  }
  var Outcomes34;
  (function(Outcomes87) {
    Outcomes87.HasPerceivableTranscript = (kind) => Ok.of(Diagnostic.of(`The \`${kind}\` element has a transcript that is perceivable`));
    Outcomes87.HasPerceivableLink = (kind) => Ok.of(Diagnostic.of(`The \`${kind}\` element has a link that is perceivable`));
    Outcomes87.HasNoTranscriptLink = (kind) => Err.of(Diagnostic.of(`The \`${kind}\` element does not have a transcript`));
    Outcomes87.HasNonPerceivableLink = (kind) => Err.of(Diagnostic.of(`The \`${kind}\` has a link to transcript, but the link is not perceivable`));
    Outcomes87.HasNonPerceivableTranscript = (kind) => Err.of(Diagnostic.of(`The \`${kind}\` element has a transcript that is not perceivable`));
  })(Outcomes34 || (Outcomes34 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r23/rule.js
  var rule_default38 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r23",
    tags: [Scope.Component, Stability.Stable],
    evaluate({ document: document2, device }) {
      return {
        applicability() {
          return audio(document2, device);
        },
        expectations(target) {
          return audioTranscript(target, device);
        }
      };
    }
  });

  // node_modules/@siteimprove/alfa-rules/dist/sia-r24/rule.js
  var rule_default39 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r24",
    requirements: [Criterion.of("1.2.8"), Technique.of("G69")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return video(document2, device, { audio: { has: true } });
        },
        expectations(target) {
          return videoTranscript(target, device);
        }
      };
    }
  });

  // node_modules/@siteimprove/alfa-rules/dist/sia-r25/rule.js
  var rule_default40 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r25",
    requirements: [Technique.of("G8"), Technique.of("G78"), Technique.of("G173")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return video(document2, device, { audio: { has: true } });
        },
        expectations(target) {
          return {
            1: Question2.of("has-description", target, `Is the visual information of the \`<video>\` available through its audio or a separate audio description track?`).map((hasAudio) => expectation(hasAudio, () => Outcomes35.HasInformativeAudio, () => Outcomes35.HasNoInformativeAudio))
          };
        }
      };
    }
  });
  var Outcomes35;
  (function(Outcomes87) {
    Outcomes87.HasInformativeAudio = Ok.of(Diagnostic.of(`The visual information of the \`<video>\` element is available through audio`));
    Outcomes87.HasNoInformativeAudio = Err.of(Diagnostic.of(`The visual information of the \`<video>\` element is not available through audio`));
  })(Outcomes35 || (Outcomes35 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/common/expectation/media-text-alternative.js
  var { isPerceivableForAll: isPerceivableForAll8 } = DOM;
  function mediaTextAlternative(alt, label, device, kind) {
    return {
      1: alt.map((alt2) => expectation(alt2.isSome(), () => expectation(alt2.some(isPerceivableForAll8(device)), () => Outcomes36.HasPerceivableAlternative(kind), () => Outcomes36.HasNonPerceivableAlternative(kind)), () => Outcomes36.HasNoAlternative(kind))),
      2: label.map((label2) => expectation(label2.isSome(), () => expectation(label2.some(isPerceivableForAll8(device)), () => Outcomes36.HasPerceivableLabel(kind), () => Outcomes36.HasNonPerceivableLabel(kind)), () => Outcomes36.HasNoLabel(kind)))
    };
  }
  function audioTextAlternative(target, device) {
    const alt = Question2.of("text-alternative", target, `Where is the text alternative of the \`<audio>\` element?`);
    const label = Question2.of("label", target, `Where is the text that labels the \`<audio>\` element as an audio alternative?`);
    return mediaTextAlternative(alt, label, device, "<audio>");
  }
  function videoTextAlternative(target, device) {
    const alt = Question2.of("text-alternative", target, `Where is the text alternative of the \`<video>\` element?`);
    const label = Question2.of("label", target, `Where is the text that labels the \`<video>\` element as a video alternative?`);
    return mediaTextAlternative(alt, label, device, "<video>");
  }
  var Outcomes36;
  (function(Outcomes87) {
    Outcomes87.HasPerceivableAlternative = (kind) => Ok.of(Diagnostic.of(`The \`${kind}\` element has a text alternative that is perceivable`));
    Outcomes87.HasNonPerceivableAlternative = (kind) => Err.of(Diagnostic.of(`The \`${kind}\` element has a text alternative that is not perceivable`));
    Outcomes87.HasNoAlternative = (kind) => Err.of(Diagnostic.of(`The \`${kind}\` element has no text alternative`));
    Outcomes87.HasPerceivableLabel = (kind) => Ok.of(Diagnostic.of(`The \`${kind}\` element is labelled as an alternative for text and the label is perceivable`));
    Outcomes87.HasNonPerceivableLabel = (kind) => Err.of(Diagnostic.of(`The \`${kind}\` element is labelled as an alternative for text, but the label is not perceivable`));
    Outcomes87.HasNoLabel = (kind) => Err.of(Diagnostic.of(`The \`${kind}\` element is not labelled as an alternative for text`));
  })(Outcomes36 || (Outcomes36 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r26/rule.js
  var rule_default41 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r26",
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return video(document2, device, { audio: { has: false } });
        },
        expectations(target) {
          return videoTextAlternative(target, device);
        }
      };
    }
  });

  // node_modules/@siteimprove/alfa-rules/dist/sia-r31/rule.js
  var rule_default42 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r31",
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return video(document2, device, { audio: { has: true } });
        },
        expectations(target) {
          return videoTextAlternative(target, device);
        }
      };
    }
  });

  // node_modules/@siteimprove/alfa-rules/dist/sia-r27/rule.js
  var rule_default43 = Rule.Composite.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r27",
    requirements: [
      Criterion.of("1.2.2"),
      Technique.of("G87"),
      Technique.of("G93"),
      Technique.of("H95")
    ],
    tags: [Scope.Component, Stability.Stable],
    composes: [rule_default37, rule_default42],
    evaluate: () => {
      return {
        expectations(outcomes) {
          return {
            1: expectation(Trilean.some(outcomes, isPassed), () => Outcomes37.HasTextAlternative, () => Outcomes37.HasNoTextAlternative)
          };
        }
      };
    }
  });
  var Outcomes37;
  (function(Outcomes87) {
    Outcomes87.HasTextAlternative = Ok.of(Diagnostic.of(`The \`<video>\` element has a text alternative for its audio content`));
    Outcomes87.HasNoTextAlternative = Err.of(Diagnostic.of(`The \`<video>\` element has no text alternative for its audio content`));
  })(Outcomes37 || (Outcomes37 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r28/rule.js
  var { hasAccessibleName: hasAccessibleName3, isIncludedInTheAccessibilityTree: isIncludedInTheAccessibilityTree16 } = DOM;
  var { hasInputType: hasInputType9, hasNamespace: hasNamespace27 } = Element;
  var { and: and64, test: test32 } = Predicate;
  var { getElementDescendants: getElementDescendants31 } = Query3;
  var rule_default44 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r28",
    requirements: [
      Criterion.of("1.1.1"),
      Criterion.of("4.1.2"),
      Technique.of("G94"),
      Technique.of("G95")
    ],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return getElementDescendants31(document2, Node4.fullTree).filter(and64(hasNamespace27(Namespace.HTML), hasInputType9("image"), isIncludedInTheAccessibilityTree16(device)));
        },
        expectations(target) {
          return {
            1: expectation(test32(
              // Rejecting default name
              hasAccessibleName3(device, (name) => name.source.length !== 0),
              target
            ), () => Outcomes38.HasAccessibleName, () => Outcomes38.HasNoAccessibleName)
          };
        }
      };
    }
  });
  var Outcomes38;
  (function(Outcomes87) {
    Outcomes87.HasAccessibleName = Ok.of(Diagnostic.of(`The \`<input type="image">\` element has an accessible name`));
    Outcomes87.HasNoAccessibleName = Err.of(Diagnostic.of(`The \`<input type="image">\` element does not have an accessible name`));
  })(Outcomes38 || (Outcomes38 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r29/rule.js
  var rule_default45 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r29",
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return audio(document2, device);
        },
        expectations(target) {
          return audioTextAlternative(target, device);
        }
      };
    }
  });

  // node_modules/@siteimprove/alfa-rules/dist/sia-r30/rule.js
  var rule_default46 = Rule.Composite.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r30",
    requirements: [Criterion.of("1.2.1"), Technique.of("G158")],
    tags: [Scope.Component, Stability.Stable],
    composes: [rule_default38, rule_default45],
    evaluate() {
      return {
        expectations(outcomes) {
          return {
            1: expectation(Trilean.some(outcomes, isPassed), () => Outcomes39.HasTextAlternative, () => Outcomes39.HasNoTextAlternative)
          };
        }
      };
    }
  });
  var Outcomes39;
  (function(Outcomes87) {
    Outcomes87.HasTextAlternative = Ok.of(Diagnostic.of(`The \`<audio>\` element has a text alternative`));
    Outcomes87.HasNoTextAlternative = Err.of(Diagnostic.of(`The \`<audio>\` element does not have a text alternative`));
  })(Outcomes39 || (Outcomes39 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r32/rule.js
  var rule_default47 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r32",
    requirements: [Technique.of("G166")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return video(document2, device, { audio: { has: false } });
        },
        expectations(target) {
          return {
            1: Question2.of("has-audio-track", target).map((hasAudioTrack) => expectation(hasAudioTrack, () => Outcomes40.HasDescriptiveAudio, () => Outcomes40.HasNoDescriptiveAudio))
          };
        }
      };
    }
  });
  var Outcomes40;
  (function(Outcomes87) {
    Outcomes87.HasDescriptiveAudio = Ok.of(Diagnostic.of(`The \`<video>\` element has an audio track that describes its visual
      information`));
    Outcomes87.HasNoDescriptiveAudio = Err.of(Diagnostic.of(`The \`<video>\` element does not have an audio track that describes its
      visual information`));
  })(Outcomes40 || (Outcomes40 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r33/rule.js
  var rule_default48 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r33",
    requirements: [Technique.of("G159")],
    tags: [Scope.Component, Stability.Stable],
    evaluate: ({ device, document: document2 }) => {
      return {
        applicability() {
          return video(document2, device, { audio: { has: false } });
        },
        expectations(target) {
          return videoTranscript(target, device);
        }
      };
    }
  });

  // node_modules/@siteimprove/alfa-rules/dist/sia-r35/rule.js
  var rule_default49 = Rule.Composite.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r35",
    requirements: [
      Criterion.of("1.2.1"),
      Technique.of("G159"),
      Technique.of("G166")
    ],
    tags: [Scope.Component, Stability.Stable],
    composes: [rule_default41, rule_default47, rule_default48],
    evaluate() {
      return {
        expectations(outcomes) {
          return {
            1: expectation(Trilean.some(outcomes, isPassed), () => Outcomes41.HasAlternative, () => Outcomes41.HasNoAlternative)
          };
        }
      };
    }
  });
  var Outcomes41;
  (function(Outcomes87) {
    Outcomes87.HasAlternative = Ok.of(Diagnostic.of(`The \`<video>\` element has an alternative`));
    Outcomes87.HasNoAlternative = Err.of(Diagnostic.of(`The \`<video>\` element does not have an alternative`));
  })(Outcomes41 || (Outcomes41 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r37/rule.js
  var rule_default50 = Rule.Composite.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r37",
    requirements: [
      Criterion.of("1.2.5"),
      Technique.of("G8"),
      Technique.of("G78"),
      Technique.of("G173")
    ],
    tags: [Scope.Component, Stability.Stable],
    composes: [rule_default40, rule_default42],
    evaluate() {
      return {
        expectations(outcomes) {
          return {
            1: expectation(Trilean.some(outcomes, isPassed), () => Outcomes42.HasAudioDescription, () => Outcomes42.HasNoAudioDescription)
          };
        }
      };
    }
  });
  var Outcomes42;
  (function(Outcomes87) {
    Outcomes87.HasAudioDescription = Ok.of(Diagnostic.of(`The \`<video>\` element has an audio description`));
    Outcomes87.HasNoAudioDescription = Err.of(Diagnostic.of(`The \`<video>\` element does not have an audio description`));
  })(Outcomes42 || (Outcomes42 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r38/rule.js
  var rule_default51 = Rule.Composite.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r38",
    requirements: [
      Criterion.of("1.2.3"),
      Criterion.of("1.2.5"),
      Criterion.of("1.2.8"),
      Technique.of("G8"),
      Technique.of("G69"),
      Technique.of("G78"),
      Technique.of("G173")
    ],
    tags: [Scope.Component, Stability.Stable],
    composes: [rule_default39, rule_default40, rule_default42],
    evaluate() {
      return {
        expectations(outcomes) {
          return {
            1: expectation(Trilean.some(outcomes, isPassed), () => Outcomes43.HasAlternative, () => Outcomes43.HasNoAlternative)
          };
        }
      };
    }
  });
  var Outcomes43;
  (function(Outcomes87) {
    Outcomes87.HasAlternative = Ok.of(Diagnostic.of(`The \`<video>\` element has an audio or text alternative`));
    Outcomes87.HasNoAlternative = Err.of(Diagnostic.of(`The \`<video>\` element does not have an audio or text alternative`));
  })(Outcomes43 || (Outcomes43 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r39/rule.js
  var { hasAccessibleName: hasAccessibleName4, isIncludedInTheAccessibilityTree: isIncludedInTheAccessibilityTree17 } = DOM;
  var { hasInputType: hasInputType10, hasName: hasName34, hasNamespace: hasNamespace28 } = Element;
  var { and: and65, or: or31, test: test33 } = Predicate;
  var { getElementDescendants: getElementDescendants32 } = Query3;
  var rule_default52 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r39",
    requirements: [
      Criterion.of("1.1.1"),
      Technique.of("G94"),
      Technique.of("G95")
    ],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return getElementDescendants32(document2, Node4.fullTree).filter(and65(hasNamespace28(Namespace.HTML), or31(hasName34("img"), and65(hasName34("input"), hasInputType10("image"))), isIncludedInTheAccessibilityTree17(device), (element) => test33(hasAccessibleName4(device, (accessibleName) => element.attribute("src").map((attr) => getFilename(attr.value)).some((filename) => filename.toLowerCase() === accessibleName.value.toLowerCase().trim())), element)));
        },
        expectations(target) {
          const accName = WithName2.getName(target, device).getUnsafe();
          return {
            1: Question2.of("name-describes-purpose", target, `Does the accessible name of the \`<${target.name}>\` element describe its purpose?`, {
              diagnostic: WithName2.of(`Does the accessible name of the \`<${target.name}>\` element describe its purpose?`, accName)
            }).map((nameDescribesPurpose) => expectation(nameDescribesPurpose, () => Outcomes44.NameIsDescriptive(target.name, accName), () => Outcomes44.NameIsNotDescriptive(target.name, accName)))
          };
        }
      };
    }
  });
  function getFilename(path) {
    const base3 = path.substring(path.lastIndexOf("/") + 1);
    const params = base3.indexOf("?");
    if (params !== -1) {
      return base3.substring(0, params).trim();
    }
    return base3.trim();
  }
  var Outcomes44;
  (function(Outcomes87) {
    Outcomes87.NameIsDescriptive = (name, accName) => Ok.of(WithName2.of(`The accessible name of the \`<${name}>\` element describes its purpose`, accName));
    Outcomes87.NameIsNotDescriptive = (name, accName) => Err.of(WithName2.of(`The accessible name of the \`<${name}>\` element does not describe its purpose`, accName));
  })(Outcomes44 || (Outcomes44 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r40/rule.js
  var { hasIncorrectRoleWithoutName: hasIncorrectRoleWithoutName4, hasNonEmptyAccessibleName: hasNonEmptyAccessibleName10, hasRole: hasRole19, isIncludedInTheAccessibilityTree: isIncludedInTheAccessibilityTree18 } = DOM;
  var { and: and66 } = Predicate;
  var { getElementDescendants: getElementDescendants33 } = Query3;
  var rule_default53 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r40",
    requirements: [
      ARIA.of("https://www.w3.org/TR/wai-aria/#region"),
      ARIA.of("https://www.w3.org/WAI/ARIA/apg/practices/landmark-regions/#aria_lh_region")
    ],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return getElementDescendants33(document2, Node4.fullTree).filter(and66(hasRole19(device, (role) => role.is("region")), isIncludedInTheAccessibilityTree18(device))).reject(hasIncorrectRoleWithoutName4(device));
        },
        expectations(target) {
          return {
            1: expectation(hasNonEmptyAccessibleName10(device)(target), () => Outcomes45.HasName, () => Outcomes45.HasNoName)
          };
        }
      };
    }
  });
  var Outcomes45;
  (function(Outcomes87) {
    Outcomes87.HasName = Ok.of(Diagnostic.of(`The region has an accessible name`));
    Outcomes87.HasNoName = Err.of(Diagnostic.of(`The region does not have an accessible name`));
  })(Outcomes45 || (Outcomes45 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r41/rule.js
  var { hasNonEmptyAccessibleName: hasNonEmptyAccessibleName11, hasRole: hasRole20, isIncludedInTheAccessibilityTree: isIncludedInTheAccessibilityTree19 } = DOM;
  var { hasNamespace: hasNamespace29 } = Element;
  var { and: and67 } = Predicate;
  var { getElementDescendants: getElementDescendants34 } = Query3;
  var rule_default54 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r41",
    requirements: [Criterion.of("2.4.9")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2, response }) {
      return {
        applicability() {
          return getElementDescendants34(document2, Node4.fullTree).filter(and67(hasNamespace29(Namespace.HTML, Namespace.SVG), hasRole20(device, (role) => role.is("link")), isIncludedInTheAccessibilityTree19(device), hasNonEmptyAccessibleName11(device))).groupBy((element) => Node5.from(element, device).name.map((name) => String2.normalize(name.value))).filter((elements) => elements.size > 1).map(Group2.of).values();
        },
        expectations(target) {
          const name = WithName2.getName(
            Iterable.first(target).getUnsafe(),
            // Existence of first element is guaranteed by applicability
            device
          ).getUnsafe();
          const embedSameResource = [...target].every((element, i, elements) => {
            return i === 0 || // ...or an element that embeds the same resource as the element
            // before it.
            referenceSameResource(response.url)(element, elements[i - 1]);
          });
          return {
            1: expectation(embedSameResource, () => Outcomes46.ResolveSameResource(name), () => Question2.of("reference-equivalent-resources", target, `Do the links resolve to equivalent resources?`, {
              diagnostic: WithName2.of(`Do the links resolve to equivalent resources?`, name)
            }).map((embedEquivalentResources) => expectation(embedEquivalentResources, () => Outcomes46.ResolveEquivalentResource(name), () => Outcomes46.ResolveDifferentResource(name))))
          };
        }
      };
    }
  });
  var Outcomes46;
  (function(Outcomes87) {
    Outcomes87.ResolveSameResource = (name) => Ok.of(WithName2.of(`The links resolve to the same resource`, name));
    Outcomes87.ResolveEquivalentResource = (name) => Ok.of(WithName2.of(`The links resolve to equivalent resources`, name));
    Outcomes87.ResolveDifferentResource = (name) => Err.of(WithName2.of(`The links do not resolve to the same or equivalent resources`, name));
  })(Outcomes46 || (Outcomes46 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r42/rule.js
  var { hasRole: hasRole21, isIncludedInTheAccessibilityTree: isIncludedInTheAccessibilityTree20 } = DOM;
  var { isElement: isElement46, hasNamespace: hasNamespace30 } = Element;
  var { and: and68 } = Predicate;
  var { getElementDescendants: getElementDescendants35 } = Query3;
  var rule_default55 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r42",
    requirements: [Criterion.of("1.3.1")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return getElementDescendants35(document2, Node4.fullTree).filter(and68(hasNamespace30(Namespace.HTML, Namespace.SVG), isIncludedInTheAccessibilityTree20(device), hasRole21(device, (role) => role.hasRequiredParent())));
        },
        expectations(target) {
          return {
            1: expectation(hasRequiredParent(device)(target), () => Outcomes47.IsOwnedByContextRole(WithRole.getRoleName(target, device)), () => Outcomes47.IsNotOwnedByContextRole(WithRole.getRoleName(target, device)))
          };
        }
      };
    }
  });
  var Outcomes47;
  (function(Outcomes87) {
    Outcomes87.IsOwnedByContextRole = (role) => Ok.of(WithRole.of(`The element is owned by an element of its required context role`, role));
    Outcomes87.IsNotOwnedByContextRole = (role) => Err.of(WithRole.of(`The element is not owned by an element of its required context role`, role));
  })(Outcomes47 || (Outcomes47 = {}));
  function hasRequiredParent(device) {
    return (element) => {
      const node = Node5.from(element, device);
      return node.role.filter((role) => role.hasRequiredParent()).every((role) => node.parent().some(isRequiredParent(role.requiredParent)));
    };
  }
  function isRequiredParent(requiredParent) {
    return (node) => requiredParent.some((roles2) => isRequiredParent2(roles2)(node));
    function isRequiredParent2(requiredParent2) {
      return (node) => {
        const [role, ...rest] = requiredParent2;
        if (node.role.some(Role.hasName(role))) {
          return rest.length === 0 || node.parent().filter((node2) => isElement46(node2.node)).some(isRequiredParent2(rest));
        }
        return false;
      };
    }
  }

  // node_modules/@siteimprove/alfa-rules/dist/sia-r43/rule.js
  var { hasExplicitRole: hasExplicitRole2, hasNonEmptyAccessibleName: hasNonEmptyAccessibleName12, isIncludedInTheAccessibilityTree: isIncludedInTheAccessibilityTree21 } = DOM;
  var { hasNamespace: hasNamespace31 } = Element;
  var { and: and69 } = Predicate;
  var { getElementDescendants: getElementDescendants36 } = Query3;
  var rule_default56 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r43",
    requirements: [Criterion.of("1.1.1")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ document: document2, device }) {
      return {
        applicability() {
          return getElementDescendants36(document2, Node4.fullTree).filter(and69(hasNamespace31(Namespace.SVG), hasExplicitRole2("img", "graphics-document", "graphics-symbol"), isIncludedInTheAccessibilityTree21(device)));
        },
        expectations(target) {
          return {
            1: expectation(hasNonEmptyAccessibleName12(device)(target), () => Outcomes48.HasName(target.name), () => Outcomes48.HasNoName(target.name))
          };
        }
      };
    }
  });
  var Outcomes48;
  (function(Outcomes87) {
    Outcomes87.HasName = (target) => Ok.of(Diagnostic.of(`The \`<${target}>\` element has an accessible name`));
    Outcomes87.HasNoName = (target) => Err.of(Diagnostic.of(`The \`<${target}>\` element does not have an accessible name`));
  })(Outcomes48 || (Outcomes48 = {}));

  // node_modules/@siteimprove/alfa-affine/dist/transformation.js
  var { cos, sin, tan, sqrt: sqrt2, max: max4 } = Math;
  var { norm, normalize, dot, cross } = Vector;
  var { determinant, multiply, inverse, transpose } = Matrix;
  var Transformation = class _Transformation {
    static of(matrix) {
      const [[a = 1, b = 0, c = 0, d = 0] = [], [e = 0, f = 1, g = 0, h2 = 0] = [], [i = 0, j = 0, k = 1, l = 0] = [], [m = 0, n = 0, o = 0, p = 1] = []] = matrix;
      return new _Transformation([
        [a, b, c, d],
        [e, f, g, h2],
        [i, j, k, l],
        [m, n, o, p]
      ]);
    }
    static _empty = new _Transformation(Matrix.identity(4));
    static empty() {
      return this._empty;
    }
    _matrix;
    constructor(matrix) {
      this._matrix = matrix;
    }
    apply(transformation) {
      return new _Transformation(multiply(this._matrix, transformation._matrix));
    }
    translate(tx, ty = 0, tz = 0) {
      return this.apply(_Transformation.translate(tx, ty, tz));
    }
    scale(sx, sy = sx, sz = 1) {
      return this.apply(_Transformation.scale(sx, sy, sz));
    }
    skew(a, b) {
      return this.apply(_Transformation.skew(a, b));
    }
    rotate(a, u) {
      return this.apply(_Transformation.rotate(a, u));
    }
    perspective(d) {
      return this.apply(_Transformation.perspective(d));
    }
    /**
     * {@link https://drafts.csswg.org/css-transforms-2/#decomposing-a-3d-matrix}
     */
    decompose() {
      const m = this._matrix;
      if (m[3][3] === 0) {
        return None;
      }
      for (let i = 0; i < 4; i++) {
        for (let j = 0; j < 4; j++) {
          m[i][j] /= m[3][3];
        }
      }
      let p = Matrix.clone(m);
      for (let i = 0; i < 3; i++) {
        p[3][i] = 0;
      }
      p[3][3] = 1;
      if (determinant(p) === 0) {
        return None;
      }
      if (m[3][0] !== 0 || m[3][1] !== 0 || m[3][2] !== 0) {
        p = multiply(transpose(inverse(p)), m[3].map((v) => [v])).map(([v]) => v);
      } else {
        p = [0, 0, 0, 1];
      }
      const t = [m[0][3], m[1][3], m[2][3]];
      const u = [
        [m[0][0], m[0][1], m[0][2]],
        [m[1][0], m[1][1], m[1][2]],
        [m[2][0], m[2][1], m[2][2]]
      ];
      const s = [norm(u[0]), 0, 0];
      u[0] = normalize(u[0]);
      const z = [dot(u[0], u[1]), 0, 0];
      u[1] = combine(u[1], u[0], 1, -z[0]);
      s[1] = norm(u[1]);
      u[1] = normalize(u[1]);
      z[0] /= s[1];
      z[1] = dot(u[0], u[2]);
      u[2] = combine(u[2], u[0], 1, -z[1]);
      z[2] = dot(u[1], u[2]);
      u[2] = combine(u[2], u[1], 1, -z[2]);
      s[2] = norm(u[2]);
      u[2] = normalize(u[2]);
      z[1] /= s[2];
      z[2] /= s[2];
      if (dot(u[0], cross(u[1], u[2])) < 0) {
        for (let i = 0; i < 3; i++) {
          s[i] *= -1;
          u[i][0] *= -1;
          u[i][1] *= -1;
          u[i][2] *= -1;
        }
      }
      const r = [
        0.5 * sqrt2(max4(1 + u[0][0] - u[1][1] - u[2][2], 0)),
        0.5 * sqrt2(max4(1 - u[0][0] + u[1][1] - u[2][2], 0)),
        0.5 * sqrt2(max4(1 - u[0][0] - u[1][1] + u[2][2], 0)),
        0.5 * sqrt2(max4(1 + u[0][0] + u[1][1] + u[2][2], 0))
      ];
      if (u[2][1] > u[1][2]) {
        r[0] = -r[0];
      }
      if (u[0][2] > u[2][0]) {
        r[1] = -r[1];
      }
      if (u[1][0] > u[0][1]) {
        r[2] = -r[2];
      }
      return Option.of({
        translate: t,
        scale: s,
        skew: z,
        rotate: r,
        perspective: p
      });
    }
    equals(value) {
      return value instanceof _Transformation && Matrix.equals(value._matrix, this._matrix);
    }
    toArray() {
      return Matrix.clone(this._matrix);
    }
    toJSON() {
      return Matrix.clone(this._matrix);
    }
  };
  (function(Transformation2) {
    function translate(tx, ty = 0, tz = 0) {
      return Transformation2.of([
        [1, 0, 0, tx],
        [0, 1, 0, ty],
        [0, 0, 1, tz],
        [0, 0, 0, 1]
      ]);
    }
    Transformation2.translate = translate;
    function scale(sx, sy = sx, sz = 1) {
      return Transformation2.of([
        [sx, 0, 0],
        [0, sy, 0],
        [0, 0, sz]
      ]);
    }
    Transformation2.scale = scale;
    function skew(a, b) {
      return Transformation2.of([
        [1, tan(a)],
        [tan(b), 1]
      ]);
    }
    Transformation2.skew = skew;
    function rotate(a, u = [0, 0, 1]) {
      const [x, y, z] = normalize(u);
      return Transformation2.of([
        [
          cos(a) + x ** 2 * (1 - cos(a)),
          x * y * (1 - cos(a)) - z * sin(a),
          x * z * (1 - cos(a)) + y * sin(a)
        ],
        [
          y * x * (1 - cos(a)) + z * sin(a),
          cos(a) + y ** 2 * (1 - cos(a)),
          y * z * (1 - cos(a)) - x * sin(a)
        ],
        [
          z * x * (1 - cos(a)) - y * sin(a),
          z * y * (1 - cos(a)) + x * sin(a),
          cos(a) + z ** 2 * (1 - cos(a))
        ]
      ]);
    }
    Transformation2.rotate = rotate;
    function perspective(d) {
      return Transformation2.of([
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 1, 0],
        [0, 0, -1 / d, 1]
      ]);
    }
    Transformation2.perspective = perspective;
  })(Transformation || (Transformation = {}));
  function combine(a, b, ascl, bscl) {
    return [
      ascl * a[0] + bscl * b[0],
      ascl * a[1] + bscl * b[1],
      ascl * a[2] + bscl * b[2]
    ];
  }

  // node_modules/@siteimprove/alfa-rules/dist/sia-r44/rule.js
  var { isElement: isElement47 } = Element;
  var { filter: filter12, flatMap: flatMap4, none, some } = Iterable;
  var { abs: abs4, acos, PI: PI2 } = Math;
  var { or: or32 } = Predicate;
  var { hasComputedStyle: hasComputedStyle6, isVisible: isVisible10 } = Style;
  var { getElementDescendants: getElementDescendants37 } = Query3;
  var rule_default57 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r44",
    requirements: [Criterion.of("1.3.4")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      let landscape;
      let portrait;
      if (device.viewport.orientation === Viewport.Orientation.Landscape) {
        landscape = device;
        portrait = Device.of(device.type, Viewport.of(device.viewport.width, device.viewport.height, Viewport.Orientation.Portrait), device.display);
      } else {
        portrait = device;
        landscape = Device.of(device.type, Viewport.of(device.viewport.width, device.viewport.height, Viewport.Orientation.Landscape), device.display);
      }
      return {
        applicability() {
          if (none(filter12(flatMap4(document2.style, (sheet) => sheet.descendants()), MediaRule.isMediaRule), (rule) => some(rule.queries.queries, (query) => query.condition.some(hasOrientationCondition)))) {
            return [];
          }
          return getElementDescendants37(document2, Node4.fullTree).filter(isVisible10(device)).filter(or32(hasConditionalRotation(landscape), hasConditionalRotation(portrait)));
        },
        expectations(target) {
          const rotation = getRelativeRotation(target, landscape, portrait).map((rotation2) => Real.round(rotation2));
          return {
            1: expectation(rotation.every((rotation2) => rotation2 !== 90 && rotation2 !== 270), () => Outcomes49.RotationNotLocked, () => Outcomes49.RotationLocked)
          };
        }
      };
    }
  });
  var Outcomes49;
  (function(Outcomes87) {
    Outcomes87.RotationNotLocked = Ok.of(Diagnostic.of(`The element is not locked in orientation`));
    Outcomes87.RotationLocked = Err.of(Diagnostic.of(`The element is locked in orientation`));
  })(Outcomes49 || (Outcomes49 = {}));
  function hasConditionalRotation(device) {
    return or32(hasComputedStyle6("transform", (value, source) => (
      // The only keyword value is "none", which is no rotation
      !Keyword.isKeyword(value) && source.some(isOrientationConditional) && some(value, (transform) => transform.kind === "rotate" || transform.kind === "matrix")
    ), device), hasComputedStyle6("rotate", (value, source) => (
      // The only keyword value is "none", which is no rotation
      !Keyword.isKeyword(value) && source.some(isOrientationConditional)
    ), device));
  }
  function isOrientationConditional(declaration) {
    return some(declaration.ancestors(), (rule) => MediaRule.isMediaRule(rule) && some(rule.queries.queries, (query) => query.condition.some(hasOrientationCondition)));
  }
  function hasOrientationCondition(condition) {
    for (const feature of condition) {
      if (feature.name === "orientation" && feature.value.some((value) => value.matches(Keyword.of("landscape")) || value.matches(Keyword.of("portrait")))) {
        return true;
      }
    }
    return false;
  }
  function getRotation(element, device) {
    const parent = element.parent(Node4.flatTree).filter(isElement47);
    const rotation = parent.isNone() ? Option.of(0) : parent.flatMap((parent2) => getRotation(parent2, device));
    return rotation.flatMap((rotation2) => {
      const style = Style.from(element, device);
      const rotate = style.computed("rotate").value;
      if (!Keyword.isKeyword(rotate)) {
        const { x, y, angle } = rotate;
        if (x.value !== 0 || y.value !== 0) {
          return None;
        }
        rotation2 += angle.value;
      }
      const transform = style.computed("transform").value;
      if (Keyword.isKeyword(transform)) {
        return Option.of(rotation2);
      }
      for (const fn of transform) {
        switch (fn.kind) {
          case "rotate": {
            const { x, y, angle } = fn;
            if (x.value !== 0 || y.value !== 0) {
              return None;
            }
            rotation2 += angle.value;
            break;
          }
          case "matrix": {
            const decomposed = Transformation.of(fn.values.map((row) => row.map((number) => number.value))).decompose();
            if (!decomposed.isSome()) {
              continue;
            }
            const [x, y, , w] = decomposed.get().rotate;
            if (x !== 0 || y !== 0) {
              return None;
            }
            const angle = 2 * acos(w) * 180 / PI2;
            rotation2 += angle;
          }
        }
      }
      return Option.of(Real.modulo(rotation2, 360));
    });
  }
  function getRelativeRotation(element, left22, right38) {
    return getRotation(element, left22).flatMap((left23) => getRotation(element, right38).map((right39) => Real.modulo(abs4(left23 - right39), 360)));
  }

  // node_modules/@siteimprove/alfa-rules/dist/sia-r45/rule.js
  var { hasRole: hasRole22, isPerceivableForAll: isPerceivableForAll9 } = DOM;
  var { hasAttribute: hasAttribute20, hasId: hasId3, hasName: hasName35, hasNamespace: hasNamespace32 } = Element;
  var { and: and70, equals: equals28 } = Predicate;
  var { getElementDescendants: getElementDescendants38 } = Query3;
  var rule_default58 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r45",
    requirements: [Criterion.of("1.3.1"), Technique.of("H43")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      const cellsCache = Cache2.empty();
      const headers = getElementDescendants38(document2).filter(and70(hasNamespace32(Namespace.HTML), hasName35("table"), isPerceivableForAll9(device), hasRole22(device, (role) => role.is("table")))).reduce((headers2, table) => {
        const cells = cellsCache.get(table, () => getElementDescendants38(table).filter(and70(hasNamespace32(Namespace.HTML), hasName35("td", "th")))).filter(hasAttribute20("headers"));
        for (const cell of cells) {
          headers2 = headers2.set(cell.attribute("headers").getUnsafe(), table);
        }
        return headers2;
      }, Map2.empty());
      return {
        applicability() {
          return headers.keys();
        },
        expectations(target) {
          const table = headers.get(target).getUnsafe();
          const ids2 = target.tokens();
          const cells = cellsCache.get(table, () => getElementDescendants38(table).filter(and70(hasNamespace32(Namespace.HTML), hasName35("td", "th")))).filter(hasId3(equals28(...ids2)));
          return {
            1: expectation(
              // Each token refers to a different cell in the same table if the
              // number of identified cells is equal to the number of IDs.
              cells.size === ids2.size,
              () => Outcomes50.HeadersRefersToCellInTable,
              () => Outcomes50.HeadersDoesNotReferToCellsInTable
            ),
            2: expectation(cells.every((cell) => !target.owner.some(equals28(cell))), () => Outcomes50.HeadersDoesNotRefersToSelf, () => Outcomes50.HeadersRefersToSelf)
          };
        }
      };
    }
  });
  var Outcomes50;
  (function(Outcomes87) {
    Outcomes87.HeadersRefersToCellInTable = Ok.of(Diagnostic.of(`The \`headers\` attribute refers to cells in the same \`<table>\``));
    Outcomes87.HeadersDoesNotReferToCellsInTable = Err.of(Diagnostic.of(`The \`headers\` attribute refers to cells not present in the same \`<table>\``));
    Outcomes87.HeadersDoesNotRefersToSelf = Ok.of(Diagnostic.of(`The \`headers\` attribute does not refer to the cell defining it`));
    Outcomes87.HeadersRefersToSelf = Err.of(Diagnostic.of(`The \`headers\` attribute refers to the cell defining it`));
  })(Outcomes50 || (Outcomes50 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r46/rule.js
  var { hasRole: hasRole23, isIncludedInTheAccessibilityTree: isIncludedInTheAccessibilityTree22, isPerceivableForAll: isPerceivableForAll10 } = DOM;
  var { hasName: hasName36, hasNamespace: hasNamespace33 } = Element;
  var { and: and71 } = Predicate;
  var { getElementDescendants: getElementDescendants39 } = Query3;
  var rule_default59 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r46",
    requirements: [Criterion.of("1.3.1"), Technique.of("H43")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      let data = Map2.empty();
      return {
        *applicability() {
          const tables = getElementDescendants39(document2).filter(and71(hasNamespace33(Namespace.HTML), hasName36("table"), isIncludedInTheAccessibilityTree22(device)));
          for (const table of tables) {
            const model = Table.from(table);
            const headers = getElementDescendants39(table).filter(and71(hasNamespace33(Namespace.HTML), hasName36("th"), hasRole23(device, "rowheader", "columnheader"), isPerceivableForAll10(device)));
            for (const header of headers) {
              for (const cell of model.cells.find((cell2) => cell2.element.equals(header))) {
                data = data.set(header, [cell, model]);
                yield header;
              }
            }
          }
        },
        expectations(target) {
          const [header, table] = data.get(target).getUnsafe();
          return {
            1: expectation(table.cells.some((cell) => (
              // Does there exists a cell with the target as one of its headers?
              hasRole23(device, (role) => role.is("cell"))(cell.element) && cell.headers.some((slot) => slot.equals(header.anchor))
            )), () => Outcomes51.IsAssignedToDataCell, () => Outcomes51.IsNotAssignedToDataCell)
          };
        }
      };
    }
  });
  var Outcomes51;
  (function(Outcomes87) {
    Outcomes87.IsAssignedToDataCell = Ok.of(Diagnostic.of(`The header cell is assigned to a cell`));
    Outcomes87.IsNotAssignedToDataCell = Err.of(Diagnostic.of(`The header cell is not assigned to any cell`));
  })(Outcomes51 || (Outcomes51 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r47/rule.js
  var { hasAttribute: hasAttribute21, hasName: hasName37, hasNamespace: hasNamespace34 } = Element;
  var { and: and72, equals: equals29 } = Predicate;
  var { getElementDescendants: getElementDescendants40 } = Query3;
  var rule_default60 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r47",
    requirements: [
      Criterion.of("1.4.4")
      // The 1.4.10 secondary mapping is missing in ACT rules
      // https://github.com/act-rules/act-rules.github.io/issues/2025
      // Commenting it out as it would otherwise invalidate our implementation
      // in the reports.
      // Criterion.of("1.4.10"),
    ],
    tags: [Scope.Page, Stability.Stable],
    evaluate({ document: document2 }) {
      let maximumScaleMap = Map2.empty();
      let userScalableMap = Map2.empty();
      return {
        applicability() {
          return getElementDescendants40(document2).filter(and72(hasNamespace34(Namespace.HTML), hasName37("meta"), hasAttribute21("name", equals29("viewport")), hasAttribute21("content"))).filter((meta) => {
            const properties = parsePropertiesList(
              // The previous filter ensures there is a content.
              meta.attribute("content").getUnsafe().value.toLowerCase()
            );
            const scale = parseMaximumScale(properties.get("maximum-scale"));
            const scalable = parseUserScalable(properties.get("user-scalable"));
            scale.forEach((scale2) => {
              maximumScaleMap = maximumScaleMap.set(meta, scale2);
            });
            scalable.forEach((scalable2) => {
              userScalableMap = userScalableMap.set(meta, scalable2);
            });
            return scale.or(scalable).isSome();
          });
        },
        expectations(target) {
          return {
            1: expectation(maximumScaleMap.get(target).every((scale) => scale >= 2) && userScalableMap.get(target).every((scalable) => scalable !== "fixed"), () => Outcomes52.MetaDoesNotPreventZoom, () => Outcomes52.MetaDoesPreventZoom)
          };
        }
      };
    }
  });
  var Outcomes52;
  (function(Outcomes87) {
    Outcomes87.MetaDoesNotPreventZoom = Ok.of(Diagnostic.of(`The \`<meta>\` element does not restrict the ability to zoom`));
    Outcomes87.MetaDoesPreventZoom = Err.of(Diagnostic.of(`The \`<meta>\` element restricts the ability to zoom`));
  })(Outcomes52 || (Outcomes52 = {}));
  function parsePropertiesList(propertiesList) {
    let valueMap = Map2.empty();
    const whitespace2 = [" ", "\xA0", "	", "\n", "\f", "\r", "\v"];
    const separator = [",", ";"];
    const equal = ["="];
    const sepSet = Set2.from(separator);
    const allSpecial = Set2.of(...whitespace2, ...separator, ...equal);
    const separatorAndEqual = Set2.of(...separator, ...equal);
    const notSeparator = Set2.of(...whitespace2, ...equal);
    const { length } = propertiesList;
    let i = 0;
    let start;
    let name;
    let value;
    while (i < length) {
      while (i < length && allSpecial.has(propertiesList[i])) {
        i++;
      }
      start = i;
      while (i < length && !allSpecial.has(propertiesList[i])) {
        i++;
      }
      name = propertiesList.substring(start, i);
      while (i < length && !separatorAndEqual.has(propertiesList[i])) {
        i++;
      }
      while (i < length && notSeparator.has(propertiesList[i])) {
        i++;
      }
      if (!sepSet.has(propertiesList[i])) {
        start = i;
        while (i < length && !allSpecial.has(propertiesList[i])) {
          i++;
        }
        value = propertiesList.substring(start, i);
        if (value.length > 0) {
          valueMap = valueMap.set(name, value);
        }
      }
    }
    return valueMap;
  }
  function parseMaximumScale(scale) {
    return scale.flatMap((scale2) => {
      switch (scale2) {
        case "yes":
          return Option.of(1);
        case "device-width":
        case "device-height":
          return Option.of(10);
        case "no":
          return Option.of(0.1);
        default:
          const scaleValue = Number(scale2);
          if (scaleValue < 0) {
            return None;
          }
          return Option.of(isNaN(scaleValue) ? 0.1 : Real.clamp(scaleValue, 0.1, 10));
      }
    });
  }
  function parseUserScalable(scalable) {
    return scalable.map((scalable2) => {
      switch (scalable2) {
        case "yes":
        case "device-width":
        case "device-height":
          return "zoom";
        case "no":
          return "fixed";
        default:
          const scalableValue = Number(scalable2);
          return scalableValue <= -1 || scalableValue >= 1 ? "zoom" : "fixed";
      }
    });
  }

  // node_modules/@siteimprove/alfa-rules/dist/sia-r48/rule.js
  var { hasAttribute: hasAttribute22, hasName: hasName38, hasNamespace: hasNamespace35, isElement: isElement48 } = Element;
  var { or: or33, nor: nor4 } = Predicate;
  var { and: and73 } = Refinement;
  var { getElementDescendants: getElementDescendants41 } = Query3;
  var rule_default61 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r48",
    requirements: [Technique.of("G60")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ document: document2 }) {
      return {
        applicability() {
          return getElementDescendants41(document2, Node4.composedNested).filter(and73(hasNamespace35(Namespace.HTML), hasName38("audio", "video"), hasAttribute22("autoplay"), nor4(hasAttribute22("paused"), hasAttribute22("muted")), or33(hasAttribute22("src"), Node4.hasChild(and73(isElement48, hasName38("source")))))).map((element) => {
            const isAboveDurationThreshold = Question2.of("is-above-duration-threshold", element, `Does the \`<${element.name}>\` element have a duration of more than 3 seconds?`).map((isAboveDurationThreshold2) => isAboveDurationThreshold2 ? Option.of(element) : None);
            if (element.name === "audio") {
              return isAboveDurationThreshold;
            } else {
              return Question2.of("has-audio", element, `Does the \`<${element.name}>\` element contain audio?`).map((hasAudio) => hasAudio ? isAboveDurationThreshold : None);
            }
          });
        },
        expectations(target) {
          return {
            1: Question2.of("is-below-audio-duration-threshold", target, `Does the \`<${target.name}>\` element have a total audio duration of less than 3 seconds?`).map((isBelowAudioDurationThreshold) => expectation(isBelowAudioDurationThreshold, () => Outcomes53.DurationBelowThreshold(target.name), () => Outcomes53.DurationAboveThreshold(target.name)))
          };
        }
      };
    }
  });
  var Outcomes53;
  (function(Outcomes87) {
    Outcomes87.DurationBelowThreshold = (name) => Ok.of(Diagnostic.of(`The total duration of audio output of the \`<${name}>\` element does
        not exceed 3 seconds`));
    Outcomes87.DurationAboveThreshold = (name) => Err.of(Diagnostic.of(`The total duration of audio output of the \`<${name}>\` element exceeds
        3 seconds`));
  })(Outcomes53 || (Outcomes53 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r49/rule.js
  var { hasNonEmptyAccessibleName: hasNonEmptyAccessibleName13, isPerceivableForAll: isPerceivableForAll11 } = DOM;
  var { hasAttribute: hasAttribute23, hasName: hasName39, hasNamespace: hasNamespace36, isElement: isElement49 } = Element;
  var { or: or34, nor: nor5, equals: equals30 } = Predicate;
  var { and: and74 } = Refinement;
  var { getElementDescendants: getElementDescendants42 } = Query3;
  var rule_default62 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r49",
    requirements: [Technique.of("G170")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ document: document2, device }) {
      return {
        applicability() {
          return getElementDescendants42(document2, Node4.composedNested).filter(and74(hasNamespace36(Namespace.HTML), hasName39("audio", "video"), hasAttribute23("autoplay"), nor5(hasAttribute23("paused"), hasAttribute23("muted")), or34(hasAttribute23("src"), Node4.hasChild(and74(isElement49, hasName39("source")))))).map((element) => {
            const isAboveDurationThreshold = Question2.of("is-above-duration-threshold", element, `Does the \`<${element.name}>\` element have a duration of more than 3 seconds?`).map((isAboveDurationThreshold2) => isAboveDurationThreshold2 ? Option.of(element) : None);
            if (element.name === "audio") {
              return isAboveDurationThreshold;
            } else {
              return Question2.of("has-audio", element, `Does the \`<${element.name}>\` element contain audio?`).map((hasAudio) => hasAudio ? isAboveDurationThreshold : None);
            }
          });
        },
        expectations(target) {
          return {
            1: Question2.of("audio-control-mechanism", target, `Where is the mechanism that can pause or stop the audio of the \`<${target.name}>\` element?`).answerIf(target.attribute("controls").isSome(), Option.of(target)).map((mechanism) => expectation(mechanism.isSome(), () => expectation(mechanism.some(and74(isElement49, and74(
              isPerceivableForAll11(device),
              // The mechanism is either the applicable <video> or
              // <audio> element itself, in which case we assume the
              // native controls provide accessible names, or it has
              // a non-empty accessible name.
              or34(equals30(target), hasNonEmptyAccessibleName13(device))
            ))), () => Outcomes54.HasPerceivablePauseMechanism(target.name), () => Outcomes54.HasNonPerceivablePauseMechanism(target.name)), () => Outcomes54.HasNoPauseMechanism(target.name)))
          };
        }
      };
    }
  });
  var Outcomes54;
  (function(Outcomes87) {
    Outcomes87.HasPerceivablePauseMechanism = (name) => Ok.of(Diagnostic.of(`The \`<${name}>\` element has a mechanism to pause or stop audio and
        the mechanism is perceivable`));
    Outcomes87.HasNonPerceivablePauseMechanism = (name) => Err.of(Diagnostic.of(`The \`<${name}>\` element has a mechanism to pause or stop audio but
        the mechanism is not perceivable`));
    Outcomes87.HasNoPauseMechanism = (name) => Err.of(Diagnostic.of(`The \`<${name}>\` element does not have a mechanism to pause or stop
        audio`));
  })(Outcomes54 || (Outcomes54 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r50/rule.js
  var rule_default63 = Rule.Composite.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r50",
    requirements: [
      Criterion.of("1.4.2"),
      Technique.of("G60"),
      Technique.of("G170"),
      Technique.of("G171")
    ],
    tags: [Scope.Component, Stability.Stable],
    composes: [rule_default61, rule_default62],
    evaluate() {
      return {
        expectations(outcomes) {
          return {
            1: expectation(Trilean.some(outcomes, isPassed), () => Outcomes55.AutoplayGood, () => Outcomes55.AutoplayBad)
          };
        }
      };
    }
  });
  var Outcomes55;
  (function(Outcomes87) {
    Outcomes87.AutoplayGood = Ok.of(Diagnostic.of(`The total duration of the autoplaying audio output of the element either
      lasts no longer than 3 seconds or a mechanism to pause or stop the audio
      is available`));
    Outcomes87.AutoplayBad = Err.of(Diagnostic.of(`The total duration of the autoplaying audio output of the element lasts
      longer than 3 seconds and no mechanism to pause or stop the audio is
      available`));
  })(Outcomes55 || (Outcomes55 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r53/rule.js
  var { hasHeadingLevel: hasHeadingLevel2, hasRole: hasRole24, isIncludedInTheAccessibilityTree: isIncludedInTheAccessibilityTree23 } = DOM;
  var { and: and75, equals: equals31, tee: tee2 } = Predicate;
  var { getElementDescendants: getElementDescendants43 } = Query3;
  var rule_default64 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r53",
    requirements: [BestPractice.of("headings-structured")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      const headings = getElementDescendants43(document2, Node4.flatTree).filter(and75(hasRole24(device, "heading"), isIncludedInTheAccessibilityTree23(device)));
      return {
        applicability() {
          return headings.skip(1);
        },
        expectations(target) {
          const previousHeading = headings.takeUntil(equals31(target)).last().getUnsafe();
          let previousLevel = -1;
          let currentLevel = -1;
          return {
            1: expectation(hasHeadingLevel2(device, tee2((currentLevel2) => hasHeadingLevel2(device, tee2((previousLevel2) => previousLevel2 >= currentLevel2 - 1, (p) => previousLevel = p))(previousHeading), (c) => currentLevel = c))(target), () => Outcomes56.IsStructured(previousHeading, currentLevel, previousLevel), () => Outcomes56.IsNotStructured(previousHeading, currentLevel, previousLevel))
          };
        }
      };
    }
  });
  var Outcomes56;
  (function(Outcomes87) {
    Outcomes87.IsStructured = (previousHeading, currentLevel, previousLevel) => Ok.of(WithOtherHeading.of(`The heading is correctly ordered`, Option.of(previousHeading), currentLevel, previousLevel, "previous"));
    Outcomes87.IsNotStructured = (previousHeading, currentLevel, previousLevel) => Err.of(WithOtherHeading.of(`The heading skips one or more levels`, Option.of(previousHeading), currentLevel, previousLevel, "previous"));
  })(Outcomes56 || (Outcomes56 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r54/rule.js
  var { isIncludedInTheAccessibilityTree: isIncludedInTheAccessibilityTree24 } = DOM;
  var { and: and76 } = Predicate;
  var { getElementDescendants: getElementDescendants44 } = Query3;
  var rule_default65 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r54",
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return getElementDescendants44(document2, Node4.fullTree).filter(and76(isIncludedInTheAccessibilityTree24(device), (element) => Node5.from(element, device).attribute("aria-live").some((attribute) => attribute.value === "assertive"), (element) => !getElementDescendants44(element, Node4.fullTree).isEmpty()));
        },
        expectations(target) {
          return {
            1: expectation(Node5.from(target, device).attribute("aria-atomic").some((attribute) => attribute.value.toLowerCase() === "true"), () => Outcomes57.IsAtomic, () => Outcomes57.IsNotAtomic)
          };
        }
      };
    }
  });
  var Outcomes57;
  (function(Outcomes87) {
    Outcomes87.IsAtomic = Ok.of(Diagnostic.of("The assertive region is atomic"));
    Outcomes87.IsNotAtomic = Err.of(Diagnostic.of("The assertive region is not atomic"));
  })(Outcomes57 || (Outcomes57 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r57/rule.js
  var { hasIncorrectRoleWithoutName: hasIncorrectRoleWithoutName5, hasRole: hasRole25, isIncludedInTheAccessibilityTree: isIncludedInTheAccessibilityTree25 } = DOM;
  var { isElement: isElement50 } = Element;
  var { not: not45, or: or35, property: property12, test: test34 } = Predicate;
  var { and: and77 } = Refinement;
  var { isTabbable: isTabbable5 } = Style;
  var { isText: isText10 } = Text;
  var { getElementDescendants: getElementDescendants45 } = Query3;
  var rule_default66 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r57",
    requirements: [
      ARIA.of("https://www.w3.org/WAI/ARIA/apg/practices/landmark-regions/#generalprinciplesoflandmarkdesign")
    ],
    tags: [Scope.Page, Stability.Stable],
    evaluate({ document: document2, device }) {
      const firstTabbable = document2.tabOrder().filter(isTabbable5(device)).first();
      return {
        *applicability() {
          if (getElementDescendants45(document2, Node4.fullTree).some(and77(
            hasRole25(device, (role) => role.isLandmark()),
            // Circumventing https://github.com/Siteimprove/alfa/issues/298
            not45(hasIncorrectRoleWithoutName5(device))
          ))) {
            yield* document2.descendants(Node4.fullTree).filter(isText10).filter(and77(property12("data", not45(String2.isWhitespace)), isIncludedInTheAccessibilityTree25(device)));
          }
        },
        expectations(target) {
          const role = Node5.from(target, device).ancestors().find(or35(
            // landmark
            and77(
              (ancestor) => ancestor.role.some((role2) => role2.isLandmark()),
              // Circumventing https://github.com/Siteimprove/alfa/issues/298
              // by discarding the "landmark" ancestor if the role is incorrect
              (ancestor) => test34(and77(isElement50, not45(hasIncorrectRoleWithoutName5(device))), ancestor.node)
            ),
            // dialog
            (ancestor) => ancestor.role.some((role2) => role2.is("dialog"))
          )).flatMap((ancestor) => ancestor.role);
          return {
            1: expectation(role.some((role2) => role2.isLandmark()), () => Outcomes58.IsIncludedInLandmark, () => expectation(role.some((role2) => role2.is("dialog")), () => Outcomes58.IsIncludedInDialog, () => expectation(firstTabbable.some((element) => element.isInclusiveAncestorOf(target, Node4.flatTree)), () => Outcomes58.IsIncludedInFirstFocusableElement, () => Outcomes58.IsNotIncludedInLandmark)))
          };
        }
      };
    }
  });
  var Outcomes58;
  (function(Outcomes87) {
    Outcomes87.IsIncludedInLandmark = Ok.of(Diagnostic.of(`The text is included in a landmark region`));
    Outcomes87.IsIncludedInDialog = Ok.of(Diagnostic.of(`The text is included in a dialog`));
    Outcomes87.IsIncludedInFirstFocusableElement = Ok.of(Diagnostic.of(`The text is included in the first focusable element`));
    Outcomes87.IsNotIncludedInLandmark = Err.of(Diagnostic.of(`The text is not included in a landmark region`));
  })(Outcomes58 || (Outcomes58 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r59/rule.js
  var { hasRole: hasRole26 } = DOM;
  var { hasNamespace: hasNamespace37 } = Element;
  var { and: and78 } = Predicate;
  var { getElementDescendants: getElementDescendants46 } = Query3;
  var rule_default67 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r59",
    requirements: [BestPractice.of("document-has-headings")],
    tags: [Scope.Page, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return withDocumentElement(document2);
        },
        expectations(target) {
          const hasHeadings = getElementDescendants46(target, Node4.flatTree).some(and78(hasNamespace37(Namespace.HTML), hasRole26(device, "heading")));
          return {
            1: expectation(hasHeadings, () => Outcomes59.HasOneHeading, () => Outcomes59.HasNoHeadings)
          };
        }
      };
    }
  });
  var Outcomes59;
  (function(Outcomes87) {
    Outcomes87.HasOneHeading = Ok.of(Diagnostic.of(`The document has at least one heading element`));
    Outcomes87.HasNoHeadings = Err.of(Diagnostic.of(`The document does not have a heading element`));
  })(Outcomes59 || (Outcomes59 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r60/rule.js
  var { hasNonEmptyAccessibleName: hasNonEmptyAccessibleName14, hasRole: hasRole27, isIncludedInTheAccessibilityTree: isIncludedInTheAccessibilityTree26 } = DOM;
  var { isElement: isElement51, hasNamespace: hasNamespace38 } = Element;
  var { and: and79 } = Refinement;
  var rule_default68 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r60",
    requirements: [BestPractice.of("group-has-name")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          let groups = Map2.empty();
          function visit3(node, group) {
            if (isElement51(node)) {
              group.forEach((group2) => {
                if (and79(isIncludedInTheAccessibilityTree26(device), isFormInput(device))(node)) {
                  groups = groups.set(group2, groups.get(group2).getOr(0) + 1);
                }
              });
              if (and79(hasNamespace38(Namespace.HTML), hasRole27(device, (role) => role.is("group")))(node)) {
                group = Option.of(node);
              }
            }
            for (const child of node.children(Node4.fullTree)) {
              visit3(child, group);
            }
          }
          visit3(document2, None);
          return groups.filter((n) => n >= 2).keys();
        },
        expectations(target) {
          const role = Node5.from(target, device).role.getUnsafe().name;
          return {
            1: expectation(hasNonEmptyAccessibleName14(device)(target), () => Outcomes60.HasAccessibleName(role), () => Outcomes60.HasNoAccessibleName(role))
          };
        }
      };
    }
  });
  var Outcomes60;
  (function(Outcomes87) {
    Outcomes87.HasAccessibleName = (role) => Ok.of(WithRole.of(`The grouping element has an accessible name`, role));
    Outcomes87.HasNoAccessibleName = (role) => Err.of(WithRole.of(`The grouping element has an accessible name`, role));
  })(Outcomes60 || (Outcomes60 = {}));
  function isFormInput(device) {
    return hasRole27(device, "checkbox", "combobox", "listbox", "menuitemcheckbox", "menuitemradio", "radio", "searchbox", "slider", "spinbutton", "switch", "textbox");
  }

  // node_modules/@siteimprove/alfa-rules/dist/sia-r62/rule.js
  var { hasRole: hasRole28 } = DOM;
  var { isElement: isElement52 } = Element;
  var { or: or36, not: not46, test: test35, tee: tee3 } = Predicate;
  var { and: and80 } = Refinement;
  var { hasBorder: hasBorder2, hasBoxShadow: hasBoxShadow2, hasComputedStyle: hasComputedStyle7, hasOutline: hasOutline2, hasTextDecoration: hasTextDecoration2, isVisible: isVisible11 } = Style;
  var { isText: isText11 } = Text;
  var distinguishingProperties = Map2.empty();
  var rule_default69 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r62",
    requirements: [Criterion.of("1.4.1")],
    tags: [Scope.Component, Stability.Stable, Version.of(2)],
    evaluate({ device, document: document2 }) {
      let containers = Map2.empty();
      return {
        applicability() {
          let linkText = Map2.empty();
          let nonLinkText = Map2.empty();
          gather(document2, None, None);
          return getApplicableLinks();
          function gather(node, container, link) {
            const isLink2 = hasRole28(device, (role) => role.is("link"));
            const isParagraph = hasRole28(device, "paragraph");
            if (isElement52(node)) {
              if (container.isSome() && isLink2(node)) {
                containers = containers.set(node, container.get());
                link = Option.of(node);
              }
              if (isParagraph(node)) {
                if (test35(hasNonLinkText(device), node)) {
                  container = Option.of(node);
                } else {
                  container = None;
                }
              }
            } else {
              const isTextNode = test35(and80(isText11, isVisible11(device)), node);
              const parent = node.parent().filter(isElement52);
              if (isTextNode && container.isSome() && parent.isSome()) {
                if (link.isSome()) {
                  linkText = linkText.set(link.get(), linkText.get(link.get()).getOr(Set2.empty()).add(parent.get()));
                } else {
                  nonLinkText = nonLinkText.set(container.get(), nonLinkText.get(container.get()).getOr(Set2.empty()).add(parent.get()));
                }
              }
            }
            for (const child of node.children(Node4.fullTree)) {
              gather(child, container, link);
            }
          }
          function* getApplicableLinks() {
            const hasDifferentForeground = (link, container) => getForeground(link, device).none((linkColors) => (
              // If the link has a foreground with the alpha channel less than 1 and background gradient color
              // then the rule is applicable as we can't tell for sure if it ever has the same foreground with a link
              // that might have the same foreground and gradient background, but with different gradient type or spread
              linkColors.length === 1 && getForeground(container, device).some((containerColors) => (
                // Similarly to the link, we assume the rule is applicable if the container has more than one foreground color
                containerColors.length === 1 && linkColors[0].equals(containerColors[0])
              ))
            ));
            for (const [link, linkTexts] of linkText) {
              const nonLinkTexts = containers.get(link).flatMap((container) => nonLinkText.get(container)).getOrElse(Set2.empty);
              if (linkTexts.some((linkElement) => nonLinkTexts.some((nonLinkElement) => hasDifferentForeground(linkElement, nonLinkElement)))) {
                yield link;
              }
            }
          }
        },
        expectations(target) {
          const nonLinkElements = containers.get(target).map((node) => node.inclusiveDescendants(Node4.fullTree).filter(and80(isElement52, hasNonLinkText(device)))).getOrElse(Sequence.empty);
          const linkElements = target.inclusiveDescendants(Node4.fullTree).filter(isElement52).concat(target.ancestors(Node4.fullTree).takeWhile(and80(isElement52, not46(hasNonLinkText(device)))));
          const hasDistinguishingStyle = (context = Context.empty()) => Set2.from(linkElements.map((link) => {
            const hasDistinguishableStyle = nonLinkElements.some((container) => Distinguishable.isDistinguishable(container, target, device, context).map((isDistinguishable) => isDistinguishable(link)).some((distinguishable) => distinguishable));
            const distinguishableContrast = Set2.from(nonLinkElements.flatMap((container) => Sequence.from(Distinguishable.getPairwiseContrast(container, link, device, context))));
            const properties = distinguishingProperties.get(context).flatMap((elementMap) => elementMap.get(link)).getOrElse(() => List.empty());
            return hasDistinguishableStyle ? Ok.of(ElementDistinguishable.from(link, device, target, context, properties, distinguishableContrast)) : Err.of(ElementDistinguishable.from(link, device, target, context, properties, distinguishableContrast));
          })).toArray().sort((a, b) => b.isOk() ? 1 : -1);
          const isDefaultDistinguishable = hasDistinguishingStyle();
          const isHoverDistinguishable = hasDistinguishingStyle(Context.hover(target));
          const isFocusDistinguishable = hasDistinguishingStyle(Context.focus(target));
          return {
            1: expectation(
              // If at least one link element is good, this is enough. The sorting
              // guarantees it is first in the array.
              isDefaultDistinguishable[0].isOk() && isHoverDistinguishable[0].isOk() && isFocusDistinguishable[0].isOk(),
              () => Outcomes61.IsDistinguishable(isDefaultDistinguishable, isHoverDistinguishable, isFocusDistinguishable),
              () => Outcomes61.IsNotDistinguishable(isDefaultDistinguishable, isHoverDistinguishable, isFocusDistinguishable)
            )
          };
        }
      };
    }
  });
  var Outcomes61;
  (function(Outcomes87) {
    Outcomes87.IsDistinguishable = (defaultStyles, hoverStyles, focusStyles) => Ok.of(DistinguishingStyles.of(`The link is distinguishable from the surrounding text`, defaultStyles, hoverStyles, focusStyles));
    Outcomes87.IsNotDistinguishable = (defaultStyles, hoverStyles, focusStyles) => Err.of(DistinguishingStyles.of(`The link is not distinguishable from the surrounding text`, defaultStyles, hoverStyles, focusStyles));
  })(Outcomes61 || (Outcomes61 = {}));
  var hasNonLinkTextCache = Cache2.empty();
  function hasNonLinkText(device) {
    return function hasNonLinkText2(element) {
      return hasNonLinkTextCache.get(element, () => {
        if (element.inclusiveAncestors(Node4.flatTree).some(and80(isElement52, hasRole28(device, (role) => role.is("link"))))) {
          return false;
        }
        const children = element.children(Node4.flatTree);
        if (children.some(and80(isText11, and80(isVisible11(device), (text) => !String2.isWhitespace(text.data, false))))) {
          return true;
        }
        return children.filter(isElement52).reject(hasRole28(device, (role) => role.is("link"))).reject(hasRole28(device, "paragraph")).some(hasNonLinkText2);
      });
    };
  }
  var Distinguishable;
  (function(Distinguishable2) {
    function isDistinguishable(container, target, device, context = Context.empty()) {
      let predicates = [
        // Things like text decoration and backgrounds risk blending with the
        // container element. We therefore need to check if these can be distinguished
        // from what the container element might itself set.
        ["background", hasDistinguishableBackground(container, device, context)],
        ["contrast", hasDistinguishableContrast(container, device, context)],
        ["font", hasDistinguishableFont(container, device, context)],
        [
          "text-decoration",
          hasDistinguishableTextDecoration(container, device, context)
        ],
        [
          "vertical-align",
          hasDistinguishableVerticalAlign(container, device, context)
        ],
        // We consider the mere presence of borders, box-shadows or outlines on the element as
        // distinguishable features. There's of course a risk of these blending with
        // other features of the container element, such as its background, but this
        // should hopefully not happen (too often) in practice. When it does, we
        // risk false negatives.
        ["border", hasBorder2(device, context)],
        [
          "box-shadow",
          hasBoxShadow2(device, context)
          //Checks for color != transparent and spread => 0
        ],
        ["outline", hasOutline2(device, context)]
      ];
      if (context.isHovered(target)) {
        predicates = [
          ...predicates,
          ["cursor", hasDistinguishableCursor(container, device, context)]
        ];
      }
      return predicates.map(([name, predicate]) => tee3(predicate, (link, result) => {
        if (result) {
          const linkToProperties = distinguishingProperties.get(context).getOr(Map2.empty());
          const properties = linkToProperties.get(link).getOr(List.empty()).append(name);
          distinguishingProperties = distinguishingProperties.set(context, linkToProperties.set(link, properties));
        }
      }));
    }
    Distinguishable2.isDistinguishable = isDistinguishable;
    function hasDistinguishableTextDecoration(container, device, context) {
      return (element) => test35(not46(hasTextDecoration2(device, context)), container) && test35(hasTextDecoration2(device, context), element);
    }
    function hasDistinguishableBackground(container, device, context) {
      const colorReference = Style.from(container, device, context).computed("background-color").value;
      const imageReference = Style.from(container, device, context).computed("background-image").value;
      return (link) => {
        const color = Style.from(link, device, context).computed("background-color").value;
        const image = Style.from(link, device, context).computed("background-image").value;
        const hasBackground = !(Keyword.isKeyword(image.values[0]) && image.values[0].equals(Keyword.of("none")) && Color.isTransparent(color));
        const hasDifferentBackgroundFromContainer = !(color.equals(colorReference) && image.equals(imageReference));
        return hasDifferentBackgroundFromContainer && hasBackground;
      };
    }
    function getPairwiseContrast(container, link, device, context = Context.empty()) {
      return getForeground(container, device, context).map((containerColors) => [
        ...Array2.flatMap(containerColors, (containerColor) => getForeground(link, device, context).map((linkColors) => Array2.map(linkColors, (linkColor) => Contrast.Pairing.of(["container", containerColor], ["link", linkColor], contrast(containerColor, linkColor)))).getOr([]))
      ]).getOr([]);
    }
    Distinguishable2.getPairwiseContrast = getPairwiseContrast;
    function hasDistinguishableContrast(container, device, context = Context.empty()) {
      return (link) => {
        for (const contrastPairing of getPairwiseContrast(container, link, device, context)) {
          if (contrastPairing.contrast >= 3) {
            return true;
          }
        }
        return false;
      };
    }
    function hasDistinguishableFont(container, device, context) {
      const style = Style.from(container, device, context);
      const referenceWeight = style.computed("font-weight").value;
      const referenceFamily = Option.from(style.computed("font-family").value.values[0]);
      return or36(hasComputedStyle7("font-weight", not46((weight) => weight.equals(referenceWeight)), device, context), hasComputedStyle7("font-family", not46((family) => Option.from(family.values[0]).equals(referenceFamily)), device, context));
    }
    function hasDistinguishableVerticalAlign(container, device, context) {
      const reference = Style.from(container, device, context).computed("vertical-align").value;
      return hasComputedStyle7("vertical-align", not46((alignment) => alignment.equals(reference)), device, context);
    }
    function hasDistinguishableCursor(container, device, context) {
      function getFirstCursor(style) {
        return style.values[0].values.length !== 0 ? style.values[0].values[0] : style.values[1];
      }
      const containerCursorStyle = Style.from(container, device, context).computed("cursor").value;
      const reference = getFirstCursor(containerCursorStyle);
      return hasComputedStyle7("cursor", not46((cursor) => getFirstCursor(cursor).equals(reference)), device, context);
    }
  })(Distinguishable || (Distinguishable = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r63/rule.js
  var { hasNonEmptyAccessibleName: hasNonEmptyAccessibleName15, isIncludedInTheAccessibilityTree: isIncludedInTheAccessibilityTree27 } = DOM;
  var { hasName: hasName40, hasNamespace: hasNamespace39 } = Element;
  var { and: and81 } = Predicate;
  var { getElementDescendants: getElementDescendants47 } = Query3;
  var rule_default70 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r63",
    requirements: [Criterion.of("1.1.1")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return getElementDescendants47(document2, Node4.fullTree).filter(and81(hasNamespace39(Namespace.HTML), hasName40("object"), isIncludedInTheAccessibilityTree27(device), embedsMedia));
        },
        expectations(target) {
          return {
            1: expectation(hasNonEmptyAccessibleName15(device)(target), () => Outcomes62.HasName, () => Outcomes62.HasNoName)
          };
        }
      };
    }
  });
  var Outcomes62;
  (function(Outcomes87) {
    Outcomes87.HasName = Ok.of(Diagnostic.of(`The \`<object>\` element has an accessible name`));
    Outcomes87.HasNoName = Err.of(Diagnostic.of(`The \`<object>\` element does not have an accessible name`));
  })(Outcomes62 || (Outcomes62 = {}));
  function embedsMedia(element) {
    return element.attribute("type").map((type) => MediaMIMEType.includes(type.value.split("/")[0])).getOrElse(() => element.attribute("data").some((data) => MediaFileExtension.includes(data.value.split(".").splice(-1)[0])));
  }
  var MediaMIMEType = ["audio", "image", "video"];
  var MediaFileExtension = [
    "aac",
    "avif",
    "avi",
    "bmp",
    "gif",
    "ico",
    "jpeg",
    "jpg",
    "mid",
    "midi",
    "mp3",
    "mp4",
    "mpeg",
    "oga",
    "ogv",
    "opus",
    "png",
    "svg",
    "tif",
    "tiff",
    "ts",
    "wav",
    "weba",
    "webm",
    "webp",
    "3gp",
    "3GPP",
    "3g2",
    "3GPP2"
  ];

  // node_modules/@siteimprove/alfa-rules/dist/sia-r64/rule.js
  var { hasNonEmptyAccessibleName: hasNonEmptyAccessibleName16, hasRole: hasRole29, isIncludedInTheAccessibilityTree: isIncludedInTheAccessibilityTree28 } = DOM;
  var { hasNamespace: hasNamespace40 } = Element;
  var { and: and82 } = Predicate;
  var { getElementDescendants: getElementDescendants48 } = Query3;
  var rule_default71 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r64",
    requirements: [Criterion.of("1.3.1"), Technique.of("H42")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return getElementDescendants48(document2, Node4.fullTree).filter(and82(hasNamespace40(Namespace.HTML), hasRole29(device, "heading"), isIncludedInTheAccessibilityTree28(device)));
        },
        expectations(target) {
          return {
            1: expectation(hasNonEmptyAccessibleName16(device)(target), () => Outcomes63.HasAccessibleName, () => Outcomes63.HasNoAccessibleName)
          };
        }
      };
    }
  });
  var Outcomes63;
  (function(Outcomes87) {
    Outcomes87.HasAccessibleName = Ok.of(Diagnostic.of(`The heading has an accessible name`));
    Outcomes87.HasNoAccessibleName = Err.of(Diagnostic.of(`The heading does not have an accessible name`));
  })(Outcomes63 || (Outcomes63 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r65/rule.js
  var { isElement: isElement53 } = Element;
  var { isKeyword } = Keyword;
  var { or: or37, test: test36, xor, not: not47 } = Predicate;
  var { and: and83 } = Refinement;
  var { hasBorder: hasBorder3, hasBoxShadow: hasBoxShadow3, hasOutline: hasOutline3, hasTextDecoration: hasTextDecoration3, isTabbable: isTabbable6 } = Style;
  var rule_default72 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r65",
    requirements: [Criterion.of("2.4.7")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      const tabbables = document2.tabOrder().filter(isTabbable6(device));
      const matchingTargets = tabbables.flatMap((tabbable) => tabbable.classes).groupBy((c) => c).map((list) => list.size);
      const matchingNonTargets = document2.descendants().filter(and83(isElement53, not47((element) => tabbables.includes(element)))).flatMap((nonTarget) => nonTarget.classes).groupBy((c) => c).map((list) => list.size);
      return {
        applicability() {
          return tabbables;
        },
        expectations(target) {
          const askFocusIndicator = Question2.of("has-focus-indicator", target);
          return {
            1: askFocusIndicator.answerIf(hasFocusIndicator(device)(target), true).map((hasFocusIndicator2) => expectation(hasFocusIndicator2, () => Outcomes64.HasFocusIndicator(matchingTargets, matchingNonTargets), () => Outcomes64.HasNoFocusIndicator(matchingTargets, matchingNonTargets)))
          };
        }
      };
    }
  });
  var Outcomes64;
  (function(Outcomes87) {
    Outcomes87.HasFocusIndicator = (matchingTargets, matchingNonTargets) => Ok.of(MatchingClasses.of(`The element has a visible focus indicator`, matchingTargets, matchingNonTargets));
    Outcomes87.HasNoFocusIndicator = (matchingTargets, matchingNonTargets) => Err.of(MatchingClasses.of(`The element does not have a visible focus indicator`, matchingTargets, matchingNonTargets));
  })(Outcomes64 || (Outcomes64 = {}));
  function hasFocusIndicator(device) {
    return (element) => {
      const withFocus = Context.focus(element);
      return element.inclusiveDescendants(Node4.flatTree).concat(element.ancestors(Node4.flatTree)).filter(isElement53).some(or37(
        // For these properties, we assume that the difference is to set it or remove it, not to make small changes on it.
        xor(hasOutline3(device), hasOutline3(device, withFocus)),
        xor(hasTextDecoration3(device), hasTextDecoration3(device, withFocus)),
        xor(hasBoxShadow3(device), hasBoxShadow3(device, withFocus)),
        // These properties are essentially always set, so any difference in the color is good enough.
        hasDifferentColors(device, withFocus),
        hasDifferentBackgroundColors(device, withFocus),
        // Any difference in border is accepted
        hasDifferentBorder(device, withFocus)
      ));
    };
  }
  function hasDifferentColors(device, context1 = Context.empty(), context2 = Context.empty()) {
    return function hasDifferentColors2(element) {
      const color1 = Style.from(element, device, context1).computed("color");
      const color2 = Style.from(element, device, context2).computed("color");
      if (isKeyword(color1) || isKeyword(color2)) {
        return false;
      }
      return !color1.value.equals(color2.value);
    };
  }
  function hasDifferentBackgroundColors(device, context1 = Context.empty(), context2 = Context.empty()) {
    return function hasDifferentBackgroundColors2(element) {
      const color1 = Style.from(element, device, context1).computed("background-color");
      const color2 = Style.from(element, device, context2).computed("background-color");
      if (isKeyword(color1) || isKeyword(color2)) {
        return false;
      }
      return !color1.value.equals(color2.value);
    };
  }
  function hasDifferentBorder(device, context1 = Context.empty(), context2 = Context.empty()) {
    return function hasDifferentBorder2(element) {
      const style1 = Style.from(element, device, context1);
      const style2 = Style.from(element, device, context2);
      const hasBorder1 = test36(hasBorder3(device, context1), element);
      const hasBorder22 = test36(hasBorder3(device, context2), element);
      if (hasBorder1 !== hasBorder22) {
        return true;
      }
      if (!hasBorder1 && !hasBorder22) {
        return false;
      }
      for (const side of ["top", "right", "bottom", "left"]) {
        for (const effect of ["color", "style", "width"]) {
          const longhand2 = `border-${side}-${effect}`;
          const border1 = style1.computed(longhand2);
          const border2 = style2.computed(longhand2);
          if (!(effect === "color" && (isKeyword(border1) || isKeyword(border2)) || Equatable.equals(border1.value, border2.value))) {
            return true;
          }
        }
      }
      return false;
    };
  }

  // node_modules/@siteimprove/alfa-rules/dist/sia-r66/rule.js
  var rule_default73 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r66",
    requirements: [Criterion.of("1.4.6")],
    tags: [Scope.Component, Stability.Stable, Version.of(2)],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return nonDisabledTexts(document2, device);
        },
        expectations(target) {
          return hasSufficientContrast(target, device, 4.5, 7);
        }
      };
    }
  });

  // node_modules/@siteimprove/alfa-rules/dist/sia-r67/rule.js
  var { isMarkedDecorative: isMarkedDecorative3 } = DOM;
  var { hasName: hasName41, hasNamespace: hasNamespace41 } = Element;
  var { and: and84, or: or38, not: not48 } = Predicate;
  var { getElementDescendants: getElementDescendants49 } = Query3;
  var rule_default74 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r67",
    requirements: [Criterion.of("1.1.1")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return getElementDescendants49(document2, Node4.fullTree).filter(and84(or38(and84(hasNamespace41(Namespace.HTML), hasName41("img")), and84(hasNamespace41(Namespace.SVG), hasName41("svg"))), isMarkedDecorative3));
        },
        expectations(target) {
          return {
            1: expectation(Node5.from(target, device).role.some(not48((role) => role.isPresentational())), () => Outcomes65.IsExposed, () => Outcomes65.IsNotExposed)
          };
        }
      };
    }
  });
  var Outcomes65;
  (function(Outcomes87) {
    Outcomes87.IsNotExposed = Ok.of(Diagnostic.of(`The element is marked as decorative and is not exposed`));
    Outcomes87.IsExposed = Err.of(Diagnostic.of(`The element is marked as decorative but is exposed`));
  })(Outcomes65 || (Outcomes65 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r68/rule.js
  var { hasRole: hasRole30, isIncludedInTheAccessibilityTree: isIncludedInTheAccessibilityTree29 } = DOM;
  var { hasAttribute: hasAttribute24, hasNamespace: hasNamespace42, isElement: isElement54 } = Element;
  var { and: and85, equals: equals32 } = Refinement;
  var rule_default75 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r68",
    requirements: [Criterion.of("1.3.1")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return visit2(document2, device);
        },
        expectations(target) {
          return {
            1: expectation(hasRequiredChildren(device)(target), () => Outcomes66.HasCorrectOwnedElements(WithRole.getRoleName(target, device)), () => Outcomes66.HasIncorrectOwnedElements(WithRole.getRoleName(target, device)))
          };
        }
      };
    }
  });
  var Outcomes66;
  (function(Outcomes87) {
    Outcomes87.HasCorrectOwnedElements = (role) => Ok.of(WithRole.of(`The element owns elements as required by its semantic role`, role));
    Outcomes87.HasIncorrectOwnedElements = (role) => Err.of(WithRole.of(`The element owns no elements as required by its semantic role`, role));
  })(Outcomes66 || (Outcomes66 = {}));
  function hasRequiredChildren(device) {
    return (element) => {
      const node = Node5.from(element, device);
      return node.role.filter((role) => role.hasRequiredChildren()).every((role) => node.children().filter((node2) => isElement54(node2.node)).some(isRequiredChild(role.requiredChildren)));
    };
  }
  function isRequiredChild(requiredChildren) {
    return (node) => requiredChildren.some((roles2) => isRequiredChild2(roles2)(node));
    function isRequiredChild2(requiredChildren2) {
      return (node) => {
        const [role, ...rest] = requiredChildren2;
        if (node.role.some(Role.hasName(role))) {
          return rest.length === 0 || node.children().filter((node2) => isElement54(node2.node)).some(isRequiredChild2(rest));
        }
        return false;
      };
    }
  }
  function* visit2(node, device) {
    if (and85(isElement54, hasAttribute24("aria-busy", equals32("true")))(node)) {
      return;
    }
    if (and85(isElement54, and85(hasNamespace42(Namespace.HTML, Namespace.SVG), isIncludedInTheAccessibilityTree29(device), hasRole30(device, (role) => role.hasRequiredChildren())))(node)) {
      yield node;
    }
    for (const child of node.children(Node4.fullTree)) {
      yield* visit2(child, device);
    }
  }

  // node_modules/@siteimprove/alfa-rules/dist/sia-r69/rule.js
  var rule_default76 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r69",
    requirements: [Criterion.of("1.4.3"), Criterion.of("1.4.6")],
    tags: [Scope.Component, Stability.Stable, Version.of(2)],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return nonDisabledTexts(document2, device).reject(isOnlyPunctuation);
        },
        expectations(target) {
          return hasSufficientContrast(target, device, 3, 4.5);
        }
      };
    }
  });
  function isOnlyPunctuation(text) {
    return /^[\p{P}\p{S}\p{Cf}]+$/gu.test(text.data);
  }

  // node_modules/@siteimprove/alfa-rules/dist/sia-r70/rule.js
  var { hasName: hasName42, hasNamespace: hasNamespace43 } = Element;
  var { and: and86 } = Predicate;
  var { isRendered: isRendered4 } = Style;
  var { getElementDescendants: getElementDescendants50 } = Query3;
  var isDeprecated = hasName42("acronym", "applet", "basefont", "bgsound", "big", "blink", "center", "content", "dir", "font", "frame", "frameset", "image", "keygen", "marquee", "menuitem", "nobr", "noembed", "noframes", "plaintext", "rb", "rtc", "shadow", "spacer", "strike", "tt", "xmp");
  var rule_default77 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r70",
    requirements: [BestPractice.of("no-deprecated-elements")],
    tags: [Scope.Page, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return withDocumentElement(document2);
        },
        expectations(target) {
          const deprecatedElements = getElementDescendants50(target, Node4.fullTree).filter(and86(hasNamespace43(Namespace.HTML), isDeprecated, isRendered4(device)));
          return {
            1: expectation(deprecatedElements.isEmpty(), () => Outcomes67.HasNoDeprecatedElement, () => Outcomes67.HasDeprecatedElements(deprecatedElements))
          };
        }
      };
    }
  });
  var Outcomes67;
  (function(Outcomes87) {
    Outcomes87.HasNoDeprecatedElement = Ok.of(Diagnostic.of(`The document doesn't contain any deprecated elements`));
    Outcomes87.HasDeprecatedElements = (errors) => Err.of(WithBadElements.of(`The document contains deprecated elements`, errors));
  })(Outcomes67 || (Outcomes67 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r71/rule.js
  var { hasRole: hasRole31 } = DOM;
  var { and: and87, test: test37 } = Predicate;
  var { isVisible: isVisible12, hasComputedStyle: hasComputedStyle8 } = Style;
  var { getElementDescendants: getElementDescendants51 } = Query3;
  var rule_default78 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r71",
    requirements: [Criterion.of("1.4.8")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return getElementDescendants51(document2, Node4.fullTree).filter(and87(hasRole31(device, "paragraph"), isVisible12(device)));
        },
        expectations(target) {
          return {
            1: expectation(test37(isNotJustified(device), target), () => Outcomes68.IsNotJustified, () => Outcomes68.IsJustified)
          };
        }
      };
    }
  });
  var Outcomes68;
  (function(Outcomes87) {
    Outcomes87.IsNotJustified = Ok.of(Diagnostic.of(`The text of the paragraph is not justified`));
    Outcomes87.IsJustified = Err.of(Diagnostic.of(`The text of the paragraph is justified`));
  })(Outcomes68 || (Outcomes68 = {}));
  function isNotJustified(device) {
    return hasComputedStyle8("text-align", (align) => align.value !== "justify", device);
  }

  // node_modules/@siteimprove/alfa-rules/dist/sia-r72/rule.js
  var { hasRole: hasRole32 } = DOM;
  var { and: and88, test: test38 } = Predicate;
  var { isVisible: isVisible13, hasComputedStyle: hasComputedStyle9 } = Style;
  var { getElementDescendants: getElementDescendants52 } = Query3;
  var rule_default79 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r72",
    requirements: [BestPractice.of("paragraph-not-uppercase")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return getElementDescendants52(document2, Node4.fullTree).filter(and88(hasRole32(device, "paragraph"), isVisible13(device)));
        },
        expectations(target) {
          return {
            1: expectation(test38(isNotUpperCased(device), target), () => Outcomes69.IsNotUppercased, () => Outcomes69.IsUppercased)
          };
        }
      };
    }
  });
  var Outcomes69;
  (function(Outcomes87) {
    Outcomes87.IsNotUppercased = Ok.of(Diagnostic.of(`The text of the paragraph is not uppercased`));
    Outcomes87.IsUppercased = Err.of(Diagnostic.of(`The text of the paragraph is uppercased`));
  })(Outcomes69 || (Outcomes69 = {}));
  function isNotUpperCased(device) {
    return hasComputedStyle9("text-transform", (transform) => transform.value !== "uppercase", device);
  }

  // node_modules/@siteimprove/alfa-rules/dist/sia-r73/rule.js
  var { hasRole: hasRole33 } = DOM;
  var { and: and89 } = Predicate;
  var { isVisible: isVisible14 } = Style;
  var { getElementDescendants: getElementDescendants53 } = Query3;
  var rule_default80 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r73",
    requirements: [Criterion.of("1.4.8")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return getElementDescendants53(document2, Node4.fullTree).filter(and89(hasRole33(device, "paragraph"), isVisible14(device)));
        },
        expectations(target) {
          const style = Style.from(target, device);
          const { value: lineHeight } = style.computed("line-height");
          let outcome = Outcomes70.IsNormal;
          switch (lineHeight.type) {
            case "number":
              outcome = lineHeight.value >= 1.5 ? Outcomes70.IsSufficient : Outcomes70.IsInsufficient;
              break;
            case "length": {
              const { value: fontSize } = style.computed("font-size");
              outcome = lineHeight.value / fontSize.value >= 1.5 ? Outcomes70.IsSufficient : Outcomes70.IsInsufficient;
            }
          }
          return {
            1: Option.of(outcome)
          };
        }
      };
    }
  });
  var Outcomes70;
  (function(Outcomes87) {
    Outcomes87.IsSufficient = Ok.of(Diagnostic.of(`The line height of the paragraph is at least 1.5`));
    Outcomes87.IsInsufficient = Err.of(Diagnostic.of(`The line height of the paragraph is less than 1.5`));
    Outcomes87.IsNormal = Err.of(Diagnostic.of(`The line height of the paragraph is \`normal\` which will result in
      a line height of less than 1.5`));
  })(Outcomes70 || (Outcomes70 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r74/rule.js
  var { hasRole: hasRole34 } = DOM;
  var { and: and90, not: not49 } = Predicate;
  var { isVisible: isVisible15, hasCascadedStyle: hasCascadedStyle4 } = Style;
  var { getElementDescendants: getElementDescendants54 } = Query3;
  var rule_default81 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r74",
    requirements: [Criterion.of("1.4.8")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return getElementDescendants54(document2, Node4.fullTree).filter(and90(
            hasRole34(device, "paragraph"),
            Node4.hasTextContent(not49(String2.isWhitespace)),
            isVisible15(device),
            // If the font-size ultimately computes to size 0, the element is not
            // visible.
            hasCascadedStyle4("font-size", () => true, device)
          ));
        },
        expectations(target) {
          const { value: fontSize } = Style.from(target, device).cascaded("font-size").getUnsafe();
          return {
            1: expectation(
              // Keyword, percentage, number
              !Length2.isLength(fontSize) || // Calculated length
              fontSize.hasCalculation() || // Fixed length in relative units
              fontSize.isRelative(),
              () => Outcomes71.HasRelativeUnit,
              () => Outcomes71.HasAbsoluteUnit
            )
          };
        }
      };
    }
  });
  var Outcomes71;
  (function(Outcomes87) {
    Outcomes87.HasRelativeUnit = Ok.of(Diagnostic.of(`The font size is specified using a relative unit`));
    Outcomes87.HasAbsoluteUnit = Err.of(Diagnostic.of(`The font size is specified using an absolute unit`));
  })(Outcomes71 || (Outcomes71 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r76/rule.js
  var { hasRole: hasRole35, isIncludedInTheAccessibilityTree: isIncludedInTheAccessibilityTree30, isPerceivableForAll: isPerceivableForAll12 } = DOM;
  var { isElement: isElement55, hasName: hasName43, hasNamespace: hasNamespace44 } = Element;
  var { and: and91, test: test39 } = Refinement;
  var rule_default82 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r76",
    requirements: [Criterion.of("1.3.1")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return visit3(document2);
          function* visit3(node, collect = false) {
            if (test39(and91(isElement55, hasNamespace44(Namespace.HTML)), node)) {
              if (test39(hasName43("table"), node)) {
                collect = test39(isIncludedInTheAccessibilityTree30(device), node);
              }
              if (collect && test39(and91(hasName43("th"), isPerceivableForAll12(device)), node)) {
                yield node;
              }
            }
            for (const child of node.children(Node4.fullTree)) {
              yield* visit3(child, collect);
            }
          }
        },
        expectations(target) {
          return {
            1: expectation(test39(hasRole35(device, "columnheader", "rowheader"), target), () => Outcomes72.HasHeaderRole(WithRole.getRoleName(target, device)), () => Outcomes72.HasNoHeaderRole(WithRole.getRoleName(target, device)))
          };
        }
      };
    }
  });
  var Outcomes72;
  (function(Outcomes87) {
    Outcomes87.HasHeaderRole = (role) => Ok.of(WithRole.of(`The header element is a semantic header`, role));
    Outcomes87.HasNoHeaderRole = (role) => Err.of(WithRole.of(`The header element is not a semantic header`, role));
  })(Outcomes72 || (Outcomes72 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r77/rule.js
  var { hasRole: hasRole36, isIncludedInTheAccessibilityTree: isIncludedInTheAccessibilityTree31, isPerceivableForAll: isPerceivableForAll13 } = DOM;
  var { hasName: hasName44, hasNamespace: hasNamespace45 } = Element;
  var { and: and92 } = Predicate;
  var { getElementDescendants: getElementDescendants55 } = Query3;
  var rule_default83 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r77",
    requirements: [Criterion.of("1.3.1")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      let data = Map2.empty();
      return {
        *applicability() {
          const tables = getElementDescendants55(document2).filter(and92(hasNamespace45(Namespace.HTML), hasName44("table"), isIncludedInTheAccessibilityTree31(device)));
          for (const table of tables) {
            const model = Table.from(table);
            if (model.cells.find((cell) => cell.isHeader()).isNone()) {
              continue;
            }
            const dataCells = getElementDescendants55(table).filter(and92(hasNamespace45(Namespace.HTML), hasName44("td"), hasRole36(device, "cell", "gridcell"), isPerceivableForAll13(device)));
            for (const dataCell of dataCells) {
              for (const cell of model.cells.find((cell2) => cell2.element.equals(dataCell))) {
                data = data.set(dataCell, cell);
                yield dataCell;
              }
            }
          }
        },
        expectations(target) {
          const cell = data.get(target).getUnsafe();
          return {
            1: expectation(cell.headers.isEmpty(), () => Outcomes73.IsNotAssignedToHeaderCell, () => Outcomes73.IsAssignedToHeaderCell)
          };
        }
      };
    }
  });
  var Outcomes73;
  (function(Outcomes87) {
    Outcomes87.IsAssignedToHeaderCell = Ok.of(Diagnostic.of(`The cell is assigned to an header cell`));
    Outcomes87.IsNotAssignedToHeaderCell = Err.of(Diagnostic.of(`The cell is not assigned to any header cell`));
  })(Outcomes73 || (Outcomes73 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r78/rule.js
  var isText12 = Text.isText;
  var { hasHeadingLevel: hasHeadingLevel3, hasRole: hasRole37, isIncludedInTheAccessibilityTree: isIncludedInTheAccessibilityTree32 } = DOM;
  var { hasNamespace: hasNamespace46, isContent: isContent3, isElement: isElement56 } = Element;
  var { not: not50, tee: tee4 } = Predicate;
  var { and: and93 } = Refinement;
  var { getElementDescendants: getElementDescendants56 } = Query3;
  var rule_default84 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r78",
    requirements: [BestPractice.of("heading-has-content")],
    tags: [Scope.Page, Stability.Stable],
    evaluate({ device, document: document2 }) {
      let headings;
      return {
        applicability() {
          headings = document2.descendants(Node4.fullTree).filter(and93(isElement56, and93(
            hasNamespace46(Namespace.HTML),
            isIncludedInTheAccessibilityTree32(device),
            hasRole37(device, "heading"),
            // Headings containing a button is the ARIA pattern for accordions.
            // Headings containing a link is frequently misused instead.
            // Headings containing a link is also used for, e.g., list of news.
            not50((heading) => getElementDescendants56(heading).some(hasRole37(device, "button", "link")))
          )));
          return headings;
        },
        expectations(target) {
          const currentLevel = Node5.from(target, device).attribute("aria-level").map((level) => Number(level.value)).getOr(0);
          let nextLevel = -1;
          let end10 = false;
          const next = headings.skipUntil((heading) => heading.equals(target)).rest().find(hasHeadingLevel3(device, tee4((level) => level <= currentLevel, (level, isLower) => {
            if (isLower) {
              nextLevel = level;
            }
          }))).getOrElse(() => {
            end10 = true;
            return document2.descendants(Node4.fullTree).last().getUnsafe();
          });
          return {
            1: expectation(Node4.getNodesBetween(target, next, {
              includeFirst: false,
              // If this is the last heading (of this level or less), then the
              // last node of the document is acceptable content; otherwise, the
              // next heading (of this level or less) is not acceptable content.
              includeSecond: end10
            }).some(and93(isIncludedInTheAccessibilityTree32(device), isContent3(Node4.fullTree), not50(and93(isText12, (text) => text.data.trim() === "")))), () => Outcomes74.hasContent(
              // The link between end nad the type of next is lost by TS
              end10 ? None : Some.of(next),
              currentLevel,
              nextLevel
            ), () => Outcomes74.hasNoContent(
              // The link between end nad the type of next is lost by TS
              end10 ? None : Some.of(next),
              currentLevel,
              nextLevel
            ))
          };
        }
      };
    }
  });
  var Outcomes74;
  (function(Outcomes87) {
    Outcomes87.hasContent = (nextHeading, currentLevel, nextLevel) => Ok.of(WithOtherHeading.of("There is content between this heading and the next", nextHeading, currentLevel, nextLevel, "next"));
    Outcomes87.hasNoContent = (nextHeading, currentLevel, nextLevel) => Err.of(WithOtherHeading.of("There is no content between this heading and the next", nextHeading, currentLevel, nextLevel, "next"));
  })(Outcomes74 || (Outcomes74 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r79/rule.js
  var { equals: equals33 } = Predicate;
  var { hasAttribute: hasAttribute25, hasName: hasName45, isElement: isElement57 } = Element;
  var { and: and94 } = Refinement;
  var { isRendered: isRendered5, isVisible: isVisible16 } = Style;
  var { isText: isText13 } = Text;
  var { getElementDescendants: getElementDescendants57 } = Query3;
  var rule_default85 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r79",
    requirements: [BestPractice.of("preformated-text-is-code-or-figure")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return getElementDescendants57(document2, Node4.fullTree).filter(and94(hasName45("pre"), isRendered5(device)));
        },
        expectations(target) {
          return {
            1: expectation(isVisible16(device)(target), () => Outcomes75.IsVisible, () => expectation(target.inclusiveAncestors(Node4.fullTree).filter(isElement57).some(hasAttribute25("aria-hidden", equals33("true"))), () => Outcomes75.IsHidden, () => Outcomes75.IsNotVisibleAndNotHidden)),
            2: expectation(hasFigureAncestor(target) || hasOnlyAllowedText(device)(target), () => Outcomes75.IsDescendant, () => Outcomes75.IsNotDescendant)
          };
        }
      };
    }
  });
  function hasOnlyAllowedText(device) {
    return function hasOnlyAllowedText2(node) {
      if (and94(isElement57, hasName45("code", "kbd", "samp"))(node)) {
        return true;
      }
      if (and94(isText13, isVisible16(device))(node)) {
        return false;
      }
      return node.children(Node4.fullTree).every(hasOnlyAllowedText2);
    };
  }
  function hasFigureAncestor(target) {
    return target.ancestors(Node4.fullTree).filter(isElement57).some(hasName45("figure"));
  }
  var Outcomes75;
  (function(Outcomes87) {
    Outcomes87.IsVisible = Ok.of(Diagnostic.of(`The element is visible.`));
    Outcomes87.IsHidden = Ok.of(Diagnostic.of(`One inclusive ancestor of the element has "aria-hidden = true."`));
    Outcomes87.IsDescendant = Ok.of(Diagnostic.of(`The target element either has a <figure> ancestor, or all its text is inside <code>, <kbd> or <samp> elements.`));
    Outcomes87.IsNotVisibleAndNotHidden = Err.of(Diagnostic.of(`The element is not visible and there isn't an inclusive ancestor with "aria-hidden" state.`));
    Outcomes87.IsNotDescendant = Err.of(Diagnostic.of(`The element has no <figure> ancestor and has text which not inside a <code>, <kbd> or <samp> element. `));
  })(Outcomes75 || (Outcomes75 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r80/rule.js
  var { hasRole: hasRole38 } = DOM;
  var { and: and95, not: not51, test: test40 } = Predicate;
  var { isVisible: isVisible17, hasCascadedStyle: hasCascadedStyle5 } = Style;
  var { getElementDescendants: getElementDescendants58 } = Query3;
  var rule_default86 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r80",
    requirements: [Criterion.of("1.4.8")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return getElementDescendants58(document2, Node4.fullTree).filter(and95(hasRole38(device, "paragraph"), Node4.hasTextContent(not51(String2.isWhitespace)), isVisible17(device), hasCascadedStyle5("line-height", () => true, device)));
        },
        expectations(target) {
          return {
            1: expectation(test40(hasRelativeUnit(device), target), () => Outcomes76.HasRelativeUnit, () => Outcomes76.HasAbsoluteUnit)
          };
        }
      };
    }
  });
  var Outcomes76;
  (function(Outcomes87) {
    Outcomes87.HasRelativeUnit = Ok.of(Diagnostic.of(`The line height is specified using a relative unit`));
    Outcomes87.HasAbsoluteUnit = Err.of(Diagnostic.of(`The line height is specified using an absolute unit`));
  })(Outcomes76 || (Outcomes76 = {}));
  function hasRelativeUnit(device) {
    return hasCascadedStyle5("line-height", (lineHeight) => (
      // Keyword, percentage, number
      !Length2.isLength(lineHeight) || // Calculated length
      lineHeight.hasCalculation() || // Fixed length in relative units
      lineHeight.isRelative()
    ), device);
  }

  // node_modules/@siteimprove/alfa-rules/dist/sia-r81/rule.js
  var { hasNonEmptyAccessibleName: hasNonEmptyAccessibleName17, hasRole: hasRole39, isIncludedInTheAccessibilityTree: isIncludedInTheAccessibilityTree33 } = DOM;
  var { isElement: isElement58, hasName: hasName46, hasNamespace: hasNamespace47 } = Element;
  var { and: and96 } = Predicate;
  var { getElementDescendants: getElementDescendants59, getElementIdMap: getElementIdMap4 } = Query3;
  var rule_default87 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r81",
    requirements: [Criterion.of("2.4.4"), Criterion.of("2.4.9")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2, response }) {
      return {
        applicability() {
          const map126 = getElementDescendants59(document2, Node4.fullTree).filter(and96(hasNamespace47(Namespace.HTML, Namespace.SVG), hasRole39(device, (role) => role.is("link")), isIncludedInTheAccessibilityTree33(device), hasNonEmptyAccessibleName17(device))).groupBy((element) => linkContext(element, device)).map((elements) => elements.groupBy((element) => Node5.from(element, device).name.map((name) => String2.normalize(name.value))));
          const groups = Sequence.from(Iterable.flatMap(map126.values(), (map127) => map127.values()));
          return groups.filter((links) => links.size > 1).map(Group2.of);
        },
        expectations(target) {
          const name = WithName2.getName(
            Iterable.first(target).getUnsafe(),
            // Existence of first element is guaranteed by applicability
            device
          ).getUnsafe();
          const embedSameResource = [...target].every((element, i, elements) => (
            // This is either the first element...
            i === 0 || // ...or an element that embeds the same resource as the element
            // before it.
            referenceSameResource(response.url)(element, elements[i - 1])
          ));
          return {
            1: expectation(embedSameResource, () => Outcomes77.ResolveSameResource(name), () => Question2.of("reference-equivalent-resources", target, `Do the links resolve to equivalent resources?`, {
              diagnostic: WithName2.of(`Do the links resolve to equivalent resources?`, name)
            }).map((embedEquivalentResources) => expectation(embedEquivalentResources, () => Outcomes77.ResolveEquivalentResource(name), () => Outcomes77.ResolveDifferentResource(name))))
          };
        }
      };
    }
  });
  var Outcomes77;
  (function(Outcomes87) {
    Outcomes87.ResolveSameResource = (name) => Ok.of(WithName2.of(`The links resolve to the same resource`, name));
    Outcomes87.ResolveEquivalentResource = (name) => Ok.of(WithName2.of(`The links resolve to equivalent resources`, name));
    Outcomes87.ResolveDifferentResource = (name) => Err.of(WithName2.of(`The links do not resolve to the same or equivalent resources`, name));
  })(Outcomes77 || (Outcomes77 = {}));
  function linkContext(element, device) {
    let context = Set2.empty();
    const ancestors = element.ancestors(Node4.fullTree).filter(isElement58);
    for (const listitem of ancestors.filter(hasRole39(device, "listitem"))) {
      context = context.add(listitem);
    }
    for (const paragraph of ancestors.find(hasName46("p"))) {
      context = context.add(paragraph);
    }
    for (const cell of ancestors.find(hasRole39(device, "cell", "gridcell"))) {
      context = context.add(cell);
    }
    const idMap = getElementIdMap4(element.root());
    for (const describedby of element.attribute("aria-describedby")) {
      for (const reference of describedby.tokens().collect((id) => idMap.get(id))) {
        context = context.add(reference);
      }
    }
    return context;
  }

  // node_modules/@siteimprove/alfa-rules/dist/sia-r84/rule.js
  var { hasNamespace: hasNamespace48, isBrowsingContextContainer: isBrowsingContextContainer2, isElement: isElement59 } = Element;
  var { not: not52 } = Predicate;
  var { and: and97 } = Refinement;
  var { isTabbable: isTabbable7, isVisible: isVisible18 } = Style;
  var { getElementDescendants: getElementDescendants60 } = Query3;
  var rule_default88 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r84",
    requirements: [
      Criterion.of("2.1.1"),
      Criterion.of("2.1.3"),
      Technique.of("G202")
    ],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return getElementDescendants60(document2, Node4.fullTree).filter(and97(hasNamespace48(Namespace.HTML), isVisible18(device), isPossiblyScrollable(device), not52(isBrowsingContextContainer2)));
        },
        expectations(target) {
          return {
            1: expectation(Node4.hasInclusiveDescendant(and97(isElement59, isTabbable7(device)), Node4.flatTree)(target), () => Outcomes78.IsReachable, () => Outcomes78.IsNotReachable)
          };
        }
      };
    }
  });
  var Outcomes78;
  (function(Outcomes87) {
    Outcomes87.IsReachable = Ok.of(Diagnostic.of(`The scrollable element is reachable through keyboard navigation`));
    Outcomes87.IsNotReachable = Err.of(Diagnostic.of(`The scrollable element is not reachable through keyboard navigation`));
  })(Outcomes78 || (Outcomes78 = {}));
  function isPossiblyScrollable(device) {
    const properties = [
      ["x", "width"],
      ["y", "height"]
    ];
    return (element) => {
      const style = Style.from(element, device);
      return properties.some(([axis, dimension]) => style.computed(dimension).some((dimension2) => dimension2.hasCalculation() || dimension2.value !== "auto") && style.computed(`overflow-${axis}`).some((overflow2) => {
        switch (overflow2.value) {
          case "auto":
          case "scroll":
            if (axis === "x") {
              return style.computed("white-space").some((whitespace2) => whitespace2.value === "nowrap");
            }
            return true;
          default:
            return false;
        }
      }));
    };
  }

  // node_modules/@siteimprove/alfa-rules/dist/sia-r85/rule.js
  var { hasRole: hasRole40 } = DOM;
  var { and: and98, test: test41 } = Predicate;
  var { isVisible: isVisible19, hasComputedStyle: hasComputedStyle10 } = Style;
  var { getElementDescendants: getElementDescendants61 } = Query3;
  var rule_default89 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r85",
    requirements: [BestPractice.of("paragraph-not-italics")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return getElementDescendants61(document2, Node4.fullTree).filter(and98(hasRole40(device, "paragraph"), isVisible19(device)));
        },
        expectations(target) {
          return {
            1: expectation(test41(isNotItalic(device), target), () => Outcomes79.IsNotItalic, () => Outcomes79.IsItalic)
          };
        }
      };
    }
  });
  var Outcomes79;
  (function(Outcomes87) {
    Outcomes87.IsNotItalic = Ok.of(Diagnostic.of(`The text of the paragraph is not all italic`));
    Outcomes87.IsItalic = Err.of(Diagnostic.of(`The text of the paragraph is all italic`));
  })(Outcomes79 || (Outcomes79 = {}));
  function isNotItalic(device) {
    return hasComputedStyle10("font-style", (style) => style.value !== "italic", device);
  }

  // node_modules/@siteimprove/alfa-rules/dist/sia-r86/rule.js
  var { isIncludedInTheAccessibilityTree: isIncludedInTheAccessibilityTree34, isMarkedDecorative: isMarkedDecorative4 } = DOM;
  var { getElementDescendants: getElementDescendants62 } = Query3;
  var rule_default90 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r86",
    requirements: [
      BestPractice.of("element-marked-as-decorative-is-not-exposed")
    ],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return getElementDescendants62(document2, Node4.fullTree).filter(isMarkedDecorative4);
        },
        expectations(target) {
          return {
            1: expectation(isIncludedInTheAccessibilityTree34(device)(target), () => Outcomes80.IsExposed, () => Outcomes80.IsNotExposed)
          };
        }
      };
    }
  });
  var Outcomes80;
  (function(Outcomes87) {
    Outcomes87.IsNotExposed = Ok.of(Diagnostic.of(`The element is marked as decorative and is not exposed`));
    Outcomes87.IsExposed = Err.of(Diagnostic.of(`The element is marked as decorative but is exposed`));
  })(Outcomes80 || (Outcomes80 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r87/rule.js
  var { hasRole: hasRole41, isIgnored: isIgnored3 } = DOM;
  var { hasName: hasName47, isElement: isElement60 } = Element;
  var { and: and99 } = Refinement;
  var { isTabbable: isTabbable8, isVisible: isVisible20 } = Style;
  var { getElementDescendants: getElementDescendants63 } = Query3;
  var rule_default91 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r87",
    requirements: [
      Technique.of("G1"),
      BestPractice.of("first-focusable-is-skip-link")
    ],
    tags: [Scope.Page, Stability.Stable],
    evaluate({ device, document: document2, response }) {
      return {
        applicability() {
          return withDocumentElement(document2);
        },
        expectations(target) {
          const firstTabbable = target.tabOrder().find(isTabbable8(device));
          if (!firstTabbable.isSome()) {
            return { 1: Outcomes81.HasNoTabbable };
          }
          const element = firstTabbable.get();
          const url = hasName47("a", "area")(element) ? element.attribute("href").flatMap((attribute) => URL3.parse(attribute.value, response.url).ok()) : None;
          const reference = url.filter(isInternalURL2(response.url)).flatMap((url2) => url2.fragment.flatMap((fragment) => getElementDescendants63(element.root()).find((element2) => element2.id.includes(fragment))));
          const mains = document2.inclusiveDescendants(Node4.flatTree).filter(and99(isElement60, hasRole41(device, "main")));
          const askIsMain = Question2.of("first-tabbable-reference-is-main", target);
          const askIsInternalLink = Question2.of("first-tabbable-is-internal-link", target).answerIf(reference.isSome(), true);
          const askReference = Question2.of("first-tabbable-reference", target).answerIf(reference.isSome(), reference);
          const isAtTheStartOfMain = (reference2) => expectation(mains.some((main) => reference2.some(isAtTheStart(main, device))), () => Outcomes81.FirstTabbableIsLinkToContent, () => askIsMain.map((isMain) => expectation(isMain, () => Outcomes81.FirstTabbableIsLinkToContent, () => Outcomes81.FirstTabbableIsNotLinkToContent)));
          const isSkipLink = () => askIsInternalLink.map((isInternalLink) => expectation(isInternalLink, () => askReference.map(isAtTheStartOfMain), () => Outcomes81.FirstTabbableIsNotInternalLink));
          const askIsVisible = () => Question2.of("first-tabbable-is-visible", target).answerIf(isVisible20(device, Context.focus(element))(element), true).map((isVisible25) => expectation(isVisible25, isSkipLink, () => Outcomes81.FirstTabbableIsNotVisible));
          return {
            1: expectation(isIgnored3(device)(element), () => Outcomes81.FirstTabbableIsIgnored, () => expectation(hasRole41(device, (role) => role.is("link"))(element), askIsVisible, () => Outcomes81.FirstTabbableIsNotLink))
          };
        }
      };
    }
  });
  var Outcomes81;
  (function(Outcomes87) {
    Outcomes87.HasNoTabbable = Err.of(Diagnostic.of(`The document has no tabbable descendants`));
    Outcomes87.FirstTabbableIsNotLink = Err.of(Diagnostic.of(`The first tabbable element in the document is not a semantic link`));
    Outcomes87.FirstTabbableIsNotInternalLink = Err.of(Diagnostic.of(`The first tabbable element in the document is not an internal link`));
    Outcomes87.FirstTabbableIsIgnored = Err.of(Diagnostic.of(`The first tabbable element in the document is not included in the
      accessibility tree`));
    Outcomes87.FirstTabbableIsNotVisible = Err.of(Diagnostic.of(`The first tabbable element in the document is not visible when on focus`));
    Outcomes87.FirstTabbableIsLinkToContent = Ok.of(Diagnostic.of(`The first tabbable element in the document is a keyboard actionable link
      that is included in the accessibility tree and links to the main block of
      content of the document`));
    Outcomes87.FirstTabbableIsNotLinkToContent = Err.of(Diagnostic.of(`The first tabbable element in the document is a keyboard actionable link
      that is included in the accessibility tree, but does not link to the main
      block of content of the document`));
  })(Outcomes81 || (Outcomes81 = {}));
  function isInternalURL2(base3) {
    return (url) => url.fragment.isSome() && url.withoutFragment().equals(base3.withoutFragment());
  }

  // node_modules/@siteimprove/alfa-rules/dist/sia-r90/rule.js
  var { hasRole: hasRole42 } = DOM;
  var { isElement: isElement61, hasNamespace: hasNamespace49 } = Element;
  var { and: and100 } = Refinement;
  var { isTabbable: isTabbable9 } = Style;
  var rule_default92 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r90",
    requirements: [Criterion.of("4.1.2")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return document2.descendants(Node4.fullTree).filter(and100(isElement61, and100(hasNamespace49(Namespace.HTML, Namespace.SVG), hasRole42(device, (role) => role.hasPresentationalChildren()))));
        },
        expectations(target) {
          const tabbables = target.descendants(Node4.flatTree).filter(and100(isElement61, isTabbable9(device)));
          return {
            1: expectation(tabbables.isEmpty(), () => Outcomes82.HasNoTabbableDescendants, () => Outcomes82.HasTabbableDescendants(tabbables))
          };
        }
      };
    }
  });
  var Outcomes82;
  (function(Outcomes87) {
    Outcomes87.HasNoTabbableDescendants = Ok.of(Diagnostic.of(`The element has no tabbable descendants`));
    Outcomes87.HasTabbableDescendants = (errors) => Err.of(WithBadElements.of(`The element has tabbable descendants`, errors));
  })(Outcomes82 || (Outcomes82 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/common/applicability/text-with-inlined-important-property.js
  var { hasNamespace: hasNamespace50, isElement: isElement62 } = Element;
  var { and: and101 } = Refinement;
  var { hasSpecifiedStyle: hasSpecifiedStyle3, isImportant: isImportant2, isVisible: isVisible21 } = Style;
  var { isText: isText14 } = Text;
  function textWithInlinedImportantProperty(document2, device, property16) {
    return document2.descendants(Node4.fullTree).filter(and101(isElement62, hasNamespace50(Namespace.HTML))).filter(and101(
      // The specified value is declared in a style attribute
      hasSpecifiedStyle3(property16, (_, source) => (
        // A property is declared in a style attribute if
        // its declaration has an owner element
        source.some((declaration) => declaration.owner.isSome())
      ), device),
      // The computed value is important (`!important`)
      isImportant2(device, property16),
      // The element has visible text node children
      (element) => element.children(Node4.fullTree).some(and101(isText14, isVisible21(device)))
    ));
  }

  // node_modules/@siteimprove/alfa-rules/dist/common/expectation/is-wide-enough.js
  function isWideEnough(target, device, property16, threshold4) {
    const style = Style.from(target, device);
    const fontSize = style.computed("font-size").value;
    const value = style.computed(property16).value;
    const declaration = style.computed(property16).source.getUnsafe();
    let ratio;
    let used;
    switch (value.type) {
      case "length":
        used = value;
        ratio = value.value / fontSize.value;
        break;
      case "number":
        used = fontSize.scale(value.value);
        ratio = value.value;
        break;
      case "keyword":
        used = fontSize.scale(1.2);
        ratio = 1.2;
    }
    return {
      1: expectation(ratio >= threshold4, () => Outcomes83.IsWideEnough(
        property16,
        used,
        fontSize,
        ratio,
        threshold4,
        declaration,
        // The owner is guaranteed to exist by the hasSpecifiedStyle
        // filter in Applicability.
        declaration.owner.getUnsafe()
      ), () => Outcomes83.IsNotWideEnough(
        property16,
        used,
        fontSize,
        ratio,
        threshold4,
        declaration,
        // The owner is guaranteed to exist by the hasSpecifiedStyle
        // filter in Applicability.
        declaration.owner.getUnsafe()
      ))
    };
  }
  var Outcomes83;
  (function(Outcomes87) {
    Outcomes87.IsWideEnough = (prop, value, fontSize, ratio, threshold4, declaration, owner) => Ok.of(TextSpacing.of(`${prop} is at least ${threshold4} times the font-size`, prop, value, fontSize, ratio, threshold4, declaration, owner));
    Outcomes87.IsNotWideEnough = (prop, value, fontSize, ratio, threshold4, declaration, owner) => Err.of(TextSpacing.of(`${prop} is less than ${threshold4} times the font-size`, prop, value, fontSize, ratio, threshold4, declaration, owner));
  })(Outcomes83 || (Outcomes83 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r91/rule.js
  var property13 = "letter-spacing";
  var threshold = 0.12;
  var rule_default93 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r91",
    requirements: [Criterion.of("1.4.12")],
    tags: [Scope.Component, Stability.Stable, Version.of(2)],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return textWithInlinedImportantProperty(document2, device, property13);
        },
        expectations(target) {
          return isWideEnough(target, device, property13, threshold);
        }
      };
    }
  });

  // node_modules/@siteimprove/alfa-rules/dist/sia-r92/rule.js
  var property14 = "word-spacing";
  var threshold2 = 0.16;
  var rule_default94 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r92",
    requirements: [Criterion.of("1.4.12")],
    tags: [Scope.Component, Stability.Stable, Version.of(2)],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return textWithInlinedImportantProperty(document2, device, property14);
        },
        expectations(target) {
          return isWideEnough(target, device, property14, threshold2);
        }
      };
    }
  });

  // node_modules/@siteimprove/alfa-rules/dist/sia-r93/rule.js
  var property15 = "line-height";
  var threshold3 = 1.5;
  var rule_default95 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r93",
    requirements: [Criterion.of("1.4.12")],
    tags: [Scope.Component, Stability.Stable, Version.of(2)],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return textWithInlinedImportantProperty(document2, device, property15);
        },
        expectations(target) {
          return isWideEnough(target, device, property15, threshold3);
        }
      };
    }
  });

  // node_modules/@siteimprove/alfa-rules/dist/sia-r94/rule.js
  var { hasNonEmptyAccessibleName: hasNonEmptyAccessibleName18, hasRole: hasRole43, isIncludedInTheAccessibilityTree: isIncludedInTheAccessibilityTree35 } = DOM;
  var { hasNamespace: hasNamespace51 } = Element;
  var { and: and102 } = Predicate;
  var { getElementDescendants: getElementDescendants64 } = Query3;
  var rule_default96 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r94",
    requirements: [Criterion.of("4.1.2")],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return getElementDescendants64(document2, Node4.fullTree).filter(and102(hasNamespace51(Namespace.HTML), hasRole43(device, "menuitem"), isIncludedInTheAccessibilityTree35(device)));
        },
        expectations(target) {
          return {
            1: expectation(hasNonEmptyAccessibleName18(device)(target), () => Outcomes84.HasName, () => Outcomes84.HasNoName)
          };
        }
      };
    }
  });
  var Outcomes84;
  (function(Outcomes87) {
    Outcomes87.HasName = Ok.of(Diagnostic.of(`The menuitem has an accessible name`));
    Outcomes87.HasNoName = Err.of(Diagnostic.of(`The menuitem does not have an accessible name`));
  })(Outcomes84 || (Outcomes84 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r95/rule.js
  var { hasName: hasName48, hasNamespace: hasNamespace52, hasTabIndex: hasTabIndex5 } = Element;
  var { and: and103, test: test42 } = Predicate;
  var { isTabbable: isTabbable10, isVisible: isVisible22 } = Style;
  var { getElementDescendants: getElementDescendants65 } = Query3;
  var rule_default97 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r95",
    requirements: [
      Criterion.of("2.1.1")
      // The 2.1.3 secondary mapping is missing in ACT rules
      // https://github.com/act-rules/act-rules.github.io/issues/2026
      // Commenting it out as it would otherwise invalidate our implementation
      // in the reports.
      // Criterion.of("2.1.3"),
    ],
    tags: [Scope.Component, Stability.Stable, Version.of(2)],
    evaluate({ device, document: document2 }) {
      let tabbables = Map2.empty();
      return {
        applicability() {
          return getElementDescendants65(document2, Node4.fullTree).filter(and103(hasNamespace52(Namespace.HTML), hasName48("iframe"))).filter((iframe) => iframe.content.map((contentDocument) => getElementDescendants65(contentDocument, Node4.flatTree).filter(and103(isVisible22(device), isTabbable10(device)))).some((sequence) => {
            tabbables = tabbables.set(iframe, sequence);
            return !sequence.isEmpty();
          }));
        },
        expectations(target) {
          return {
            1: expectation(test42(hasTabIndex5((tabindex) => tabindex >= 0), target), () => Outcomes85.IsTabbable(tabbables.get(target).getOr(Sequence.empty())), () => Outcomes85.IsNotTabbable(tabbables.get(target).getOr(Sequence.empty())))
          };
        }
      };
    }
  });
  var Outcomes85;
  (function(Outcomes87) {
    Outcomes87.IsTabbable = (tabbables) => Ok.of(WithBadElements.of(`The iframe has no negative tabindex`, tabbables));
    Outcomes87.IsNotTabbable = (tabbables) => Err.of(WithBadElements.of(`The iframe has a negative tabindex`, tabbables));
  })(Outcomes85 || (Outcomes85 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/sia-r96/rule.js
  var { hasAttribute: hasAttribute26, hasName: hasName49, hasNamespace: hasNamespace53 } = Element;
  var { and: and104 } = Predicate;
  var { getElementDescendants: getElementDescendants66 } = Query3;
  var rule_default98 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r96",
    requirements: [
      Criterion.of("2.2.4"),
      Criterion.of("3.2.5"),
      Technique.of("G110"),
      Technique.of("H76")
    ],
    tags: [Scope.Page, Stability.Stable],
    evaluate({ document: document2 }) {
      let refreshTime;
      return {
        applicability() {
          return getElementDescendants66(document2).find(and104(hasNamespace53(Namespace.HTML), hasName49("meta"), hasAttribute26("http-equiv", (value) => value.toLowerCase() === "refresh"), hasAttribute26("content", (value) => getRefreshTime(value).map((time) => refreshTime = time).isSome()))).map((meta) => [meta]).getOr([]);
        },
        expectations(target) {
          return {
            1: expectation(refreshTime === 0, () => RefreshDelay.HasImmediateRefresh, () => RefreshDelay.HasDelayedRefresh)
          };
        }
      };
    }
  });

  // node_modules/@siteimprove/alfa-rules/dist/sia-r110/rule.js
  var rule_default99 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r110",
    requirements: [
      Criterion.of("1.3.1"),
      Technique.of("ARIA4"),
      Technique.of("G108")
    ],
    tags: [Scope.Component, Stability.Stable],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return roleAttributes(document2, device);
        },
        expectations(target) {
          return {
            1: expectation(target.tokens().some((token) => Role.isName(token) && Role.of(token).isConcrete()), () => Outcomes86.HasValidRole, () => Outcomes86.HasNoValidRole)
          };
        }
      };
    }
  });
  var Outcomes86;
  (function(Outcomes87) {
    Outcomes87.HasValidRole = Ok.of(Diagnostic.of(`The element has a at least one valid role`));
    Outcomes87.HasNoValidRole = Err.of(Diagnostic.of(`The element does not have a valid role`));
  })(Outcomes86 || (Outcomes86 = {}));

  // node_modules/@siteimprove/alfa-rules/dist/common/dom/get-clickable-box.js
  var { getInclusiveElementDescendants: getInclusiveElementDescendants2 } = Query3;
  var { isVisible: isVisible23 } = Style;
  var cache15 = Cache2.empty();
  function getClickableBox(device, element) {
    const visible = isVisible23(device);
    return cache15.get(device, Cache2.empty).get(element, () => {
      if (!visible(element)) {
        return Err.of("Cannot get clickable box of an invisible element.");
      }
      let boxes = [];
      for (let box of getInclusiveElementDescendants2(element).filter(visible).map((element2) => element2.getBoundingBox(device))) {
        if (!box.isSome()) {
          return Err.of("The element of one its descendants does not have a bounding box.");
        }
        boxes.push(box.get());
      }
      return Result.of(Rectangle2.union(...boxes));
    });
  }

  // node_modules/@siteimprove/alfa-rules/dist/common/applicability/targets-of-pointer-events.js
  var { hasRole: hasRole44 } = DOM;
  var { hasComputedStyle: hasComputedStyle11, isFocusable: isFocusable4, isVisible: isVisible24, isScrolledBehind: isScrolledBehind2 } = Style;
  var { and: and105, not: not53 } = Predicate;
  var { getElementDescendants: getElementDescendants67 } = Query3;
  var { isElement: isElement63 } = Element;
  var { isText: isText15 } = Text;
  var applicabilityCache = Cache2.empty();
  function applicableTargetsOfPointerEvents(document2, device) {
    return applicabilityCache.get(document2, Cache2.empty).get(device, () => {
      const isArea = (element) => element.name === "area";
      const isBlock = hasComputedStyle11("display", (display) => display.values[0].value === "block", device);
      const isInline = hasComputedStyle11("display", (display) => display.values[0].value === "inline", device);
      let targets = Sequence.empty();
      function visit3(node, lineContainer) {
        if (isElement63(node)) {
          if (and105(isTarget(device), not53(isArea))(node)) {
            if (lineContainer.isSome() && isInline(node)) {
              return;
            }
            targets = targets.append(node);
          }
          if (isBlock(node)) {
            if (hasNonTargetText(device)(node)) {
              lineContainer = Option.of(node);
            } else {
              lineContainer = None;
            }
          }
        }
        for (const child of node.children(Node4.fullTree)) {
          visit3(child, lineContainer);
        }
      }
      visit3(document2, None);
      return targets;
    });
  }
  var allTargetsCache = Cache2.empty();
  function allTargetsOfPointerEvents(document2, device) {
    return allTargetsCache.get(document2, Cache2.empty).get(device, () => getElementDescendants67(document2, Node4.fullTree).filter(isTarget(device)));
  }
  function isTarget(device) {
    return and105(hasComputedStyle11("pointer-events", (keyword) => keyword.value !== "none", device), isFocusable4(device), isVisible24(device), not53(isScrolledBehind2(device)), hasRole44(device, (role) => role.isWidget()), hasClickableBox(device));
  }
  function hasClickableBox(device) {
    return (element) => getClickableBox(device, element).isOk();
  }
  var nonTargetTextCache = Cache2.empty();
  function hasNonTargetText(device) {
    return (element) => nonTargetTextCache.get(device, Cache2.empty).get(element, () => {
      if (isTarget(device)(element)) {
        return false;
      }
      const children = element.children(Node4.flatTree);
      return children.some(and105(isText15, isVisible24(device))) || children.filter(isElement63).reject(isTarget(device)).some(hasNonTargetText(device));
    });
  }

  // node_modules/@siteimprove/alfa-rules/dist/common/outcome/target-size.js
  var TargetSize;
  (function(TargetSize2) {
    TargetSize2.IsUserAgentControlled = (name, box) => Ok.of(WithBoundingBox.of("Target is user agent controlled", name, box, Either.left({ ua: true }), []));
    TargetSize2.HasSufficientSize = (name, box) => Ok.of(WithBoundingBox.of("Target has sufficient size", name, box, Either.right({ size: true, spacing: true }), []));
    TargetSize2.HasInsufficientSize = (name, box) => Err.of(WithBoundingBox.of("Target has insufficient size", name, box, Either.right({ size: false, spacing: true }), []));
    TargetSize2.HasSufficientSpacing = (name, box) => Ok.of(WithBoundingBox.of("Target has sufficient spacing", name, box, Either.right({ size: false, spacing: true }), []));
    TargetSize2.HasInsufficientSizeAndSpacing = (name, box, tooCloseNeighbors) => Err.of(WithBoundingBox.of("Target has insufficient size and spacing", name, box, Either.right({ size: false, spacing: false }), tooCloseNeighbors));
  })(TargetSize || (TargetSize = {}));

  // node_modules/@siteimprove/alfa-rules/dist/common/predicate/has-sufficient-size.js
  function hasSufficientSize(size, device) {
    return (element) => getClickableBox(device, element).map((box) => box.width >= size && box.height >= size).getOr(true);
  }

  // node_modules/@siteimprove/alfa-rules/dist/common/predicate/is-user-agent-controlled.js
  function isUserAgentControlled() {
    return (element) => element.name === "input";
  }

  // node_modules/@siteimprove/alfa-rules/dist/sia-r111/rule.js
  var rule_default100 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r111",
    requirements: [Criterion.of("2.5.5")],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return applicableTargetsOfPointerEvents(document2, device);
        },
        expectations(target) {
          const box = getClickableBox(device, target).getUnsafe();
          const name = WithName2.getName(target, device).getOr("");
          return {
            1: expectation(isUserAgentControlled()(target), () => TargetSize.IsUserAgentControlled(name, box), hasSufficientSize(44, device)(target) ? () => TargetSize.HasSufficientSize(name, box) : () => TargetSize.HasInsufficientSize(name, box))
          };
        }
      };
    }
  });

  // node_modules/@siteimprove/alfa-rules/dist/sia-r113/rule.js
  var rule_default101 = Rule.Atomic.of({
    uri: "https://alfa.siteimprove.com/rules/sia-r113",
    requirements: [Criterion.of("2.5.8")],
    evaluate({ device, document: document2 }) {
      return {
        applicability() {
          return applicableTargetsOfPointerEvents(document2, device);
        },
        expectations(target) {
          const box = getClickableBox(device, target).getUnsafe();
          const name = WithName2.getName(target, device).getOr("");
          return {
            1: expectation(isUserAgentControlled()(target), () => TargetSize.IsUserAgentControlled(name, box), () => expectation(hasSufficientSize(24, device)(target), () => TargetSize.HasSufficientSize(name, box), () => {
              const tooCloseNeighbors = Sequence.from(findElementsWithInsufficientSpacingToTarget(document2, device, target));
              return expectation(tooCloseNeighbors.isEmpty(), () => TargetSize.HasSufficientSpacing(name, box), () => TargetSize.HasInsufficientSizeAndSpacing(name, box, tooCloseNeighbors));
            }))
          };
        }
      };
    }
  });
  var undersizedCache = Cache2.empty();
  function* findElementsWithInsufficientSpacingToTarget(document2, device, target) {
    const targetRect = getClickableBox(device, target).getUnsafe();
    const undersizedTargets = undersizedCache.get(document2, Cache2.empty).get(device, () => allTargetsOfPointerEvents(document2, device).reject(hasSufficientSize(24, device)));
    for (const candidate of allTargetsOfPointerEvents(document2, device)) {
      if (target !== candidate) {
        const candidateRect = getClickableBox(device, candidate).getUnsafe();
        if (candidateRect.intersectsCircle(targetRect.center.x, targetRect.center.y, 12) || undersizedTargets.includes(candidate) && targetRect.distanceSquared(candidateRect) < 24 ** 2) {
          yield candidate;
        }
      }
    }
  }

  // node_modules/@siteimprove/alfa-rules/dist/index.js
  var Rules = Record.of(rules_exports);
  var FlattenedRules = Sequence.from(Rules.values());
  var dist_default = FlattenedRules;

  // assets/alfa.js
  var { and: and106, or: or39 } = Refinement;
  async function startAudit(auditOptions) {
    const isNotCriterion = (rule) => !rule.hasRequirement(Criterion.isCriterion);
    const wcagRuleKeywords = {
      wcag_a: Conformance.isA,
      wcag_aa: Conformance.isAA,
      wcag_aaa: Conformance.isAAA
    };
    const otherRuleKeywords = {
      techniques: Technique.isTechnique,
      best_practices: BestPractice.isBestPractice,
      aria: ARIA.isARIA
    };
    const { wcagLevel, otherRequirementTypes, includedRules, miscRules } = auditOptions["included_rules"].reduce(
      (intermediateValue, currentRule) => {
        const wcagConformance = wcagRuleKeywords[currentRule];
        if (wcagConformance) intermediateValue.wcagLevel = wcagConformance;
        else if (currentRule === "misc_rules")
          intermediateValue.miscRules = true;
        else {
          const otherRequirementType = otherRuleKeywords[currentRule];
          if (otherRequirementType)
            intermediateValue.otherRequirementTypes.push(otherRequirementType);
          else includedRules.push(currentRule);
        }
        return intermediateValue;
      },
      {
        wcagLevel: void 0,
        miscRules: false,
        otherRequirementTypes: [],
        includedRules: []
      }
    );
    const excludedRules = auditOptions["excluded_rules"];
    const filteredRules = dist_default.filter((rule) => {
      const ruleId = rule.uri.split("/").pop();
      if (includedRules.includes(ruleId)) return true;
      if (excludedRules.includes(ruleId)) return false;
      if (wcagLevel && rule.hasRequirement(and106(Criterion.isCriterion, wcagLevel)))
        return true;
      else if (isNotCriterion(rule) && rule.hasRequirement(or39(...otherRequirementTypes)))
        return true;
      else if (miscRules && rule.requirements.length === 0) return true;
    });
    const alfaDocument = Node4.from(await Native.fromNode(window.document));
    const input = Page.of(
      Request.empty(),
      Response.of(URL3.parse(window.location.href).getUnsafe(), 200),
      alfaDocument,
      Device.standard()
    );
    const outcomes = [
      ...await Audit.of(input, filteredRules).evaluate()
    ];
    const earlAssertions = [
      ...outcomes.filter(Outcome.isFailed, Outcome.isCantTell).map((outcome) => outcome.toEARL())
    ];
    const result = earlAssertions.reduce(
      (intermediateResult, assertion) => {
        const outcome = assertion["earl:result"]["earl:outcome"]["@id"];
        const key = assertion["earl:test"]["@id"] + assertion["earl:result"]["earl:info"] + assertion["earl:result"]["earl:outcome"]["@id"] + outcome;
        const newPointers = [
          assertion["earl:result"]["earl:pointer"]["ptr:expression"] ?? assertion["earl:result"]["earl:pointer"]["ptr:groupPointer"]["@list"].map((pointer) => pointer["ptr:expression"])
        ].flat();
        if (key in intermediateResult[outcome]) {
          intermediateResult[outcome][key]["occurences"].push(...newPointers);
        } else {
          intermediateResult[outcome][key] = {
            url: assertion["earl:test"]["@id"],
            ruleId: new URL(assertion["earl:test"]["@id"]).pathname.split("/").pop(),
            info: assertion["earl:result"]["earl:info"].replace(/\s{2,}/g, " "),
            outcome: assertion["earl:result"]["earl:outcome"]["@id"],
            occurences: newPointers
          };
        }
        return intermediateResult;
      },
      { "earl:failed": {}, "earl:cantTell": {} }
    );
    return {
      errors: Object.values(result["earl:failed"]),
      warnings: Object.values(result["earl:cantTell"])
    };
  }
  window.alfa = {
    startAudit
  };
})();
